{Compared 20140123 /DKTBG}
{******************************************************************************
*
* Module Name   : $LIB_RE_RESULT
*
* Purpose       : Handling for the base result class for Result Entry code
*
* Document Ref. : SE/T/TVGL-WORK-RESENTO/1/5
*
* Specification :
*
* Portability   : Not Checked
*
* Re-entrant    : Yes
*
*******************************************************************************}

SET COMPILE_OPTION DECLARE


set notprotected

JOIN STANDARD_LIBRARY std_class
JOIN STANDARD_LIBRARY std_client
JOIN STANDARD_LIBRARY std_login
JOIN STANDARD_LIBRARY std_result
JOIN STANDARD_LIBRARY std_utils
JOIN STANDARD_LIBRARY std_array
JOIN STANDARD_LIBRARY std_window
JOIN STANDARD_LIBRARY std_database

JOIN LIBRARY          $lib_utils
JOIN LIBRARY          $lib_comp
JOIN LIBRARY          $lib_re_mlp
JOIN LIBRARY          $lib_re_incident
JOIN LIBRARY          $instrument_comm
JOIN LIBRARY          $lib_re_audit
JOIN LIBRARY          $lib_re_prompt
JOIN LIBRARY          $lib_re_globals
JOIN LIBRARY          $lib_re_graph
JOIN LIBRARY          $lib_re_formula
JOIN LIBRARY          $lib_unit
JOIN LIBRARY          $resl_user
JOIN LIBRARY          $lib_test_validate
JOIN LIBRARY          $lib_samp_validate
JOIN LIBRARY          $lib_job_validate
JOIN LIBRARY          $incident_login

CONSTANT PQL_LESS_THAN_MODE    = "LESS_THAN"
CONSTANT PQL_GREATER_THAN_MODE = "GREATER_THAN"

{*****************************************************************************}

DECLARE lib_re_result_common_entries

{*****************************************************************************}

GLOBAL
ROUTINE lib_re_result_initialise

        { The first set of calls just defines classes                }
        { If the result base class has been defined so have the rest }
        { dont bother calling any of the initialisation routines     }


    DEFINE CLASS "LIB_RE_RESULT"

        PROPERTIES
            "RESULT_ROW_EXISTS",
            "RESULT_READ_IN",
            "MODIFY_ALLOWED",
			"MODIFY_ALLOWED_MESSAGE",
            "TEST_OBJECT",
            "TEST_NUMBER" ,
            "ANALYSIS",
            "ANALYSIS_VERSION",
            "NAME",
            "IS_CALCULATION" ,

            { Properties for value prompting }
            "RESULT_STR",
            "RESULT_VAL",
            "RESULT_UNIT",
			"RESULT_RAW_STR",

            { Component limits string }
            "BROWSE_BUILT",
            "BROWSE_STRING",

            { Pop up window properties }
            "MLP_INITIALISED",
            "MLP_OBJECT",
            "INCIDENT_CONTEXT" ,
            "AUDIT_CONTEXT",
            "GRAPH_CONTEXT",

            { incident creation properties }
            "INCIDENTS_ARRAY" ,

            { Properties for status setting }
            "SELECTED"       ,
            "INITIAL_STATUS" ,
            "RESULT_STATUS"  ,
            "STATUS_ARRAY"   ,

            "CONFIRM_MESSAGE"                 ,
            "STORE_PENDING"                   ,
            "STATUS_PRE_STATUS_UPDATE"        ,
            "STORE_PENDING_PRE_STATUS_UPDATE" ,

            {Properties for screen positions }
            "COLUMN"         ,
            "ROW"            ,
            "GRID"           ,

            {Pointers to all the formulas }
            "FORMULAS"       ,

            { Has the user entered a specific dilution for this result }
            "DILUTION_SET" ,

            {Properties for holding initial values}
            "INITIAL_RESULT_STR" ,
            "INITIAL_RESULT_VAL" ,
            "INITIAL_RESULT_UNIT"

        ACTIONS
            "INITIALISE_RESULT_FROM_COMPONENT",
            "READ_EXISTING_RESULT",
            "UPDATE_EXISTING_RESULT",
            "RESERVE_RESULT",
            "RESET_RESULT",
            "FLUSH_RESULT",
            "STORE_RESULT",
            "STORE_STATUS",
            "RELEASE_RESULT",
			"RESELECT",
            "RESELECT_RESULT",
            "SCHEDULE_CHECK_MODIFY_ALLOWED",
            "CHECK_MODIFY_ALLOWED",
            "SET_STORE_PENDING" ,
            "UPDATE_RESULT_OBJECT",

            "DISPLAY_AUDITS"
                ROUTINE    "LIB_RE_AUDIT_DISPLAY_AUDITS"
                IN LIBRARY "$LIB_RE_AUDIT",
            "REBUILD_AUDITS"
                ROUTINE    "LIB_RE_AUDIT_REBUILD_AUDITS"
                IN LIBRARY "$LIB_RE_AUDIT",
            "REMOVE_AUDITS"
                ROUTINE    "LIB_RE_AUDIT_REMOVE_AUDITS"
                IN LIBRARY "$LIB_RE_AUDIT",
            "MLP_INITIALISE"
                ROUTINE    "LIB_RE_MLP_ACTION_MLP_INITIALISE"
                IN LIBRARY "$LIB_RE_MLP",
            "MLP_PASTE"
                ROUTINE    "LIB_RE_MLP_ACTION_MLP_PASTE"
                IN LIBRARY "$LIB_RE_MLP",
            "MLP_UNPASTE"
                ROUTINE    "LIB_RE_MLP_ACTION_MLP_UNPASTE"
                IN LIBRARY "$LIB_RE_MLP",
            "MLP_IN_SPEC"
                ROUTINE    "LIB_RE_MLP_ACTION_MLP_IN_SPEC"
                IN LIBRARY "$LIB_RE_MLP",
            "MLP_UPDATE"
                ROUTINE    "LIB_RE_MLP_ACTION_MLP_UPDATE"
                IN LIBRARY "$LIB_RE_MLP",

            "PROMPT_FOR_VALUE"
                ROUTINE    "LIB_RE_PROMPT_PROMPT_FOR_VALUE"
                IN LIBRARY "$LIB_RE_PROMPT",
            "PROMPT_FOR_STATUS"
                ROUTINE    "LIB_RE_PROMPT_PROMPT_FOR_STATUS"
                IN LIBRARY "$LIB_RE_PROMPT",
            "PROMPT_FOR_STATUS_BAR"
                ROUTINE    "LIB_RE_PROMPT_PROMPT_FOR_STATUS_BAR"
                IN LIBRARY "$LIB_RE_PROMPT",
            "DISPLAY_RESULT"
                ROUTINE    "LIB_RE_PROMPT_DISPLAY_RESULT"
                IN LIBRARY "$LIB_RE_PROMPT",
            "PROMPT_GUI_SELECT"
                ROUTINE    "LIB_RE_PROMPT_PROMPT_GUI_SELECT"
                IN LIBRARY "$LIB_RE_PROMPT",

            "MLP_SET_UP"
                ROUTINE    "LIB_RE_MLP_ACTION_MLP_SET_UP"
                IN LIBRARY "$LIB_RE_MLP",
            "HAS_MLP_LIMITS"
                ROUTINE    "LIB_RE_MLP_ACTION_HAS_MLP_LIMITS"
                IN LIBRARY "$LIB_RE_MLP",
            "MLP_COMPARE"
                ROUTINE    "LIB_RE_MLP_ACTION_MLP_COMPARE"
                IN LIBRARY "$LIB_RE_MLP",

            "MLP_FORMAT_LIMITS_CONTEXT"
                ROUTINE    "LIB_RE_MLP_ACTION_MLP_FORMAT_LIMITS_CONTEXT"
                IN LIBRARY "$LIB_RE_MLP",

            "MLP_FORMAT_LIMITS"
                ROUTINE    "LIB_RE_MLP_ACTION_MLP_FORMAT_LIMITS"
                IN LIBRARY "$LIB_RE_MLP",

            "SET_CONFIRM_MESSAGE"    ,
            "CONFIRM_UPDATE"         ,

            "SET_POSITION"           ,
            "REDISPLAY"              ,
            "USED_IN_FORMULA"        ,
            "RECALCULATE_FORMULAS"   ,
            "GET_BASE"               ,
            "GET_NAME"               ,
            "GET_CATEGORY"           ,
            "GET_REPLICATE"          ,
            "GET_RESULT_TYPE"        ,

            "ENTER_FOR_TYPE"         ,
            "MODIFIED"               ,
            "UPGRADE_LOCK"           ,
            "DOWNGRADE_LOCK"         ,
            "IS_LOCKED_FOR_UPDATE"   ,
            "RESULT_ENTERED"         ,
            "RESULT_ACCEPTED_STATUS" ,

            "SET_UNITS"              ,
            "SET_FIELD"              ,
            "UPDATE"                 ,
            "GET_FIELD"              ,
            "GET_INEQUALITY"         ,
            "RESULT_AS_UNITS"        ,

            "UPDATE_LESS_THAN_PQL"   ,
            "SET_LESS_THAN_PQL"      ,
            "GET_MINIMUM_PQL"        ,
            "SET_GREATER_THAN_PQL"   ,
            "UPDATE_GREATER_THAN_PQL",
            "GET_MAXIMUM_PQL"        ,
            "SET_PQL"                ,
			"FORMAT_NUMBER"          ,
            "SET_DEFAULT_DILUTION"   ,

            "BLANK_OUT_RESULT"       ,
            "REMOVE_FAILED_CALC"     ,

            "REBUILD_INCIDENTS"
                ROUTINE    "LIB_RE_INCIDENT_REBUILD_INCIDENTS"
                IN LIBRARY "$LIB_RE_INCIDENT",
            "DISPLAY_INCIDENTS"
                ROUTINE    "LIB_RE_INCIDENT_DISPLAY_INCIDENTS"
                IN LIBRARY "$LIB_RE_INCIDENT",

            "REBUILD_GRAPH"
                ROUTINE    "LIB_RE_GRAPH_REBUILD_GRAPH"
                IN LIBRARY "$LIB_RE_GRAPH",
            "DISPLAY_GRAPH"
                ROUTINE    "LIB_RE_GRAPH_DISPLAY_GRAPH"
                IN LIBRARY "$LIB_RE_GRAPH",

            "UNDO_STATUS"            ,
            "CREATE_INCIDENTS"       ,
            "READ_INSTRUMENT_RESULT" ,

            "PRE_UPDATE_ROUTINE"     ,
			"PRE_RESET_ROUTINE"      ,
			
			{ Raw result handling }
			"READ_RAW_RESULT"        ,
			"ASSIGN_RAW_RESULT"

        TABLES result

        INITIALISATION

    END CLASS

    lib_re_prompt_initialise ( )
    lib_re_audit_initialise ( )

    instrument_comm_setup_initialisation( )

    { These need to be called to set up module level variables }

    lib_comp_initialise ()
    lib_re_mlp_initialise ( )
    lib_re_formula_initialise ()
    lib_re_incident_incident_initialise ()
    lib_re_graph_initialise ()

ENDROUTINE

{*****************************************************************************}

ROUTINE LIB_RE_RESULT_CLASS_INITIALISATION ( result_object )

    ARRAY result_object . incidents_array ARRAYSIZE ( 0 )

        result_object . result_row_exists    = FALSE
        result_object . result_read_in       = FALSE
        result_object . is_calculation       = FALSE
        result_object . selected             = FALSE

        result_object . modify_allowed = TRUE
        result_object . modify_allowed_message = ""

        result_object . browse_built  = FALSE

        result_object . mlp_initialised = FALSE

        result_object . result_str    = " "
        result_object . result_val    = 0.0
        result_object . result_unit   = " "
        result_object . result_status = " "
        result_object . initial_status = " "
        result_object . result_raw_str = " "

        result_object . confirm_message                 = EMPTY
        result_object . store_pending                   = FALSE
        result_object . status_pre_status_update        = " "
        result_object . store_pending_pre_status_update = FALSE

        result_object . column = EMPTY
        result_object . row    = EMPTY
        result_object . grid   = EMPTY

        ARRAY result_object . formulas ARRAY_SIZE ( 0 )

        result_object . dilution_set = FALSE

ENDROUTINE


{*****************************************************************************}

    ROUTINE lib_re_result_action_create_incidents ( result_object )

{
*
*
******************************************************************************}

DECLARE incident_obj , count , record_obj

    IF size_of_array ( result_object . incidents_array ) > 0 THEN

        count = 1

        WHILE count <= size_of_array ( result_object . incidents_array ) DO

            incident_obj = result_object . incidents_array [ count ]

            IF NOT transaction_is_write () THEN
                START WRITE TRANSACTION "Update incidents"
            ENDIF

            IF transaction_is_write () THEN
                UPDATE incidents IN OBJECT incident_obj

                incident_obj . checklist_db . invoke_all ( "UPDATE" )
            ENDIF

            incident_obj . table_id = TOUPPER ( incident_obj . table_id )

            IF ( STRIP ( incident_obj . table_id ) ) = "RESULT" THEN

                record_obj = result_object

            ELSEIF ( STRIP ( incident_obj . table_id ) ) = "TEST" THEN

                record_obj = result_object . test_object
                record_obj . read_incidents = TRUE

            ELSEIF ( STRIP ( incident_obj . table_id ) ) = "SAMPLE" THEN

                record_obj = result_object . test_object . sample_object
                record_obj . read_incidents = TRUE

            ENDIF

            object_set_current_table ( record_obj , incident_obj . table_id )

            inc_login_set_has_incidents_flag ( incident_obj . table_id ,
                               incident_obj . key0     )

            count = count + 1

        ENDWHILE

        ARRAY result_object . incidents_array ARRAYSIZE ( 0 )

        object_copy_current_table ( record_obj , incident_obj . table_id )

    ENDIF

	result_object . test_object . create_incidents ( )

ENDROUTINE    { lib_re_result_action_create_incident }


{*****************************************************************************}

ROUTINE lib_re_result_action_pre_update_routine ( result_object )

{
*   Base class action to be overridden with result type specific
*   pre update tasks.
*
*******************************************************************************}

ENDROUTINE    { lib_re_result_action_pre_update_routine }

{*****************************************************************************}

ROUTINE lib_re_result_action_pre_reset_routine ( result_object )

{
*   Base class action to be overridden with result type specific
*   pre reset tasks.
*
*******************************************************************************}

ENDROUTINE    { lib_re_result_action_pre_reset_routine }

{*****************************************************************************}

ROUTINE lib_re_result_action_flush_result ( result_object         ,
                                            result_context_object )

{
*   UPDATE result, test and sample as required.
*   Used in multi-result transaction mode
*
*******************************************************************************}

    DECLARE target_status  ,
            check_ok       ,
            value_allowed  ,
            sample_updated ,
            test_updated

    IF result_object . store_pending THEN

        target_status = SELECT result . status IN OBJECT result_object

        { Put the result back the way it was }

		{ Set the hierarchy status values }
        ASSIGN result . status IN OBJECT result_object =
                                     result_object . initial_status
		ASSIGN test . status   IN OBJECT result_object . test_object =
		                             result_object . test_object . initial_status

        IF ( result_object . status_pre_status_update <> " " ) AND
           ( result_object . store_pending_pre_status_update ) THEN

            CHANGE RESULT STATUS TO result_object . status_pre_status_update
                   USING result IN OBJECT result_object ,
                         test   IN OBJECT result_object . test_object ,
                         sample IN OBJECT result_object . test_object . sample_object
                   PROPAGATE,
                   check_ok

        ELSE
            check_ok = EMPTY
        ENDIF

        result_object . status_pre_status_update        = " "
        result_object . store_pending_pre_status_update = FALSE

        IF check_ok = EMPTY THEN

            CHANGE RESULT STATUS TO target_status
                   USING result IN OBJECT result_object ,
                         test   IN OBJECT result_object . test_object ,
                         sample IN OBJECT result_object . test_object . sample_object
                   PROPAGATE,
                   check_ok

        ENDIF

        IF check_ok = EMPTY THEN

            result_object . pre_update_routine ( )

            result_object . mlp_in_spec ( result_context_object      ,
                                          result_object . result_str ,
                                          value_allowed              )

            IF ROW_HAS_UPDATES_OBJECT ( "SAMPLE", result_object . test_object . sample_object ) THEN
                sample_updated = result_object . test_object . sample_object . update()

            ELSE

                sample_updated = TRUE

            ENDIF


            IF sample_updated THEN

                IF ROW_HAS_UPDATES_OBJECT ( "TEST", result_object . test_object ) THEN
                    test_updated = result_object . test_object . update()

					result_object . test_object . initial_status = 
		                                 SELECT test . status
		                                        IN OBJECT result_object . test_object

                ELSE

                    test_updated = TRUE
                ENDIF

                IF test_updated THEN

                    IF ROW_HAS_UPDATES_OBJECT ( "RESULT", result_object ) THEN
                        UPDATE result IN OBJECT result_object
                    ENDIF

                ELSE

                    flash_message( GET_USER_MESSAGE( "LIB_RE_RESULT_LOCK_TEST_FAIL", 1 ) ,
                                                     TRUE                                )

                ENDIF

            ELSE

                flash_message( GET_USER_MESSAGE( "LIB_RE_RESULT_LOCK_SAMPLE_FAIL", 1 ) ,
                               TRUE                                                    )

            ENDIF



        ELSE
            flash_message ( check_ok, TRUE )
        ENDIF

    ENDIF

ENDROUTINE    { lib_re_result_action_flush_result }

{*****************************************************************************}

ROUTINE lib_re_result_action_update_result_object ( result_object         ,
                                                    result_context_object )

{
*   UPDATE result, test and sample as required.
*   Used in multi-result transaction mode
*
*******************************************************************************}

    IF result_object . store_pending THEN

        result_object . mlp_update ()

		{ Don't create incidents during authorisation }

		IF ( INDEX ( "ARX", SELECT result . status IN OBJECT result_object ) = 0 ) THEN

        result_object . create_incidents ()

		ENDIF

		IF result_context_object <> EMPTY THEN
        result_context_object . worksheet_status_update ( )
		ENDIF

        IF ( ( "C" = ( SELECT test . status IN OBJECT result_object . test_object ) ) AND
             ( result_object . test_object . status_pre_status_update = " "       ) ) THEN
            auto_validate_test ( result_object . test_object )

		ELSEIF ( "A" = ( SELECT test . status IN OBJECT result_object . test_object ) ) AND 
		       ( result_object . test_object . status_pre_status_update = " "         ) THEN

			auto_validate_sample ( SELECT test . sample      IN OBJECT result_object . test_object ,
			                       SELECT test . test_number IN OBJECT result_object . test_object )

        ENDIF

		IF result_context_object <> EMPTY THEN
        result_object . rebuild_graph     ( result_context_object )
        result_object . rebuild_audits    ( result_context_object )
        result_object . rebuild_incidents ( result_context_object )
		ENDIF

        result_object . store_pending  = FALSE

        result_object . result_status  = SELECT result . status
                            IN OBJECT result_object

        result_object . initial_status = SELECT result . status
                            IN OBJECT result_object

		result_object . test_object . initial_status = 
		                                 SELECT test . status
		                                        IN OBJECT result_object . test_object

    ENDIF

    result_object . check_modify_allowed ( FALSE )

ENDROUTINE    { lib_re_result_action_update_result }

{*****************************************************************************}

ROUTINE lib_re_result_action_set_store_pending ( result_object         ,
                                                 result_context_object )

{
*   Mark the result as needing store
*
*******************************************************************************}

    result_context_object . add_to_result_cache (
                      SELECT result . test_number IN OBJECT result_object ,
                      SELECT result . name        IN OBJECT result_object ,
                      SELECT result . text        IN OBJECT result_object ,
                      SELECT result . value       IN OBJECT result_object ,
                      result_object                                       )

    IF NOT result_object . store_pending THEN

        result_object . store_pending            = TRUE
        result_context_object . results_to_store =
                 result_context_object . results_to_store + 1

    ENDIF

ENDROUTINE

{*****************************************************************************}

ROUTINE lib_re_result_action_reset_result ( result_object         ,
                                            result_context_object )

{
*   Remove user entered value
*
*******************************************************************************}

    DECLARE was_pending_update

    was_pending_update = result_object . store_pending

    IF was_pending_update THEN

        result_object . pre_reset_routine ( )

        result_object . reselect_result ( result_context_object, FALSE )

        result_object . store_pending                   = FALSE
        result_object . status_pre_status_update        = " "
        result_object . store_pending_pre_status_update = FALSE
        result_object . mlp_initialised                 = FALSE

    ENDIF

    result_object . check_modify_allowed ( FALSE )

    RETURN ( was_pending_update )

ENDROUTINE    { lib_re_result_action_reset_result }

{*****************************************************************************}

ROUTINE lib_re_result_action_store_result ( result_object         ,
                                            result_context_object )

        DECLARE target_status , value_allowed , in_spec , test_upgrade,
                sample_upgrade , sample_object , test_object ,
                test_reselected, sample_reselected,
                check_ok, test_available , save_message, error_message,
                original_text, original_value, original_units, original_raw_str


        test_object   = result_object . test_object
        sample_object = test_object . sample_object

        value_allowed = TRUE

        original_text  = SELECT result . text  IN OBJECT result_object
        original_value = SELECT result . value IN OBJECT result_object
        original_units = SELECT result . units IN OBJECT result_object

        original_raw_str = result_object . read_raw_result ( )


        IF ( SELECT result . status IN OBJECT result_object <> " " ) AND
           ( SELECT result . status IN OBJECT result_object <> "U" ) AND
           ( NOT result_object . is_calculation                    ) THEN

                { Set the confirm message to 'Modified Result' preserving the }
                { value set by the range check in $lib_re_numeric.rpf         }

                save_message = result_object . confirm_message

                result_object . confirm_message = EMPTY

                result_object . set_confirm_message ( "MESSAGE_PRN_426" )

                value_allowed = result_object . confirm_update (
                                                  result_context_object )

                result_object . confirm_message = save_message

        ENDIF

        IF  ( value_allowed ) THEN

                value_allowed = result_object . confirm_update (
                                                  result_context_object )

        ENDIF

        IF ( value_allowed          ) AND
           ( global ( "PQL_ENABLE" )) THEN

                IF ( NOT result_object . store_pending ) OR
                   ( SELECT result . status IN OBJECT result_object <> "U" ) THEN

                result_object . set_default_dilution ( result_context_object )
                result_object . set_pql ( result_context_object )

        ENDIF

        ENDIF
        
        IF ( value_allowed ) THEN
        
        	test_object . create_stocks ( result_context_object )
        
        ENDIF

        IF value_allowed THEN

                { Set the proposed result configuration }

                ASSIGN result . value IN OBJECT result_object =
                                                  result_object . result_val
                ASSIGN result . text IN OBJECT result_object =
                                                  result_object . result_str
                ASSIGN result . units IN OBJECT result_object =
                                                  result_object . result_unit

		result_object . assign_raw_result ( result_object . result_raw_str )

                in_spec = result_object . mlp_in_spec ( result_context_object      ,
                                                        result_object . result_str ,
                                                        value_allowed              )

        ENDIF

        IF result_object . is_calculation THEN

                { Always allow a calculation }

                value_allowed = TRUE

        ENDIF

        IF NOT value_allowed THEN

                { Set things back and take the quick way out }

                ASSIGN result . value IN OBJECT result_object = original_value
                ASSIGN result . text  IN OBJECT result_object = original_text
                ASSIGN result . units IN OBJECT result_object = original_units

		result_object . assign_raw_result ( original_raw_str )

                RETURN ( value_allowed )

        ENDIF

    { In Single result mode lock the test and sample }

        IF result_context_object . single_result_commit THEN

        test_upgrade = result_context_object .
                       lock_upgrade_object ( "TEST"          ,
                                 test_object     ,
                                 test_reselected )

        sample_upgrade = result_context_object .
                     lock_upgrade_object ( "SAMPLE"          ,
                                   sample_object     ,
                                   sample_reselected )

        IF ( SELECT test . status IN OBJECT test_object = "A" ) OR
           ( SELECT test . status IN OBJECT test_object = "R" ) OR
           ( SELECT test . status IN OBJECT test_object = "X" ) THEN

            result_object . result_status = SELECT test . status
                              IN OBJECT test_object
            result_object . initial_status = SELECT test . status
                               IN OBJECT test_object

            ASSIGN result . status IN OBJECT
                result_object = SELECT test . status
                          IN OBJECT test_object

            result_object . check_modify_allowed ( FALSE )

            test_available = FALSE

        ELSE

            test_available = TRUE

        ENDIF

        IF NOT test_upgrade THEN

            error_message = "RESULT_ENTRY_TESTLOCKED"
            value_allowed = FALSE

        ELSEIF NOT sample_upgrade THEN

            error_message = "RESULT_ENTRY_SAMPLELOCKED"
            value_allowed = FALSE

        ELSEIF NOT test_available THEN

            error_message = "RESULT_ENTRY_AUTH_TEST"
            value_allowed = FALSE

        ENDIF

    ENDIF

        IF value_allowed THEN

                ASSIGN result . value IN OBJECT result_object =
                                                  result_object . result_val
                ASSIGN result . text IN OBJECT result_object =
                                                  result_object . result_str
                ASSIGN result . units IN OBJECT result_object =
                                                  result_object . result_unit
                ASSIGN result . out_of_range IN OBJECT result_object =
                                                  NOT in_spec

		target_status = SELECT result . status IN OBJECT result_object

		IF (( target_status = "U" ) OR ( target_status = " " )) THEN

			target_status = "E"

		ELSEIF NOT result_object . store_pending THEN

            target_status = "M"

        ENDIF

        result_context_object . start_write_transaction (
                  get_user_message ( "RESULT_ENTRY_TRANSACTION", 1 ))

            IF result_context_object . single_result_commit THEN

                    IF result_context_object . propagate_status THEN

                            CHANGE RESULT STATUS TO target_status
                                   USING result IN OBJECT result_object ,
                                         test   IN OBJECT test_object   ,
                                         sample IN OBJECT sample_object
                                   PROPAGATE,
                                   check_ok

                    ELSE

                            CHANGE RESULT STATUS TO target_status
                                   USING   result IN OBJECT result_object ,
                                           test   IN OBJECT test_object   ,
                                           sample IN OBJECT sample_object
                                   PROPAGATE NONE,
                                   check_ok

                    ENDIF

            ELSE

                        ASSIGN result . status IN OBJECT result_object = target_status

            result_object . result_status = target_status

            check_ok = EMPTY

        ENDIF

        IF check_ok = EMPTY THEN

            result_context_object .
                     result_info_update ( result_object )

        ENDIF

                IF check_ok <> EMPTY THEN

            result_context_object . rollback ( )

                        value_allowed = FALSE
                        error_message = check_ok

                ELSE

                        IF result_context_object . single_result_commit THEN

                UPDATE result IN OBJECT result_object
                UPDATE test   IN OBJECT test_object
                UPDATE sample IN OBJECT sample_object

                result_object . mlp_update ()
                result_object . create_incidents ()

				IF test_object . stock_grid <> EMPTY THEN
									
					test_object . stock_grid . stock_screen_save ( )
					IF ( result_context_object . tests_to_store > 0 ) THEN
						
						result_context_object . tests_to_store = result_context_object . tests_to_store - 1

					ENDIF					
									
				ENDIF

                                result_context_object . worksheet_status_update ( )

                IF NOT result_context_object . existing_transaction THEN

                                    IF ( "C" = ( SELECT test . status IN OBJECT test_object )) THEN

                                        auto_validate_test ( test_object )

                                    ENDIF

                                    COMMIT

                                    result_object . rebuild_graph (
                                                          result_context_object )
                                    result_object . rebuild_audits (
                                                          result_context_object )
                                    result_object . rebuild_incidents (
                                                          result_context_object )

                ENDIF

                                result_object . result_status = SELECT result . status
                                                                  IN OBJECT result_object

                                result_object . initial_status = result_object . result_status

                            result_object . check_modify_allowed ( FALSE )

            ELSE

                result_object . set_store_pending ( result_context_object )

            ENDIF

                        result_object . recalculate_formulas ( result_context_object )

                ENDIF

        ENDIF

        IF NOT value_allowed THEN

                IF global ( "TERMTYPE" ) = "GUI" THEN

                        flash_message ( error_message, TRUE )

                ELSE

                        result_context_object . display_message ( error_message,
                                                                  TRUE         )

                        pause ()

                        result_context_object . display_message ( "" , FALSE )

                ENDIF

        ENDIF

        result_context_object . lock_downgrade_object ( "TEST"      ,
                                                        test_object )
        result_context_object . lock_downgrade_object ( "SAMPLE"      ,
                                                        sample_object )

        RETURN ( value_allowed )

ENDROUTINE

{*****************************************************************************}

ROUTINE lib_re_result_action_store_status ( result_object         ,
                                            result_context_object )


    DECLARE check_ok

        IF result_context_object . single_result_commit THEN

            result_context_object . start_write_transaction ( "Update result" )

        CHANGE RESULT STATUS TO result_object . result_status
               USING result IN OBJECT result_object,
                 test   IN OBJECT result_object . test_object,
                 sample IN OBJECT result_object . test_object . sample_object
               PROPAGATE,
               check_ok

            IF check_ok = EMPTY THEN

                    UPDATE result IN OBJECT result_object

			IF ROW_HAS_UPDATES_OBJECT ( "TEST", result_object . test_object ) THEN
				result_object . test_object . update ( )
			ENDIF

			IF ROW_HAS_UPDATES_OBJECT ( "SAMPLE", result_object . test_object . sample_object ) THEN
				result_object . test_object . sample_object . update ( )
			ENDIF

                    result_object . check_modify_allowed ( FALSE )

                    result_context_object . commit ( )

            ELSE

            window_set_status ( check_ok )

                    result_context_object . rollback ( )

            ENDIF

    ELSE

        result_object . status_pre_status_update        = SELECT result . status
                                                                 IN OBJECT result_object
        result_object . store_pending_pre_status_update = result_object . store_pending

        ASSIGN result . status IN OBJECT result_object =
                                    result_object . result_status

        result_object . set_store_pending ( result_context_object )

        result_object . check_modify_allowed ( FALSE )

    ENDIF

        RETURN ( TRUE )

ENDROUTINE

{*****************************************************************************}

ROUTINE lib_re_result_action_release_result (       result_object ,
                                              VALUE result_only   )

    IF NOT result_only THEN

        result_object . test_object . release_test ( )

    ENDIF

	lock_downgrade_object ( "RESULT", result_object )
    lock_unretain_object ( "RESULT", result_object )
	unlock_object         ( "RESULT", result_object )

    IF VARIABLE_IS_ASSIGNED ( result_object . mlp_object ) THEN

        result_object . mlp_object = EMPTY

    ENDIF

ENDROUTINE

{*****************************************************************************}

ROUTINE lib_re_result_action_initialise_result_from_component
                                                ( result_object    ,
                                                  component_object )

DECLARE temp_value, common_fields, count

lib_re_result_get_common_fields ( common_fields )

count = 1

WHILE common_fields [ count ] <> EMPTY DO

    ASSIGN result . 'common_fields [ count ]' IN OBJECT result_object =
            SELECT versioned_component . 'common_fields [ count ]' IN OBJECT component_object

    count = count + 1

ENDWHILE

result_object . result_unit = SELECT versioned_component . units
                                 IN OBJECT component_object


{ The following values are assigned as defaults by RESERVE ENTRY

ASSIGN result . typical                 IN OBJECT result_object = " "
ASSIGN result . value                   IN OBJECT result_object = 0.0
ASSIGN result . text                    IN OBJECT result_object = " "
ASSIGN result . out_of_range            IN OBJECT result_object = FALSE
ASSIGN result . status                  IN OBJECT result_object = " "
ASSIGN result . old_status              IN OBJECT result_object = " "
ASSIGN result . entered_on              IN OBJECT result_object = date ( " " )
ASSIGN result . entered_by              IN OBJECT result_object = " "
ASSIGN result . date_authorised         IN OBJECT result_object = date ( " " )
ASSIGN result . authoriser              IN OBJECT result_object = " "
ASSIGN result . group_id                IN OBJECT result_object = " "
ASSIGN result . security_flags          IN OBJECT result_object = 0

}

IF global ( "RESULT_USER_ASSIGN_ENABLE" ) THEN

        object_set_current_table (  result_object  ,
                                   "RESULT"        )

        object_set_current_table (  component_object      ,
                                   "VERSIONED_COMPONENT" )

        result_user_create ()

        IF result_object . result_str <> SELECT result . text THEN
                temp_value = result_object . result_str
                result_object . result_str = SELECT result . text
                ASSIGN result . text = temp_value
        ENDIF

        IF result_object . result_val <> SELECT result . value THEN
                temp_value = result_object . result_val
                result_object . result_val = SELECT result . value
                ASSIGN result . value = temp_value
        ENDIF

        IF result_object . result_unit <> SELECT result . units THEN
                temp_value = result_object . result_unit
                result_object . result_unit = SELECT result . units
                ASSIGN result . units = temp_value
        ENDIF

        object_copy_current_table (  result_object ,
                                    "RESULT"       )

        object_copy_current_table (  component_object     ,
                                    "VERSIONED_COMPONENT" )

ENDIF


ENDROUTINE

{*****************************************************************************}

ROUTINE lib_re_result_action_reserve_result ( result_object    ,
                                              component_object )

        DECLARE status, return_value

        return_value = FALSE

        IF NOT result_object . result_row_exists THEN

                status = result_reserve ( result_object . test_number :
                                          result_object . name )

                IF status = EMPTY THEN

                        result_object . read_existing_result ( TRUE )

                        result_object . result_read_in = FALSE

                        lock_downgrade_object ( "RESULT", result_object )

                        IF component_object <> EMPTY THEN

                                result_object .
                                       initialise_result_from_component (
                                             component_object )

            ELSEIF ( object_get_class_name (result_object) =
                                MATRIX_RESULT_CLASS_NAME ) THEN

                    lock_retain_object ( "RESULT", result_object )

                ASSIGN result . result_type
                       IN OBJECT result_object =
                                  MATRIX_RESULT_TYPE

            ENDIF

                        return_value = TRUE

                ELSE

                        { Failure }

                ENDIF

        ENDIF

        RETURN ( return_value )

ENDROUTINE

{*****************************************************************************}

ROUTINE lib_re_result_action_read_existing_result (       result_object ,
                                                    VALUE initial       )

        result_object . result_read_in    = TRUE
        result_object . result_row_exists = TRUE

        result_object . result_status  = SELECT result . status
        result_object . initial_status = SELECT result . status
        result_object . result_str     = SELECT result . text
        result_object . result_val     = SELECT result . value
        result_object . result_unit    = SELECT result . units

        result_object . initial_result_str  = result_object . result_str
        result_object . initial_result_val  = result_object . result_val
        result_object . initial_result_unit = result_object . result_unit

        object_copy_current_table ( result_object, "RESULT" )

        result_object . check_modify_allowed ( initial )

ENDROUTINE

{*****************************************************************************}

ROUTINE lib_re_result_action_reselect_result (       result_object         ,
                                                     result_context_object ,
                                               VALUE for_update            )

        DECLARE test_status, comp_obj, result_type, result_reselected


        lock_downgrade_object ( "RESULT", result_object )
        lock_unretain_object ( "RESULT", result_object )

        result_type = SELECT result . result_type IN OBJECT result_object

        result_context_object . rollback ( )

        test_status = SELECT result . test_number FOR READ_LOCK
                      WHERE test_number = result_object . test_number
                      AND name = result_object . name

        IF test_status <> EMPTY THEN

                result_object . read_existing_result ( TRUE )

        ELSE

                comp_obj = result_context_object .
                              component_collection . get_component
                                      ( result_object . analysis         ,
                                        result_object . analysis_version ,
                                        result_object . name             )

                result_object . result_row_exists = FALSE

                result_object . reserve_result ( comp_obj )

                IF EMPTY = comp_obj THEN

                        ASSIGN result . result_type
                               IN OBJECT result_object = result_type
                        ASSIGN result . places
                               IN OBJECT result_object = -1

                ENDIF

        ENDIF

        result_object . rebuild_graph     ( result_context_object )
        result_object . rebuild_audits    ( result_context_object )
        result_object . rebuild_incidents ( result_context_object )

        result_context_object . lock_retain_object ( "RESULT", result_object )

        IF for_update THEN

                result_context_object .
                        lock_upgrade_object ( "RESULT"          ,
                                              result_object     ,
                                              result_reselected )

        ENDIF

ENDROUTINE

{******************************************************************************}

ROUTINE lib_re_result_action_reselect ( result_object )

{
*
*	Simple reselect called from context
*
*******************************************************************************}

	DECLARE result_lock_state,
	        test_numb

	test_numb = SELECT result . test_number IN OBJECT result_object

	result_lock_state = lock_state_object ( "RESULT", result_object )

	IF ( result_lock_state = "EMPTY" ) OR ( result_lock_state = "SELECTED" ) THEN
	
		test_numb = SELECT result . test_number
		            WHERE test_number = test_numb AND
		                  name = result_object . name

	ELSE

		test_numb = SELECT result . test_number FOR READ_LOCK
		            WHERE test_number = test_numb AND
		                  name = result_object . name

	ENDIF

	result_object . read_existing_result ( TRUE )

ENDROUTINE

{*****************************************************************************}

ROUTINE lib_re_result_action_update_existing_result ( result_object  ,
                                                      result_context )

        DECLARE test_number, comp_name, test_status

        IF NOT lock_validate_object ( "RESULT", result_object ) THEN

                test_number = SELECT result .test_number
                              IN OBJECT result_object

                comp_name = SELECT result . name
                            IN OBJECT result_object

                test_status = SELECT result . test_number FOR READ_LOCK
                              WHERE test_number = test_number
                              AND name = comp_name

                IF test_status <> EMPTY THEN

                        result_object . read_existing_result ( FALSE )

                        result_context . lock_retain_object ( "RESULT", result_object )

                ENDIF

        ELSE

                ASSIGN result . status IN OBJECT result_object = "A"

                result_object . initial_status = "A"
                result_object . result_status  = "A"

                result_object . check_modify_allowed ( FALSE )

        ENDIF

ENDROUTINE

{*****************************************************************************}

ROUTINE lib_re_result_action_check_modify_allowed (       result_object ,
                                                    VALUE initial       )

        DECLARE status, test_status

        status      = SELECT result . status IN OBJECT result_object
    test_status = SELECT test . status   IN OBJECT result_object . test_object

	IF result_object . test_object . read_only THEN

                result_object . modify_allowed = FALSE
		result_object . modify_allowed_message =
			result_object . test_object . read_only_message

        ELSEIF index ( LIB_RE_RESULT_AUTH_STATUS, status ) > 0 THEN

                result_object . modify_allowed = FALSE
                result_object . modify_allowed_message = GET_USER_MESSAGE ( "RESULT_ENTRY_AUTH_RESULT", 1 )

    ELSEIF index ( LIB_RE_RESULT_AUTH_STATUS, test_status ) > 0 THEN

                result_object . modify_allowed = FALSE
                result_object . modify_allowed_message = GET_USER_MESSAGE ( "RESULT_ENTRY_AUTH_TEST", 1 )

        ELSEIF index ( LIB_RE_RESULT_ENTERED_STATUS, status ) > 0 THEN

                IF initial THEN

                        result_object . modify_allowed =
                                                global ( "RES_MODIFY_RESULT" )

                ELSE

                        result_object . modify_allowed =
                                            global ( "RES_MODIFY_NEW_RESULT" )

                ENDIF

        ELSE

                result_object . modify_allowed = TRUE

        ENDIF

ENDROUTINE

{*****************************************************************************}

ROUTINE lib_re_result_action_schedule_check_modify_allowed (
                                              result_object         ,
                                              result_context_object )

{
*
*   Schedule an update for the modify_allowed flag after commit
*
******************************************************************************}

    result_object . check_modify_allowed ( FALSE )

    result_context_object . add_to_result_cache (
                      SELECT result . test_number IN OBJECT result_object ,
                      SELECT result . name        IN OBJECT result_object ,
                      SELECT result . text        IN OBJECT result_object ,
                      SELECT result . value       IN OBJECT result_object ,
                      result_object                                       )

ENDROUTINE

{*****************************************************************************}
{                                                                              }
{ Locally called routines                                                      }
{                                                                              }
{*****************************************************************************}

ROUTINE create_result_object ( VALUE result_type )

        DECLARE result_object , strip_result_type

        strip_result_type = result_type

        strip_result_type = STRIP ( result_type )

        IF index ( LIB_RE_VALID_RESULT_TYPES, strip_result_type ) > 0 THEN

                CREATE OBJECT "LIB_RE_RESULT_" : strip_result_type, result_object

        ELSEIF strip_result_type = LIB_RE_AD_HOC_RESULT_TYPE THEN

                CREATE OBJECT "LIB_RE_RESULT_AD_HOC", result_object

        ELSE

                CREATE OBJECT "LIB_RE_RESULT_UNKNOWN", result_object

        ENDIF

        RETURN ( result_object )

ENDROUTINE

{*****************************************************************************}
{                                                                              }
{ Global Routines                                                              }
{                                                                              }
{*****************************************************************************}

GLOBAL
ROUTINE lib_re_result_assign_defaults

        ASSIGN result . places            = -1
        ASSIGN result . out_of_range      = FALSE
        ASSIGN result . sig_figs_number   = -1
        ASSIGN result . sig_figs_rounding = -1

        IF BLANK ( SELECT result . true_word ) THEN

                ASSIGN result . true_word = RE_DEFAULT_TRUE_WORD

        ENDIF

        IF BLANK ( SELECT result . false_word ) THEN

                ASSIGN result . false_word = RE_DEFAULT_FALSE_WORD

        ENDIF

ENDROUTINE

{*****************************************************************************}

GLOBAL
ROUTINE lib_re_result_create_result_from_component ( test_object      ,
                                                     component_object )

        DECLARE result_object

        result_object = create_result_object ( SELECT versioned_component .
                                                         result_type
                                               IN OBJECT component_object )

        result_object . test_object = test_object

        result_object . test_number      = SELECT test . test_number
                                             IN OBJECT test_object
        result_object . analysis         = SELECT test . analysis
                                             IN OBJECT test_object
        result_object . analysis_version = SELECT test . analysis_version
                                             IN OBJECT test_object
        result_object . name             = SELECT versioned_component . name
                                             IN OBJECT component_object
        result_object . result_unit      = SELECT versioned_component . units
                                             IN OBJECT component_object

        RETURN ( result_object )

ENDROUTINE

{*****************************************************************************}

GLOBAL
ROUTINE lib_re_result_create_result_from_result ( test_object )

        DECLARE result_object

        result_object = create_result_object ( SELECT result . result_type )

        result_object . test_object      = test_object
        result_object . test_number      = SELECT test . test_number
                                             IN OBJECT test_object
        result_object . analysis         = SELECT test . analysis
                                             IN OBJECT test_object
        result_object . analysis_version = SELECT test . analysis_version
                                             IN OBJECT test_object
        result_object . name             = SELECT result . name

        result_object . read_existing_result ( TRUE )

        RETURN ( result_object )

ENDROUTINE

{*****************************************************************************}

GLOBAL
ROUTINE lib_re_result_create_result_matrix (       test_object      ,
                                             VALUE name             ,
                                             VALUE matrix_number    )

        DECLARE result_object

        result_object = create_result_object ( MATRIX_RESULT_TYPE )

        result_object . test_object = test_object

        result_object . test_number      = SELECT test . test_number
                                             IN OBJECT test_object
        result_object . analysis         = SELECT test . analysis
                                             IN OBJECT test_object
        result_object . analysis_version = SELECT test . analysis_version
                                             IN OBJECT test_object

        result_object . name             = name
        result_object . matrix_number    = matrix_number

        RETURN ( result_object )

ENDROUTINE

{*****************************************************************************}

GLOBAL
ROUTINE lib_re_result_create_result_blank ( test_object )

        DECLARE result_object, blank_component

        result_object = create_result_object ( LIB_RE_AD_HOC_RESULT_TYPE )

        result_object . test_object = test_object

        result_object . test_number      = SELECT test . test_number
                                             IN OBJECT test_object
        result_object . analysis         = SELECT test . analysis
                                             IN OBJECT test_object
        result_object . analysis_version = SELECT test . analysis_version
                                             IN OBJECT test_object
        result_object . name             = " "

        blank_component = EMPTY

        IF result_object . reserve_result ( blank_component ) THEN

                ASSIGN result . result_type IN OBJECT result_object =
                                                LIB_RE_AD_HOC_RESULT_TYPE

        ENDIF

        RETURN ( result_object )

ENDROUTINE

{*****************************************************************************}

GLOBAL
ROUTINE lib_re_result_create_result_null ( test_object )

        DECLARE result_object, blank_component

        result_object = create_result_object ( " " )

        result_object . test_object = test_object

        result_object . test_number      = SELECT test . test_number
                                             IN OBJECT test_object
        result_object . analysis         = SELECT test . analysis
                                             IN OBJECT test_object
        result_object . analysis_version = SELECT test . analysis_version
                                             IN OBJECT test_object
        result_object . name             = " "

        blank_component = EMPTY

        result_object . reserve_result ( blank_component )

        RETURN ( result_object )

ENDROUTINE

{*****************************************************************************}

GLOBAL
ROUTINE lib_re_result_create_blank_from_type (       test_object    ,
                                               VALUE component_name ,
                                               VALUE result_type    )

        DECLARE result_object, blank_component

        result_object = create_result_object ( result_type )

        result_object . test_object = test_object

        result_object . test_number      = SELECT test . test_number
                                             IN OBJECT test_object
        result_object . analysis         = SELECT test . analysis
                                             IN OBJECT test_object
        result_object . analysis_version = SELECT test . analysis_version
                                             IN OBJECT test_object
        result_object . name             = component_name

        blank_component = EMPTY

        IF result_object . reserve_result ( blank_component ) THEN

                ASSIGN result . result_type
                        IN OBJECT result_object = result_type

                ASSIGN result . places
                        IN OBJECT result_object = -1

        ENDIF

        RETURN ( result_object )

ENDROUTINE

{*****************************************************************************}

ROUTINE lib_re_result_action_set_confirm_message (       result_object ,
                                                   VALUE message_id    )

        IF ( result_object . confirm_message = EMPTY ) OR
           ( message_id = EMPTY )                      THEN

                result_object . confirm_message = message_id

        ENDIF

ENDROUTINE

{*****************************************************************************}

ROUTINE lib_re_result_action_confirm_update ( result_object         ,
                                              result_context_object )

        DECLARE ok

        ok = TRUE

        IF result_object . confirm_message <> EMPTY THEN

                IF ( NOT GLOBAL( "CONFIRMSUPPRESSED" ) ) AND
                   result_context_object . interactive   THEN

                        IF GLOBAL ( "TERMTYPE" ) = "GUI" THEN

                                ok = confirm_with_message
                                       ( result_object . confirm_message )

                        ELSE

                                result_context_object . display_message
                                          ( result_object . confirm_message ,
                                            TRUE                            )

                                ok = confirm ( )

                                result_context_object . display_message ( "" ,
                                                                         FALSE )

                        ENDIF

                        IF NOT ok THEN

                                SET GLOBAL "LASTKEY" TO "CONTINUE"

                        ENDIF

                ENDIF

                result_object . confirm_message = EMPTY

        ENDIF

        RETURN ( ok )

ENDROUTINE

{*****************************************************************************}

ROUTINE lib_re_result_action_set_position (       result_object ,
                                            VALUE column        ,
                                            VALUE row           ,
                                                  grid          )


        result_object . column = column
        result_object . row    = row
        result_object . grid   = grid

ENDROUTINE

{*****************************************************************************}

ROUTINE lib_re_result_action_redisplay ( result_object )

        DECLARE grid

        grid = result_object . grid

        IF grid = EMPTY THEN

        ELSEIF result_object . column = EMPTY THEN

                grid . redisplay_row ( result_object . row    )

        ELSEIF result_object . row    = EMPTY THEN

                grid . redisplay_column ( result_object . column )

        ELSE

                grid . redisplay_cell ( result_object . column ,
                                        result_object . row    )

        ENDIF

ENDROUTINE

{*****************************************************************************}

ROUTINE lib_re_result_action_used_in_formula ( result_object ,
                                               formula       )

        DECLARE count

    IF formula <> result_object THEN

            count = 1

            WHILE count <= size_of_array ( result_object . formulas ) DO

                    IF result_object . formulas [ count ] = formula THEN

                            RETURN

                    ENDIF

                    count = count + 1

            ENDWHILE

            result_object . formulas [ count ] = formula

    ENDIF

ENDROUTINE

{*****************************************************************************}

ROUTINE lib_re_result_action_recalculate_formulas ( result_object  ,
                                                    result_context )

        DECLARE count      ,
                formula    ,
                reselected ,
                worked

        count = 1

        WHILE count <= size_of_array ( result_object . formulas ) DO

                formula = result_object . formulas [ count ]

                worked = formula . recalculate  ( result_context )

                IF NOT worked THEN

                        formula . remove_failed_calc ( result_context )

                        formula . redisplay   ()

                ELSEIF formula . modified () THEN

                        IF formula . upgrade_lock ( reselected ) THEN

                                result_context . transaction_esig_override ( )
                                formula . store_result ( result_context )

			ELSE

				formula . store_pending = TRUE
				formula . reset_result ( result_context )

                        ENDIF

			formula . redisplay   ()

                ENDIF

                count = count + 1

        ENDWHILE

ENDROUTINE

{*****************************************************************************}

ROUTINE lib_re_result_action_get_base ( result_object )


        DECLARE base_name

        base_name = lib_comp_get_base ( SELECT result . name
                                        IN OBJECT result_object )

        RETURN ( base_name )

ENDROUTINE

{*****************************************************************************}

ROUTINE lib_re_result_action_get_name ( result_object )


        DECLARE name

        name = lib_comp_get_name ( SELECT result . name
                                   IN OBJECT result_object )

        RETURN ( name )

ENDROUTINE

{*****************************************************************************}

ROUTINE lib_re_result_action_get_category ( result_object )


        DECLARE category

        category = lib_comp_get_category ( SELECT result . name
                                           IN OBJECT result_object )

        RETURN ( category )

ENDROUTINE

{*****************************************************************************}

ROUTINE lib_re_result_action_get_replicate ( result_object )


        DECLARE replicate

        replicate = lib_comp_get_replicate ( SELECT result . name
                                             IN OBJECT result_object )

        RETURN ( replicate )

ENDROUTINE

{*****************************************************************************}

ROUTINE lib_re_result_action_get_result_type ( result_object )


        RETURN ( SELECT result . result_type IN OBJECT result_object )

ENDROUTINE

{*****************************************************************************}

ROUTINE lib_re_result_action_set_units (       result_object  ,
                                         VALUE new_units      )

        result_object . result_unit = new_units

ENDROUTINE

{*****************************************************************************}

ROUTINE lib_re_result_action_set_field (       result_object  ,
                                         VALUE required_field ,
                                         VALUE required_value ,
                                               result_context )

        DECLARE field   ,
                message

        message = EMPTY
        field   = field_name_to_number ( required_field , "RESULT" )

        IF ( field = field_name_to_number ( "TEXT"  , "RESULT" )) OR
           ( field = field_name_to_number ( "VALUE" , "RESULT" )) THEN

                message = result_object . enter_for_type ( required_value ,
                                                           result_context )

        ELSEIF field = field_name_to_number ( "UNITS" , "RESULT" ) THEN

                result_object . set_units ( required_value )

        ELSEIF field = field_name_to_number ( "LESS_THAN_PQL" , "RESULT" ) THEN

                IF required_value THEN
                        result_object . set_less_than_pql ( result_context )
                ELSE
                        ASSIGN result . less_than_pql
                               IN OBJECT result_object = FALSE
                ENDIF

        ELSEIF field = field_name_to_number ( "GREATER_THAN_PQL" , "RESULT" ) THEN

                IF required_value THEN
                        result_object . set_greater_than_pql ( result_context )
                ELSE
                        ASSIGN result . greater_than_pql
                               IN OBJECT result_object = FALSE
                ENDIF

        ELSEIF field = field_name_to_number ( "RESULT_TYPE" , "RESULT" ) THEN

                message = "RPC_K_BADFLDTYPE"

        ELSEIF field = field_name_to_number ( "NAME" , "RESULT" ) THEN

                message = "RPC_K_BADFLDNAME"

        ELSEIF field = field_name_to_number ( "STATUS" , "RESULT" ) THEN

                message = "RPC_K_BADFLDSTATUS"

        ELSEIF field = field_name_to_number ( "TEST_NUMBER" , "RESULT" ) THEN

                message = "RPC_K_BADFLDTEST"

        ELSEIF field = field_name_to_number ( "ENTERED_ON" , "RESULT" ) THEN

                message = "RPC_K_BADFLDENTON"

        ELSEIF field = field_name_to_number ( "ENTERED_BY" , "RESULT" ) THEN

                message = "RPC_K_BADFLDENTBY"

        ELSEIF field = field_name_to_number ( "DILUTION_FACTOR" , "RESULT" ) THEN


                ASSIGN result . dilution_factor IN OBJECT result_object =
                                required_value

                result_object . dilution_set = TRUE

                result_object . set_pql ( result_context )

        ELSE

                ASSIGN result . 'required_field' IN OBJECT result_object =
                                required_value

        ENDIF

        RETURN ( message )

ENDROUTINE

{*****************************************************************************}

ROUTINE lib_re_result_action_get_field (       result_object  ,
                                         VALUE required_field )

        DECLARE answer ,
                field

        field   = field_name_to_number ( required_field , "RESULT" )

        IF SELECT result . name IN OBJECT result_object = EMPTY THEN

                answer = EMPTY

        ELSEIF field = field_name_to_number ( "TEXT" , "RESULT" ) THEN

                answer = result_object . result_str

        ELSEIF field = field_name_to_number ( "VALUE" , "RESULT" ) THEN

                answer = result_object . result_val

        ELSEIF field = field_name_to_number ( "UNITS" , "RESULT" ) THEN

                answer = result_object . result_unit

        ELSE

                answer = SELECT result . 'required_field'
                         IN OBJECT result_object

        ENDIF

        RETURN ( answer )

ENDROUTINE

{*****************************************************************************}

ROUTINE lib_re_result_action_update ( result_object  ,
                                      result_context )

        IF result_object . modified () THEN

                result_object . store_result ( result_context )

        ELSEIF result_context . single_result_commit THEN


                UPDATE RESULT IN OBJECT result_object

    ELSE

        result_object . set_store_pending  ( result_context )

        ENDIF

ENDROUTINE

{*****************************************************************************}

ROUTINE lib_re_result_action_modified ( result_object )

        RETURN (( result_object . result_str <>
                  SELECT result . text IN OBJECT result_object  ) OR
                ( result_object . result_val <>
                  SELECT result . value IN OBJECT result_object ) OR
                ( result_object . result_unit <>
                  SELECT result . units IN OBJECT result_object ))

ENDROUTINE

{*****************************************************************************}

ROUTINE lib_re_result_action_is_locked_for_update ( result_object )

        DECLARE row_state

        row_state = lock_state_object ( "RESULT", result_object )

        RETURN (( row_state = "SELECTED_WRITE" ) OR
                ( row_state = "RESERVED_WRITE" ))

ENDROUTINE

{*****************************************************************************}

ROUTINE lib_re_result_action_upgrade_lock ( result_object ,
                                            reselected    )

        DECLARE ok

        ok = lock_upgrade_object ( "RESULT"         ,
                                    result_object   ,
                                    reselected      )

        IF reselected AND ok THEN

        result_object . result_str     = SELECT result . text
                                           IN OBJECT result_object
        result_object . result_val     = SELECT result . value
                                           IN OBJECT result_object
        result_object . result_unit    = SELECT result . units
                                           IN OBJECT result_object
        result_object . initial_status = SELECT result . status
                                           IN OBJECT result_object

        ENDIF

        RETURN ( ok )

ENDROUTINE

{*****************************************************************************}

ROUTINE lib_re_result_action_downgrade_lock ( result_object  ,
                                              result_context )

    result_context . lock_downgrade_object ( "RESULT"       ,
                                              result_object )

ENDROUTINE

{*****************************************************************************}

ROUTINE lib_re_result_action_result_entered ( result_object )

        DECLARE status

        status = SELECT result . status IN OBJECT result_object

        RETURN (( status <> EMPTY ) AND
                ( status <> "U"   ) AND
                ( status <> " "   ))

ENDROUTINE

{*****************************************************************************}

ROUTINE lib_re_result_action_result_accepted_status ( result_object )

        DECLARE status

        status = SELECT result . status IN OBJECT result_object

        RETURN ((  status <> EMPTY ) AND
                (( status = "E"    ) OR
                 ( status = "M"    ) OR
                 ( status = "A"    )))

ENDROUTINE

{*****************************************************************************}

ROUTINE lib_re_result_action_get_minimum_pql (  result_object  ,
                                                pql            ,
                                                result_context )

        DECLARE limit_calc    ,
                mlp_component ,
                mode

        limit_calc = SELECT result . pql_calculation
                        IN OBJECT result_object

        IF limit_calc <> NULL THEN

                IF NOT ( blank ( limit_calc )) THEN

                        mode = PQL_LESS_THAN_MODE

                        CALL_ROUTINE "limit_calculation"
                             IN LIMIT_CALCULATION_LIBRARY limit_calc
                             USING result_object  ,
                                   result_context ,
                                   mlp_component ,
                                   mode
                        NEW CONTEXT


                ENDIF

        ENDIF

        pql = SELECT result . minimum_pql IN OBJECT result_object

        RETURN ( pql <> 0 )

ENDROUTINE


{*****************************************************************************}

ROUTINE lib_re_result_action_set_less_than_pql ( result_object  ,
                                                 result_context )

        DECLARE pql  ,
                numb


        IF (     result_object . get_minimum_pql ( numb           ,
                                                   result_context )) AND
           ( NOT result_object . is_calculation                   ) THEN

                ASSIGN result . less_than_pql    IN OBJECT result_object = TRUE
                ASSIGN result . greater_than_pql IN OBJECT result_object = FALSE

                pql = "<" : result_object . format_number ( numb )

                IF result_object . enter_for_type ( pql            ,
                                                    result_context ) = EMPTY THEN
            result_object . store_result ( result_context )
        ENDIF

        ENDIF

ENDROUTINE


{*****************************************************************************}

ROUTINE lib_re_result_action_update_less_than_pql ( result_object  ,
                                                    result_context )

{
*
*       Lock the result set the pql and update the value.
*       Used by the twr and tsr grid modules.
*
*******************************************************************************}

        DECLARE updated,
                pql,
                reselected

        updated = FALSE

        IF ( NOT result_object . result_entered ( ))                  AND
           ( NOT result_object . is_calculation )                     AND
           ( result_object . get_minimum_pql ( pql, result_context )) THEN

                IF result_object . upgrade_lock ( reselected ) THEN

                        ASSIGN result . less_than_pql
                               IN OBJECT result_object = TRUE
                        ASSIGN result . greater_than_pql
                               IN OBJECT result_object = FALSE

	                pql = "<" : result_object . format_number ( pql )

                        result_object . enter_for_type ( pql            ,
                                                         result_context )

                        result_object . store_result ( result_context )

                        result_object . downgradelock ( result_context )

                        updated = TRUE

                ENDIF

        ENDIF

        RETURN ( updated )

ENDROUTINE

{*****************************************************************************}

ROUTINE lib_re_result_action_get_maximum_pql ( result_object  ,
                                               pql            ,
                                               result_context )

        DECLARE limit_calc    ,
                mlp_component ,
                mode

        limit_calc = SELECT result . pql_calculation
                        IN OBJECT result_object

        IF limit_calc <> NULL THEN

                IF NOT ( blank ( limit_calc )) THEN

                        mode = PQL_GREATER_THAN_MODE

                        CALL_ROUTINE "limit_calculation"
                             IN LIMIT_CALCULATION_LIBRARY limit_calc
                             USING result_object  ,
                                   result_context ,
                                   mlp_component ,
                                   mode
                        NEW CONTEXT


                ENDIF

        ENDIF

        pql = SELECT result . maximum_pql IN OBJECT result_object

        RETURN ( pql <> 0.0 )

ENDROUTINE


{*****************************************************************************}

ROUTINE lib_re_result_action_set_greater_than_pql ( result_object  ,
                                                    result_context )

        DECLARE pql  ,
                numb

        IF (     result_object . get_maximum_pql ( numb             ,
                                                   result_context  )) AND
           ( NOT result_object . is_calculation                     ) THEN

                ASSIGN result . less_than_pql    IN OBJECT result_object = FALSE
                ASSIGN result . greater_than_pql IN OBJECT result_object = TRUE

                pql = ">" : result_object . format_number ( numb )

        IF result_object . enter_for_type ( pql            ,
                                            result_context ) = EMPTY THEN
            result_object . store_result ( result_context )
        ENDIF

        ENDIF

ENDROUTINE

{*****************************************************************************}

ROUTINE lib_re_result_action_update_greater_than_pql ( result_object  ,
                                                       result_context )

{
*
*       Lock the result set the pql and update the value.
*       Used by the twr and tsr grid modules.
*
*******************************************************************************}

        DECLARE updated,
                pql,
                reselected

        updated = FALSE

        IF ( NOT result_object . result_entered ( ))                  AND
           ( NOT result_object . is_calculation )                     AND
           ( result_object . get_maximum_pql ( pql, result_context )) THEN

                IF result_object . upgrade_lock ( reselected ) THEN

                        ASSIGN result . less_than_pql
                               IN OBJECT result_object = FALSE
                        ASSIGN result . greater_than_pql
                               IN OBJECT result_object = TRUE

	                pql = ">" : result_object . format_number ( pql )

                        result_object . enter_for_type ( pql            ,
                                                         result_context )

                        result_object . store_result ( result_context )

                        result_object . downgradelock ( result_context )

                        updated = TRUE

                ENDIF

        ENDIF

        RETURN ( updated )

ENDROUTINE

{*****************************************************************************}

ROUTINE lib_re_result_action_format_number (       result_object ,
                                             VALUE numb          )

	DECLARE curr_format, places, formatted_numb

	curr_format = GLOBAL ( "FORMAT_TEXT" )

	places = SELECT result . places IN OBJECT result_object

	IF places > 0 THEN

		SET FORMAT pad ( "9", "9", find_max_number ( 10 - places - 1, 1 )) :
			   "." : pad ( "9", "9", places )

	ELSEIF places = 0 THEN

		SET FORMAT pad ( "9", "9", 10 )

	ELSE

		SET FORMAT "999999.999"

	ENDIF
	
	formatted_numb = STRIP ( numb )
	
	SET FORMAT curr_format
	
	RETURN ( formatted_numb )

ENDROUTINE

{*****************************************************************************}

ROUTINE lib_re_result_action_set_pql ( result_object  ,
                                       result_context )

        DECLARE result_text         ,
                assign_less_than    ,
                assign_greater_than ,
                pql

        assign_less_than    = FALSE
        assign_greater_than = FALSE

        result_text      = result_object . get_field ( "TEXT" )

        IF result_object . get_minimum_pql ( pql             ,
                                             result_context  ) THEN

                IF ( result_object . get_inequality () = "<" )  AND
                   ( numeric ( result_text ) = pql           )  THEN

                        assign_less_than = TRUE

                ELSE

                        assign_less_than = numeric ( result_text ) < pql

                ENDIF

        ENDIF

        IF result_object . get_maximum_pql ( pql            ,
                                             result_context ) THEN

                IF ( result_object . get_inequality () = ">" )  AND
                   ( numeric ( result_text ) = pql           )  THEN

                        assign_greater_than = TRUE

                ELSE

                        assign_greater_than = numeric ( result_text ) > pql

                ENDIF

        ENDIF

        IF GLOBAL ( "PQL_SET_RESULT" ) THEN

                IF assign_less_than THEN

                        result_object . get_minimum_pql ( pql, result_context )
                        result_object . result_str = "<" : result_object . format_number ( pql )

                ELSEIF assign_greater_than THEN

                        result_object . get_maximum_pql ( pql, result_context )
                        result_object . result_str = ">" : result_object . format_number ( pql )

                ENDIF

        ENDIF

        ASSIGN result . less_than_pql IN OBJECT result_object =
                        assign_less_than

        ASSIGN result . greater_than_pql IN OBJECT result_object =
                        assign_greater_than

ENDROUTINE

{*****************************************************************************}

ROUTINE lib_re_result_action_set_default_dilution ( result_object  ,
                                                    result_context )



        IF NOT result_object . result_entered () THEN

                IF NOT result_object . dilution_set THEN

                        ASSIGN result . dilution_factor
                               IN OBJECT result_object = result_context . default_dilution_factor

                ENDIF

        ENDIF

ENDROUTINE

{*****************************************************************************}

ROUTINE lib_re_result_action_get_inequality ( result_object )

        DECLARE inequality ,
                temp       ,
                first      ,
                second

        temp = strip ( result_object . result_str )


        inequality = ""

        first  = substring ( temp , 1 , 1 )
        second = substring ( temp , 2 , 1 )


        IF INDEX ( "<>" , first ) <> 0 THEN


                IF second = "=" THEN

                        inequality = first : second

                ELSE

                        inequality = first

                ENDIF

        ELSEIF first = "~" THEN

                inequality = first

        ENDIF

        RETURN ( inequality )

ENDROUTINE

{*****************************************************************************}

ROUTINE lib_re_result_action_result_as_units (       result_object ,
                                               VALUE units         ,
                                                     error_status  )

        DECLARE result    ,
                old_units ,
                answer

        result    = result_object . get_field ( "TEXT"  )
        old_units = result_object . get_field ( "UNITS" )

        answer = unit_convert ( result       ,
                                old_units    ,
                                units        ,
                                error_status )

        RETURN ( answer )

ENDROUTINE

{*****************************************************************************}

ROUTINE lib_re_result_action_blank_out_result ( result_object  ,
                                                result_context )

{
*
*   Set the result as if were not entered.
*
******************************************************************************}

        DECLARE analysis          ,
                analysis_version  ,
                name              ,
                component         ,
                already_in_write  ,
                sample_upgrade    ,
                test_upgrade      ,
                sample_reselected ,
                test_reselected   ,
                reselected        ,
                blank_out_result  ,
                value_changed     ,
                check_ok

    value_changed    = FALSE
        blank_out_result = FALSE
        already_in_write = TRANSACTION_IS_WRITE ( )

        IF NOT result_object . result_entered () THEN

                result_object . downgradelock ( result_context )

        ELSEIF NOT ( result_object . upgrade_lock ( reselected )) THEN

        { Do nothing if we cant upgrade the lock
          else either clear the fields or delete the record }

    ELSEIF ( SELECT test . has_result_list
                    IN OBJECT result_object . test_object ) THEN

        blank_out_result = TRUE


    ELSEIF ( NOT result_context . single_result_commit ) THEN

        blank_out_result = TRUE { NOT result_object . reset_result ( result_context )}

    ELSEIF lock_exclusive_object ( "RESULT", result_object ) THEN

                { Calculation is no longer valid - Attempt to delete it }

                IF NOT already_in_write THEN
            result_context . start_write_transaction (
                                 "Blank out result" )
                ENDIF

                analysis = SELECT test . analysis
                           IN OBJECT result_object . test_object

                analysis_version = SELECT test . analysis_version
                                   IN OBJECT result_object . test_object

                name = SELECT result . name IN OBJECT result_object

                name = lib_comp_get_name ( name )

                component = result_context . component_collection .
                                get_component ( analysis          ,
                                                analysis_version  ,
                                                name              )

                test_upgrade = result_context . lock_upgrade_object (
                                            "TEST"                      ,
                                            result_object . test_object ,
                                            test_reselected             )

                sample_upgrade = result_context . lock_upgrade_object (
                                   "SAMPLE"                                    ,
                                   result_object . test_object . sample_object ,
                                   sample_reselected                           )

                IF sample_upgrade AND test_upgrade THEN

			check_ok = SELECT result . test_number
			           WHERE  test_number = ( SELECT result . test_number IN OBJECT result_object ) AND
			                  name <> ( SELECT result . name IN OBJECT result_object )

                DELETE result IN OBJECT result_object

			IF ( check_ok <> EMPTY ) THEN
				CHANGE TEST STATUS TO "P"
				       USING test   IN OBJECT result_object . test_object ,
				             sample IN OBJECT result_object . test_object . sample_object
				       PROPAGATE,
				       check_ok
			ELSE
				CHANGE TEST STATUS TO "V"
				       USING test   IN OBJECT result_object . test_object ,
				             sample IN OBJECT result_object . test_object . sample_object
				       PROPAGATE,
				       check_ok
			ENDIF

			IF ROW_HAS_UPDATES_OBJECT ( "TEST", result_object . test_object ) THEN
				result_object . test_object . update()
			ENDIF

			IF ROW_HAS_UPDATES_OBJECT ( "SAMPLE", result_object . test_object . sample_object ) THEN
				result_object . test_object . sample_object . update()
			ENDIF

                lock_downgrade_object ( "RESULT", result_object )
                lock_unretain_object ( "RESULT", result_object )

                IF NOT already_in_write THEN
            result_context . commit ( )
                ENDIF

                result_object . result_row_exists = FALSE
                result_object . reserve_result ( component )
                result_context . lock_retain_object ( "RESULT",  result_object )

        value_changed = TRUE

		ENDIF

        ELSE

        { We cant delete the failed result do blank it out }
        blank_out_result = TRUE

    ENDIF

    IF blank_out_result THEN

                IF NOT already_in_write THEN
			result_context . start_write_transaction ( "Blank out result" )
                ENDIF

                test_upgrade = result_context . lock_upgrade_object (
                                            "TEST"                      ,
                                            result_object . test_object ,
                                            test_reselected             )

                sample_upgrade = result_context . lock_upgrade_object (
                                   "SAMPLE"                                    ,
                                   result_object . test_object . sample_object ,
                                   sample_reselected                           )

                IF sample_upgrade AND test_upgrade THEN

			IF result_context . single_result_commit THEN

                        change_result_status ( "U" ,
                                       result_object . test_object . sample_object,
                                       result_object . test_object,
                                       result_object )

			ELSE

				ASSIGN result . status IN OBJECT result_object = "U"

			ENDIF

            analysis = SELECT test . analysis
                   IN OBJECT result_object . test_object

            analysis_version = SELECT test . analysis_version
                       IN OBJECT result_object . test_object

            name = SELECT result . name IN OBJECT result_object

            name = lib_comp_get_name ( name )

            component = result_context . component_collection .
                    get_component ( analysis          ,
                            analysis_version  ,
                            name              )

                        ASSIGN result . value        IN OBJECT result_object = 0.0
                        ASSIGN result . text         IN OBJECT result_object = ""
                        ASSIGN result . out_of_range IN OBJECT result_object = FALSE

			result_object . assign_raw_result ( "" )

			IF ( component <> EMPTY ) THEN
            ASSIGN result . units        IN OBJECT result_object =
                     SELECT versioned_component . units
                                        IN OBJECT component
			ELSE
				ASSIGN result . units IN OBJECT result_object = result_object . initial_result_unit
			ENDIF

                        IF result_context . single_result_commit THEN

                            UPDATE result IN OBJECT result_object
                            UPDATE test   IN OBJECT result_object . test_object
                            UPDATE sample IN OBJECT result_object . test_object . sample_object

            ELSE

                result_object . set_store_pending ( result_context )

            ENDIF

                        result_object . result_str     = ""
                        result_object . result_val     = 0.0

			IF ( component <> EMPTY ) THEN
            result_object . result_unit    = SELECT versioned_component . units
                                                                IN OBJECT component
			ELSE
				result_object . result_unit = result_object . initial_result_unit
			ENDIF

            value_changed = TRUE

                ENDIF

                IF NOT already_in_write THEN
            result_context . commit ( )
                ENDIF

        ENDIF

    IF value_changed THEN

        result_context . result_info_update ( result_object )

        IF result_context . single_result_commit THEN

            result_object . mlp_update ()
            result_object . create_incidents ()

            result_context . worksheet_status_update ( )
            result_object . rebuild_graph     ( result_context )
            result_object . rebuild_audits    ( result_context )
            result_object . rebuild_incidents ( result_context )

        ENDIF

        result_object . recalculate_formulas ( result_context )

    ENDIF

ENDROUTINE

{*****************************************************************************}

ROUTINE lib_re_result_action_remove_failed_calc ( result_object  ,
                                                  result_context )

{
*
*   Set the calculation as if were not entered.
*
******************************************************************************}

        IF (( SELECT result . formula IN OBJECT result_object ) = NULL ) AND
           ( NOT GLOBAL ( "RES_DELETE_FAILED_CALCS" ))                   THEN

                result_object . downgradelock ( result_context )

    ELSE

        result_object . blank_out_result ( result_context )

    ENDIF

ENDROUTINE

{*****************************************************************************}

ROUTINE lib_re_result_action_undo_status ( result_object  ,
                                           result_context )

    DECLARE reselected,
            status

    IF ( result_object . status_pre_status_update <> " " ) AND
       ( result_object . status_pre_status_update <> result_object . initial_status ) THEN

        result_object . result_status = result_object . status_pre_status_update

        result_object . store_status ( result_context )

        result_object . status_pre_status_update        = " "
        result_object . store_pending_pre_status_update = FALSE

    ELSEIF result_object . reset_result ( result_context ) THEN

        result_context . remove_from_result_cache (
                          SELECT result . test_number IN OBJECT result_object ,
                          SELECT result . name        IN OBJECT result_object )

        result_context . results_to_store =
                 result_context . results_to_store + 1

    ELSEIF ( result_object . initial_status <>
             result_object . result_status ) AND
           (( result_object . result_status = "A" ) OR
            ( result_object . result_status = "R" )) THEN

        IF result_object . upgrade_lock ( reselected ) THEN

            status = result_object . initial_status

            IF ( status <> "E" ) AND ( status <> "M" ) THEN
                status = "M"
            ENDIF

            result_object . result_status = status

            IF result_object . result_status <>
               ( SELECT result . status IN OBJECT result_object ) THEN

                result_object . store_status ( result_context )

            ENDIF

            result_object . downgrade_lock ( result_context )

        ENDIF

    ENDIF

ENDROUTINE

{*****************************************************************************}

ROUTINE lib_re_result_action_read_instrument_result ( result_object  ,
                                                      result_context )

    DECLARE instrument_result ,
            store_status      ,
            reselected        ,
            test_inst_type    ,
            test_inst_id      ,
            inst_comm         ,
            ok

    ok = TRUE

    CREATE OBJECT INSTRUMENT_COMM_CLASS, inst_comm
    inst_comm . check_calibration = TRUE

    test_inst_id   = SELECT test . instrument
                          IN OBJECT result_object . test_object

    test_inst_type = SELECT  test . instrument_type
                          IN OBJECT result_object . test_object

    IF BLANK( test_inst_id ) AND BLANK( test_inst_type ) THEN

        IF ok AND NOT inst_comm . is_setup( ) THEN

            {*****************************************************************}
            {* No instrument has been specified. Allow user to pick from all *}
            {* insts. available on their machine (subject to config item )   *}
            {*****************************************************************}

            IF GLOBAL( "INST_UNSPECIFIED_ALLOW_ANY" ) THEN

                ok = ok AND inst_comm . setup_from_machine( )

            ELSE

                flash_message( GET_USER_MESSAGE( "INST_COMM_ERR_NOT_DEFINE", 1 ) :
                               ASCII( 13 ) :
                               GET_USER_MESSAGE( "INST_COMM_ERR_NOT_DEFINE", 2 ) , TRUE )

            ENDIF

        ENDIF

    ELSE

        {*********************************************************************}
        {* First, try to find exact instrument specified on test             *}
        {*********************************************************************}

        ok = ok AND inst_comm . setup_from_identity( test_inst_id )

        IF ok AND NOT inst_comm . is_setup( ) THEN

            {*****************************************************************}
            {* Next, try to find an instrument of type specified on test     *}
            {*****************************************************************}

            ok = ok AND inst_comm . setup_from_type( test_inst_type )

        ENDIF

        IF ok AND NOT inst_comm . is_setup( ) THEN

            {*****************************************************************}
            {* Finally, (subject to config item) allow user to select any    *}
            {* instrument on their machine                                   *}
            {*****************************************************************}

            IF GLOBAL( "INST_NOT_FOUND_ALLOW_ANY" ) THEN

                ok = ok AND inst_comm . setup_from_machine( )

            ELSE

                flash_message( GET_USER_MESSAGE( "INST_COMM_ERR_NOT_FOUND", 1 ) :
                               ASCII( 13 ) :
                               GET_USER_MESSAGE( "INST_COMM_ERR_NOT_FOUND", 2 ) , TRUE )

            ENDIF

        ENDIF

    ENDIF

    IF ok THEN

        IF inst_comm . is_setup( ) THEN

            instrument_result = inst_comm . read_result( )

            IF ( instrument_result = ERROR ) THEN

                { Nothing to do no result read }

            ELSEIF ( result_object . upgrade_lock ( reselected )) THEN

                store_status = result_object . enter_for_type ( instrument_result ,
                                                                result_context    )

                IF store_status = EMPTY THEN

                    ASSIGN result . instrument_used
                           IN OBJECT result_object = inst_comm . instrument_id

                    result_object . store_result ( result_context )

                ELSE
                    flash_message ( store_status, TRUE )
                ENDIF

                result_object . downgradelock ( result_context )

            ENDIF

        ELSE

            client_message_box( GET_USER_MESSAGE( "RE_INST_ERR_NO_LOCAL", 1 ) ,
                                GET_USER_MESSAGE( "RE_INST_H_READ", 1 )       ,
                                MB_OK + MB_ICONHAND                           )
        ENDIF

    ENDIF

ENDROUTINE

{******************************************************************************}
{ Raw result handling                                                          }
{******************************************************************************}

ROUTINE lib_re_result_action_read_raw_result ( result_object )

	DECLARE ret_value ,
		name_of_field

	name_of_field = "RAW_RESULT"

	IF valid_field ( "RESULT", name_of_field ) THEN
		ret_value = SELECT result . 'name_of_field'
		              IN OBJECT result_object
	ELSE
		ret_value = " "
	ENDIF

	RETURN ( ret_value )

ENDROUTINE

{******************************************************************************}

ROUTINE lib_re_result_action_assign_raw_result (       result_object  ,
                                                 VALUE result_raw_str )

	DECLARE name_of_field

	name_of_field = "RAW_RESULT"

	IF valid_field ( "RESULT", name_of_field ) THEN
	
		IF BLANK ( result_raw_str ) THEN
		
			ASSIGN result . 'name_of_field' IN OBJECT result_object =
			       SELECT result . text IN OBJECT result_object

		ELSE

			ASSIGN result . 'name_of_field' IN OBJECT result_object =
			                                              result_raw_str

		ENDIF

	ENDIF

ENDROUTINE

{******************************************************************************}

GLOBAL

ROUTINE lib_re_result_get_common_fields ( common_fields_array )

{
*   Returns an array containing field names common to the result and
*   component tables
*
*******************************************************************************}

    IF NOT variable_is_assigned ( lib_re_result_common_entries ) THEN

        lib_re_result_common_entries = lib_utils_get_common_fields_array
                                            ( "result"              ,
                                              "versioned_component" )

    ENDIF

    common_fields_array = lib_re_result_common_entries

ENDROUTINE { lib_re_result_get_common_fields }

{******************************************************************************}
{******************************************************************************}
{******************************************************************************}
