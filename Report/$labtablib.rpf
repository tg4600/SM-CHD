{******************************************************************************
*
* Module Name   : $LABTABLIB
*
* Purpose       : The aim of this report is to simulate sample manager lab
*                 tables. The goal of the report is to allow the customer to
*                 be able to define the layout of a lab table input. This is
*                 desirable with the advent of user defined tables.
*
* Document Ref. : SE/T/TVGL-WORK-REPORTS/1/3
*
* Specification :
*
* Portability   : Not Checked
*
* Re-entrant    :
*
*******************************************************************************}

{******************************************************************************}
{ Programming Notes                                                            }
{ -----------------                                                            }
{                                                                              }
{    Normal lab table functions include :                                      }
{      1   Adding Records                                                      }
{      2   Copying Records                                                     }
{      3   Modifying Records                                                   }
{      4   Displaying Records                                                  }
{      5   Removing Records                                                    }
{      6   Restoring Records                                                   }
{      7   List Records                                                        }
{      8   Print Records                                                       }
{      9   Create new version                                                  }
{                                                                              }
{    On versioned laboratory tables we may have approval                       }
{                                                                              }
{      10  Submit Records                                                      }
{      11  Approve Records                                                     }
{                                                                              }
{******************************************************************************}

JOIN STANDARD_LIBRARY STD_ARRAY
JOIN STANDARD_LIBRARY STD_ARRAY_SELECT
JOIN STANDARD_LIBRARY STD_CLASS
JOIN STANDARD_LIBRARY STD_CLIENT
JOIN STANDARD_LIBRARY STD_DATABASE
JOIN STANDARD_LIBRARY STD_GENERAL
JOIN STANDARD_LIBRARY STD_GLOBAL
JOIN STANDARD_LIBRARY STD_MESSAGE
JOIN STANDARD_LIBRARY STD_PROMPT
JOIN STANDARD_LIBRARY STD_UTILS
JOIN STANDARD_LIBRARY STD_VGL
JOIN STANDARD_LIBRARY STD_WINDOW

JOIN LIBRARY $LIB_INSPECT
JOIN LIBRARY $GEN_APPR
JOIN LIBRARY $INSTALL_WINDOW
JOIN LIBRARY $LABTAB_IMPRINT
JOIN LIBRARY $LIB_DYNAMIC_SQL
JOIN LIBRARY $LIB_GRID
JOIN LIBRARY $LIB_UTILS
JOIN LIBRARY $LINE_EDITOR
JOIN LIBRARY $PRINT_LTE
JOIN LIBRARY $PROMPT_TAB
JOIN LIBRARY $PROMPT_WINDOW
JOIN LIBRARY $ROLE_LIB
JOIN LIBRARY MLP_SCHED_UPDATE

SET COMPILE_OPTION DECLARE
ENABLE WINDOWS
SET NOTPROTECTED

{* Global Constants ***********************************************************}

GLOBAL CONSTANT CHARACTER_POSITION  = 1
GLOBAL CONSTANT TITLE_POSITION      = 2
GLOBAL CONSTANT LIBRARY_POSITION    = 3
GLOBAL CONSTANT ROUTINE_POSITION    = 4

GLOBAL CONSTANT MESSAGE_POSITION    = 1
GLOBAL CONSTANT TYPE_POSITION       = 2
GLOBAL CONSTANT TABLE_NAME_POSITION = 3
GLOBAL CONSTANT FIELD_NAME_POSITION = 4

GLOBAL CONSTANT IDENTITY_MESSAGE    = 1

GLOBAL CONSTANT IDENTITY1_MESSAGE   = 1
GLOBAL CONSTANT IDENTITY2_MESSAGE   = 2
GLOBAL CONSTANT IDENTITY3_MESSAGE   = 3
GLOBAL CONSTANT IDENTITY4_MESSAGE   = 4

GLOBAL CONSTANT MOD_ON_MESSAGE      = 5
GLOBAL CONSTANT MOD_BY_MESSAGE      = 6
GLOBAL CONSTANT READ_MESSAGE        = 7
GLOBAL CONSTANT WRITE_MESSAGE       = 8
GLOBAL CONSTANT APPROVAL_MESSAGE    = 9

{* Local Constants ************************************************************}

CONSTANT CONTROL_BUTTON_WIDTH       = 10

CONSTANT LABTABLIB_CLASS            = "STD_LABTABLE_EDITOR"
CONSTANT LABTABLIB_TAB_CLASS        = "LABTABLIB_TAB"
CONSTANT LABTABLIB_TAB_PROMPT_CLASS = "LABTABLIB_TAB_PROMPT"

CONSTANT OPERATION_ADD              = "ADD"
CONSTANT OPERATION_COPY             = "COPY"
CONSTANT OPERATION_MODIFY           = "MODIFY"
CONSTANT OPERATION_NEW_VERSION      = "NEW_VERSION"
CONSTANT OPERATION_DISPLAY          = "DISPLAY"
CONSTANT OPERATION_PRINT            = "PRINT"
CONSTANT OPERATION_LIST             = "LIST"
CONSTANT OPERATION_REMOVE           = "REMOVE"
CONSTANT OPERATION_RESTORE          = "RESTORE"
CONSTANT OPERATION_APPROVE          = "APPROVE"
CONSTANT OPERATION_SUBMIT           = "SUBMIT"

CONSTANT LOCK_RECORD                = TRUE
CONSTANT DONT_LOCK_RECORD           = FALSE

CONSTANT TAB_USER_TYPE              = 1
CONSTANT TAB_USER_TABLE             = 2
CONSTANT TAB_USER_FIELD             = 3
CONSTANT TAB_USER_DATA              = 4

CONSTANT TAB_USER_LIBRARY           = 2
CONSTANT TAB_USER_ROUTINE           = 3

CONSTANT TAB_MAX_PROMPT_HEIGHT      = 4

CONSTANT APPROVAL_APPROVED          = FALSE
CONSTANT APPROVAL_ANY               = TRUE

{* Global Variables ***********************************************************}

DECLARE labtablib_global_labtable ,
        labtablib_global_form

{* Start Of Routines **********************************************************}

{*****************************************************************************}

    GLOBAL

    ROUTINE labtablib_get_labtable ( labtable )

{
*
*
*****************************************************************************}

        labtable = labtablib_global_labtable

ENDROUTINE

{*****************************************************************************}

    GLOBAL

    ROUTINE labtablib_get_form ( form )

{
*
*
*****************************************************************************}

        form = labtablib_global_form

ENDROUTINE

{*****************************************************************************}

    ROUTINE labtablib_define_class

{
*
*
*****************************************************************************}

        DEFINE CLASS LABTABLIB_CLASS

        PROPERTIES "NAME_OF_TABLE"        ,
                   "USER_NAME_OF_TABLE"   ,
                   "OPERATION"            ,
                   "MESSAGES"             ,
                   "IDENTITY"             ,
                   "KEY0_FIELDS"          ,
                   "NUMBER_KEY0_FIELDS"   ,
                   "COPY_VALUE"           ,
                   "DEFAULT_VALUE"        ,
                   "INPUT_MESSAGE"        ,
                   "DIRECTORY"            ,
                   "EXTENSION"            ,
                   "SPECIAL_ACTIONS"      ,
                   "LTE_REPORT"           ,
                   "MODIFIED_ON"          ,
                   "MODIFIED_BY"          ,
                   "REMOVE_FIELD"         ,
                   "GROUP_FIELD"          ,
                   "MODIFIABLE_FIELD"     ,
                   "VERSION_FIELD"        ,
                   "HELP_CONTEXT"         ,
                   "TEXT_FILE_SAVED"      ,
                   "TEXT_FILE_COPIED"     ,
                   "INFO_POSITION"        ,
                   "DISPLAY_START"        ,
                   "FIRST_ID_PROMPT"      ,
                   "LAST_ID_PROMPT"       ,
                   "EDITOR_PROMPT"        ,
                   "MODIFIED_ON_OBJECT"   ,
                   "MODIFIED_BY_OBJECT"   ,
                   "IS_EDITING"           ,
                   "CLEAR_SCREEN"         ,
                   "PROMPT_DETAILS"       ,
                   "LABTABLE_MODE"        ,
           "APPROVAL_MODE"        ,
           "SUBMIT_MODE"          ,
           "APPROVAL_STAT_OBJECT" ,
           "APPROVAL_FIELD"       ,
           "INSPECTION_FIELD"     ,
           "HAS_APPROVAL"         ,
           "ASK_FOR_SUBMIT"       ,
                   "APPROVE_AS"           ,
                   "INTERFACE"            ,
                   "NAME_FIELD"

        END CLASS

ENDROUTINE

{****************************************************************************}

    ROUTINE labtablib_create_prompt_details ( labtable       ,
                                              prompt_details ,
                                              actual_prompts ,
                                              box_width      )

{
*
*
*****************************************************************************}

        DECLARE count       ,
                message     ,
                message_var

        box_width = 0

        ARRAY actual_prompts ARRAY_SIZE ( 0 , 7 )

        count = 1

        WHILE prompt_details [ count , FIELD_NAME_POSITION ] <> EMPTY DO

                message = prompt_details [ count , MESSAGE_POSITION ]

                IF message = ERROR THEN

                        message_fetch ( "LABTABLIB_BADMESSAGE", message_var )
                        message_add_parameter ( message_var,
                                    prompt_details [ count ,
                                                     FIELD_NAME_POSITION ] )
                        flash_message ( message_get_text ( message_var, 1 ) ,
                                        TRUE                                )
                        EXIT

                ENDIF

                IF ( STRIP ( message ) = " " ) OR ( message = EMPTY ) THEN

                        GET_FIELD_DETAILS 'labtable . name_of_table' .
                                          'prompt_details [ count , FIELD_NAME_POSITION ]' ,
                                          "PROMPT_DESCRIPTION"                             ,
                                           message

                ENDIF

                actual_prompts [ count , MESSAGE_POSITION ] = message

                box_width = find_max_number ( length(message) , box_width )

                IF prompt_details [ count , TYPE_POSITION ] = EMPTY THEN

                        actual_prompts [ count , TYPE_POSITION ] = "FORMAT"

                ELSE

                        actual_prompts [ count , TYPE_POSITION ] =
                                prompt_details [ count , TYPE_POSITION ]

                ENDIF

                IF prompt_details [ count , TABLE_NAME_POSITION ] <> EMPTY THEN

                        actual_prompts [ count , TABLE_NAME_POSITION ] =
                                prompt_details [ count , TABLE_NAME_POSITION ]

                ELSE

                        actual_prompts [ count , TABLE_NAME_POSITION ] =
                                                labtable . name_of_table

                ENDIF

                actual_prompts [ count , FIELD_NAME_POSITION ] =
                                        prompt_details [ count , FIELD_NAME_POSITION ]

                count = count + 1

        ENDWHILE

ENDROUTINE

{****************************************************************************}

    ROUTINE labtable_initialise

{
*
*
*****************************************************************************}

    labtablib_define_class ( )
    line_editor_initialise_new ( )
    lib_grid_initialise ( )
    dynamic_sql_prompt_declare ( )
    lib_inspect_define_inspection_prompt ( )

ENDROUTINE

{****************************************************************************}

    ROUTINE labtable_initialise_library ( VALUE vgl_report )

{
*   Ensure that any Library Initialisation Required is carried out.
*
*****************************************************************************}

    IF VGL_VALIDATE_ROUTINE ( vgl_report,"SMP_LTE_INITIALISE" ) THEN

        CALL_ROUTINE "SMP_LTE_INITIALISE"
            IN LIBRARY vgl_report

    ENDIF

ENDROUTINE

{****************************************************************************}

    GLOBAL

    ROUTINE smp_lte_perform_option (       name_of_table           ,
                           displayed_name_of_table ,
                           prompt_details          ,
                           labtable_messages       ,
                           default_value           ,
                           input_mess              ,
                           header_mess             ,
                           footer_mess             ,
                           display_footer_mess     ,
                           directory               ,
                           extn                    ,
                           help_context            ,
                     VALUE calling_library         ,
                           fields_to_output        ,
                           special_actions         ,
                     VALUE operation               )

{
*
*
*****************************************************************************}

        DECLARE labtable    ,
                need_screen ,
                form        ,
                bottom_line ,
                title_width ,
                curr_help   ,
                use_tabs    ,
        title_mess

       operation = TOUPPER ( STRIP ( operation ) )

        message_fetch ( "LABTABLIB_" : operation , title_mess )

        IF title_mess <> EMPTY THEN

            header_mess = header_mess :
                  message_get_text ( title_mess , 1 )

        ENDIF

        labtable_initialise (  )
    labtable_initialise_library ( calling_library )

        IF NOT variable_is_assigned ( help_context ) THEN

                help_context = "$LABTABLIB_HELP"

        ELSEIF blank ( help_context ) THEN

                help_context = "$LABTABLIB_HELP"

        ENDIF

        curr_help = GLOBAL ( "STD_EDITOR_HELP" )
        SET GLOBAL "STD_EDITOR_HELP" TO help_context

        CREATE OBJECT LABTABLIB_CLASS , labtable

        labtablib_global_labtable = labtable

        labtable . name_of_table      = name_of_table
        labtable . user_name_of_table = displayed_name_of_table
        labtable . interface          = SELECT interface . interface
        labtable . messages           = labtable_messages
        labtable . input_message      = input_mess
        labtable . directory          = directory
        labtable . extension          = extn
        labtable . special_actions    = special_actions
        labtable . lte_report         = calling_library
        labtable . text_file_saved    = FALSE
        labtable . text_file_copied   = FALSE
        labtable . copy_value         = EMPTY
        labtable . default_value      = default_value
        labtable . is_editing         = FALSE
        labtable . clear_screen       = FALSE
        labtable . help_context       = help_context
        labtable . labtable_mode      = GLOBAL ( "LABTABLE_MODE" )
    labtable . approval_mode      = FALSE
    labtable . submit_mode        = FALSE

    IF NOT labtable . labtable_mode THEN
        labtable . labtable_mode = GLOBAL ( "PARAM_ACTIVE" )
    ENDIF

        GET_TABLE_DETAILS 'labtable . name_of_table' ,
                          "KEY0_FIELD"               ,
                           labtable . key0_fields

        labtable . number_key0_fields = size_of_array ( labtable . key0_fields )

        GET_TABLE_DETAILS 'labtable . name_of_table' ,
                          "MODIFIED_ON_FIELD"        ,
                           labtable . modified_on

        GET_TABLE_DETAILS 'labtable . name_of_table' ,
                          "MODIFIED_BY_FIELD"        ,
                           labtable . modified_by

        GET_TABLE_DETAILS 'labtable . name_of_table' ,
                          "REMOVE_FIELD"             ,
                           labtable . remove_field

        GET_TABLE_DETAILS 'labtable . name_of_table' ,
                          "GROUP_FIELD"              ,
                           labtable . group_field

        GET_TABLE_DETAILS 'labtable . name_of_table'   ,
                          "MODIFIABLE_FIELD"           ,
                           labtable . modifiable_field

        GET_TABLE_DETAILS 'labtable . name_of_table' ,
                          "VERSION_FIELD"            ,
                           labtable . version_field

    labtable . has_approval = lib_utils_table_has_approval ( name_of_table )
    labtable . ask_for_submit = FALSE

        GET_TABLE_DETAILS 'labtable . name_of_table' ,
                      "APPROVAL_STATUS"          ,
                      labtable . approval_field

        GET_TABLE_DETAILS 'labtable . name_of_table'  ,
                      "INSPECTION_FIELD"                ,
                      labtable . inspection_field

        labtablib_create_prompt_details ( labtable                  ,
                                          prompt_details            ,
                                          labtable . prompt_details ,
                                          title_width               )

        labtablib_do_name_field ( labtable )

        object_add_table ( labtable , labtable . name_of_table )

        bottom_line = footer_mess

        IF operation = "ADD_IDENT" THEN

                IF default_value <> EMPTY THEN

                        labtable . copy_value = default_value
                        labtable . operation = OPERATION_COPY

                ELSE

                        labtable . operation = OPERATION_ADD

                ENDIF

                need_screen = TRUE

        ELSEIF operation = "COPY_IDENT" THEN

        labtable . operation = OPERATION_COPY

        IF get_ident ( labtable . copy_value    ,
                       get message ( 2550 , 1 ) ,
                       labtable                 ,
                       APPROVAL_ANY             ) THEN

            need_screen = TRUE

        ELSE

            need_screen = FALSE

        ENDIF

    ELSEIF operation = "MODIFY_IDENT" THEN

        labtable . operation = OPERATION_MODIFY
        need_screen = TRUE

    ELSEIF operation = "NEW_VERSION" THEN

        labtable . operation = OPERATION_NEW_VERSION
        need_screen = TRUE

    ELSEIF operation = "DISPLAY_IDENT" THEN

        bottom_line = display_footer_mess
        labtable . operation = OPERATION_DISPLAY
        need_screen = TRUE

    ELSEIF operation = "PRINT_IDENT" THEN

        labtable . operation = OPERATION_PRINT
        labtablib_print ( labtable )
        need_screen = FALSE

    ELSEIF operation = "LIST_IDENTS" THEN

        labtable . operation = OPERATION_LIST
        labtablib_list ( labtable         ,
                         fields_to_output )
        need_screen = FALSE

        ELSEIF operation = "REMOVE_IDENT" THEN

                labtable . operation = OPERATION_REMOVE
                labtablib_remove ( labtable )
                need_screen = FALSE

        ELSEIF operation = "RESTORE_IDENT" THEN

                labtable . operation = OPERATION_RESTORE
                labtablib_restore ( labtable )
                need_screen = FALSE

    ELSEIF operation = "APPROVE_IDENT" THEN

        labtable . operation = OPERATION_DISPLAY
        labtable . approval_mode = TRUE
        need_screen = TRUE

    ELSEIF operation = "SUBMIT_IDENT" THEN

        labtable . operation = OPERATION_DISPLAY
        labtable . submit_mode = TRUE
        need_screen = TRUE

    ELSEIF operation = "MIGRATE_DATA" THEN

        labtable_migrate ( labtable, header_mess, 
                           fields_to_output     )
        need_screen = FALSE
    
        ENDIF

        IF need_screen THEN

                IF GLOBAL_EXISTS ( "LABTABLE_EXPLORER" ) THEN

                        use_tabs = GLOBAL ( "LABTABLE_EXPLORER" )

                ELSE

                        use_tabs = FALSE

                ENDIF

                IF NOT use_tabs THEN

                        labtablib_create_form ( form                ,
                                                labtable            ,
                                                title_width         ,
                                                bottom_line         ,
                                                help_context        ,
                                                header_mess         ,
                                                footer_mess         ,
                                                display_footer_mess )

                        labtablib_prompt ( labtable , form )

        ELSE

            { Tab mode is always editing }

            labtable . is_editing = TRUE

            IF labtablib_tab_get_ident ( labtable ) THEN

                labtablib_tab_create_form ( labtable     ,
                                title_width  ,
                                help_context )

            ENDIF

        ENDIF

    ENDIF

        SET GLOBAL "STD_EDITOR_HELP" TO curr_help

ENDROUTINE

{****************************************************************************}

    ROUTINE labtable_determine_sizes (       labtable             ,
                                             box_width            ,
                                             actual_prompts       ,
                                             screen_height        ,
                                             editor_object_height ,
                                             display_increment    ,
                                       VALUE header_mess          ,
                                       VALUE footer_mess          ,
                                       VALUE display_footer_mess  )

{
*
*
*****************************************************************************}

        DECLARE answer       ,
                prompt_size  ,
                message_loop

        prompt_size = size_of_array ( actual_prompts )

        screen_height = find_min_number ( prompt_size                   ,
                                          global ( "GUI_HEIGHT" )    -
                      14                            -
                                          labtable . number_key0_fields )

        editor_object_height = screen_height

        message_loop = 1

        REPEAT

                box_width = find_max_number (
                LENGTH ( labtable . messages [ message_loop ] ) ,
                box_width                                       )

                message_loop = message_loop + 1

        UNTIL message_loop > labtable . number_key0_fields

        answer = labtable . modified_on

        IF answer <> EMPTY THEN

                box_width = find_max_number (
                                 LENGTH ( labtable . messages [ MOD_ON_MESSAGE ] ) ,
                                 box_width                                         )

                screen_height = screen_height + 1

        ENDIF

        answer = labtable . modified_by

        IF answer <> EMPTY THEN

                box_width = find_max_number (
                                 LENGTH ( labtable . messages [ MOD_BY_MESSAGE ] ) ,
                                 box_width                                         )

                screen_height = screen_height + 1

        ENDIF

    IF labtable . has_approval THEN

                screen_height = screen_height + 1

    ENDIF

        pad_prompt_messages ( actual_prompts , box_width , prompt_size )

        pad_identity_messages ( labtable . messages                       ,
                                box_width                                 ,
                                size_of_array ( labtable . messages ) - 2 )

        IF GLOBAL ( "TERMTYPE" ) = "GUI" THEN

        labtable . display_start  = box_width + 4
        box_width = GLOBAL ( "SCREEN_WIDTH" ) - 2
        screen_height = screen_height + 2 + labtable . number_key0_fields
        labtable . info_position = 1 + labtable . number_key0_fields
        display_increment = 2

    ELSE

        labtable . display_start  = box_width + 3
        box_width = find_max_number ( box_width + 34             ,
                                      length ( header_mess ) + 4 )
        box_width = find_max_number ( box_width              ,
                                      LENGTH ( footer_mess ) )
        box_width = find_max_number ( box_width                      ,
                                      LENGTH ( display_footer_mess ) )

        IF ( box_width >= 70 ) THEN

            box_width = box_width + 2

        ELSE

            box_width = box_width + 6

        ENDIF

        screen_height = screen_height + 1 + labtable . number_key0_fields
        labtable . info_position = 1 + labtable . number_key0_fields
        display_increment = 1

    ENDIF

ENDROUTINE

{******************************************************************************}

        ROUTINE labtablib_remove_header_from_title (       title     ,
                                                     VALUE character )

{
* Remove the callmenu character header from the title
*
*******************************************************************************}


        IF ( ( title = EMPTY ) OR ( blank ( title ) ) ) THEN

        title = get_user_message ( "LABTABLIB_DETAILS" , 1 )

    ELSE

        title = STRIP ( STRIP ( title ) # STRIP ( character ) )

    ENDIF

ENDROUTINE

{******************************************************************************}

        ROUTINE labtablib_create_control_buttons ( labtable     ,
                           button_list  )

{
* Adds the control buttons to the form.
*
*******************************************************************************}

        DECLARE button_count ,
                count        ,
                title        ,
                character

        ARRAY button_list
        button_count = 1

        lib_grid_lastkey_button ( button_list    ,
                                  button_count   ,
                                  "DO"           ,
                                  EMPTY          )

        IF ( size_of_array ( labtable . special_actions ) = 0 ) AND
           ( labtable . extension <> EMPTY                    ) THEN

                lib_grid_lastkey_button ( button_list                 ,
                                          button_count                ,
                                          "SELECT"                    ,
                                          get_user_message (
                                        "LABTABLIB_DETAILS" ,
                                         1                  ) )

    ELSE

        IF size_of_array ( labtable . special_actions ) <= 1 THEN

            count = 1

        ELSE

            count = 2

        ENDIF

        WHILE count <= size_of_array ( labtable . special_actions ) DO

            title = labtable . special_actions [ count          ,
                                                 TITLE_POSITION ]

            character = labtable . special_actions [ count              ,
                                                     CHARACTER_POSITION ]

                        labtablib_remove_header_from_title ( title     ,
                                                             character )

            lib_grid_action_button ( button_list                  ,
                         button_count                 ,
                         title                        ,
                         "labtablib_button_press"     ,
                         GLOBAL ( "CURRENT_LIBRARY" ) ,
                         count                        )

            count = count + 1

        ENDWHILE

    ENDIF

    lib_grid_lastkey_button ( button_list  ,
                  button_count ,
                  "HELP"       ,
                  EMPTY        )

    lib_grid_lastkey_button ( button_list  ,
                  button_count ,
                  "EXIT"       ,
                  EMPTY        )

ENDROUTINE

{*****************************************************************************}

    ROUTINE add_identity_prompts (       form              ,
                         labtable          ,
                       VALUE display_increment )

{
*
*
******************************************************************************}

    DECLARE identity_count  ,
            prompt_object   ,
            count

    identity_count = 1

    REPEAT

        form . add_display (
            labtable . messages [ identity_count ]          ,
            display_increment                               ,
            identity_count                                  ,
            PROMPT_RENDITION_BOLD + PROMPT_RENDITION_RAISED )

        IF ( labtable . operation = OPERATION_NEW_VERSION  ) AND
           ( labtable . key0_fields [ identity_count ] =
             labtable . version_field                      ) THEN

            PROMPT OBJECT prompt_object
                ON LINE identity_count
                FROM    labtable . display_start
                FORMAT 'labtable . name_of_table' .
                       'labtable . key0_fields [ identity_count ]'
                WITH ( display_only = TRUE )

        ELSEIF ( labtable . operation = OPERATION_ADD  ) OR
               ( labtable . operation = OPERATION_COPY ) THEN

            PROMPT OBJECT prompt_object
                ON LINE identity_count
                FROM    labtable . display_start
                FORMAT 'labtable . name_of_table' .
                       'labtable . key0_fields [ identity_count ]'
                WITH ( enter_prompt_routine = "LABTABLIB_ENTER_ID_PROMPT"  ,
                       validation_routine   = "LABTABLIB_VALIDATE_ID_NEW"  ,
                       always_validate      = TRUE                         ,
                       vgl_library          = GLOBAL ( "CURRENT_LIBRARY" ) )

        ELSEIF ( labtable . operation = OPERATION_MODIFY      ) OR
               ( labtable . operation = OPERATION_NEW_VERSION ) THEN

            IF ( labtable . has_approval              ) AND
                   ( labtable . operation = OPERATION_NEW_VERSION ) AND
               ( identity_count = 1                           ) THEN

                CREATE OBJECT DYNAMIC_SQL_PROMPT_CLASS , prompt_object
                prompt_object . row                  = identity_count
                prompt_object . column               = labtable . display_start
                prompt_object . table                = labtable . name_of_table
                prompt_object . enter_prompt_routine = "LABTABLIB_ENTER_ID_PROMPT"
                prompt_object . leave_prompt_routine = "LABTABLIB_LEAVE_ID_PROMPT"
                prompt_object . validation_routine   = "LABTABLIB_VALIDATE_ID_PROMPT"
                prompt_object . always_validate      = TRUE
                prompt_object . vgl_library          = GLOBAL ( "CURRENT_LIBRARY" )
                prompt_object . select_all_fields ( "LT1" )
                prompt_object . add_sql ( "WHERE [" )
                prompt_object . add_sql ( labtable . version_field )
                prompt_object . add_sql ( "] >= ( SELECT MAX ( [" )
                prompt_object . add_sql ( labtable . version_field )
                prompt_object . add_sql ( "] ) FROM [" )
                prompt_object . add_sql ( labtable . name_of_table )
                prompt_object . add_sql ( "] LT2 " )
                prompt_object . add_sql ( "WHERE " )

                count = 1

                WHILE count < size_of_array ( labtable . key0_fields )

                    IF count > 1 THEN
                        prompt_object . add_sql ( " AND " )
                    ENDIF

                    prompt_object . add_sql ( " LT1.[" )
                    prompt_object . add_sql ( labtable . key0_fields [ count ] )
                    prompt_object . add_sql ( "]=" )
                    prompt_object . add_sql ( " LT2.[" )
                    prompt_object . add_sql ( labtable . key0_fields [ count ] )
                    prompt_object . add_sql ( "]" )

                    count = count + 1

                ENDWHILE

                IF labtable . remove_field <> EMPTY THEN

                    prompt_object . add_sql ( " AND [" )
                    prompt_object . add_sql ( labtable . remove_field )
                    prompt_object . add_sql ( "] ='F'" )

                ENDIF

                prompt_object . add_sql ( " ) AND ( [" )
                prompt_object . add_sql ( labtable . approval_field )
                prompt_object . add_sql ( "] = 'A'" )
                prompt_object . add_sql ( " OR [" )
                prompt_object . add_sql ( labtable . approval_field )
                prompt_object . add_sql ( "] = 'R' ) " )

                prompt_object . add_sql ( "ORDER BY " )

                count = 1

                WHILE count < size_of_array ( labtable . key0_fields )

                    prompt_object . add_sql ( "[" : labtable . key0_fields [ count ] : "] , " )
                    count = count + 1

                ENDWHILE

                prompt_object . add_sql ( "[" : labtable . key0_fields [ count ] : "]" )

                prompt_object . initialise ( )

            ELSE

                PROMPT OBJECT prompt_object
                    ON LINE   identity_count
                    FROM      labtable . display_start
                    BROWSE ON 'labtable . name_of_table' .
                          'labtable . key0_fields [ identity_count ]'
                    WITH ( enter_prompt_routine = "LABTABLIB_ENTER_ID_PROMPT"    ,
                           leave_prompt_routine = "LABTABLIB_LEAVE_ID_PROMPT"    ,
                           validation_routine   = "LABTABLIB_VALIDATE_ID_PROMPT" ,
                           always_validate      = TRUE                           ,
                           vgl_library          = GLOBAL ( "CURRENT_LIBRARY" )   )

            ENDIF

        ELSEIF ( labtable . operation = OPERATION_DISPLAY ) AND
               ( labtable . approval_mode                 ) AND
               ( identity_count = 1                       ) THEN

                CREATE OBJECT INSPECTION_SELECT_CLASS , prompt_object

                prompt_object . row                  = identity_count
                prompt_object . column               = labtable . display_start
                prompt_object . table                = labtable . name_of_table
                prompt_object . enter_prompt_routine = "LABTABLIB_ENTER_ID_PROMPT"
                prompt_object . leave_prompt_routine = "LABTABLIB_LEAVE_ID_PROMPT"
                prompt_object . validation_routine   = "LABTABLIB_VALIDATE_ID_PROMPT"
                prompt_object . always_validate      = TRUE
                prompt_object . vgl_library          = GLOBAL ( "CURRENT_LIBRARY" )

                { Can authorise for anyone if sufficient priv }

                IF role_lib_has_privilege ( ROLE_LIB_PRIV_APPROVE_ON_BEHALF ) THEN

                    labtable . approve_as = prompt_for_approver ( )

                    IF labtable . approve_as = EMPTY THEN
                        EXIT
                    ENDIF

                    labtable . approve_as = STRIP ( labtable . approve_as )

                ELSE

                    labtable . approve_as = STRIP ( OPERATOR )

                ENDIF

                prompt_object . set_for_table ( labtable . name_of_table ,
                                                labtable . approve_as    )

        ELSE

            PROMPT OBJECT prompt_object
                ON LINE identity_count
                FROM    labtable . display_start
                BROWSE ON 'labtable . name_of_table' .
                      'labtable . key0_fields [ identity_count ]'
                THEN SELECT
                WITH ( enter_prompt_routine = "LABTABLIB_ENTER_ID_PROMPT"  ,
                       leave_prompt_routine = "LABTABLIB_LEAVE_ID_PROMPT"  ,
                       vgl_library          = GLOBAL ( "CURRENT_LIBRARY" ) )

        ENDIF

        IF vgl_validate_routine ( labtable .  lte_report  ,
                                          "PROMPT_OBJECT_ROUTINE" ) THEN

            CALL_ROUTINE "PROMPT_OBJECT_ROUTINE"
                USING prompt_object        ,
                      identity_count       ,
                      labtable . operation
                IN LIBRARY labtable . lte_report

        ENDIF

        labtable . last_id_prompt = form . add_prompt ( prompt_object )

        IF identity_count = 1 THEN

            labtable . first_id_prompt = labtable . last_id_prompt

        ENDIF

        identity_count = identity_count + 1

    UNTIL identity_count > labtable . number_key0_fields

ENDROUTINE

{*****************************************************************************}

    ROUTINE labtablib_create_form (       form                ,
                          labtable            ,
                    VALUE box_width           ,
                    VALUE bottom_line         ,
                    VALUE help_context        ,
                    VALUE header_mess         ,
                    VALUE footer_mess         ,
                    VALUE display_footer_mess )

{
*
*
******************************************************************************}

    DECLARE prompt_row        ,
        special_field     ,
        top_frame_height  ,
        button_list       ,
        button_lines      ,
        buttons_per_line  ,
        screen_height     ,
        editor_height     ,
        editor_object     ,
        title_width       ,
        display_increment ,
        end_column

    labtable_determine_sizes ( labtable                  ,
                               box_width                 ,
                               labtable . prompt_details ,
                               screen_height             ,
                               editor_height             ,
                               display_increment         ,
                               header_mess               ,
                               footer_mess               ,
                               display_footer_mess       )

    labtablib_create_control_buttons ( labtable    ,
                                       button_list )

    lib_form_button_lines ( box_width        ,
                            button_list      ,
                            button_lines     ,
                            buttons_per_line )

    screen_height = screen_height + 2 * button_lines

    CREATE OBJECT PROMPT_CLASS_FORM , form

    { Set up the global }
    labtablib_global_form = form

    form . height         = screen_height
    form . width          = box_width
    form . row            = 8
    form . column         = ( ( 80 - box_width ) DIV 2 ) + 1
    form . border         = TRUE
    form . header         = header_mess
    form . footer         = bottom_line
    form . proportional   = TRUE
    form . button_style   = FORM_BUTTON_NONE
    form . user_info      = labtable
    form . select_routine = "LABTABLIB_FORM_SELECT"
    form . prompt_id      = "$LABTABLIB_MAIN_" : labtable . name_of_table

    IF variable_is_assigned ( help_context ) THEN

        form . help_context = help_context

    ENDIF

    form . return_behaviour = FORM_RETURN_STAY

    add_identity_prompts ( form , labtable, display_increment )

    top_frame_height = labtable . number_key0_fields
    prompt_row       = labtable . info_position
    special_field    = labtable . modified_on

        IF special_field <> EMPTY THEN

        form . add_display ( labtable . messages [ MOD_ON_MESSAGE ] ,
                             display_increment                      ,
                             prompt_row                             ,
                             PROMPT_RENDITION_BOLD +
                             PROMPT_RENDITION_RAISED                )

        PROMPT OBJECT labtable . modified_on_object
               FORMAT 'labtable . name_of_table' . 'special_field'
               ON LINE prompt_row
               FROM labtable . display_start
               WITH ( lowered = TRUE ,
                      value   = " "  )

                form . add_display ( labtable . modified_on_object )

                prompt_row       = prompt_row + 1
                top_frame_height = top_frame_height + 1

        ENDIF

        special_field = labtable . modified_by

        IF special_field <> EMPTY THEN

                form . add_display ( labtable . messages [ MOD_BY_MESSAGE ] ,
                                     display_increment                      ,
                                     prompt_row                             ,
                                     PROMPT_RENDITION_BOLD +
                                     PROMPT_RENDITION_RAISED                )

                PROMPT OBJECT labtable . modified_by_object
                       FORMAT 'labtable . name_of_table' . 'special_field'
                       ON LINE prompt_row
                       FROM labtable . display_start
                       WITH ( lowered = TRUE ,
                              value   = " "  )

        form . add_display ( labtable . modified_by_object )

        prompt_row = prompt_row + 1
        top_frame_height = top_frame_height + 1

    ENDIF

    IF labtable . has_approval THEN

                        form . add_display ( PAD ( get_user_message ( "LABTABLIB_APPR_STAT" , 1 ) ,
                                           " "                                     ,
                                           STRINGLENGTH ( labtable . messages [ 1 ])) ,
                                     display_increment               ,
                                     prompt_row                      ,
                                     PROMPT_RENDITION_BOLD +
                                     PROMPT_RENDITION_RAISED         )

                PROMPT OBJECT labtable . approval_stat_object
                       FORMAT 'labtable . name_of_table' . 'labtable . approval_field'
                       ON LINE prompt_row
                       FROM labtable . display_start
               TO   labtable . display_start + 10
                       WITH ( lowered = TRUE ,
                              value   = " "  )

        form . add_display ( labtable . approval_stat_object )

        prompt_row = prompt_row + 1
        top_frame_height = top_frame_height + 1

    ENDIF

    IF GLOBAL ( "TERMTYPE" ) = "GUI" THEN

        prompt_row  = prompt_row + 1
        end_column  = box_width - 1
        title_width = labtable . display_start - 3

    ELSE

        prompt_row  = prompt_row + 1
        end_column  = box_width
        title_width = labtable . display_start - 1

    ENDIF

    PROMPT OBJECT editor_object
           ON LINE prompt_row
           FROM display_increment
           TO   end_column
           CLASS "STD_LINE_EDITOR"
           WITH ( height                    = editor_height                             ,
                  title_width               = title_width                               ,
                  data_width                = end_column - labtable . display_start + 1 ,
                  compatability             = PROMPT_DETAILS_260                        ,
                  user_enter_prompt_routine = "LABTABLIB_ENTER_EDITOR_PROMPT"           ,
                  user_leave_prompt_routine = "LABTABLIB_LEAVE_EDITOR_PROMPT"           ,
                  user_select_routine       = "LABTABLIB_SELECT"                        ,
                  user_callback_library     = GLOBAL ( "current_library" )              ,
                  prompt_details            = labtable . prompt_details                 ,
                  display_only              = labtable . operation = OPERATION_DISPLAY  )

    labtable . editor_prompt = form . add_prompt ( editor_object )

    lib_form_add_control_buttons ( form, button_list )

ENDROUTINE

{*****************************************************************************}

    ROUTINE labtablib_tab_setup_class

{
*
*
******************************************************************************}

    IF NOT ( GLOBAL ( "LIBRARY_INITIALISED" ) ) THEN

        set_up_std_prompt_tab_class ( )

        DEFINE CLASS LABTABLIB_TAB_CLASS

            INHERIT PROMPT_TAB_CLASS

            PROPERTIES "DISPLAY_NOTHING"

        END CLASS

        SET GLOBAL "LIBRARY_INITIALISED" TO TRUE

    ENDIF

ENDROUTINE

{******************************************************************************}

    ROUTINE strip_the_colon ( string_to_strip )

{
*
*
******************************************************************************}

    DECLARE last_char

    string_to_strip = STRIP ( string_to_strip )

    last_char = SUBSTRING ( string_to_strip , LENGTH ( string_to_strip ) , 1 )

    WHILE ( last_char = ":" ) OR ( last_char = "." ) DO

        string_to_strip = STRIP ( SUBSTRING ( string_to_strip                  ,
                                                      1                                ,
                                                      LENGTH ( string_to_strip ) - 1 ) )

        last_char = SUBSTRING ( string_to_strip                ,
                    LENGTH ( string_to_strip ) , 1 )

    ENDWHILE

ENDROUTINE

{*****************************************************************************}

    ROUTINE labtablib_tab_display_cell (       self        ,
                                         VALUE cell_column ,
                                         VALUE cell_row    ,
                                               window      ,
                                         VALUE column      ,
                                         VALUE row         ,
                                         VALUE cell_width  ,
                                         VALUE cell_height )

{
*
*
******************************************************************************}

    DECLARE is_display

    is_display = TRUE

    CALL_ROUTINE self . user_info [ TAB_USER_ROUTINE ]
        IN LIBRARY   self . user_info [ TAB_USER_LIBRARY ]
        USING column , row , cell_width , window , is_display

ENDROUTINE

{*****************************************************************************}

    ROUTINE labtablib_tab_prompt_cell (       self        ,
                                        VALUE cell_column ,
                                        VALUE cell_row    ,
                                              window      ,
                                        VALUE column      ,
                                        VALUE row         ,
                                        VALUE cell_width  ,
                                        VALUE cell_height )

{
*
*
******************************************************************************}

    DECLARE is_display

    is_display = self . display_only

    CALL_ROUTINE self . user_info [ TAB_USER_ROUTINE ]
        IN LIBRARY   self . user_info [ TAB_USER_LIBRARY ]
        USING column , row , cell_width , window , is_display

    IF is_display THEN

        PROMPT ON LINE row FROM column IN WINDOW window

    ENDIF

ENDROUTINE

{*****************************************************************************}

    ROUTINE labtablib_tab_add_prompt (       tab_form       ,
                                             labtable       ,
                                       VALUE current_prompt ,
                                       VALUE prompt_type    ,
                                       VALUE the_table_name ,
                                       VALUE the_field_name ,
                                       VALUE title_text     ,
                                       VALUE prompt_line    ,
                                       VALUE prompt_column  ,
                                       VALUE prompt_height  ,
                                       VALUE display_only   )

{
*
*
******************************************************************************}

    DECLARE data           ,
        details_object

    tab_form . add_display ( title_text            ,
                             2                     ,
                             prompt_line           ,
                             PROMPT_RENDITION_BOLD )

    IF ( prompt_type = "FORMAT" ) THEN

        data = SELECT 'the_table_name' . 'the_field_name'

        PROMPT OBJECT  details_object
               ON LINE prompt_line
               FROM    prompt_column
               TO      tab_form . width - 1
               FORMAT  'the_table_name' . 'the_field_name'
               WITH ( display_only = display_only  ,
                      height       = prompt_height ,
                      value        = data          ,
                      user_info    = data          )

        ARRAY details_object . user_info

        details_object . user_info [ TAB_USER_TABLE ] = the_table_name
        details_object . user_info [ TAB_USER_FIELD ] = the_field_name
        details_object . user_info [ TAB_USER_DATA  ] = data

    ELSEIF ( prompt_type = "DISPLAY" ) THEN

                data = SELECT 'the_table_name' . 'the_field_name'

                FORMAT data FROM data USING  'the_table_name' . 'the_field_name'

                PROMPT OBJECT  details_object
                       ON LINE prompt_line
                       FROM    prompt_column
                       TO      tab_form . width - 1
                       BROWSE ON DISPLAY
                       WITH ( value = data )

        ARRAY details_object . user_info

        details_object . user_info [ TAB_USER_TABLE ] = the_table_name
        details_object . user_info [ TAB_USER_FIELD ] = the_field_name
        details_object . user_info [ TAB_USER_DATA  ] = data

        ELSEIF ( prompt_type = "OBJECT" ) THEN

        details_object = EMPTY

    ELSE

        CREATE OBJECT PROMPT_CLASS_GRID, details_object

        details_object . column               = prompt_column
        details_object . row                  = prompt_line
        details_object . height               = 1
        details_object . width                = tab_form . width - 1 - prompt_column
        details_object . border               = TRUE
        details_object . cell_columns         = 1
        details_object . cell_rows            = 1
        details_object . display_cell_routine = "LABTABLIB_TAB_DISPLAY_CELL"
        details_object . prompt_cell_routine  = "LABTABLIB_TAB_PROMPT_CELL"
        details_object . return_behaviour     = GRID_RETURN_STAY
        details_object . column_size [ 1 ]    = details_object . width

        ARRAY details_object . user_info

        details_object . user_info [ TAB_USER_LIBRARY ] =
                       labtable . prompt_details [ current_prompt , 3 ]
        details_object . user_info [ TAB_USER_ROUTINE ] =
                       labtable . prompt_details [ current_prompt , 4 ]

        ENDIF

    IF details_object <> EMPTY THEN

        details_object . user_info [ TAB_USER_TYPE ] = prompt_type

            tab_form . add_prompt ( details_object )

    ENDIF

ENDROUTINE

{*****************************************************************************}

    ROUTINE labtablib_tab_create_details_tab ( labtable , tab )

{
*
*
******************************************************************************}

    DECLARE number_of_prompts ,
            prompt_column     ,
            current_prompt    ,
            current_line      ,
            title_width       ,
            page_count        ,
            tab_form          ,
            prompt_type       ,
            the_table_name    ,
            the_field_name    ,
            prompt_height     ,
            field_size        ,
            is_security_field

    number_of_prompts = size_of_array ( labtable . prompt_details )

    current_prompt = 1
    title_width    = 0

    WHILE current_prompt <= number_of_prompts DO

                strip_the_colon ( labtable . prompt_details [ current_prompt, 1 ] )
                title_width = find_max_number (
                         title_width                                     ,
                         LENGTH ( labtable .
                                  prompt_details [ current_prompt, 1 ] ) )
                current_prompt = current_prompt + 1

    ENDWHILE

        prompt_column = title_width + 2

    page_count     = 0
    current_line   = 1
    current_prompt = 1

    WHILE current_prompt <= number_of_prompts DO

        the_table_name = labtable . prompt_details [ current_prompt , 3 ]
        the_field_name = labtable . prompt_details [ current_prompt , 4 ]
        is_security_field = labtablib_tab_is_security ( labtable       ,
                                                        the_table_name ,
                                                        the_field_name )

        IF NOT is_security_field THEN

            prompt_type = toupper ( labtable . prompt_details [ current_prompt , 2 ] )

            IF ( prompt_type = "DISPLAY" ) OR ( prompt_type = "FORMAT" ) THEN

                GET_FIELD_DETAILS 'the_table_name' . 'the_field_name'
                                  "FIELD_SIZE" ,
                                  field_size

            ELSE

                field_size = 1

            ENDIF

            IF current_line = 1 THEN

                page_count = page_count + 1

                CREATE OBJECT "STD_FORM", tab_form

                tab . set_size ( tab_form )

                tab_form . header = get_user_message ( "LABTABLIB_DETAILS" , 1 ) : strip ( page_count )

                tab_form . add_frame ( ""                    ,
                                       1                     ,
                                       1                     ,
                                       tab_form . height - 1 ,
                                       tab_form . width      )

                tab . add_form ( tab_form )

            ENDIF

            IF field_size > ( tab_form . width - prompt_column ) THEN

                prompt_height = find_min_number (
                                   TRUNC ( field_size                           /
                                           ( tab_form . width - prompt_column ) ) + 1 ,
                                         tab_form . height - 1                        )

                prompt_height = find_min_number ( prompt_height         ,
                                                  TAB_MAX_PROMPT_HEIGHT )

            ELSE

                prompt_height = 1

            ENDIF

            IF current_line > 1 THEN

                IF current_line + prompt_height > tab_form . height THEN

                    current_line = 1

                ENDIF

            ENDIF

            labtablib_tab_add_prompt ( tab_form                                                 ,
                                       labtable                                                 ,
                                       current_prompt                                           ,
                                       prompt_type                                              ,
                                       the_table_name                                           ,
                                       the_field_name                                           ,
                                       PAD ( labtable . prompt_details [ current_prompt , 1 ] ,
                                             " "                                              ,
                                             title_width                                      ) ,
                                       current_line                                             ,
                                       prompt_column                                            ,
                                       prompt_height                                            ,
                                       labtable . operation = OPERATION_DISPLAY                 )

            current_line = current_line + prompt_height

            IF current_line >= tab_form . height THEN

                current_line = 1

            ENDIF

        ENDIF

        current_prompt = current_prompt + 1

    ENDWHILE

ENDROUTINE

{*****************************************************************************}

    ROUTINE labtablib_tab_is_security (       labtable       ,
                                        VALUE the_table_name ,
                                        VALUE the_field_name )

{
*
*
******************************************************************************}

    DECLARE return_value

    return_value = FALSE

    IF the_table_name = labtable . name_of_table THEN

        IF ( the_field_name = labtable . modified_on      ) OR
           ( the_field_name = labtable . modified_by      ) OR
           ( the_field_name = labtable . modifiable_field ) OR
           ( the_field_name = labtable . remove_field     ) OR
           ( the_field_name = labtable . group_field      ) THEN

            return_value = TRUE

        ENDIF

        ENDIF

        RETURN ( return_value )

ENDROUTINE

{*****************************************************************************}

    ROUTINE labtablib_tab_find_field ( labtable   ,
                                       field_name ,
                                       field_text )

{
*
*
******************************************************************************}

    DECLARE field_number

        field_number = 1
        field_text   = EMPTY

    IF field_name <> EMPTY THEN

        WHILE ( field_number <= size_of_array ( labtable . prompt_details ) ) AND
              ( field_text = EMPTY                                          ) DO

            IF field_name = labtable . prompt_details [ field_number , 4 ] THEN

                field_text = labtable . prompt_details [ field_number , 1 ]

            ENDIF

            field_number = field_number + 1

        ENDWHILE

        IF field_text = EMPTY THEN

            field_text = capitalise ( field_name )

        ENDIF

    ENDIF

    RETURN ( field_text <> EMPTY )

ENDROUTINE

{*****************************************************************************}

    ROUTINE labtablib_tab_create_security_tab ( labtable , tab )

{
*
*
******************************************************************************}

    DECLARE tab_form        ,
            current_line    ,
            modifiable_text ,
            remove_text     ,
            group_text      ,
            title_width

    title_width = 0

    IF labtable . modified_on <> EMPTY THEN

        title_width = find_max_number (
                        title_width                                      ,
                        LENGTH ( labtable . messages [ MOD_ON_MESSAGE ] ) )

    ENDIF

    IF labtable . modified_by <> EMPTY THEN

        title_width = find_max_number (
                        title_width                                       ,
                        LENGTH ( labtable . messages [ MOD_BY_MESSAGE ] ) )

    ENDIF

    IF labtablib_tab_find_field ( labtable                    ,
                                      labtable . modifiable_field ,
                                      modifiable_text             ) THEN

        title_width = find_max_number ( title_width                ,
                                        LENGTH ( modifiable_text ) )

    ENDIF

    IF labtablib_tab_find_field ( labtable                ,
                                      labtable . remove_field ,
                                      remove_text             ) THEN

        title_width = find_max_number ( title_width            ,
                                        LENGTH ( remove_text ) )

    ENDIF

    IF labtablib_tab_find_field ( labtable               ,
                                      labtable . group_field ,
                                      group_text             ) THEN

        title_width = find_max_number ( title_width           ,
                                        LENGTH ( group_text ) )

    ENDIF

    IF title_width > 0 THEN

        CREATE OBJECT "STD_FORM", tab_form

        tab . set_size ( tab_form )

        tab_form . header = get_user_message ( "LABTABLIB_SECURITY" , 1 )

                tab_form . add_frame ( ""                    ,
                               1                     ,
                               1                     ,
                               tab_form . height - 1 ,

                               tab_form . width      )
        tab . add_form ( tab_form )

        ENDIF

    current_line = 1

    IF labtable . modified_on <> EMPTY THEN

        labtablib_tab_add_prompt ( tab_form                                       ,
                                   labtable                                       ,
                                   1                                              ,
                                   "DISPLAY"                                      ,
                                   labtable . name_of_table                       ,
                                   labtable . modified_on                         ,
                                   PAD ( labtable . messages [ MOD_ON_MESSAGE ] ,
                                         " "                                    ,
                                         title_width                            ) ,
                                           current_line                                   ,
                                           title_width + 2                                ,
                                           1                                              ,
                                           TRUE                                           )

        current_line = current_line + 1

    ENDIF

    IF labtable . modified_by <> EMPTY THEN

        labtablib_tab_add_prompt ( tab_form                                       ,
                                   labtable                                       ,
                                   1                                              ,
                                   "DISPLAY"                                      ,
                                   labtable . name_of_table                       ,
                                   labtable . modified_by                         ,
                                   PAD ( labtable . messages [ MOD_BY_MESSAGE ] ,
                                         " "                                    ,
                                         title_width                            ) ,
                                           current_line                                   ,
                                           title_width + 2                                ,
                                           1                                              ,
                                           TRUE                                           )

        current_line = current_line + 1

    ENDIF

    IF labtable . modifiable_field <> EMPTY THEN

        labtablib_tab_add_prompt ( tab_form                                 ,
                                   labtable                                 ,
                                   1                                        ,
                                   "FORMAT"                                 ,
                                   labtable . name_of_table                 ,
                                   labtable . modifiable_field              ,
                                   PAD ( modifiable_text ,
                                                 " "             ,
                                                 title_width     )                  ,
                                   current_line                             ,
                                   title_width + 2                          ,
                                   1                                        ,
                                   labtable . operation = OPERATION_DISPLAY )

        current_line = current_line + 1

    ENDIF

    IF labtable . remove_field <> EMPTY THEN

        labtablib_tab_add_prompt ( tab_form                                 ,
                                   labtable                                 ,
                                   1                                        ,
                                   "FORMAT"                                 ,
                                   labtable . name_of_table                 ,
                                   labtable . remove_field                  ,
                                   PAD ( remove_text ,
                                                 " "         ,
                                                 title_width )                      ,
                                   current_line                             ,
                                   title_width + 2                          ,
                                   1                                        ,
                                   labtable . operation = OPERATION_DISPLAY )

        current_line = current_line + 1

    ENDIF

    IF labtable . group_field <> EMPTY THEN

        labtablib_tab_add_prompt ( tab_form                                 ,
                                   labtable                                 ,
                                   1                                        ,
                                   "FORMAT"                                 ,
                                   labtable . name_of_table                 ,
                                   labtable . group_field                   ,
                                   PAD ( group_text  ,
                                                 " "         ,
                                                 title_width )                      ,
                                   current_line                             ,
                                   title_width + 2                          ,
                                   1                                        ,
                                   labtable . operation = OPERATION_DISPLAY )

        current_line = current_line + 1

    ENDIF

ENDROUTINE

{*****************************************************************************}

    ROUTINE labtablib_tab_get_ident ( labtable )

{
*
*
******************************************************************************}

    DECLARE return_value

    return_value = FALSE

    IF labtable . operation <> "ADD" THEN

        IF get_ident ( labtable . identity  ,
                       labtable . operation ,
                       labtable             ,
                       APPROVAL_APPROVED    ) THEN

            return_value = labtablib_find_record (
                              labtable                          ,
                              labtable . identity               ,
                              labtable . operation <> "DISPLAY" )

        ENDIF

    ELSE

        return_value = get_new_ident ( labtable . identity  ,
                                       labtable . operation ,
                                       labtable             )

    ENDIF

    RETURN ( return_value )

ENDROUTINE

{*****************************************************************************}

    ROUTINE labtablib_tab_save_data ( labtable , tab )

{
*
*
******************************************************************************}

    DECLARE num_tabs     ,
            tab_count    ,
            num_prompts  ,
            prompt_count ,
        this_prompt

    tab_count = 1
    num_tabs = size_of_array ( tab . forms )

    WHILE tab_count <= num_tabs DO

        prompt_count = 1
        num_prompts = size_of_array ( tab                 .
                                      forms [ tab_count ] .
                                      prompt_objects      )

        WHILE prompt_count <= num_prompts DO

            this_prompt = tab                           .
                          forms [ tab_count ]           .
                          prompt_objects [ prompt_count ]

            IF NOT ( this_prompt . display_only ) THEN

                IF ( this_prompt .
                     user_info [ TAB_USER_TYPE ] ) = "FORMAT" THEN

                    IF ( this_prompt . value                       ) <>
                       ( this_prompt . user_info [ TAB_USER_DATA ] ) THEN

                        ASSIGN 'this_prompt . user_info [ TAB_USER_TABLE ]' .
                               'this_prompt . user_info [ TAB_USER_FIELD ]' =
                               this_prompt . value

                    ENDIF

                ENDIF

            ENDIF

            prompt_count = prompt_count + 1

        ENDWHILE

        tab_count = tab_count + 1

    ENDWHILE

ENDROUTINE

{*****************************************************************************}

    ROUTINE labtablib_tab_create_form (       labtable     ,
                                        VALUE box_width    ,
                                        VALUE help_context )

{
*
*
******************************************************************************}

        DECLARE tab  ,
            form

    labtablib_tab_setup_class ( )

    box_width = find_min_number ( box_width , 100 )
    box_width = find_max_number ( box_width , 60  )

    CREATE OBJECT PROMPT_CLASS_FORM, form

    { Set up the global }
        labtablib_global_form = form

    form . height          = 18
    form . width           = box_width
    form . row             = 3
    form . column          = 6
    form . border          = TRUE
    form . header          = capitalise ( labtable . name_of_table ) :
                                 " " : labtable . identity
    form . proportional    = TRUE
    form . button_style    = FORM_BUTTON_NONE
    form . user_info       = labtable
    form . select_routine  = "LABTABLIB_FORM_SELECT"
    form . return_behaviour = FORM_RETURN_STAY

    IF variable_is_assigned ( help_context ) THEN

        form . help_context = help_context

    ENDIF

    { create the Tab object }

    CREATE OBJECT LABTABLIB_TAB_CLASS , tab

    tab . height = form . height - 3
    tab . width  = form . width - 2
    tab . row    = 1
    tab . column = 2

        labtable . editor_prompt = form . add_prompt ( tab )

    labtablib_tab_create_control_buttons ( form     , labtable )
    labtablib_prepare_for_action         ( form     , TRUE     )
    labtablib_tab_create_details_tab     ( labtable , tab      )
    labtablib_tab_create_security_tab    ( labtable , tab      )

    form . start_prompt ( )

    REPEAT

        form . wait_prompt  ( )

        IF form . getlastkey ( ) = "DO" THEN

            labtablib_tab_save_data ( labtable , tab )

        ENDIF

    UNTIL ( labtablib_is_finished ( form , labtable ) )

    form . end_prompt ( )

ENDROUTINE

{******************************************************************************}

        ROUTINE labtablib_tab_create_control_buttons (  form     ,
                                                        labtable  )

{
* Adds the control buttons to the form.
*
*******************************************************************************}

    DECLARE button_count       ,
            count              ,
            button_object      ,
            total_button_count ,
            button_line        ,
            button_lines       ,
            current_button     ,
            buttons_per_line   ,
            title              ,
            character

    IF ( size_of_array ( labtable . special_actions ) = 0 ) THEN

        PROMPT OBJECT button_object
            CLASS "STD_PROMPT_BUTTON"
            ON LINE form . height - 1
            FROM  form . width - 10
            WITH ( caption      = get_user_message (
                                       "SMP_PROMPT_BUTTON_CANCEL" , 1 ) ,
                   enabled      = TRUE                                  ,
                   width        = 10                                    ,
                   send_lastkey = "EXIT"                                )

        form . add_prompt ( button_object )

        IF ( labtable . extension <> EMPTY ) THEN

            button_count = 3

            PROMPT OBJECT button_object
                   CLASS "STD_PROMPT_BUTTON"
                   ON LINE form . height - 1
                   FROM  form . width - 21
                   WITH ( caption             = "Info"                       ,
                          enabled             = TRUE                         ,
                          width               = 10                           ,
                          mouse_click_routine = "call_tab_special_operation" ,
                          vgl_library         = GLOBAL ( "CURRENT_LIBRARY" ) )

            ARRAY button_object . user_info

            button_object . user_info [ 1 ] = labtable
            button_object . user_info [ 2 ] = 1

            form . add_prompt ( button_object )

        ELSE

            button_count = 2

        ENDIF

        PROMPT OBJECT button_object
            CLASS "STD_PROMPT_BUTTON"
            ON LINE form . height - 1
            FROM  form . width - ( 11 * button_count ) + 1
            WITH ( caption      = get_user_message (
                                      "SMP_PROMPT_BUTTON_OK" , 1 ) ,
                   enabled      = TRUE                             ,
                   width        = 10                               ,
                   send_lastkey = "DO"                             )

        form . add_prompt ( button_object )

    ELSE

        IF size_of_array ( labtable . special_actions ) = 1 THEN

            count = 1

        ELSE

            count = 2

        ENDIF

        total_button_count = size_of_array ( labtable . special_actions ) - count + 2

        button_lines = ( ( ( total_button_count * 11 ) - 1 ) +
                         ( form . width - 1                )   ) DIV form . width

        form . height = form . height + ( button_lines * 2 ) - 2

        buttons_per_line = ( total_button_count + 1 ) DIV button_lines

        { Exit button bottom right }

        PROMPT OBJECT button_object
            CLASS "STD_PROMPT_BUTTON"
            ON LINE form . height - 1
            FROM  form . width - 10
            WITH ( caption      = get_user_message (
                                               "SMP_PROMPT_BUTTON_CANCEL" , 1 ) ,
                   enabled      = TRUE                                  ,
                   width        = 10                                    ,
                   send_lastkey = "EXIT"                                )

        form . add_prompt ( button_object )

        current_button = size_of_array ( labtable . special_actions )

        button_count = 2
        button_line  = form . height - 1

        WHILE current_button >= count DO

            IF button_count > buttons_per_line THEN

                button_count = 1
                button_line = button_line - 2

            ENDIF

            title     = labtable . special_actions [ current_button , TITLE_POSITION ]
            character = labtable . special_actions [ current_button , CHARACTER_POSITION ]

            labtablib_remove_header_from_title ( title , character )

            PROMPT OBJECT button_object
                CLASS "STD_PROMPT_BUTTON"
                ON LINE button_line
                FROM  form . width - ( 11 * button_count ) + 1
                WITH ( caption             = title                        ,
                       enabled             = TRUE                         ,
                       width               = 10                           ,
                       mouse_click_routine = "call_tab_special_operation" ,
                       vgl_library         = GLOBAL ( "CURRENT_LIBRARY" ) )

            ARRAY button_object . user_info

            button_object . user_info [ 1 ] = labtable
            button_object . user_info [ 2 ] = current_button

            form . add_prompt ( button_object )

            button_count = button_count + 1
            current_button = current_button - 1

        ENDWHILE

        IF button_count > buttons_per_line THEN

            button_count = 1
            button_line = button_line - 2

        ENDIF

        PROMPT OBJECT button_object
            CLASS "STD_PROMPT_BUTTON"
            ON LINE button_line
            FROM  form . width - ( 11 * button_count ) + 1
            WITH ( caption      = get_user_message (
                                       "SMP_PROMPT_BUTTON_OK" , 1 ) ,
                   enabled      = TRUE                              ,
                   width        = 10                                ,
                   send_lastkey = "DO"                              )

        form . add_prompt ( button_object )

    ENDIF

ENDROUTINE

{*****************************************************************************}

    ROUTINE labtable_callback (       labtable   ,
                    VALUE operation  )

{
*
*
******************************************************************************}

    DECLARE answer

    answer = FALSE

    IF ( ( operation = OPERATION_ADD ) AND ( labtable . copy_value <> EMPTY ) ) OR
       ( operation = OPERATION_COPY                                           ) OR
       ( operation = OPERATION_NEW_VERSION ) THEN

        copy_text_file ( labtable )

    ENDIF

    IF operation = "SELECT_KEY" THEN

        IF labtable . operation <> OPERATION_DISPLAY THEN

            decide_on_next_screen (  labtable , "MODIFY" )

        ELSE

            decide_on_next_screen (  labtable , "DISPLAY" )

        ENDIF

    ELSE

        answer = perform_special_operations ( labtable , operation )

    ENDIF
    
    RETURN ( answer )

ENDROUTINE

{*****************************************************************************}

    ROUTINE labtablib_enter_id_prompt ( self )

{
*
*
******************************************************************************}

    DECLARE labtable        ,
            form            ,
            editor_object   ,
            reset_data      ,
            temp            ,
            new_id          ,
            count           ,
            select_array    ,
            needs_select
     

    reset_data = TRUE
    form       = self . parent_prompt
    labtable   = form . user_info

    ARRAY select_array ARRAY_SIZE ( 0, 3 )

    IF labtable . has_approval THEN

        IF labtable . operation = OPERATION_MODIFY THEN

            { Can modify an available or rejected record only }

            array_select_add ( select_array              ,
                               ARRAY_SELECT_PUSH         ,
                               EMPTY                     ,
                               EMPTY                     )

            array_select_add ( select_array              ,
                               ARRAY_SELECT_EQ           ,
                               labtable . approval_field ,
                               APPR_AVAILABLE            )

            array_select_add ( select_array    ,
                               ARRAY_SELECT_OR ,
                               EMPTY           ,
                               EMPTY           )

            array_select_add ( select_array              ,
                               ARRAY_SELECT_EQ           ,
                               labtable . approval_field ,
                               APPR_REJECTED             )

            IF ( GLOBAL ( "APPROVAL_INSPECT_SECURITY" ) = "LOW" ) THEN

                array_select_add ( select_array    ,
                                   ARRAY_SELECT_OR ,
                                   EMPTY           ,
                                   EMPTY           )

                array_select_add ( select_array              ,
                                   ARRAY_SELECT_EQ           ,
                                   labtable . approval_field ,
                                   APPR_APPROVED             )

            ENDIF

            array_select_add ( select_array              ,
                               ARRAY_SELECT_POP          ,
                               EMPTY                     ,
                               EMPTY                     )

            self . mandatory_array = select_array

        ELSEIF labtable . submit_mode THEN
            array_select_add ( select_array              ,
                               ARRAY_SELECT_EQ           ,
                               labtable . approval_field ,
                               APPR_AVAILABLE            )

            self . mandatory_array = select_array

        ELSEIF labtable . approval_mode THEN

            array_select_add ( select_array              ,
                               ARRAY_SELECT_EQ           ,
                               labtable . approval_field ,
                               APPR_INSPECT              )

            self . mandatory_array = select_array

        ELSE

            { Anything else display all records                 }
            { this is neede to stop browse adding Approved only }

            array_select_add ( select_array              ,
                               ARRAY_SELECT_GE           ,
                               labtable . approval_field ,
                               " "                       )

            self . mandatory_array = select_array
        ENDIF

    ENDIF

    IF labtable . is_editing THEN

        IF ( labtable . operation = OPERATION_DISPLAY ) THEN

            labtablib_quit ( labtable )
            reset_data = TRUE

        ELSEIF confirm_with_message ( "LABTABLIB_CONFIRM_CHANGE" ) THEN

            reset_data = labtablib_save ( labtable )

        ELSE

            labtablib_quit ( labtable )
            reset_data = TRUE

        ENDIF

        IF NOT reset_data THEN

            reset_data = FALSE
            self . stop_prompt ( )
            SET GLOBAL ( "LASTKEY" ) TO "RETURN"

        ENDIF

    ENDIF

    IF reset_data THEN

        self . char_position = 1
        self . cursor_position = 1
        self . repaste ( )

        IF ( labtable . clear_screen                        ) AND
           ( labtable . operation <> OPERATION_ADD          ) AND
           ( labtable . operation <> OPERATION_NEW_VERSION  ) AND
           ( labtable . operation <> OPERATION_COPY         ) THEN

            NEXT 'labtable . name_of_table' IN OBJECT labtable

            object_set_current_table ( labtable ,
                                       labtable . name_of_table )

        ELSE

            NEXT 'labtable . name_of_table'

        ENDIF

        labtable . clear_screen = FALSE

        IF variable_is_assigned ( labtable . editor_prompt ) THEN

            editor_object = form . prompt_objects [ labtable . editor_prompt ]
            editor_object . display_nothing = TRUE
            editor_object . redisplay_contents ( )
            editor_object . display_nothing = FALSE

        ENDIF

        IF variable_is_assigned ( labtable . modified_on_object ) THEN

            temp = PAD ( " " , " " , labtable . modified_on_object . length )
            labtable . modified_on_object . set_text ( temp )

        ENDIF

        IF variable_is_assigned ( labtable . modified_by_object ) THEN

            temp = PAD ( " " , " " , labtable . modified_by_object . length )
            labtable . modified_by_object . set_text ( temp )

        ENDIF

    ENDIF

    IF ( labtable . operation = OPERATION_ADD  ) OR
       ( labtable . operation = OPERATION_COPY ) THEN

        IF vgl_validate_routine ( labtable .  lte_report ,
                                  "CREATE_ID_ROUTINE"    ) THEN

            CALL_ROUTINE "CREATE_ID_ROUTINE"
              RETURNING  new_id
              IN LIBRARY labtable . lte_report

        ELSE

            new_id = EMPTY

        ENDIF

        IF new_id <> EMPTY THEN

            self . value = new_id
            self . text  = new_id
            self . repaste ( )
            self . stop_prompt ( )
            self . set_lastkey ( "RETURN" )
            labtable . labtable_mode = TRUE

        ENDIF

    ENDIF

    labtable . is_editing = FALSE

    needs_select = FALSE

    IF form . active_prompt > labtable . first_id_prompt THEN

        needs_select = TRUE

        IF ( labtable . operation = OPERATION_ADD  ) OR
           ( labtable . operation = OPERATION_COPY ) THEN

            IF labtable . name_of_table <>
               form . prompt_objects [ form . active_prompt ] . table THEN

                needs_select = FALSE

            ENDIF

        ENDIF

    ENDIF       

    IF needs_select THEN

        ARRAY select_array ARRAYSIZE ( 0 , 3 )

        count = labtable . first_id_prompt

        WHILE count < form . active_prompt DO

            IF count > labtable . first_id_prompt THEN

                array_select_add ( select_array     ,
                                   ARRAY_SELECT_AND ,
                                   EMPTY            ,
                                   EMPTY            )

            ENDIF

            array_select_add ( select_array                            ,
                           ARRAY_SELECT_EQ                         ,
                               labtable . key0_fields [ count ]        ,
                               form . prompt_objects [ count ] . value )

            count = count + 1

        ENDWHILE

        array_select_concat ( select_array                                    ,
                              form                                          .
                              prompt_objects [ labtable . first_id_prompt ] .
                              mandatory_array                                 )

        self . mandatory_array = select_array

    ENDIF

ENDROUTINE

{*****************************************************************************}

    ROUTINE labtablib_validate_id_new ( self )

{
*
* If the next field is a version number dont allow duplicates of an
* existing id to be created in the add option.
* Construct a string containing the ID values so far and check if it exists
*
*****************************************************************************}

    DECLARE form     ,
            labtable ,
            id_is_ok

    form     = self . parent_prompt
    labtable = form . user_info

    IF self . get_lastkey ( ) = "EXIT" THEN

        id_is_ok = TRUE

    ELSEIF blank ( form . prompt_objects [ form . active_prompt ] . text ) THEN

        id_is_ok = FALSE

    ELSE
    
        IF ( form . active_prompt < labtable . number_key0_fields ) AND
               ( labtable . key0_fields [ form . active_prompt + 1 ] = labtable . version_field ) THEN

            id_is_ok = NOT labtablib_find_record_by_array ( form                 ,
                                                            form . active_prompt ,
                                                            DONT_LOCK_RECORD     )

            IF NOT id_is_ok THEN
                flash_message ( "DB_ID_EXISTS", TRUE )
            ENDIF

        ELSE

            id_is_ok = TRUE

        ENDIF

        IF id_is_ok THEN

            IF vgl_validate_routine ( labtable .  lte_report    ,
                                      "VALIDATE_NEW_ID_ROUTINE" ) THEN

                CALL_ROUTINE "VALIDATE_NEW_ID_ROUTINE"
                   USING form . prompt_objects [ form . active_prompt ] . text
                   RETURNING  id_is_ok
                   IN LIBRARY labtable . lte_report

            ENDIF

        ENDIF

    ENDIF

        IF id_is_ok AND ( self . get_lastkey () = "DO" ) THEN

        self . set_lastkey ( "TAB" )

    ENDIF

    RETURN ( id_is_ok )

ENDROUTINE

{*****************************************************************************}

    ROUTINE labtablib_leave_id_prompt ( self )

{
*
* If the next field is a version number find the highest value used
* so far and the version prompt accordingly.
*
*****************************************************************************}

    DECLARE form           ,
            labtable       ,
            version_number ,
            empty_var

    form     = self . parent_prompt
    labtable = form . user_info

    IF self . get_lastkey () = "EXIT" THEN

    ELSEIF ( form . active_prompt < labtable . number_key0_fields  ) AND
               ( labtable . key0_fields [ form . active_prompt + 1 ] =
             labtable . version_field                              ) THEN


        IF ( labtable . operation = OPERATION_NEW_VERSION ) THEN

            empty_var = EMPTY

            version_number = NUMERIC ( labtablib_highest_version ( empty_var ,
                                           labtable  ,
                                           form      ))
            version_number = version_number + 1
                        
        ELSE

            version_number = NUMERIC ( labtablib_highest_version ( self     ,
                                           labtable ,
                                           form     ))

        ENDIF

        form . prompt_objects [ form . active_prompt + 1 ] . text =
                            PACKED_DECIMAL ( version_number )

        form . prompt_objects [ form . active_prompt + 1 ] . value =
                  form . prompt_objects [ form . active_prompt + 1 ] . text

        form . prompt_objects [ form . active_prompt + 1 ] . maximum =
                  version_number

        form . prompt_objects [ form . active_prompt + 1 ] . minimum = 0


        form . prompt_objects [ form . active_prompt + 1 ] . repaste ( )

    ENDIF

    IF self . get_lastkey ( ) = "DO" THEN

        form . set_position ( labtable . editor_prompt )
        self . set_lastkey ( "CONTINUE" )

    ENDIF

ENDROUTINE

{*****************************************************************************}

    ROUTINE labtablib_copy_values ( labtable )

{
*
*
******************************************************************************}

    DECLARE field_names ,
            count       ,
            is_key

    IF labtablib_find_record ( labtable              ,
                               labtable . copy_value ,
                               DONT_LOCK_RECORD      ) THEN

        get_field_names ( labtable . name_of_table ,
                                  field_names              )

        count = 1

        WHILE count <= size_of_array ( field_names ) DO

            GET_FIELD_DETAILS  'labtable . name_of_table'   .
                               'field_names [ count , 1 ] '   ,
                               "KEY0_FIELD"                   ,
                               is_key

                IF ( NOT is_key ) AND 
                   ( NOT field_names [ count , 2 ] ) AND
                   ( field_names [ count, 1 ] <> labtable . name_field ) AND
                       ( interface_copy_flag ( labtable, field_names [ count, 1 ] ) ) THEN

                ASSIGN 'labtable . name_of_table' . 'field_names [ count , 1 ]'
                  IN OBJECT labtable = SELECT 'labtable . name_of_table' .
                                              'field_names [ count , 1 ]'

            ENDIF

            count = count + 1

        ENDWHILE

        IF labtable . remove_field <> EMPTY THEN

            ASSIGN 'labtable . name_of_table' .
                               'labtable . remove_field'
                               IN OBJECT labtable = FALSE

        ENDIF

        IF labtable . modifiable_field <> EMPTY THEN

            ASSIGN 'labtable . name_of_table' .
                               'labtable . modifiable_field'
                               IN OBJECT labtable = TRUE

        ENDIF

                IF labtable . modified_on <> EMPTY THEN

                        ASSIGN 'labtable . name_of_table' .
                               'labtable . modified_on'
                               IN OBJECT labtable = ""

                ENDIF

                IF labtable . modified_by <> EMPTY THEN

                        ASSIGN 'labtable . name_of_table' .
                               'labtable . modified_by'
                               IN OBJECT labtable = ""

                ENDIF

        IF labtable . has_approval THEN

            { Set this "new version" or "copied" record to "IN EDITING" }

            ASSIGN 'labtable . name_of_table' .
                   'labtable . approval_field'
                   IN OBJECT labtable = APPR_AVAILABLE

        ENDIF

    ENDIF

    object_set_current_table ( labtable, labtable . name_of_table )

ENDROUTINE

{*****************************************************************************}
    
ROUTINE interface_copy_flag ( labtable, VALUE field )

{
* Checks the value of the copy flag the interface. If set to No, then the 
* value of the field is not copied to the new record.
*
******************************************************************************}

    DECLARE table,
            interface,
            copy     ,
            copy_value

    copy      = TRUE
    table     = labtable . name_of_table
    interface = labtable . interface

    copy_value = SELECT interface_field . copy
                 WHERE table_name = table
                 AND   interface  = interface
                 AND   field_name = field

    IF copy_value <> EMPTY THEN

        copy = copy_value

    ENDIF

    RETURN ( copy )

ENDROUTINE

{*****************************************************************************}
    ROUTINE labtablib_leave_editor_prompt ( self )

{
*
*
******************************************************************************}
    
    DECLARE labtable ,
        form 
        
    form          = self . parent_prompt
    labtable      = form . user_info

    IF ( self . get_lastkey ( ) <> "DO" )   AND 
       ( self . get_lastkey ( ) <> "EXIT" ) THEN

        IF NOT approval_check_security ( labtable ) THEN
            self . set_lastkey ( "RETURN" )
        ENDIF
    ENDIF
        
        
ENDROUTINE


{*****************************************************************************}

    ROUTINE labtablib_enter_editor_prompt ( self )

{
*
*
******************************************************************************}

    DECLARE labtable      ,
            form          ,
            count

    form          = self . parent_prompt
    labtable      = form . user_info

    IF labtable . is_editing THEN

        { Already got a data set - dont overwrite }
        RETURN

    ENDIF

    count = 1
    labtable . identity = ""

    WHILE count <= labtable . number_key0_fields DO

        IF labtable . key0_fields [ count ] = labtable . version_field THEN

            labtable . identity = labtable . identity :
                                  PACKED_DECIMAL ( form . prompt_objects [ count ] . value )

        ELSE

            labtable . identity = labtable . identity :
                                  form . prompt_objects [ count ] . value

        ENDIF

        count = count + 1

    ENDWHILE

    labtablib_prepare_for_action ( form , FALSE )

ENDROUTINE

{*****************************************************************************}

    ROUTINE labtablib_prepare_for_action (       form     ,
                           VALUE use_tabs )

{
*
*
******************************************************************************}

        DECLARE labtable       ,
                editor_object  ,
                count          ,
                continue       ,
                status

        status = EMPTY

        labtable      = form . user_info
        editor_object = form . prompt_objects [ labtable . editor_prompt ]

    IF labtable . operation = OPERATION_NEW_VERSION THEN

        count = 1
        labtable . copy_value = ""

        WHILE count <= labtable . number_key0_fields DO

            IF labtable . key0_fields [ count ] = labtable . version_field THEN

                labtable . copy_value = labtable . copy_value :
                                        NUMBER_TO_TEXT ( form                     .
                                                         prompt_objects [ count ] .
                                                         value - 1                  ,
                                                         "9999999999"               )

            ELSE

                labtable . copy_value = labtable . copy_value :
                                        form . prompt_objects [ count ] . value

            ENDIF

            count = count + 1

        ENDWHILE

    ENDIF

    IF labtable . operation = OPERATION_ADD THEN

        RESERVE ENTRY 'labtable . name_of_table' , labtable . identity , status

        continue = ( status = EMPTY )

    ELSEIF ( labtable . operation = OPERATION_NEW_VERSION ) OR
           ( labtable . operation = OPERATION_COPY        ) THEN

        RESERVE ENTRY 'labtable . name_of_table' IN OBJECT labtable ,
                      labtable . identity                           ,
                      status

        continue = ( status = EMPTY )

        IF continue THEN

            labtablib_copy_values ( labtable )

        ENDIF

    ELSEIF ( NOT use_tabs ) THEN

        continue = labtablib_find_record_by_array (
                        form                        ,
                        labtable . last_id_prompt   ,
                        ( labtable . operation <>
                          OPERATION_DISPLAY       ) )

    ELSE

        continue = TRUE

    ENDIF

    IF continue THEN

        IF vgl_validate_routine ( labtable .  lte_report , "READ_DATA_ROUTINE" ) THEN

            CALL_ROUTINE "READ_DATA_ROUTINE"
            USING        labtable             ,
                         labtable . operation
            IN LIBRARY   labtable . lte_report

        ENDIF

        labtable . is_editing   = TRUE
        labtable . clear_screen = TRUE

        IF variable_is_assigned ( labtable . modified_on_object ) THEN

            labtable . modified_on_object . set_text
                    ( SELECT 'labtable . name_of_table' .
                             'labtable . modified_on'   )

        ENDIF

        IF variable_is_assigned ( labtable . modified_by_object ) THEN

            labtable . modified_by_object . set_text
                    ( SELECT 'labtable . name_of_table' .
                             'labtable . modified_by'   )

        ENDIF

        IF variable_is_assigned ( labtable . approval_stat_object ) THEN

            labtable . approval_stat_object . set_text
                    ( SELECT 'labtable . name_of_table' . 'labtable . approval_field' )

        ENDIF

        IF ( NOT use_tabs ) THEN

            editor_object . redisplay_contents ( )
            editor_object . set_position ( 1 , 1 )

        ENDIF

        IF labtable . operation = OPERATION_MODIFY THEN

            labtable_callback ( labtable , "READ_FOR_MODIFY" )

        ELSEIF labtable . operation = OPERATION_DISPLAY THEN

            labtable_callback ( labtable , "READ_FOR_DISPLAY" )

        ELSEIF labtable . operation = OPERATION_NEW_VERSION THEN

            labtable_callback ( labtable , "COPY" )

        ELSE

            labtable_callback ( labtable , labtable . operation )

        ENDIF

    ELSE

        IF status <> EMPTY THEN

            flash_message ( status , TRUE )

        ENDIF

        form . set_position ( labtable . first_id_prompt )
        editor_object . stop_prompt ( )
        editor_object . set_lastkey ( "CONTINUE" )

    ENDIF

ENDROUTINE

{*****************************************************************************}

    ROUTINE labtablib_validate_id_prompt ( self )

{
*
*
******************************************************************************}

    DECLARE mod_field    ,
            modifiable   ,
            return_value ,
            form         ,
            labtable

    return_value = TRUE

    form      = self . parent_prompt
    labtable  = form . user_info
    mod_field = labtable . modifiable_field

    IF ( mod_field <> EMPTY ) THEN

        IF labtable . operation = OPERATION_NEW_VERSION THEN

            modifiable = TRUE

            ASSIGN 'self . table' . 'mod_field'
              IN OBJECT self = modifiable

        ELSEIF ( role_lib_has_privilege ( ROLE_LIB_PRIV_MODIFIABLE )) THEN

            modifiable = TRUE

        ELSEIF ( form . active_prompt = labtable . number_key0_fields ) THEN

            modifiable = SELECT 'self . table' . 'mod_field' IN OBJECT self

        ELSE

            modifiable = labtablib_find_modifiable_record_by_array (
                                                        form                 ,
                                                        form . active_prompt )

        ENDIF

        IF modifiable = EMPTY THEN

            return_value = FALSE

        ELSEIF modifiable = FALSE THEN

            IF ( NOT role_lib_has_privilege ( ROLE_LIB_PRIV_MODIFIABLE )) THEN

                flash_message ( "SMP_K_IDNONMOD", TRUE )
                self . repaste ( )
                return_value = FALSE

            ENDIF

        ENDIF

    ELSE

        return_value = ( ( SELECT 'self . table' . 'self . field'IN OBJECT self ) <> EMPTY )

    ENDIF

    RETURN ( return_value )

ENDROUTINE

{*****************************************************************************}

    ROUTINE clear_id_prompts ( form , labtable )

{
*
*
******************************************************************************}

    DECLARE count

    count = labtable . first_id_prompt

    WHILE count <= labtable . last_id_prompt DO

        REPEAT

            NEXT      'form . prompt_objects [ count ] . table'
            IN OBJECT form . prompt_objects [ count ]

        UNTIL ( ( SELECT   'form . prompt_objects [ count ] . table' .
                   'form . prompt_objects [ count ] . field'
                  IN OBJECT form . prompt_objects [ count ] ) = EMPTY )

        GET_FIELD_DETAILS 'labtable . name_of_table'         .
                          'labtable . key0_fields [ count ]'      ,
                          "DEFAULT_VALUE"                         ,
                          form . prompt_objects [ count ] . value

        FORMAT form . prompt_objects [ count ] . text
        FROM   form . prompt_objects [ count ] . value
        USING  'labtable . name_of_table' . 'labtable . key0_fields [ count ]'

        form . prompt_objects [ count ] . text = STRIP ( form . prompt_objects [ count ] . text )
                form . prompt_objects [ count ] . value = form . prompt_objects [ count ] . text
        form . prompt_objects [ count ] . repaste ( )

        count = count + 1

    ENDWHILE

ENDROUTINE

{*****************************************************************************}

    ROUTINE labtablib_select ( the_line_editor )

{
*
*
******************************************************************************}

    labtable_callback ( the_line_editor . parent_prompt . user_info  ,
                            "SELECT_KEY"                                 )

ENDROUTINE

{*****************************************************************************}

    ROUTINE labtablib_form_select ( the_form )

{
*
*
******************************************************************************}

        DECLARE labtable

        labtable = the_form . user_info

        IF ( NOT labtable . is_editing ) THEN

                the_form . set_position ( labtable . editor_prompt )
                the_form . prompt_objects [ labtable . editor_prompt ] .
                                                            enter_prompt ( )

        ENDIF

        IF ( labtable . is_editing ) THEN

                labtable_callback ( the_form . user_info ,
                                    "SELECT_KEY"         )

        ENDIF

ENDROUTINE

{*****************************************************************************}

    ROUTINE labtablib_button_press ( self )

{
*
*
******************************************************************************}

        DECLARE form          ,
                labtable      ,
                edit_the_file ,
                perform_report

        form     = self . parent_prompt
        labtable = form . user_info

        IF ( NOT labtable . is_editing ) THEN

                form . set_position ( labtable . editor_prompt )
                self . set_lastkey ( "CONTINUE" )
                form . prompt_objects [ labtable . editor_prompt ] .
                                                            enter_prompt ( )

        ENDIF

        IF ( NOT labtable . is_editing ) THEN

                RETURN

        ENDIF

        edit_the_file  = labtable . extension <> empty
        perform_report = ( size_of_array ( labtable . special_actions ) >= 1 ) AND
                         ( labtable . special_actions [1,1] <> empty )

        IF perform_report THEN

                IF labtable  . operation = OPERATION_DISPLAY THEN

                        call_special_operation (  labtable              ,
                                                  self . user_info      ,
                                                 "DISPLAY"              )

                ELSE

                        call_special_operation ( labtable         ,
                                                 self . user_info ,
                                                 "MODIFY"         )

                ENDIF

        ELSEIF edit_the_file THEN

                IF labtable  . operation = OPERATION_DISPLAY THEN

                        text_file ( labtable , "DISPLAY"  )

                ELSE

                        text_file ( labtable , "MODIFY"  )

                ENDIF

        ENDIF

ENDROUTINE

{*****************************************************************************}

    ROUTINE labtablib_save ( labtable  )

{
*
*
******************************************************************************}

    DECLARE updated       ,
            special_field ,
            valid         ,
            submit_record

        CALL_ROUTINE "validation_routine"
                 RETURNING valid
                 IN LIBRARY labtable . lte_report

    IF valid THEN

        valid = labtablib_do_name_validation ( labtable )

    ENDIF

    IF valid THEN   

        IF NOT transaction_is_write ( ) THEN

            START WRITE TRANSACTION labtable . messages [ WRITE_MESSAGE ]

        ENDIF

        IF vgl_validate_routine ( labtable .  lte_report ,
                      "UPDATE_ROUTINE"       ) THEN

            CALL_ROUTINE "UPDATE_ROUTINE"
                         USING labtable
                         RETURNING updated
                         IN LIBRARY labtable . lte_report

        ENDIF

        labtable_callback ( labtable  , "SAVE" )

        IF labtable . has_approval THEN

            IF ( transaction_has_updates ( ) OR
                 row_has_updates ( labtable . name_of_table )) THEN

                { Set approved records to available }

                ASSIGN 'labtable . name_of_table' .
                       'labtable . approval_field' = APPR_AVAILABLE

            ENDIF

            IF GLOBAL ( "APPROVAL_SUBMIT_ON_ADD" ) THEN

                IF labtable . ask_for_submit THEN
                    submit_record = confirm_with_text ( get_user_message ( "LABTABLIB_SUBMIT_NOW" , 1 ) )
                ELSE
                    submit_record = TRUE
                ENDIF

                IF submit_record THEN
                    
                    IF labtable.name_of_table = "MLP_HEADER" THEN
                        CheckExternalVersion() 
{
                        IF (EMPTY = SELECT external_mlp_versions.mlp_version 
                                    WHERE identity = (SELECT mlp_header.identity) 
                                      AND external_number = (SELECT mlp_header.product_version)) THEN
                            ASSIGN mlp_header.external_version = FALSE
                        ELSE
                            ASSIGN mlp_header.external_version = TRUE
                        ENDIF
}
                    ENDIF
                    
                    gen_appr_sub_entry ( labtable . name_of_table ,
                                 labtable . identity      )

                    IF ( SELECT 'labtable . name_of_table' .
                              'labtable . approval_field' = APPR_APPROVED ) AND
                       ( GLOBAL ( "APPROVAL_INSPECT_SECURITY" ) <> "LOW"  ) THEN
                        flash_message ( get_user_message ( "LABTABLIB_AUTO_APPR" , 1 ) , TRUE )
                    ENDIF

                ENDIF

            ENDIF

        ENDIF

        updated = transaction_has_updates ( ) OR
                  row_has_updates ( labtable . name_of_table ) OR
                  labtable . text_file_saved

                IF updated THEN

            special_field = labtable . modified_on

            IF special_field <> EMPTY THEN

                ASSIGN 'labtable . name_of_table' . 'special_field' = NOW

            ENDIF

            special_field = labtable . modified_by

            IF special_field <> EMPTY THEN

                ASSIGN 'labtable . name_of_table' . 'special_field' = OPERATOR

            ENDIF

        ENDIF

        UPDATE 'labtable . name_of_table'

        IF labtable . name_of_table = "MLP_HEADER" THEN
            insert_iu("UPDATE", "UPDATE_MLP", (SELECT mlp_header.identity), (SELECT mlp_header.product_version))
        ENDIF

        COMMIT
{
        fm("approval_mode: ":labtable.approval_mode)
        IF (labtable.approval_mode) AND (labtable.name_of_table = "MLP_HEADER") THEN
            DECLARE ID
            ID = "'":(SELECT mlp_header.identity):"', '":(SELECT mlp_header.product_version):"'"
            fm("Send External Specs for ":ID:"?")
        ENDIF
}
        IF GLOBAL ( "TERMTYPE" ) <> "GUI" THEN

            output_message ( get_user_message ( "SMP_K_UPDATED", 1 ) )

        ENDIF

    ENDIF

        RETURN ( valid )

ENDROUTINE

{*****************************************************************************}

    ROUTINE labtablib_quit ( labtable  )

{
*
*
******************************************************************************}

    labtable_callback ( labtable , "QUIT" )

    ROLLBACK

    IF ( GLOBAL ( "TERMTYPE" ) <> "GUI"           ) AND
       ( labtable. operation <> OPERATION_DISPLAY ) THEN

        output_message ( get_user_message ( "SMP_K_NOTUPDATE" , 1 ) )

    ENDIF

ENDROUTINE

{*****************************************************************************}

    ROUTINE labtablib_is_finished ( form     ,
                                    labtable )

{
*
*
*****************************************************************************}

    DECLARE valid     ,
            show_mess ,
            do_exit   ,
            do_quit

        do_exit = FALSE
        do_quit = FALSE

    IF labtable . operation = OPERATION_DISPLAY THEN

        IF form . get_lastkey ( ) = "DO" THEN

            show_mess = FALSE
            valid     = TRUE

            IF labtable . approval_mode THEN

                show_mess = TRUE

                valid = gen_appr_appr_entry ( labtable . name_of_table ,
                                              labtable . identity      ,
                                              labtable . approve_as    )
                                              
                IF  labtable . name_of_table = "MLP_HEADER" THEN 
                    DECLARE mlp, ver, status
                    mlp = LEFTSTRING(labtable . identity, 10)
                    ver = SUBSTRING(labtable . identity, 11, 10)
                    START WRITE TRANSACTION "Set approval date"
                    status = SELECT mlp_header.identity FOR UPDATE WHERE identity = mlp AND product_version = ver AND approval_status = "A"
                    IF status = mlp THEN
                        ASSIGN mlp_header.appr_date = NOW
                        UPDATE mlp_header
                        COMMIT
                    ENDIF    
                ENDIF

            ELSEIF labtable . submit_mode THEN

                show_mess = TRUE

                IF labtable.name_of_table = "MLP_HEADER" THEN
                    CheckExternalVersion()
                    {IF (EMPTY = SELECT external_mlp_versions.mlp_version 
                                WHERE identity = (SELECT mlp_header.identity) 
                                  AND external_number = (SELECT mlp_header.product_version)) THEN
                        ASSIGN mlp_header.external_version = FALSE
                    ELSE
                        ASSIGN mlp_header.external_version = TRUE
                    ENDIF }
                ENDIF

                valid = gen_appr_sub_entry ( labtable . name_of_table ,
                                             labtable . identity      )

            ENDIF

            IF show_mess THEN

                IF valid THEN

                    output_message ( get_user_message ( "LABTABLIB_OP_COMP" , 1 ) )

                ELSE

                    output_message ( get_user_message ( "LABTABLIB_OP_ABOR" , 1 ) )

                ENDIF
            ENDIF

        ENDIF

        do_quit = TRUE

    ELSEIF GLOBAL ( "TERMTYPE" ) = "GUI" THEN

        IF form . get_lastkey ( ) = "DO" THEN

            IF labtable . has_approval THEN

                do_exit = approval_check_security ( labtable )

            ELSE

                do_exit = TRUE

            ENDIF

        ELSE

            do_quit = TRUE

        ENDIF

    ELSEIF confirm ( ) THEN

        do_exit = ( form . get_lastkey ( ) = "DO" )
        do_quit = NOT do_exit

    ENDIF

    IF do_quit THEN

        labtablib_quit ( labtable )
        valid = TRUE

    ELSEIF do_exit THEN

        valid = labtablib_save ( labtable )

    ELSE

        valid = FALSE

    ENDIF
    
    IF labtable . operation = OPERATION_NEW_VERSION THEN
        
        Update_mlp_schedule (labtable . identity)   
            
    ENDIF   

    RETURN ( valid )

ENDROUTINE

{*****************************************************************************}

    ROUTINE labtablib_prompt ( labtable ,
                   form     )

{
*
*
******************************************************************************}

    DECLARE can_leave

    can_leave = FALSE

    form . prompt_objects [ labtable . editor_prompt ] .
      display_nothing = TRUE

    clear_id_prompts ( form , labtable )

    form . start_prompt ( )

    REPEAT

        form . wait_prompt ( )

        IF ( form . active_prompt >= labtable . first_id_prompt ) AND
           ( form . active_prompt <= labtable . last_id_prompt  ) THEN

            IF form . get_lastkey ( ) = "EXIT" THEN

                can_leave = TRUE

            ENDIF

        ELSEIF labtablib_is_finished ( form     ,
                                       labtable ) THEN

            labtable . is_editing = FALSE

            IF labtable . labtable_mode AND NOT GLOBAL ( "PARAM_ACTIVE" ) THEN

                can_leave = TRUE

            ELSE

                clear_id_prompts ( form , labtable )
                form . set_position ( labtable . first_id_prompt )

            ENDIF

        ENDIF

    UNTIL can_leave

    form . end_prompt ( )

    form . prompt_objects [ labtable . editor_prompt ] .
       display_nothing = FALSE

ENDROUTINE

{*****************************************************************************}

    ROUTINE labtablib_remove ( labtable )

{
*
*
*****************************************************************************}

    DECLARE identity, message_var

    IF labtable . remove_field = EMPTY THEN

        message_fetch ( "LABTABLIB_NOREMOVE" , message_var )

        message_add_parameter ( message_var                      ,
                                STRIP ( labtable . name_of_table ) )

        flash_message ( message_get_text ( message_var , 1 ) , TRUE )

    ELSEIF get_ident ( identity                 ,
                       get message ( 2551 , 1 ) ,
                       labtable                 ,
                       APPROVAL_ANY             ) THEN

        message_fetch ( "LABTABLIB_CONFIRM_REMOVE", message_var )
        message_add_parameter ( message_var, STRIP ( identity ))

        IF confirm_with_message ( message_get_text ( message_var , 1 )) THEN

            show_final_mess ( "REMOVE"                           ,
                              remove_restore_record ( identity ,
                                                      TRUE     ,
                                                      labtable ) )

        ENDIF

    ENDIF

ENDROUTINE

{*****************************************************************************}

    ROUTINE labtablib_restore ( labtable )

{
*
*
*****************************************************************************}

    DECLARE ident       ,
            message_var

    SET BROWSE REMOVED

    IF labtable . remove_field = EMPTY THEN

        message_fetch ( "LABTABLIB_NOREMOVE" , message_var )

        message_add_parameter ( message_var                        ,
                                STRIP ( labtable . name_of_table ) )

        flash_message ( message_get_text ( message_var , 1 ) , TRUE )

    ELSEIF get_ident ( ident                    ,
                       get message ( 2552 , 1 ) ,
                       labtable                 ,
                       APPROVAL_ANY             ) THEN

        message_fetch ( "LABTABLIB_CONFIRM_RESTORE", message_var )
        message_add_parameter ( message_var, STRIP ( ident ))

        IF confirm_with_message ( message_get_text ( message_var , 1 )) THEN

            remove_restore_record ( ident , FALSE , labtable )
            show_final_mess ( "RESTORE" ,  TRUE )

        ENDIF

    ENDIF

    SET BROWSE ACTIVE

ENDROUTINE

{*****************************************************************************}

    ROUTINE labtablib_list ( labtable         ,
                 fields_to_output )

{
*
*
*****************************************************************************}

    DECLARE data_type        ,
            ident            ,
            data_input       ,
            success          ,
            count            ,
            bar_counter      ,
            select_array     ,
            imprint

    imprint = client_get_imprint_path ( )

    IF imprint <> EMPTY THEN

        labtab_imprint_report ( labtable . name_of_table      ,
                                labtable . user_name_of_table ,
                                labtable . prompt_details     ,
                                fields_to_output              )

    ELSE

            set format "999999"
            ARRAY data_input ARRAY_SIZE ( 0 )

            count = select count 'labtable . name_of_table'

            set_up_install_window_class ( )

            CREATE OBJECT INSTALL_WINDOW_CLASS , bar_counter

            bar_counter . header      = get message ( 2544 , 1 )
            bar_counter . row         = 15
            bar_counter . start_value = 0
            bar_counter . end_value   = count
            bar_counter . start_install ( )

            SET NAME "defer/"
            output_list_header ( labtable )

            get_field_details 'labtable . name_of_table'     .
                              'labtable . key0_fields [ 1 ]'   ,
                               "DATA_TYPE"                     ,
                                data_type

            ARRAY select_array ARRAY_SIZE ( 0, 3 )

            IF INDEX ( "TEXTIDENTITY" , TOUPPER ( data_type ) ) <> 0 THEN

                    array_select_add ( select_array                 ,
                                       ARRAY_SELECT_NE              ,
                                       labtable . key0_fields [ 1 ] ,
                                       EMPTY                        )

            ELSEIF INDEX ( "INTEGEREAL" , TOUPPER ( data_type ) ) <> 0 THEN

                    array_select_add ( select_array                 ,
                                       ARRAY_SELECT_NE              ,
                                       labtable . key0_fields [ 1 ] ,
                                       0                            )

                    array_select_add ( select_array                 ,
                                       ARRAY_SELECT_OR              ,
                                       EMPTY                        ,
                                       EMPTY                        )

                    array_select_add ( select_array                 ,
                                       ARRAY_SELECT_EQ              ,
                                       labtable . key0_fields [ 1 ] ,
                                       0                            )

            ENDIF

            count = 1

            WHILE count <= labtable . number_key0_fields DO

                    array_select_add ( select_array                     ,
                                       ARRAY_SELECT_ORDER               ,
                                       labtable . key0_fields [ count ] ,
                                       ARRAY_SELECT_ASCENDING           )

                    count = count + 1

            ENDWHILE

            array_select ( labtable . name_of_table ,
                           FALSE                    ,
                           select_array             )

            output_correct_prompt_sizes ( labtable, fields_to_output )

            ident = select 'labtable . name_of_table' .
                           'labtable . key0_fields [ 1 ]'

            WHILE ( ident <> empty ) DO

                    bar_counter . increase_one ( )

                    read_info ( ident      ,
                                data_input ,
                                success    ,
                                FALSE      ,
                                FALSE      ,
                                labtable   )

                    IF success THEN

                            IF labtable . remove_field <> EMPTY THEN

                                    IF NOT select 'labtable . name_of_table' .
                                                  'labtable . remove_field'  THEN

                                            output_list_entry ( labtable   ,
                                                                data_input ,
                                                                fields_to_output )

                                    ENDIF
                            ELSE

                                    output_list_entry ( labtable   ,
                                                        data_input ,
                                                        fields_to_output )

                            ENDIF

                    ENDIF

                    NEXT 'labtable . name_of_table'

                    ident = select 'labtable . name_of_table' .
                                   'labtable . key0_fields [ 1 ]'

            ENDWHILE

            bar_counter . end_install ( )

            flush_LITERAL

    ENDIF

ENDROUTINE

{*****************************************************************************}

    ROUTINE labtablib_print ( labtable )

{
*
*
*****************************************************************************}

    DECLARE temp       ,
            datatype   ,
            key0       ,
            ident      ,
            data_input ,
            success    ,
            imprint

    IF get_ident ( ident                    ,
                   get message ( 2553 , 1 ) ,
                   labtable                 ,
                   APPROVAL_ANY             ) THEN

            labtable . identity = ident
        imprint = client_get_imprint_path ( )

        IF imprint <> EMPTY THEN

            print_lte ( labtable )

        ELSE

            set format "999999"
            ARRAY data_input ARRAY_SIZE ( 0 )

            SET NAME "defer/"
            get_table_details 'labtable . name_of_table' ,
                              "KEY0_FIELD"               ,
                              temp

            key0 = temp [ 1 ]

            get_field_details 'labtable . name_of_table' . 'key0' ,
                              "DATA_TYPE"                         ,
                              data_type

            read_info ( ident      ,
                        data_input ,
                        success    ,
                        TRUE       ,
                        FALSE      ,
                        labtable   )

            IF success THEN

                output_print_details ( ident      ,
                                               data_input ,
                                               labtable   )

                perform_special_operations ( labtable , "PRINT" )

            ENDIF

            flush_LITERAL

        ENDIF

    ENDIF

ENDROUTINE

{*****************************************************************************}

    ROUTINE get_ident (       ident     ,
                        VALUE top_line  ,
                              labtable  ,
                        VALUE allow_any )

{
*
*
******************************************************************************}

    DECLARE new_help, select_array

    ARRAY select_array ARRAYSIZE ( 0, 3 )

    IF labtable . has_approval THEN

        IF allow_any THEN

            array_select_add ( select_array              ,
                               ARRAY_SELECT_GE           ,
                               labtable . approval_field ,
                               " "                       )

        ENDIF

    ENDIF

    ident = " "

    IF variable_is_assigned ( labtable . help_context ) THEN

        new_help = labtable . help_context

    ELSE

        new_help = ""

    ENDIF

    RETURN ( labtable_prompt_in_window ( labtable . lte_report         ,
                                         labtable . name_of_table      ,
                                         labtable . input_message      ,
                                         capitalise ( top_line ) : " " :
                                         labtable . user_name_of_table ,
                                         new_help                      ,
                                         select_array                  ,
                                         ident                         ) )

ENDROUTINE

{*****************************************************************************}

    ROUTINE get_new_ident ( ident , VALUE top_line , labtable )

{
*
*
******************************************************************************}

    DECLARE new_help

        ident = " "

    IF variable_is_assigned ( labtable . help_context ) THEN

        new_help = labtable . help_context

    ELSE

        new_help = ""

    ENDIF

        RETURN ( vgl_prompt_for_new_in_window ( labtable . name_of_table      ,
                                            labtable . input_message      ,
                                            capitalise ( top_line ) : " " :
                                            labtable . user_name_of_table ,
                                            new_help                      ,
                                            ident                         ) )

ENDROUTINE

{*****************************************************************************}

    ROUTINE read_info (       ident           ,
                  data_input      ,
                  success         ,
                VALUE look_for_record ,
                VALUE do_lock_record  ,
                  labtable        )

{
*
*
******************************************************************************}

    DECLARE field_count

    IF look_for_record THEN

        success = labtablib_find_record ( labtable         ,
                                                  ident            ,
                                                  DONT_LOCK_RECORD )

    ELSE

        success = TRUE

    ENDIF

        IF success <> EMPTY THEN

        field_count = 1

        WHILE labtable . prompt_details [ field_count         ,
                                          FIELD_NAME_POSITION ] <> EMPTY DO

            IF ( labtable . prompt_details [ field_count   ,
                                             TYPE_POSITION ] = "ROUTINE" ) THEN

                data_input [ field_count ] = ""

            ELSE

                data_input [ field_count ] =
                   SELECT 'labtable . name_of_table' .
                    'labtable . prompt_details [ field_count         ,
                                     FIELD_NAME_POSITION ]'

            ENDIF

            field_count = field_count + 1

        ENDWHILE

    ENDIF

ENDROUTINE

{*****************************************************************************}

    ROUTINE copy_text_file ( labtable )

{
*
*
******************************************************************************}

    DECLARE full_description_field ,
            orig_file              ,
            new_file               ,
        temp_file_name

    labtable . text_file_copied = FALSE

    GET_TABLE_DETAILS 'labtable . name_of_table' ,
                      "FULL_DESCRIPTION"         ,
                      full_description_field

    IF full_description_field = EMPTY THEN

        IF labtable . extension <> EMPTY THEN

            orig_file = form_file_name ( labtable , labtable . copy_value )
            new_file  = form_file_name ( labtable , labtable . identity   )

            IF FILE EXISTS ( orig_file ) THEN

                FILE COPY orig_file , new_file

            ENDIF

        ENDIF

    ELSE

        temp_file_name = form_temp_file_name ( labtable , labtable . identity )

        BLOB_TO_FILE ( labtable . name_of_table ,
                       full_description_field   ,
                       temp_file_name           )

        ASSIGN ' labtable . name_of_table ' . ' full_description_field ' = 0
        labtable . text_file_copied = TRUE

    ENDIF

ENDROUTINE

{*****************************************************************************}

    ROUTINE remove_restore_record (       ident       ,
                                    VALUE remove_flag ,
                                          labtable    )

{
*
*
******************************************************************************}

    DECLARE done , success

    done = FALSE

    IF labtable . remove_field <> EMPTY THEN

        IF labtablib_find_record ( labtable    ,
                                   ident       ,
                                   LOCK_RECORD ) THEN

            START WRITE TRANSACTION "Labtable Remove Restore"

            ASSIGN 'labtable . name_of_table'.
                   'labtable . remove_field' = remove_flag

            UPDATE 'labtable . name_of_table'

            success = TRUE

            IF vgl_validate_routine ( labtable .  lte_report   ,
                          "REMOVE_RESTORE_ROUTINE" )
            THEN

                CALL_ROUTINE "REMOVE_RESTORE_ROUTINE"
                         USING labtable
                         RETURNING success
                         IN LIBRARY labtable . lte_report

            ENDIF

            IF success THEN

                COMMIT

                done = TRUE

            ELSE

                ROLLBACK

            ENDIF

        ENDIF

    ENDIF

    RETURN ( done )

ENDROUTINE

{*****************************************************************************}

    ROUTINE call_special_operation (       labtable  ,
                                     VALUE count     ,
                                     VALUE operation )

{
*
*
******************************************************************************}

    DECLARE answer, detail

    IF ( TOUPPER ( STRIP ( labtable . special_actions [ count , 4 ] ) ) = "TEXT_FILE"  ) AND
       ( TOUPPER ( STRIP ( labtable . special_actions [ count , 3 ] ) ) = "$LABTABLIB" ) THEN

        answer = text_file ( labtable , operation )

    ELSEIF ( labtable . special_actions [ count, 3 ] = "$LABTABLE_DB" ) AND
           ( labtable . special_actions [ count, 4 ] = "LTEDETAILS"   ) THEN

        detail = labtable . special_actions [ count, 5 ]
        answer = detail . do_list ( labtable, operation )

    ELSE

        CALL_ROUTINE labtable . special_actions [ count , 4 ]
               USING labtable . identity   ,
                     labtable . copy_value ,
                     operation
           RETURNING answer
          IN LIBRARY labtable . special_actions [ count , 3 ]

    ENDIF

    RETURN ( answer )

ENDROUTINE

{*****************************************************************************}

    ROUTINE call_tab_special_operation ( self )

{
*
*
******************************************************************************}

    DECLARE labtable      ,
            count         ,
            edit_the_file ,
            perform_report

    labtable       = self . user_info [ 1 ]
    count          = self . user_info [ 2 ]
    edit_the_file  = labtable . extension <> EMPTY
    perform_report = ( size_of_array ( labtable . special_actions ) >= 1 ) AND
                         ( labtable . special_actions [ 1 , 1 ] <> EMPTY )

    IF perform_report THEN

        IF labtable  . operation = OPERATION_DISPLAY THEN

            call_special_operation ( labtable           ,
                                     count              ,
                                     "READ_FOR_DISPLAY" )

            call_special_operation ( labtable  ,
                                     count     ,
                                     "DISPLAY" )

        ELSE

            call_special_operation ( labtable          ,
                                     count             ,
                                                 "READ_FOR_MODIFY" )

            call_special_operation ( labtable ,
                                     count    ,
                                     "MODIFY" )

        ENDIF

    ELSEIF edit_the_file THEN

        IF labtable  . operation = OPERATION_DISPLAY THEN

            text_file ( labtable , "DISPLAY"  )

        ELSE

            text_file ( labtable , "MODIFY"  )

        ENDIF

    ENDIF

ENDROUTINE


{*****************************************************************************}

    ROUTINE perform_special_operations (       labtable  ,
                         VALUE operation )

{
*
*
******************************************************************************}

    DECLARE count          ,
            returned_saved ,
            answer         ,
            size

    count = 2

    IF labtable . extension <> EMPTY THEN

        returned_saved = text_file ( labtable  , operation )

    ELSE

        returned_saved = FALSE

    ENDIF

    size = size_of_array ( labtable . special_actions )

    IF ( size < 2 ) OR
           ( labtable . special_actions [ 2 , 3 ] = EMPTY ) THEN

        IF ( size >= 1                                     ) AND
                   ( labtable . special_actions [ 1 , 3 ] <> EMPTY ) THEN

            answer = call_special_operation ( labtable  ,
                                                          1         ,
                                                          operation )

            IF answer <> EMPTY THEN

                IF answer THEN

                    returned_saved = TRUE

                ENDIF

            ENDIF

        ENDIF

    ELSE

        WHILE ( count <= size                                     ) AND
                      ( labtable . special_actions [ count , 3 ] <> EMPTY ) DO

            answer = call_special_operation ( labtable  ,
                                              count     ,
                                              operation )

            IF answer <> EMPTY THEN

                IF answer THEN

                    returned_saved = TRUE

                ENDIF

            ENDIF

            count = count + 1

        ENDWHILE

    ENDIF

    RETURN ( returned_saved )

ENDROUTINE

{*****************************************************************************}

    ROUTINE get_next_screen_option (       labtable  ,
                     VALUE operation )

{
*
*
******************************************************************************}

    DECLARE options        ,
            current_option ,
            count          ,
            local_key      ,
            edit_the_file  ,
            size

    ARRAY options ARRAY_SIZE ( 0 , 3 )

    options [ 1 , 1 ] = "*"
    options [ 1 , 2 ] = labtable . special_actions [ 1 , 2 ]
    options [ 1 , 3 ] = "$LABTABLIB_OPTIONS"

    count = 2

    size = size_of_array ( labtable . special_actions )

    WHILE ( count <= size                                     ) AND
          ( labtable . special_actions [ count , 1 ] <> EMPTY ) AND
          ( labtable . special_actions [ count , 2 ] <> EMPTY ) DO

        options [ count , 1 ] = labtable . special_actions [ count , 1 ]
        options [ count , 2 ] = labtable . special_actions [ count , 2 ]
        options [ count , 3 ] = count

        count = count + 1

    ENDWHILE

    IF count > 2 THEN

        REPEAT

            CHOOSE current_option OUTOF options AT 5 , 6

            local_key = lastkey

            IF local_key <> "EXIT" THEN

                call_special_operation ( labtable       ,
                                         current_option ,
                                         operation      )

            ENDIF

        UNTIL local_key = "EXIT"

    ELSE

        edit_the_file = labtable . extension <> EMPTY

        IF edit_the_file THEN

            text_file ( labtable , operation )

        ENDIF

    ENDIF

ENDROUTINE

{*****************************************************************************}

    ROUTINE decide_on_next_screen (       labtable  ,
                    VALUE operation )

{
*
*
******************************************************************************}

    DECLARE edit_the_file

    IF labtable . special_actions [ 2 , 1 ] <> EMPTY THEN

        get_next_screen_option ( labtable  ,
                                 operation )

    ELSE

        edit_the_file  = labtable . extension <> EMPTY

                IF ( size_of_array ( labtable . special_actions ) >= 1 ) AND
           ( labtable . special_actions [ 1 , 1 ] <> EMPTY     ) THEN

            call_special_operation ( labtable , 1 , operation )

        ELSEIF edit_the_file THEN

            text_file ( labtable , operation )

        ENDIF

    ENDIF

ENDROUTINE

{*****************************************************************************}

    ROUTINE text_file (       labtable  ,
                VALUE operation )

{
*
*
******************************************************************************}

    DECLARE file_name              ,
            temp_file_name         ,
            identity               ,
            status                 ,
            full_description_field

    identity = labtable . identity

    IF operation = "READ_FOR_MODIFY" THEN

        labtable . text_file_saved = FALSE
        labtable . text_file_copied = FALSE

    ELSEIF operation = "MODIFY" THEN

        edit_file ( labtable , TRUE , identity )

    ELSEIF operation = "DISPLAY" THEN

        edit_file ( labtable , FALSE , identity )

    ELSEIF operation = "SAVE" THEN

    IF labtable . text_file_copied THEN

        file_name = form_file_name ( labtable , identity )
        temp_file_name = form_temp_file_name ( labtable , identity )

        IF FILE EXISTS ( temp_file_name ) THEN

                GET_TABLE_DETAILS 'labtable . name_of_table' ,
                                  "FULL_DESCRIPTION"         ,
                                  full_description_field

                IF full_description_field = EMPTY THEN

                    FILE SEND temp_file_name , file_name

                ELSE

                    BLOB_FROM_FILE_TEXT ( labtable.name_of_table ,
                                          full_description_field ,
                                          temp_file_name         )

                ENDIF

                FILE DELETE temp_file_name , status

            ENDIF

        ENDIF

        RETURN ( labtable . text_file_saved )

    ELSEIF operation = "QUIT" THEN

        IF labtable . text_file_copied THEN

            temp_file_name = form_temp_file_name ( labtable ,
                                                   identity )

            IF FILE EXISTS ( temp_file_name ) THEN

                FILE DELETE temp_file_name , status

            ENDIF

        ENDIF

    ENDIF

ENDROUTINE

{*****************************************************************************}

    ROUTINE edit_file (       labtable ,
                VALUE do_edit  ,
                  identity )

{
* Edit or read description text files
*
******************************************************************************}

    DECLARE file_name              ,
            temp_file_name         ,
            full_description_field ,
            edit_allowed           ,
            disp_allowed           ,
            file_attributes        ,
            file_created           ,
            file_modified          ,
            file_high_size         ,
            file_low_size          ,
            file_read_only

    edit_allowed = FALSE
    disp_allowed = FALSE

    temp_file_name = form_temp_file_name ( labtable ,
                                           identity )

    file_name = form_file_name ( labtable ,
                                 identity )

    GET_TABLE_DETAILS 'labtable . name_of_table' ,
                      "FULL_DESCRIPTION"         ,
                      full_description_field

    IF do_edit THEN

        IF full_description_field = EMPTY THEN

            IF FILE EXISTS ( file_name ) THEN

                get_file_attributes ( file_name       ,
                                          file_attributes ,
                                          file_created    ,
                                          file_modified   ,
                                          file_high_size  ,
                                          file_low_size   )

                file_read_only = ( file_attributes MOD 2 = 1 )

                IF file_read_only THEN

                    temp_file_name = file_name
                    disp_allowed = TRUE

                ELSE

                    IF NOT ( labtable . text_file_copied ) THEN
                        FILE SEND file_name , temp_file_name
                    ENDIF

                    labtable . text_file_copied = TRUE
                    edit_allowed = TRUE

                ENDIF

            ELSE

                labtable . text_file_copied = TRUE
                edit_allowed = TRUE

            ENDIF

        ELSE

            BLOB_TO_FILE ( labtable . name_of_table ,
                           full_description_field   ,
                           temp_file_name           )

            edit_allowed = TRUE
            labtable . text_file_copied = TRUE

        ENDIF

    ELSE

        IF full_description_field = EMPTY THEN

            temp_file_name = file_name
            disp_allowed = TRUE

        ELSE

            BLOB_TO_FILE ( labtable . name_of_table ,
                           full_description_field   ,
                           temp_file_name           )

            labtable . text_file_copied = TRUE
            disp_allowed = TRUE

        ENDIF

    ENDIF

    IF edit_allowed THEN
    
        FILE SEND temp_file_name , "EDIT/"

        IF lastkey = "DO"  THEN

            labtable . text_file_saved = TRUE

        ENDIF

    ELSEIF disp_allowed THEN
    
        FILE SEND temp_file_name , "DISPLAY/"

    ENDIF

ENDROUTINE


{*****************************************************************************}

    ROUTINE show_final_mess ( VALUE mess_type , VALUE done_ok )

{
* Tell operator whether record has or hasn't been successfully created/updated
*
******************************************************************************}

    DECLARE message

    IF mess_type = "REMOVE" THEN

        IF done_ok THEN

            message = 2563

        ELSE

            message = 2562

        ENDIF

    ELSEIF mess_type = "RESTORE" THEN

        IF done_ok THEN

            message = 2561

        ELSE

            message = 2562

        ENDIF

    ENDIF

    IF GLOBAL ( "TERMTYPE" ) = "GUI" THEN
        window_set_status ( get message ( message, 1 ))
    ELSE
        output_message ( get message ( message , 1 ) )
    ENDIF

ENDROUTINE

{****************************************************************************}

    ROUTINE labtablib_find_record (       labtable ,
                    VALUE identity ,
                    VALUE do_lock  )

{
* Use the key0 array to select the record.
*
*****************************************************************************}

    DECLARE required_record ,
            select_array    ,
            count           ,
            field_size

    ARRAY select_array ARRAY_SIZE ( 0, 3 )
    count = 1

    WHILE ( count <= labtable . number_key0_fields ) DO

        get_field_details 'labtable . name_of_table'        .
                          'labtable . key0_fields [ count ]'  ,
                          "FIELD_SIZE"                        ,
                          field_size

        select_array [ count , 1 ] = ARRAY_SELECT_EQ
        select_array [ count , 2 ] = labtable . key0_fields [ count ]
        select_array [ count , 3 ] = SUBSTRING ( identity   ,
                                                 1          ,
                                                 field_size )

        identity = identity # select_array [ count , 3 ]
        count = count + 1

    ENDWHILE

    array_select ( labtable . name_of_table ,
                   do_lock                  ,
                   select_array             )

    required_record = ( SELECT 'labtable . name_of_table' .
                               'labtable . key0_fields [ 1 ]' =
                           select_array [ 1 , 3 ]             )

    RETURN ( required_record )

ENDROUTINE

{****************************************************************************}

    ROUTINE labtablib_build_find_array (       form              ,
                                         VALUE number_of_prompts ,
                                               select_array      )

{
* Build a select array for the Key0 fields
*
*****************************************************************************}

    DECLARE count        ,
            labtable

    labtable = form . user_info

    ARRAY select_array ARRAY_SIZE ( 0, 3 )
    count = labtable . first_id_prompt

    WHILE count <= number_of_prompts DO

        IF count > labtable . first_id_prompt THEN

            array_select_add ( select_array     ,
                               ARRAY_SELECT_AND ,
                               EMPTY            ,
                               EMPTY            )

        ENDIF

        array_select_add ( select_array                            ,
                           ARRAY_SELECT_EQ                         ,
                           labtable . key0_fields [ count ]        ,
                           form . prompt_objects [ count ] . value )

        count = count + 1

    ENDWHILE

ENDROUTINE

{****************************************************************************}

    ROUTINE labtablib_find_record_by_array (       form              ,
                         VALUE number_of_prompts ,
                         VALUE do_lock           )

{
* Build a select array for the Key0 fields and locate the record.
* Use the number of prompts specified.
*
*****************************************************************************}

    DECLARE select_array ,
            labtable

    labtable = form . user_info

    labtablib_build_find_array ( form, number_of_prompts, select_array )

    array_select ( labtable . name_of_table , do_lock , select_array )

    RETURN ( SELECT 'labtable . name_of_table' .
                        'labtable . key0_fields [ labtable . first_id_prompt ]' =
                 form . prompt_objects [labtable . first_id_prompt] . value )

ENDROUTINE

{****************************************************************************}

    ROUTINE labtablib_find_modifiable_record_by_array (       form              ,
                                                        VALUE number_of_prompts )

{
* Build a select array for the Key0 fields, add a modifiable flag
* and locate the record. Use the number of prompts specified.
*
*****************************************************************************}

    DECLARE select_array ,
            labtable     ,
            modifiable

    labtable = form . user_info

    labtablib_build_find_array ( form, number_of_prompts, select_array )

    array_select ( labtable . name_of_table , FALSE , select_array )

    modifiable = SELECT 'labtable . name_of_table' . 'labtable . modifiable_field'

    WHILE ( modifiable <> EMPTY ) AND ( modifiable = FALSE ) DO

        NEXT 'labtable . name_of_table'
        modifiable = SELECT 'labtable . name_of_table' . 'labtable . modifiable_field'

    ENDWHILE

    RETURN ( modifiable = TRUE )

ENDROUTINE

{****************************************************************************}

    ROUTINE labtablib_highest_version ( curr_prompt, labtable , form )

{
* Find the highest currently used version.
*
*****************************************************************************}

    DECLARE select_array   ,
            count          ,
            version_number

    ARRAY select_array ARRAY_SIZE ( 0, 3 )

    IF curr_prompt <> EMPTY THEN

        IF size_of_array ( curr_prompt . mandatory_array ) > 0 THEN

            array_copy ( select_array, curr_prompt . mandatory_array )

            array_insert_slice ( select_array, 1, 1 )

            select_array [ 1, 1 ] = ARRAY_SELECT_PUSH
            select_array [ 1, 2 ] = EMPTY
            select_array [ 1, 3 ] = EMPTY

            array_select_add ( select_array     ,
                       ARRAY_SELECT_POP ,
                       EMPTY            ,
                       EMPTY            )
            array_select_add ( select_array     ,
                       ARRAY_SELECT_AND ,
                       EMPTY            ,
                       EMPTY            )

        ENDIF

    ENDIF

    count = 1

    WHILE labtable . key0_fields [ count ] <> labtable . version_field DO

        IF count > 1 THEN

            array_select_add ( select_array     ,
                               ARRAY_SELECT_AND ,
                               EMPTY            ,
                               EMPTY            )

        ENDIF

        array_select_add ( select_array                            ,
                           ARRAY_SELECT_EQ                         ,
                           labtable . key0_fields [ count ]        ,
                           form . prompt_objects [ count ] . value )

        count = count + 1

    ENDWHILE

    IF ( labtable . operation <> OPERATION_NEW_VERSION ) AND
       ( labtable . remove_field <> EMPTY              ) THEN

        array_select_add ( select_array            ,
                           ARRAY_SELECT_EQ         ,
                           labtable . remove_field ,
                           FALSE                   )

    ENDIF

    version_number = array_select_max ( labtable . name_of_table ,
                                        labtable . version_field ,
                                        select_array             )

    IF version_number = EMPTY THEN

        version_number = "0"

    ENDIF

    RETURN ( version_number )

ENDROUTINE

{****************************************************************************}

    ROUTINE pad_identity_messages (       prompt_details ,
                          pad_size       ,
                    VALUE prompt_size    )

{
*
*
*****************************************************************************}

    DECLARE count

    count = 1

    WHILE count <= prompt_size DO

        pad_message ( prompt_details [ count ] , pad_size )

        count = count + 1

    ENDWHILE

ENDROUTINE

{****************************************************************************}

    ROUTINE pad_prompt_messages (       prompt_details ,
                        pad_size       ,
                      VALUE prompt_size    )

{
*
*
*****************************************************************************}

    DECLARE count

    count = 1

    WHILE count <= prompt_size DO

        pad_message ( prompt_details [ count , MESSAGE_POSITION ] ,
                      pad_size                                    )

    count = count + 1

    ENDWHILE

ENDROUTINE

{****************************************************************************}

    ROUTINE pad_message ( message , pad_size )

{
*
*
*****************************************************************************}

    IF GLOBAL ( "TERMTYPE" ) <> "GUI" THEN

        message = PAD ( message , " " , pad_size ) : ":"

    ELSE

        message = PAD ( message , " " , pad_size )

    ENDIF

ENDROUTINE

{****************************************************************************}

    ROUTINE form_name_with_version (       labtable    ,
                     VALUE actual_file )

{
*
*
*****************************************************************************}

    DECLARE count          ,
            field_size     ,
            file_name      ,
            version_number

    version_number = "1"
    count = 1
    file_name = ""

    REPEAT

        get_field_details 'labtable . name_of_table' .
                          'labtable . key0_fields [ count ]' ,
                   "FIELD_SIZE"                      ,
                           field_size

        IF labtable . key0_fields [ count ] =
            labtable . version_field THEN

            version_number = SUBSTRING ( actual_file ,
                                         1           ,
                                         field_size  )

        ELSE

            file_name = file_name : STRIP ( SUBSTRING ( actual_file ,
                                                        1           ,
                                                        field_size  ) )

        ENDIF

        actual_file = SUBSTRING ( actual_file                         ,
                                  field_size + 1                      ,
                                  LENGTH ( actual_file ) - field_size )

        count = count + 1

    UNTIL ( count > labtable . number_key0_fields ) OR ( actual_file = "" )

    IF NUMERIC ( version_number ) > 1 THEN

        file_name = file_name : "_v" :
                    RIGHTSTRING ( "0000000000" : STRIP ( version_number ) , 10 )

    ENDIF

    RETURN ( file_name )

ENDROUTINE

{****************************************************************************}

    ROUTINE form_file_name (       labtable    ,
                 VALUE actual_file )

{
*
*
*****************************************************************************}

    RETURN ( TOLOWER ( STRIP ( labtable . directory ) : ":" :
             form_name_with_version ( labtable, actual_file ) : "." :
             STRIP ( labtable . extension ) ) )

ENDROUTINE

{****************************************************************************}

    GLOBAL

    ROUTINE form_temp_file_name (       labtable    ,
                      VALUE actual_file )

{
*
*
*****************************************************************************}

    RETURN ( TOLOWER ( "SMP$TEXTREPORTS:" :
         form_name_with_version ( labtable, actual_file ) : "." :
             STRIP ( labtable . extension ) ) )

ENDROUTINE

{****************************************************************************}

    ROUTINE output_list_header ( labtable )

{
*
*
*****************************************************************************}

    DECLARE message1   ,
            message2   ,
            message3   ,
            message4   ,
            pad_length

    message1 = get_user_message ( "LTE_PRINT_LIST_HEAD" , 1 )
    message1 = expand_message ( message1 , labtable . user_name_of_table )

    message2   = get_user_message ( "LTE_PRINT_HEAD_END" , 1 )
    pad_length = 78 - LENGTH ( message1 ) - LENGTH ( message2 )
    message2   = message1 : PAD( " " , " " , pad_length ) : message2

    message3 = get_user_message ( "LTE_PRINT_GEN_BY" , 1 ) : OPERATOR

    message4 = get_user_message ( "LTE_PRINT_GEN_ON" , 1 ) : NOW

    SET HEADER message2

LITERAL

$message3_______________________________________________________________________
$message4_______________________________________________________________________
$ENDLITERAL

ENDROUTINE

{****************************************************************************}

    ROUTINE output_record_id ( labtable )

{
*
*
*****************************************************************************}

    DECLARE count        ,
            message      ,
            message_size

    message_size = 0

    IF labtable . modified_on <> EMPTY THEN

        message_size = LENGTH ( labtable . messages [ MOD_ON_MESSAGE ] )

    ENDIF

    IF labtable . modified_by <> EMPTY THEN

        message_size = find_max_number (
                          message_size                                    ,
                          LENGTH ( labtable . messages [ MOD_BY_MESSAGE ] ) )

    ENDIF

    count = 1

    REPEAT

        message_size = find_max_number (
                          message_size                         ,
                          LENGTH ( labtable . messages [count] ) )

        count = count + 1

    UNTIL count > labtable . number_key0_fields

    IF labtable . has_approval THEN

        message_size = find_max_number (
                          message_size                                      ,
                          LENGTH ( labtable . messages [ APPROVAL_MESSAGE ] ) )

    ENDIF

{ Blank line }
LITERAL

$ENDLITERAL

    count = 1

    REPEAT

        message = PAD ( labtable . messages [ count ] ,
                        " "                           ,
                        message_size                  ) :
                  " : "                                 :
                  STRIP ( SELECT 'labtable . name_of_table' .
                                 'labtable . key0_fields [ count ]' )

LITERAL
$message_______________________________________________________________________
$ENDLITERAL

        count = count + 1

    UNTIL count > labtable . number_key0_fields

    IF labtable . has_approval THEN

                FORMAT message
               FROM SELECT 'labtable . name_of_table' .
                           'labtable . approval_field'
               USING 'labtable . name_of_table' .
                     'labtable . approval_field'

        message = PAD ( labtable . messages [ APPROVAL_MESSAGE ] ,
                        " "                                      ,
                        message_size                             ) :
                  " : "                                  :
                  message

LITERAL
$message_______________________________________________________________________
$ENDLITERAL

    ENDIF

    IF labtable . modified_on <> EMPTY THEN

        message = PAD ( labtable . messages [ MOD_ON_MESSAGE ] ,
                        " "                                    ,
                        message_size                           ) :
                  " : "                                  :
                  STRIP ( SELECT 'labtable . name_of_table' .
                                 'labtable . modified_on'   )

LITERAL
$message_______________________________________________________________________
$ENDLITERAL

    ENDIF

    IF labtable . modified_by <> EMPTY THEN

        message = PAD ( labtable . messages [ MOD_BY_MESSAGE ] ,
                        " "                                    ,
                        message_size                           ) :
                  " : "                                  :
                  STRIP ( SELECT 'labtable . name_of_table' .
                                 'labtable . modified_by'   )

LITERAL
$message_______________________________________________________________________
$ENDLITERAL

    ENDIF

{ Blank line }
LITERAL

$ENDLITERAL

ENDROUTINE

{****************************************************************************}

    ROUTINE output_correct_prompt_sizes ( labtable         ,
                          fields_to_output )

{
*
*
*****************************************************************************}

    DECLARE count          ,
            message_length

    message_length = 0
    count = 1

    WHILE fields_to_output [ count ] <> EMPTY DO

        IF ( labtable                                      .
             prompt_details [ fields_to_output [ count ] ,
                              TYPE_POSITION              ] = "FORMAT" ) THEN

            message_length = find_max_number (
                                    LENGTH ( labtable .
                                         prompt_details [ fields_to_output [ count ] ,
                                                              MESSAGE_POSITION           ] ) ,
                                message_length                                           )

        ENDIF

        count = count + 1

    ENDWHILE

    count = 1

    WHILE fields_to_output [ count ] <> empty DO

        IF ( labtable                                      .
             prompt_details [ fields_to_output [ count ] ,
                              TYPE_POSITION              ] = "FORMAT" ) THEN

            labtable .
            prompt_details [ fields_to_output [ count ] ,
                             MESSAGE_POSITION           ] =
               PAD ( labtable                                      .
                     prompt_details [ fields_to_output [ count ] ,
                                      MESSAGE_POSITION           ] ,
                     " "                                           ,
                     message_length                                )

        ENDIF

    count = count + 1

    ENDWHILE

ENDROUTINE

{****************************************************************************}

    ROUTINE output_list_entry ( labtable         ,
                    data_input       ,
                    fields_to_output )

{
*
*
*****************************************************************************}

    DECLARE count        ,
            temp_message ,
            message

    output_record_id ( labtable )
    count = 1

    WHILE fields_to_output [ count ] <> EMPTY DO

        IF ( labtable . prompt_details [ fields_to_output [ count ] ,
                                         TYPE_POSITION ] = "FORMAT" ) THEN

            FORMAT temp_message
              FROM data_input [ fields_to_output [ count ]]
             USING 'labtable . name_of_table' .
                   'labtable . prompt_details [ fields_to_output [ count ] ,
                   FIELD_NAME_POSITION ]'

            message = labtable . prompt_details [ fields_to_output [ count ] ,
                                             MESSAGE_POSITION ] : " : " : temp_message

LITERAL
$message________________________________________________________________________
$ENDLITERAL

    ENDIF

    count = count + 1

    ENDWHILE

LITERAL

                 --------------------------------
$ENDLITERAL

ENDROUTINE

{****************************************************************************}

    ROUTINE output_print_details ( ident      ,
                       data_input ,
                       labtable   )

{
*
*
*****************************************************************************}

    DECLARE message1               ,
            message2               ,
            message3               ,
            message4               ,
            pad_length             ,
            count                  ,
            file_text              ,
            full_description_field ,
            status                 ,
            file_name              ,
            temp_line              ,
            remaining_line         ,
            message_length         ,
            message

    message1 = get_user_message ( "LTE_PRINT_PRINT_HEAD" , 1 )
    message1 = expand_message ( message1 , labtable . user_name_of_table )

    message2   = get_user_message ( "LTE_PRINT_HEAD_END" , 1 )
    pad_length = 78 - LENGTH ( message1 ) - LENGTH ( message2 )
    message2   = message1 : PAD ( " " , " " , pad_length ) : message2

    message3 = get_user_message ( "LTE_PRINT_GEN_BY" , 1 ) : OPERATOR

    message4 = get_user_message ( "LTE_PRINT_GEN_ON" , 1 ) : NOW

    SET HEADER message2

LITERAL

$message3_______________________________________________________________________
$message4_______________________________________________________________________
$ENDLITERAL

    output_record_id ( labtable )

    message_length = 0

    count = 1

    WHILE labtable . prompt_details [ count , FIELD_NAME_POSITION ] <> EMPTY DO

        message_length = find_max_number ( message_length                                 ,
                                           LENGTH ( labtable .
                                                    prompt_details [ count              ,
                                                                     MESSAGE_POSITION ] ) )

        count = count + 1

    ENDWHILE

    count = 1

    WHILE labtable . prompt_details [ count , FIELD_NAME_POSITION ] <> EMPTY DO

        remaining_line = data_input [ count ]

        IF labtable . prompt_details [ count , TYPE_POSITION ] = "ROUTINE" THEN

            remaining_line = " "

        ELSE

            FORMAT remaining_line
              FROM remaining_line
             USING 'labtable . name_of_table' .
                   'labtable . prompt_details [ count , FIELD_NAME_POSITION ]'

        ENDIF

        temp_line = splitwords ( remaining_line , 75 - message_length )
        remaining_line = remaining_line # temp_line

        message = PAD ( labtable . prompt_details [ count, MESSAGE_POSITION ] ,
                        " "                                                   ,
                        message_length                                        ) :
                  " : " : temp_line

LITERAL
$message________________________________________________________________________
$ENDLITERAL

        WHILE NOT blank ( remaining_line ) DO

            temp_line = splitwords ( remaining_line , 75 - message_length )

            remaining_line = remaining_line # temp_line
            message = PAD ( " " , " " , message_length + 3 ) : STRIP ( temp_line )

LITERAL
$message________________________________________________________________________
$ENDLITERAL

        ENDWHILE

        count = count + 1

    ENDWHILE

LITERAL

$ENDLITERAL

    GET_TABLE_DETAILS 'labtable . name_of_table' ,
                      "FULL_DESCRIPTION"         ,
                      full_description_field

    IF ( labtable . extension <> EMPTY   ) OR
       ( full_description_field <> EMPTY ) THEN

        IF full_description_field = EMPTY THEN

            file_name = form_file_name ( labtable , ident )

        ELSE

            file_name = form_temp_file_name ( labtable , ident )

            IF SELECT 'labtable . name_of_table' . 'full_description_field' <> 0 THEN

                BLOB_TO_FILE ( labtable . name_of_table ,
                               full_description_field   ,
                               file_name                )

            ENDIF

        ENDIF

        FILE OPEN file_name , status

        IF status <> EMPTY THEN

            message1 = get message ( 267 , 1 )

LITERAL
$message1______________________________________________________________________
$ENDLITERAL

        ELSE

            message1 = get message ( 266 , 1 )
            message2 = get message ( 266 , 2 )

LITERAL

$message1_______________________________________________________________________
$message2_______________________________________________________________________

$ENDLITERAL

            FILE READ file_name , file_text , status

            WHILE status = empty DO

LITERAL
$file_text______________________________________________________________________
$ENDLITERAL

                FILE READ file_name , file_text , status

            ENDWHILE

            IF full_description_field <> EMPTY THEN

                { If used a temp file, delete it }
                FILE DELETE file_name

            ENDIF

        ENDIF

    ENDIF

ENDROUTINE


{****************************************************************************}

    ROUTINE select_record ( VALUE the_table_name ,
                VALUE unique_key     ,
                      first_key      )

{
*
*
*****************************************************************************}

    DECLARE key0_fields  ,
            count        ,
            field_size   ,
            select_array ,
            order_field

    ARRAY select_array ARRAY_SIZE ( 0 , 3 )

    GET_TABLE_DETAILS 'the_table_name' , "KEY0_FIELD" , key0_fields

    count = 1

    WHILE ( key0_fields [ count ] <> EMPTY ) AND
          ( STRIP ( unique_key ) <> " "    ) DO

        GET_FIELD_DETAILS 'the_table_name' . 'key0_fields [ count ]' ,
                          "FIELD_SIZE"                               ,
                              field_size

        select_array [ count , 1 ] = 1 { Array select equals }
        select_array [ count , 2 ] = key0_fields [ count ]
        select_array [ count , 3 ] = SUBSTRING ( unique_key , 1 , field_size )

        unique_key = unique_key # select_array [ count , 3 ]

        count = count + 1

    ENDWHILE

        GET_TABLE_DETAILS 'the_table_name' , "ORDER_FIELD" , order_field

    IF ( order_field <> EMPTY ) THEN

        select_array [ count , 1 ] = 14 { Array select order }
                select_array [ count , 2 ] = order_field
                select_array [ count , 3 ] = 17 { Array select ascending }

        count = count + 1

    ENDIF

    array_select ( the_table_name , FALSE , select_array )

    first_key = key0_fields [ 1 ]

    RETURN ( SELECT 'the_table_name' . 'first_key' )

ENDROUTINE

{****************************************************************************}

    ROUTINE print_line ( the_table_name ,
                 field_details  ,
                 page_size      ,
                 text_width     )
{
*
*
*****************************************************************************}

    DECLARE count ,
            text_line ,
            info

        count = 1
        text_line = " "

LITERAL

$ENDLITERAL

        TEST PAGE page_size

    WHILE field_details [ count , 1 ] <> EMPTY DO

        FORMAT info
          FROM SELECT 'the_table_name' . 'field_details [ count , 1 ]'
                        USING 'the_table_name' . 'field_details [ count , 1 ]'

        text_line = PAD ( field_details [ count , 2 ] ,
                          " "                         ,
                                  text_width                  ) : " : " : info

LITERAL
$text_line______________________________________________________________________
$ENDLITERAL

        count = count + 1

    ENDWHILE

LITERAL

$ENDLITERAL

ENDROUTINE

{****************************************************************************}

    GLOBAL

    ROUTINE print_fields ( VALUE the_table_name ,
                   VALUE unique_key     ,
                   VALUE the_header     ,
                   VALUE the_footer     ,
                   VALUE page_size      ,
                   VALUE test_width     ,
                     field_details  )

{
*
*
*****************************************************************************}

    DECLARE first_key  ,
        next_entry

    SET HEADER the_header
    SET FOOTER the_footer

    next_entry = select_record ( the_table_name ,
                                 unique_key     ,
                                 first_key      )

    WHILE next_entry <> EMPTY DO

        print_line ( the_table_name ,
                     field_details  ,
                     page_size      ,
                     test_width     )

        NEXT 'the_table_name'

        next_entry = SELECT 'the_table_name' . 'first_key'

    ENDWHILE

ENDROUTINE

{****************************************************************************}

ROUTINE labtable_migrate ( labtable, VALUE header_mess, fields_to_output )

{ Migrate Laboratory Table Information.
*
* Parameters : labtable      - Laboratory Table Object
*              Header Mess   - Header Message
*              FieldsToOuput - List Fields
* Returns    : N/a
*
*****************************************************************************}

    DECLARE lib, rout

    lib  = "$LABTABLE_DB"
    rout = "LABTABLE_DB_MIGRATE"
    
    IF VGL_VALIDATE_ROUTINE ( lib, rout ) THEN

        CALLROUTINE     rout
            IN LIBRARY  lib
            USING       labtable, header_mess, fields_to_output

    ENDIF

ENDROUTINE


{****************************************************************************}

ROUTINE labtablib_do_name_field ( labtable )

{ 
* Set the Name field - which is the Primary Browse if not part of the key. 
*
*****************************************************************************}

    DECLARE name_is_key

    GET_TABLE_DETAILS 'labtable . name_of_table',
                      "BROWSE_FIELD", labtable . name_field

    IF ( labtable . name_field <> EMPTY )

        GET_FIELD_DETAILS 'labtable . name_of_table' . 'labtable . name_field',
                          "KEY0_FIELD", name_is_key
            
        IF ( name_is_key )

            labtable . name_field = EMPTY

        ENDIF

    ENDIF        

    IF labtable . name_field <> EMPTY THEN
        labtablib_add_name_field ( labtable )
    ENDIF

ENDROUTINE

{****************************************************************************}

ROUTINE labtablib_add_name_field ( labtable )

{ 
* Add the name field if necessary
*
*****************************************************************************}

    DECLARE name_found, count, field_name, prompts, size, name_text
    
    prompts = labtable . prompt_details
    name_found = FALSE
    size = SIZE_OF_ARRAY ( prompts )
    count = 1

    WHILE ( count <= size ) AND ( NOT name_found ) DO

        field_name = prompts [ count, FIELD_NAME_POSITION ]

        IF ( field_name = labtable . name_field )

            name_found = TRUE 
            
        ENDIF

        count = count + 1

    ENDWHILE

    IF ( NOT name_found )

        array_insert_slice ( prompts, 1, 1 )

        name_text = GET_USER_MESSAGE ( "LABTABLIB_NAME", 1 )

        prompts [ 1, TYPE_POSITION ]       = "FORMAT"
        prompts [ 1, TABLE_NAME_POSITION ] = labtable . name_of_table
        prompts [ 1, MESSAGE_POSITION    ] = name_text
        prompts [ 1, FIELD_NAME_POSITION ] = labtable . name_field

    ENDIF

ENDROUTINE

{******************************************************************************}

ROUTINE escape_single_quote ( VALUE st_val )

{
*       Given a text string, double up all occurrences of the ' character
*   e.g. the string  : a'bc'd 
*            becomes : a''bc''d
*
*******************************************************************************}

    DECLARE copy , part , result , delim_idx

    copy = st_val

    result = ""

    delim_idx = INDEX ( copy , ascii(39) )

    WHILE ( delim_idx > 0 ) DO

        part = LEFTSTRING ( copy , delim_idx )

        result = result : part : ascii(39)

        copy = copy # part

        delim_idx = INDEX ( copy , ascii(39) )

    ENDWHILE

    result = result : copy

    RETURN ( result )

ENDROUTINE

{****************************************************************************}

ROUTINE labtablib_do_name_validation ( labtable )

{ 
* Validate the name field
*
*****************************************************************************}

    DECLARE valid, name, id, context, dynamic_sql

    valid = TRUE

    IF ( labtable . name_field <> EMPTY )

        name = SELECT 'labtable . name_of_table' . 'labtable . name_field'

        IF ( ( name = EMPTY ) OR ( name = "" ) )

            flash_message ( "LABTABLIB_BLANK_NAME", TRUE )
            valid = FALSE
        
        ENDIF

        IF valid THEN

            name = escape_single_quote ( name )

            id = SELECT 'labtable . name_of_table' . 'labtable . key0_fields [1]'

            push_file_descriptor ( labtable . name_of_table, context )

            CREATE OBJECT "STD_DYNAMIC_SQL" , dynamic_sql

            dynamic_sql . add_to_sql_statement ( "select 1 from [")
            dynamic_sql . add_to_sql_statement ( STRIP ( labtable . name_of_table ))
            dynamic_sql . add_to_sql_statement ( "] where [")
            dynamic_sql . add_to_sql_statement ( STRIP ( labtable . key0_fields [1] ))
            dynamic_sql . add_to_sql_statement ( "] <> '" )
            dynamic_sql . add_to_sql_statement ( STRIP ( id ))
            dynamic_sql . add_to_sql_statement ( "' and  (upper([" )
            dynamic_sql . add_to_sql_statement ( STRIP ( labtable . name_field ))
            dynamic_sql . add_to_sql_statement ( "]) = '" )
            dynamic_sql . add_to_sql_statement ( STRIP ( TOUPPER ( name )))
            dynamic_sql . add_to_sql_statement ( "' or [" )
            dynamic_sql . add_to_sql_statement ( STRIP ( labtable . key0_fields [1] ))
            dynamic_sql . add_to_sql_statement ( "] = '" )
            dynamic_sql . add_to_sql_statement ( STRIP ( TOUPPER ( name )))
            dynamic_sql . add_to_sql_statement ( "')" )

            dynamic_sql . add_select_integer ()

            dynamic_sql . execute ()

            IF dynamic_sql . select ( 1 ) = 1 THEN

                flash_message ( "LABTABLIB_DUPLICATE_NAME", TRUE )
                valid = FALSE
    
            ENDIF

            pop_file_descriptor ( context )

        ENDIF

    ENDIF

    RETURN ( valid )

ENDROUTINE

{****************************************************************************}
{****************************************************************************}
{****************************************************************************}

ROUTINE CheckExternalVersion
{*************************************************************************
* Purpose      : Writes to predefined log,
*                using WriteLog in $lib_utils
* Parameters   : Msg - what to write in log
* Return Value : N/A
**************************************************************************}
    DECLARE context
    DECLARE ext, mlp, ver, code, cert, type, c_ext
    ext   = FALSE
    mlp   = SELECT mlp_header.identity
    code  = SELECT mlp_header.product_code
    cert  = SELECT mlp_header.sap_cert
    type  = SELECT mlp_header.cert_type
    ver   = SELECT mlp_header.product_version
    c_ext = SELECT COUNT MLP_CHANGE_VIEW
            WHERE product_id = mlp 
              AND product_version = ver
              AND level_id = "EXTERNAL"

    IF (INDEX(cert, "NONE") = 0) OR (INDEX(type, "NONE") = 0) THEN
        push_file_descriptor ("MLP_HEADER", context)
            DECLARE  conf_text, p
            conf_text = ""
            IF code <> (SELECT mlp_header.product_code WHERE identity = mlp AND product_version = ver - 1) THEN
                conf_text = conf_text:"Product Code, "
            ENDIF

            IF cert <> (SELECT mlp_header.sap_cert) THEN
                conf_text = conf_text:"Certificate Type, "
            ENDIF

            IF type <> (SELECT mlp_header.cert_type) THEN
                conf_text = conf_text:"Certificate Template, "
            ENDIF

            IF c_ext > 0 THEN
                conf_text = conf_text:"External Specifications, "
            ENDIF

            conf_text = LEFTSTRING(conf_text, LENGTH(conf_text) - 2)

            p = LENGTH(conf_text)
            WHILE p > 0
                IF SUBSTRING(conf_text, p, 1) = "," THEN
                    conf_text = STRIP(LEFTSTRING(conf_text, p - 1):" and":SUBSTRING(conf_text, p + 1, LENGTH(conf_text)))
                    p = 0
                ENDIF
                p = p - 1
            ENDWHILE

    {**************************************************************************************************************
            fm("INDEX(cert, 'NONE'): ":INDEX(cert, "NONE"):ASCII(10):
               "INDEX(type, 'NONE'): ":INDEX(type, "NONE"):ASCII(10):
               "Prod Code: ":code:" <> ":(SELECT mlp_header.product_code WHERE identity = mlp AND product_version = ver - 1):"?":ASCII(10):
               "SAP Cert:  ":cert:" <> ":(SELECT mlp_header.sap_cert WHERE identity = mlp AND product_version = ver - 1):"?":ASCII(10):
               "Cert Type: ":type:" <> ":(SELECT mlp_header.cert_type WHERE identity = mlp AND product_version = ver - 1):"?":ASCII(10):
               "c_ext: ":c_ext) 
    ***************************************************************************************************************}

            IF (INDEX(cert, "NONE") = 0) AND 
               (INDEX(type, "NONE") = 0) AND
               ((code <> SELECT mlp_header.product_code WHERE identity = mlp AND product_version = ver - 1) OR
                (cert <> SELECT mlp_header.sap_cert) OR
                (type <> SELECT mlp_header.cert_type)) THEN
                ext = TRUE
            ENDIF 

            IF (0 < c_ext) THEN
                ext = TRUE
            ENDIF
        pop_file_descriptor(context)
        IF (ext <> SELECT mlp_header.external_version) THEN
            IF ext THEN
                ext = confirm_with_text(conf_text:ASCII(10):
                                        "has been changed from previous version.":ASCII(10):ASCII(10):
                                        "Set external version to 'Yes'?")
            ELSE
                ext = NOT(confirm_with_text("Product Code, Certificate Type/Template or External Specification":ASCII(10):
                                            "has NOT been changed from previous version.":ASCII(10):ASCII(10):
                                            "Set external version to 'No'?"))
            ENDIF
        ENDIF
    ELSEIF (ext <> SELECT mlp_header.external_version) THEN
        ext = NOT(confirm_with_text("No valid Certificate Type/Template has been defined":ASCII(10):ASCII(10):
                                    "Set external version to 'No'?"))    
    ENDIF

    ASSIGN  mlp_header.external_version = ext

ENDROUTINE

{****************************************************************************}
{****************************************************************************}
{****************************************************************************}

ROUTINE WriteToLog(VALUE Msg)
{*************************************************************************
* Purpose      : Writes to predefined log,
*                using WriteLog in $lib_utils
* Parameters   : Msg - what to write in log
* Return Value : N/A
**************************************************************************}

    WriteLog(Msg, global("current_library"))

ENDROUTINE

