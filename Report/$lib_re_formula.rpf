{******************************************************************************
*
*   Routines to parse and calculate formulas
*
*
{*****************************************************************************}

SET COMPILE_OPTION DECLARE
ENABLE WINDOWS
SET NAME "DISPLAY/"
SET NOTPROTECTED

JOIN STANDARD_LIBRARY STD_ARRAY
JOIN STANDARD_LIBRARY STD_GENERAL
JOIN STANDARD_LIBRARY STD_CLASS
JOIN STANDARD_LIBRARY STD_DATABASE
JOIN STANDARD_LIBRARY STD_STRUCTURE
JOIN STANDARD_LIBRARY STD_MESSAGE
JOIN STANDARD_LIBRARY STD_VGL
JOIN STANDARD_LIBRARY STD_PROMPT
JOIN STANDARD_LIBRARY STD_GLOBAL
JOIN STANDARD_LIBRARY STD_USER_GLOBAL

JOIN LIBRARY $FORMULA_SCRIPT
JOIN LIBRARY $LIB_UTILS
JOIN LIBRARY $LIB_COMP
JOIN LIBRARY $LIB_UNIT
JOIN LIBRARY $STD_VERS
JOIN LIBRARY $STAND_USER

GLOBAL CONSTANT FORMULA_LT = 1
GLOBAL CONSTANT FORMULA_LE = 2
GLOBAL CONSTANT FORMULA_EQ = 3
GLOBAL CONSTANT FORMULA_GE = 4
GLOBAL CONSTANT FORMULA_GT = 5


GLOBAL CONSTANT FORMULA_NULL          = 0
GLOBAL CONSTANT FORMULA_NUMBER        = 1
GLOBAL CONSTANT FORMULA_PLUS          = "+"
GLOBAL CONSTANT FORMULA_MINUS         = "-"
GLOBAL CONSTANT FORMULA_MULTIPLY      = "*"
GLOBAL CONSTANT FORMULA_DIVIDE        = "/"
GLOBAL CONSTANT FORMULA_OPEN_PAREN    = "("
GLOBAL CONSTANT FORMULA_CLOSE_PAREN   = ")"
GLOBAL CONSTANT FORMULA_OPEN_BRACKET  = "["
GLOBAL CONSTANT FORMULA_CLOSE_BRACKET = "]"
GLOBAL CONSTANT FORMULA_POWER         = "^"
GLOBAL CONSTANT FORMULA_NEGATE        = "--"
GLOBAL CONSTANT FORMULA_FUNCTION      = 2
GLOBAL CONSTANT FORMULA_TEXT          = 3
GLOBAL CONSTANT FORMULA_QUOTE         = 4
GLOBAL CONSTANT FORMULA_COMPARISON    = 5


GLOBAL CONSTANT FORMULA_COMP_EQUAL            = 1
GLOBAL CONSTANT FORMULA_COMP_NOT_EQUAL        = 2
GLOBAL CONSTANT FORMULA_COMP_LESS             = 3
GLOBAL CONSTANT FORMULA_COMP_LESS_OR_EQUAL    = 4
GLOBAL CONSTANT FORMULA_COMP_GREATER          = 5
GLOBAL CONSTANT FORMULA_COMP_GREATER_OR_EQUAL = 6


GLOBAL CONSTANT STD_FORMULA_PARSE            = "STD_FORMULA_PARSE"
GLOBAL CONSTANT STD_FORMULA_EXPRESSION       = "STD_FORMULA_EXPRESSION"
GLOBAL CONSTANT STD_FORMULA_EXPRESSION_BATCH = "STD_FORMULA_EXPRESSION_BATCH"
GLOBAL CONSTANT STD_FORMULA_CONTEXT          = "STD_FORMULA_CONTEXT"
GLOBAL CONSTANT STD_FORMULA_FUNCTION         = "STD_FORMULA_FUNCTION"
GLOBAL CONSTANT STD_FORMULA_VALIDATE         = "STD_FORMULA_VALIDATE"
GLOBAL CONSTANT STD_FORMULA_TRANSITION       = "STD_FORMULA_TRANSITION"


GLOBAL CONSTANT FORMULA_MODE_CALCULATE   = 1
GLOBAL CONSTANT FORMULA_MODE_BIND        = 2
GLOBAL CONSTANT FORMULA_MODE_VALIDATE    = 3
GLOBAL CONSTANT FORMULA_MODE_PRINT       = 4
GLOBAL CONSTANT FORMULA_MODE_TEST_PHASE1 = 5

GLOBAL CONSTANT FORMULA_PRINT_FILENAME = "smp$userfiles:formula_print"


CONSTANT LIB_RE_FORMULA_ALLOW_TEXT = TRUE

DECLARE  EXPRESSION_NULL               ,
     formula_inequalities          ,
     formula_inequalities_1        ,
     formula_inequality_as_text


{*******************************************************************************}

GLOBAL ROUTINE lib_re_formula_initialise

{
*
*
*******************************************************************************}

    lib_comp_initialise ()
    formula_script_initialise ()

    lib_formula_define_class ()

    lib_formula_define_inequalities ()
    
    CALL_ROUTINE "batch_formula_initialise"
    IN LIBRARY "$BATCH_FORMULA"

ENDROUTINE

{*******************************************************************************}

ROUTINE lib_formula_define_class

{
*
*
*******************************************************************************}

    EXPRESSION_NULL = EMPTY

    DEFINE CLASS STD_FORMULA_PARSE

        PROPERTIES "FORMULA"             ,
               "CURRENT_CHAR"        ,
                           "END_OF_LINE"         ,
               "POSITION"            ,  
               "ERROR_TEXT"          ,
               "ERROR_POSITION" 

        INITIALISATION

    END CLASS

    DEFINE CLASS STD_FORMULA_EXPRESSION

        PROPERTIES "LEFT"                  ,
               "RIGHT"                 ,
               "FUNCTION"              ,
               "OPERAND"               ,
               "PARAMETERS"            ,
               "TEXT"                  ,
               "VALUE"                 ,
               "INEQUALITY"            ,
               "UNITS"             ,
               "context"               ,
               "params_called"         ,
               "parameter_count_check" ,
               "transition_object"     ,
               "parent_expression"     ,
               "replicates_added"      ,
               "use_replicates"        ,
                   "is_a_parameter"


        ACTIONS    "flag_function_error"              ,
                   "flag_function_error_with_message" ,
                   "flag_function_error_param"        ,
                   "get_parameter_text"               ,
                   "get_parameter_numeric"            ,
                   "get_parameter_bool"               ,
                   "get_parameter_result_set"         ,
                   "get_parameter"                    ,
                   "get_no_of_params"                 ,
                   "get_no_of_params_called"          ,
                   "attach_context"                   ,
                   "return_value"                     ,
                   "return_text"                      ,
                   "return_units"                     ,
                   "return_inequality"                , 
                   "get_parameter_inequality"         ,
                   "get_parameter_units"              ,
                   "set_parameter_count_check_off"    ,
                   "zero_params_called"               ,
                   "attach_transition_object"         ,
                   "remove_parent_expressions"        ,
                   "global_parricide"

                   
        INITIALISATION
                   

    END CLASS

    DEFINE CLASS STD_FORMULA_EXPRESSION_BATCH
    
        INHERIT STD_FORMULA_EXPRESSION
        

        PROPERTIES "is_batch"

        INITIALISATION
        
    END CLASS

    DEFINE CLASS STD_FORMULA_CONTEXT

        PROPERTIES "TEST_NUMBER"    ,
               "RESULT_CONTEXT" ,   
               "RESULT_OBJECT"  ,
               "MODE"           ,   
               "ERROR"      ,
               "ERROR_MESSAGE"  ,
               "READ_SCRIPT"

        ACTIONS    "VALIDATION_ERROR"

        INITIALISATION      

    END CLASS
    
    DEFINE CLASS STD_FORMULA_FUNCTION

        INHERIT "STD_COLLECTED"

        PROPERTIES "NAME"     ,
               "LIBRARY"  ,
               "ROUTINE"
               
    END CLASS       


    DEFINE CLASS STD_FORMULA_VALIDATE

        PROPERTIES "NAMES"

        ACTIONS    "VALIDATE_NAME"

        INITIALISATION

    END CLASS

    DEFINE CLASS STD_FORMULA_TRANSITION

        PROPERTIES "formula_script_filename"         ,
                   "formula_script_analysis"         ,
                   "formula_script_analysis_version" ,
                   "formula_script_position"         ,
                   "formula_script_line_count"

        ACTIONS    "formula_script_get" ,
                   "formula_script_put"

        INITIALISATION

    END CLASS

ENDROUTINE

{*******************************************************************************}

ROUTINE std_formula_validate_class_initialisation ( self )

{
*
*
*******************************************************************************}

    ARRAY self . names

ENDROUTINE

{*******************************************************************************}

ROUTINE std_formula_expression_class_initialisation ( self )

{
*
*
*******************************************************************************}

DECLARE trans_obj

    self . params_called = 0
    
    self . parameter_count_check = TRUE

    self . replicates_added = FALSE
    
    self . use_replicates = FALSE
    
    self . is_a_parameter = FALSE

    CREATE OBJECT STD_FORMULA_TRANSITION , trans_obj
    
    self . attach_transition_object( trans_obj )
    
ENDROUTINE

{*******************************************************************************}

ROUTINE std_formula_expression_batch_class_initialisation ( self )

{
*
*
*******************************************************************************}

    self . is_batch = TRUE
    
ENDROUTINE

{*******************************************************************************}

ROUTINE std_formula_context_class_initialisation ( self )

{
*
*
*******************************************************************************}

    self . error       = FALSE
    self . read_script = FALSE

ENDROUTINE

{*******************************************************************************}

ROUTINE std_formula_transition_class_initialisation ( self )

{
*
*
*******************************************************************************}

    self . formula_script_filename = EMPTY

ENDROUTINE

{*******************************************************************************}

ROUTINE std_formula_validate_action_validate_name (       self ,
                            VALUE name )

{
*
*
*******************************************************************************}

    DECLARE message ,
        count

    name = strip ( name )

    IF lib_comp_has_replicate( name ) THEN
    
        name = lib_comp_get_name( name )
        
    ENDIF

    count = 1

    WHILE count <= size_of_array ( self . names ) DO

        IF strip ( self . names [ count ] ) = strip ( name ) THEN
                    
            RETURN ( TRUE )

        ENDIF

        count = count + 1

    ENDWHILE

    message_fetch ( "FORMULA_PARSE_NAME_NOT_FOUND" , message )
    message_add_parameter  ( message , name )

    flash_message ( message_get_text ( message , 1 ) , TRUE )

    RETURN ( FALSE )

ENDROUTINE

{*******************************************************************************}

ROUTINE lib_formula_define_inequalities

{
*
*
*******************************************************************************}

    ARRAY formula_inequalities 

    formula_inequalities [ FORMULA_LT , FORMULA_LT ] = FORMULA_LT
    formula_inequalities [ FORMULA_LT , FORMULA_LE ] = FORMULA_LT
    formula_inequalities [ FORMULA_LT , FORMULA_EQ ] = FORMULA_LT
    formula_inequalities [ FORMULA_LT , FORMULA_GE ] = ERROR
    formula_inequalities [ FORMULA_LT , FORMULA_GT ] = ERROR

    formula_inequalities [ FORMULA_LE , FORMULA_LT ] = FORMULA_LT
    formula_inequalities [ FORMULA_LE , FORMULA_LE ] = FORMULA_LE
    formula_inequalities [ FORMULA_LE , FORMULA_EQ ] = FORMULA_LE
    formula_inequalities [ FORMULA_LE , FORMULA_GE ] = ERROR
    formula_inequalities [ FORMULA_LE , FORMULA_GT ] = ERROR

    formula_inequalities [ FORMULA_EQ , FORMULA_LT ] = FORMULA_LT
    formula_inequalities [ FORMULA_EQ , FORMULA_LE ] = FORMULA_LE
    formula_inequalities [ FORMULA_EQ , FORMULA_EQ ] = FORMULA_EQ
    formula_inequalities [ FORMULA_EQ , FORMULA_GE ] = FORMULA_GE
    formula_inequalities [ FORMULA_EQ , FORMULA_GT ] = FORMULA_GT

    formula_inequalities [ FORMULA_GE , FORMULA_LT ] = ERROR
    formula_inequalities [ FORMULA_GE , FORMULA_LE ] = ERROR
    formula_inequalities [ FORMULA_GE , FORMULA_EQ ] = FORMULA_GE
    formula_inequalities [ FORMULA_GE , FORMULA_GE ] = FORMULA_GE
    formula_inequalities [ FORMULA_GE , FORMULA_GT ] = FORMULA_GT

    formula_inequalities [ FORMULA_GT , FORMULA_LT ] = ERROR
    formula_inequalities [ FORMULA_GT , FORMULA_LE ] = ERROR
    formula_inequalities [ FORMULA_GT , FORMULA_EQ ] = FORMULA_GT
    formula_inequalities [ FORMULA_GT , FORMULA_GE ] = FORMULA_GT
    formula_inequalities [ FORMULA_GT , FORMULA_GT ] = FORMULA_GT

    ARRAY formula_inequalities_1 

    formula_inequalities_1 [ FORMULA_LT , FORMULA_LT ] = ERROR
    formula_inequalities_1 [ FORMULA_LT , FORMULA_LE ] = ERROR
    formula_inequalities_1 [ FORMULA_LT , FORMULA_EQ ] = FORMULA_LT
    formula_inequalities_1 [ FORMULA_LT , FORMULA_GE ] = FORMULA_LT
    formula_inequalities_1 [ FORMULA_LT , FORMULA_GT ] = FORMULA_LT

    formula_inequalities_1 [ FORMULA_LE , FORMULA_LT ] = ERROR
    formula_inequalities_1 [ FORMULA_LE , FORMULA_LE ] = ERROR
    formula_inequalities_1 [ FORMULA_LE , FORMULA_EQ ] = FORMULA_LE
    formula_inequalities_1 [ FORMULA_LE , FORMULA_GE ] = FORMULA_LE
    formula_inequalities_1 [ FORMULA_LE , FORMULA_GT ] = FORMULA_LT

    formula_inequalities_1 [ FORMULA_EQ , FORMULA_LT ] = FORMULA_GT
    formula_inequalities_1 [ FORMULA_EQ , FORMULA_LE ] = FORMULA_GE
    formula_inequalities_1 [ FORMULA_EQ , FORMULA_EQ ] = FORMULA_EQ
    formula_inequalities_1 [ FORMULA_EQ , FORMULA_GE ] = FORMULA_LE
    formula_inequalities_1 [ FORMULA_EQ , FORMULA_GT ] = FORMULA_LT

    formula_inequalities_1 [ FORMULA_GE , FORMULA_LT ] = FORMULA_GT
    formula_inequalities_1 [ FORMULA_GE , FORMULA_LE ] = FORMULA_GE
    formula_inequalities_1 [ FORMULA_GE , FORMULA_EQ ] = FORMULA_GE
    formula_inequalities_1 [ FORMULA_GE , FORMULA_GE ] = ERROR
    formula_inequalities_1 [ FORMULA_GE , FORMULA_GT ] = ERROR

    formula_inequalities_1 [ FORMULA_GT , FORMULA_LT ] = FORMULA_GT
    formula_inequalities_1 [ FORMULA_GT , FORMULA_LE ] = FORMULA_GT
    formula_inequalities_1 [ FORMULA_GT , FORMULA_EQ ] = FORMULA_GT
    formula_inequalities_1 [ FORMULA_GT , FORMULA_GE ] = ERROR
    formula_inequalities_1 [ FORMULA_GT , FORMULA_GT ] = ERROR


    ARRAY formula_inequality_as_text

    formula_inequality_as_text [ FORMULA_LT ] = "<"
    formula_inequality_as_text [ FORMULA_LE ] = "<="
    formula_inequality_as_text [ FORMULA_EQ ] = ""
    formula_inequality_as_text [ FORMULA_GE ] = ">="
    formula_inequality_as_text [ FORMULA_GT ] = ">"


ENDROUTINE

    
{*******************************************************************************}

ROUTINE std_formula_parse_class_initialisation ( self )

{
*
*
*******************************************************************************}

    self . formula        = ""
    self . current_char   = ""
    self . end_of_line    = FALSE
    self . error_text     = EMPTY
    self . error_position = 0
    self . position       = 0 

ENDROUTINE

{*******************************************************************************}

ROUTINE lib_re_formula_print_error ( VALUE error_pos ,
                       parse     )  

{
*
*
*******************************************************************************}

    DECLARE arrow_line ,
        error_line
                                                 
    arrow_line = PAD ( " " , " " , error_pos - 1 ) : "^"
        error_line = parse . error_text
    
    write_to_formula_print_file( "" )
    write_to_formula_print_file( arrow_line )
    write_to_formula_print_file( error_line )
    write_to_formula_print_file( "" )

ENDROUTINE

{*******************************************************************************}

ROUTINE lib_re_formula_print_formula ( VALUE formula       ,
                         parse         ,
                         result_object )        

{
*
*
*******************************************************************************}

    DECLARE temp        ,
        error_pos   ,
        print_width

    IF formula_script_active () THEN
                                                   
                       
    ELSE

        temp = get_user_message ( "FORMULA_PRINT_TITLE" , 1 )

        write_to_formula_print_file( "" )   
        write_to_formula_print_file( temp )

        temp = pad ( "-" , "-" , string_length ( temp ))
        write_to_formula_print_file( temp )


        temp = get_user_message ( "FORMULA_PRINT_TITLE_SAMPLE" , 1 )
        temp = temp : SELECT sample . id_text IN OBJECT result_object .
                                test_object   .
                                sample_object

        write_to_formula_print_file( "" )
        write_to_formula_print_file( temp )


        temp = get_user_message ( "FORMULA_PRINT_TITLE_TEST" , 1 )
        temp = temp : strip ( SELECT test . analysis IN OBJECT result_object .
                                           test_object   )

        temp = temp : "/"

        SET FORMAT "999"

        temp = temp : strip ( SELECT test . test_count IN OBJECT result_object .
                                             test_object   )

        write_to_formula_print_file( temp )


        temp = get_user_message ( "FORMULA_PRINT_TITLE_RESULT" , 1 )
        temp = temp : strip ( SELECT result . name IN OBJECT result_object )

        write_to_formula_print_file( temp )

        print_width = 65
        error_pos   = parse . error_position

        write_to_formula_print_file( "" )

            WHILE NOT blank ( formula ) DO

            error_pos = error_pos - 
                        string_length ( formula ) +
                        string_length ( STRIP ( formula ))

            formula = STRIP ( formula )

            temp    = splitwords ( formula , print_width )
            formula = formula # temp

            IF NOT BLANK ( temp ) THEN
                write_to_formula_print_file( temp )
            ENDIF

            IF ( error_pos > 0 ) AND ( error_pos - string_length ( temp ) <= 0 ) THEN

                lib_re_formula_print_error ( error_pos ,
                                 parse     )    

                ENDIF

            error_pos = error_pos - string_length ( temp )

        ENDWHILE


        write_to_formula_print_file( "" )
        write_to_formula_print_file( "" )


    ENDIF        

ENDROUTINE

{*******************************************************************************}

ROUTINE lib_re_formula_print_runtime_error ( VALUE error_message )

{
*
*
*******************************************************************************}

    DECLARE temp


    temp = get_user_message ( "FORMULA_PRINT_RUNTIME_ERROR" ,1 )

    write_to_formula_print_file( "" )
    write_to_formula_print_file( temp )

    error_message = strip ( error_message )
    temp          = strip ( splitwords ( error_message , 75 ))
    error_message = error_message # temp

    write_to_formula_print_file( temp )

    WHILE NOT blank ( error_message ) DO

        temp          = strip ( splitwords ( error_message , 75 ))
        error_message = error_message # temp

        write_to_formula_print_file( temp )


    ENDWHILE

ENDROUTINE

{*******************************************************************************}

ROUTINE lib_re_formula_print_convert_number ( VALUE num )

{
*
*
********************************************************************************}

    num = strip (number_to_text ( num , "99999999999.99999999999"))


        IF ( index ( num , "." ) <> 0 ) AND
           ( index ( num , "E" ) = 0 ) THEN

                WHILE ( right_string ( num , 1 ) = "0" ) DO

                        num = left_string ( num                ,
                                            length ( num ) - 1 )

                ENDWHILE
        ENDIF

        IF ( right_string ( num , 1 ) = "." ) THEN

                num = left_string ( num                ,
                                    length ( num ) - 1 )

        ENDIF
                                                      
    RETURN ( num ) 
                                    
ENDROUTINE

{*******************************************************************************}

ROUTINE lib_re_formula_print_result ( VALUE name     ,      
                        result   ,
                      VALUE position ,  
                          VALUE found    )

{
*
*
*******************************************************************************}

    DECLARE temp   ,
        title  ,
        answer

    answer = lib_re_formula_print_convert_number ( result [ position , 2 ] )
                                                                              
    IF formula_script_active () THEN                               

        
        formula_script_write_result ( name                    ,
                                          formula_inequality_as_text [ result [ position , 4 ] ] ,
                                              answer                  ,
                                              result [ position , 3 ] )


    ELSE                                                         

        title = get_user_message ( "FORMULA_PRINT_TYPE_RESULT" , 1 )

        IF found THEN

            temp = formula_inequality_as_text [ result [ position , 4 ] ] :
                   " "                                                    : 
                       strip ( answer )                                 :
                   " "                                                    : 
                   strip ( result [ position , 3 ] )

                temp = strip ( temp )

        ELSE

            temp = get_user_message ( "FORMULA_PRINT_NOT_FOUND" ,1 )

        ENDIF

        write_to_formula_print_file ( title : " " : PAD ( name, " ", 29 ) : temp )

    ENDIF        

ENDROUTINE
                
{*******************************************************************************}

ROUTINE lib_re_formula_print_line ( VALUE message  ,
                    VALUE details  )    

{
*
*
*******************************************************************************}

    DECLARE temp

    IF message <> EMPTY THEN
            
        temp = get_user_message ( message , 1 )

        temp = temp : " " : details

    write_to_formula_print_file( temp )

    ELSE

    write_to_formula_print_file( "" )

    ENDIF

ENDROUTINE

{*******************************************************************************}
                
ROUTINE lib_re_formula_print_field (       self    ,
                       context ,
                         VALUE table   ,
                     VALUE field   ,
                     VALUE answer  )        

{
*
*
*******************************************************************************}

    DECLARE temp  ,
        title

    IF numtext ( answer ) THEN

        answer = lib_re_formula_print_convert_number ( answer )
    
    ENDIF
        
    IF formula_script_active () THEN                               

        formula_script_write_field ( table  ,
                         field  ,
                         answer )                    

    ELSE

        title = get_user_message ( "FORMULA_PRINT_TYPE_FIELD" , 1 )


        table  = strip ( table )
        field  = strip ( field )           
        answer = strip ( answer )

        temp = table : " . " : field

        IF NOT context . error THEN

                                                        
        write_to_formula_print_file ( title : " " : PAD ( temp, " ", 29 ) : answer )

        ENDIF

    ENDIF        

ENDROUTINE

{*******************************************************************************}

ROUTINE lib_re_formula_print_standard ( VALUE name       ,
                    VALUE version    ,
                    VALUE component  ,
                            VALUE found      ,
                          self   )

{
*
*
*******************************************************************************}

    DECLARE temp   ,
        answer ,
        title  

    answer = lib_re_formula_print_convert_number ( self . value )

    IF formula_script_active () THEN                               
    
        formula_script_write_standard ( name         ,
                        version      ,
                        component    ,
                        answer       ,  
                        self . units )      
             
    ELSE

        title = get_user_message ( "FORMULA_PRINT_TYPE_STANDARD" , 1 )

        temp = name

        IF version <> EMPTY THEN

            temp = temp : "/" : strip ( version )

        ELSE

            temp = temp : "/" : "?"
            
        ENDIF
                
        temp = temp : " " : component

        IF found THEN

            answer = strip ( answer       ) :
                 strip ( self . units )

        ELSE

            answer = get_user_message ( "FORMULA_PRINT_NOT_FOUND" ,1 )

                      
        ENDIF

        write_to_formula_print_file ( title : " " : PAD ( name, " ", 29 ) : answer )

    ENDIF        

ENDROUTINE

{*******************************************************************************}

ROUTINE lib_re_formula_print_inst_param ( VALUE inst  ,
                                          VALUE name  ,
                                          VALUE val   ,
                                          VALUE units )

{
*
*
*******************************************************************************}

    DECLARE answer ,
        title  

    IF formula_script_active () THEN                               
    
        formula_script_write_inst_param ( name  ,
                          val   ,
                          units )       
             
    ELSE

        title = get_user_message ( "FORMULA_PRINT_TYPE_INST_PARAM" , 1 )

        IF NOT BLANK ( inst ) THEN

            answer = strip ( val ) : strip ( units )

        ELSE

            answer = get_user_message ( "FORMULA_PRINT_NOT_FOUND" ,1 )

                      
        ENDIF

        write_to_formula_print_file ( title : " " : 
                                      STRIP(inst) : " " : ASCII (34) : STRIP (name) : ASCII (34) : " " : 
                                      answer )

    ENDIF        

ENDROUTINE

{*******************************************************************************}

ROUTINE lib_re_formula_print_stock_param ( VALUE stock       ,
                                           VALUE stock_batch ,
                                           VALUE name        ,
                                           VALUE val         ,
                                           VALUE units       )

{
*
*
*******************************************************************************}

    DECLARE answer      ,
        title       ,
        message_ptr

    IF formula_script_active () THEN                               
    
        formula_script_write_stock_param ( stock ,
                           name  ,
                           val   ,
                           units )      
             
    ELSE

        title = get_user_message ( "FORMULA_PRINT_TYPE_STOCK_PARAM" , 1 )

        IF stock_batch = EMPTY THEN

            message_fetch ( "FORMULA_PRINT_STOCK_BATCH_NOT_FOUND" , message_ptr )
            message_add_parameter ( message_ptr , stock )

            answer = message_get_text ( message_ptr , 1 )
        
        ELSEIF val = EMPTY THEN

            message_fetch ( "FORMULA_PRINT_STOCK_PARAM_NOT_FOUND" , message_ptr )
            message_add_parameter ( message_ptr , name )
            message_add_parameter ( message_ptr , strip ( stock ) : "/" : strip ( stock_batch ))

            answer = message_get_text ( message_ptr , 1 )

        ELSE

            answer = strip ( stock ) : "/" : strip ( stock_batch ) : " " : 
                     strip ( name ) : " = " :
                     strip ( val ) : strip ( units )

        ENDIF

        write_to_formula_print_file ( title : " " : answer )

    ENDIF        

ENDROUTINE

{*******************************************************************************}

ROUTINE lib_re_formula_parse_error (       self          ,
                         VALUE error_message )
            
{
*
*
*******************************************************************************}
    
    IF self . error_text = EMPTY THEN

        error_message = "FORMULA_PARSE_" : error_message
        self . error_text = get_user_message ( error_message , 1 )

        self . error_position = self . position

    ENDIF

ENDROUTINE

{*******************************************************************************}

ROUTINE lib_re_formula_parse_error_one (       self          ,
                             VALUE error_message ,
                     VALUE parameter     )
            
{
*
*
*******************************************************************************}

    DECLARE message_ptr 

    IF self . error_text = EMPTY THEN

        error_message = "FORMULA_PARSE_" : error_message

        message_fetch ( error_message , message_ptr )
        message_add_parameter ( message_ptr , parameter )

        self . error_text = message_get_text ( message_ptr , 1 )
        self . error_position = self . position

    ENDIF

ENDROUTINE

{*******************************************************************************}

ROUTINE lib_re_formula_allocate_expression ( VALUE operand ,
                           left    ,
                           right   )
            
{
*
*
*******************************************************************************}

    DECLARE expression

    CREATE OBJECT STD_FORMULA_EXPRESSION, expression

    expression . operand = operand
    expression . left    = left
    expression . right   = right

    RETURN ( expression )

ENDROUTINE

{*******************************************************************************}

ROUTINE lib_re_formula_get_next ( self )

{
*
*
*******************************************************************************}

    self . position = self . position + 1

    IF self . position > string_length ( self . formula ) THEN

        self . end_of_line  = TRUE
                self . current_char = " "
        
    ELSE

        self . current_char = get_character_at ( self . formula  , 
                                 self . position )

    ENDIF

    RETURN ( self . current_char )

ENDROUTINE

{*******************************************************************************}

ROUTINE lib_re_formula_find_start ( self )

{
*
*
*******************************************************************************}

    DECLARE position ,
        temp     ,
        got_one

    position = self . position + 1 

    got_one  = FALSE

    WHILE NOT got_one DO

        IF position > string_length ( self . formula ) THEN

            temp               = " "
            got_one            = TRUE   
            self . end_of_line = TRUE

        ELSE

            temp = get_character_at ( self . formula ,
                              position       )

            IF blank ( temp ) THEN

                position = position + 1

            ELSE

                got_one = TRUE

            ENDIF

        ENDIF   

    ENDWHILE     

    self . position     = position
    self . current_char = temp      

ENDROUTINE

{*******************************************************************************}

ROUTINE is_alpha ( VALUE the_char )

{
*
*
*******************************************************************************}

    the_char = toupper ( the_char )

    RETURN (  INDEX ("_ABCDEFGHIJKLMNOPQRSTUVWXYZ",the_char) > 0 ) 

ENDROUTINE

{*******************************************************************************}

ROUTINE is_alphanumeric ( VALUE the_char )

{
*
*
*******************************************************************************}

    the_char = toupper ( the_char )

    RETURN (  INDEX ("_ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789",the_char) > 0 ) 

ENDROUTINE

{*******************************************************************************}

ROUTINE is_digit ( VALUE the_char )

{
*
*
*******************************************************************************}

    RETURN ( ( index("1234567890",the_char) > 0 )) 

ENDROUTINE

{*******************************************************************************}

ROUTINE is_sign ( VALUE the_char )

{
*
*
*******************************************************************************}

    RETURN ( ( the_char = "+"  ) OR
                 ( the_char = "-" ))


ENDROUTINE

{*******************************************************************************}

ROUTINE is_decimal ( VALUE the_char )

{
*
*
*******************************************************************************}

    RETURN ( the_char = "." ) 

ENDROUTINE

{*******************************************************************************}

ROUTINE lib_re_formula_look_for (       self               ,
                      VALUE expected_token     ,
                      VALUE expected_character )        

{
*
*
*******************************************************************************}

    IF blank ( self . current_char ) THEN

        lib_re_formula_find_start ( self )

    ENDIF

    IF self . current_char = expected_token THEN

        lib_re_formula_find_start ( self )

    ELSE

        lib_re_formula_parse_error_one (  self               ,
                         "EXPECTED_A"        ,
                          expected_character )

    ENDIF

ENDROUTINE

{*******************************************************************************}

ROUTINE lib_re_formula_read_number ( self       ,
                     expression )   

{
*
*
*******************************************************************************}

    DECLARE the_char          ,
        keep_going        ,
        the_number        ,
        last_was_exponent ,
        units             ,
        is_start          ,
        param_count

    the_number        = self . current_char
    keep_going        = TRUE
    last_was_exponent = FALSE 
    units             = ""

    WHILE ( keep_going ) DO
                                  
        the_char = lib_re_formula_get_next ( self )

        IF ( self . end_of_line ) THEN

            keep_going = FALSE

        ELSEIF (( is_digit   ( the_char ))  OR
                ( is_decimal ( the_char ))) THEN

            the_number = the_number : the_char
    
        ELSEIF the_char = "E" THEN
      
            the_number        = the_number : the_char
            last_was_exponent = TRUE

        ELSEIF ( is_sign ( the_char )) THEN        { prior char must be "E" }
     
            IF ( last_was_exponent ) then 
       
                the_number = the_number : the_char
      
            ELSE
      
                keep_going = FALSE
                    
            ENDIF
    
        ELSE       
            
            keep_going = FALSE
            
        ENDIF
 
    ENDWHILE

    { Get any possible units }                         

    keep_going  = TRUE
    is_start    = TRUE  
    param_count = 0

    WHILE ( keep_going ) DO

        IF ( self . end_of_line ) THEN
                                             
            IF param_count > 0 THEN
                             
                lib_re_formula_parse_error_one (  self        ,
                                 "EXPECTED_A" ,
                                  ")"         )

            ENDIF                                             

            keep_going = FALSE

        ELSEIF is_start THEN

            IF index ( "/*+-)^," : ascii ( 34 ) , the_char ) <> 0 THEN

                keep_going = FALSE

            ELSEIF ( blank ( the_char )) THEN

                the_char = lib_re_formula_get_next ( self )

            ELSE
    
                IF the_char = "(" THEN

                    param_count = param_count + 1

                ENDIF                     

                units = the_char
                the_char = lib_re_formula_get_next ( self )

                is_start = FALSE

            ENDIF


        ELSEIF index ( "+-^," : ascii ( 34 ) , the_char ) <> 0 THEN             

            keep_going = FALSE

        
        ELSE

            IF the_char = "(" THEN

                param_count = param_count + 1

            ENDIF                     
                                
            IF the_char = ")" THEN

                IF param_count = 0 THEN

                    keep_going = FALSE

                ELSE

                    param_count = param_count - 1

                ENDIF

            ENDIF

            IF keep_going THEN                        

                    units = units : the_char                                          
                the_char = lib_re_formula_get_next ( self )

            ENDIF                

        ENDIF


    ENDWHILE                         

    IF numtext ( the_number ) THEN

        the_number = numeric ( the_number )
        self . position = self . position - 1

    ELSE                             

        the_number = 0
        lib_re_formula_parse_error (  self            , 
                         "INVALID_NUMBER" )

    ENDIF
                        
    expression . operand = FORMULA_NUMBER 
    expression . value   = the_number   
    expression . units   = units

ENDROUTINE

{*******************************************************************************}

GLOBAL ROUTINE lib_re_formula_find_function  ( VALUE func_name )

{
*
*
*******************************************************************************}

    DECLARE return_function
    
    return_function = EMPTY
    
    return_function = lib_re_formula_find_function_in_cluster( func_name )
    
    IF ( return_function = EMPTY ) THEN
    
        return_function = lib_re_formula_find_function_in_db( func_name )
        
        IF ( return_function <> EMPTY ) THEN
        
            lib_re_formula_add_function_to_cluster( return_function )
            
        ENDIF
        
    ENDIF

    RETURN ( return_function )

ENDROUTINE
{*******************************************************************************}

ROUTINE lib_re_formula_read_function ( self )
                                
{
*
*
*******************************************************************************}

    DECLARE identity  ,
        function
                                         
    identity = ""           

    REPEAT

        identity = identity : self . current_char
        lib_re_formula_get_next ( self )

    UNTIL NOT is_alphanumeric ( self . current_char )

    identity = toupper ( identity )

    function = lib_re_formula_find_function ( identity )


    IF function = EMPTY THEN

        lib_re_formula_parse_error_one (  self               ,
                         "UNKNOWN_FUNCTION"  ,
                              identity           )
                        
    ENDIF
                            
    RETURN ( function )
            
ENDROUTINE

{*******************************************************************************}

ROUTINE lib_re_formula_comparison_num ( self )

{
*
*
*******************************************************************************}

    DECLARE initial_char, 
            comparison_num

    initial_char = self . current_char

    lib_re_formula_get_next ( self )

    IF ( initial_char = "<" ) THEN

        IF ( self . current_char = ">" ) THEN

            comparison_num = FORMULA_COMP_NOT_EQUAL

            lib_re_formula_get_next ( self )

        ELSEIF ( self . current_char = "=" ) THEN

            comparison_num = FORMULA_COMP_LESS_OR_EQUAL

            lib_re_formula_get_next ( self )

        ELSE

            comparison_num = FORMULA_COMP_LESS

        ENDIF

    ELSEIF ( initial_char = ">" ) THEN

        IF ( self . current_char = "=" ) THEN

            comparison_num = FORMULA_COMP_GREATER_OR_EQUAL

            lib_re_formula_get_next ( self )

        ELSE

            comparison_num = FORMULA_COMP_GREATER

        ENDIF

    ELSEIF ( initial_char = "=" ) THEN

        comparison_num = FORMULA_COMP_EQUAL

    ENDIF

    RETURN ( comparison_num )

ENDROUTINE

{*******************************************************************************}
                                
ROUTINE lib_re_formula_parse_text (       self      ,
                          parameter ,
                    VALUE token     )   

{
*
*
*******************************************************************************}

    DECLARE name      ,
        position  ,
        temp      
        
    CREATE OBJECT STD_FORMULA_EXPRESSION, parameter

    parameter . operand = FORMULA_TEXT

    IF self . current_char = token THEN

        self . position = self . position + 1

    ENDIF

    temp            = SUBSTRING ( self . formula                  , 
                      self . position                 ,
                          string_length ( self . formula ))
                            
    position        = INDEX ( temp , token )
    name            = SUBSTRING ( temp          , 
                      1             , 
                          position - 1  )
                
    self . position = self . position + position -1    
        
    lib_re_formula_find_start ( self )

    parameter  . text   = name


ENDROUTINE

{*******************************************************************************}

ROUTINE lib_re_formula_parse_parameter ( self      ,
                         parameter )

{
*                               
*       
*******************************************************************************}
    
    parameter = lib_re_formula_parse_expression ( self )

ENDROUTINE
                                
{*******************************************************************************}

ROUTINE lib_re_formula_parse_function ( self       ,
                            expression )

{
*                               
*
*******************************************************************************}

    DECLARE count       ,
        keep_going      

    ARRAY expression . parameters 
    
    IF self . current_char <> ")" THEN

        count = 1

    
        REPEAT

            lib_re_formula_parse_parameter ( self                     ,
                             expression . parameters [ count ] )
                             
            IF self . error_text = EMPTY THEN                            
                             
                expression . parameters[ count ] . 
                parent_expression = expression
            
                expression . parameters[ count ] . 
                is_a_parameter = TRUE
            
            ENDIF
  

            count = count + 1

            IF self . current_char = "," THEN

                lib_re_formula_find_start ( self )
                keep_going = TRUE

            ELSE

                keep_going = FALSE

            ENDIF   

        UNTIL NOT keep_going

    ENDIF

ENDROUTINE

{*******************************************************************************}
                                
ROUTINE lib_re_formula_parse_factor ( self )
        
{                               
*                               
*
*******************************************************************************}

    DECLARE expression

    CREATE OBJECT STD_FORMULA_EXPRESSION, expression

    IF ( is_digit   ( self . current_char )) OR
       ( is_decimal ( self . current_char )) THEN

        lib_re_formula_read_number ( self       ,
                         expression )
    
        lib_re_formula_find_start ( self )

    ELSEIF is_alpha ( self . current_char ) THEN
                        
        expression . operand  = FORMULA_FUNCTION
        expression . function = lib_re_formula_read_function ( self )

        lib_re_formula_look_for ( self                     ,        
                      FORMULA_OPEN_PAREN , "(" )

        lib_re_formula_parse_function ( self       ,
                        expression )

        lib_re_formula_look_for ( self                      ,
                      FORMULA_CLOSE_PAREN , ")" )


    ELSEIF self . current_char = ASCII ( 34 ) THEN

        expression . operand  = FORMULA_TEXT
        lib_re_formula_parse_text ( self         ,
                               expression   ,
                               ASCII ( 34 ) )
                        
    ELSEIF self . current_char = "(" THEN
        
        lib_re_formula_find_start ( self )

        expression = lib_re_formula_parse_expression ( self )

        lib_re_formula_look_for ( self                      ,
                      FORMULA_CLOSE_PAREN , ")" )

    ELSE
                                    
        lib_re_formula_parse_error_one (  self                ,
                         "UNEXPECTED_ELEMENT" ,
                                  self . current_char )

    ENDIF
                                
    RETURN ( expression ) 

ENDROUTINE

{*******************************************************************************}

ROUTINE lib_re_formula_parse_order ( self )

{
*
*
*******************************************************************************}

    DECLARE expression ,
        temp    

    expression = lib_re_formula_parse_factor ( self )

    WHILE ( self . current_char = FORMULA_POWER ) DO

        temp = expression

        CREATE OBJECT STD_FORMULA_EXPRESSION, expression

        expression . operand = self . current_char
        expression . left    = temp

        lib_re_formula_find_start ( self )
                                    
        expression . right = lib_re_formula_parse_factor ( self )

    ENDWHILE    

    RETURN ( expression )

ENDROUTINE

{*******************************************************************************}

ROUTINE lib_re_formula_parse_term ( self )

{
*
*
*******************************************************************************}

    DECLARE expression ,
        temp    

    expression = lib_re_formula_parse_order( self )

    WHILE ( self . current_char = FORMULA_MULTIPLY ) OR
              ( self . current_char = FORMULA_DIVIDE   ) DO

        temp = expression

        CREATE OBJECT STD_FORMULA_EXPRESSION, expression

        expression . operand = self . current_char
        expression . left    = temp

        lib_re_formula_find_start ( self )
                                    
        expression . right = lib_re_formula_parse_order ( self )

    ENDWHILE    

    RETURN ( expression )

ENDROUTINE

{*******************************************************************************}

ROUTINE lib_re_formula_parse_addition ( self )

{
*
*
*******************************************************************************}

    DECLARE expression  ,
        temp       

    expression = EMPTY

    IF self . current_char = FORMULA_PLUS THEN

        lib_re_formula_find_start ( self )


    ENDIF

    IF self . current_char = FORMULA_MINUS THEN

        lib_re_formula_find_start ( self )

        expression = lib_re_formula_allocate_expression ( FORMULA_NEGATE  ,
                                      EXPRESSION_NULL ,
                                      EXPRESSION_NULL )
        
        expression . left = lib_re_formula_parse_term ( self )

    ELSE

        expression = lib_re_formula_parse_term ( self )

    ENDIF

    WHILE ( self . current_char = FORMULA_PLUS  ) OR
              ( self . current_char = FORMULA_MINUS ) DO


        temp = expression

        CREATE OBJECT STD_FORMULA_EXPRESSION, expression

        expression . operand = self . current_char
        expression . left    = temp
                            
        lib_re_formula_find_start ( self )

        expression . right = lib_re_formula_parse_term ( self )

    ENDWHILE    

    RETURN ( expression )                          

ENDROUTINE

{*******************************************************************************}

ROUTINE lib_re_formula_parse_expression ( self  )

{
*
*
*******************************************************************************}

    DECLARE expression  ,
        temp       

    expression = EMPTY

    expression = lib_re_formula_parse_addition ( self )

    IF ( self . current_char = "<" ) OR
       ( self . current_char = ">" ) OR
       ( self . current_char = "=" ) THEN

        temp = expression

        CREATE OBJECT STD_FORMULA_EXPRESSION, expression

        expression . operand  = FORMULA_COMPARISON
        expression . function = lib_re_formula_comparison_num ( self )
        expression . left     = temp

        lib_re_formula_find_start ( self )

        expression . right = lib_re_formula_parse_addition ( self )

    ENDIF

    RETURN ( expression )

ENDROUTINE

{*******************************************************************************}

ROUTINE lib_re_formula_parse ( self  )

{
*
*
*******************************************************************************}

    DECLARE expression ,
        temp

    expression = lib_re_formula_parse_expression ( self )

    IF NOT self . end_of_line THEN
        
        temp = substring ( self . formula                     ,
                   self . position                    ,
                   string_length ( self . formula ) -
                   ( self . position - 1 )        ) 

        lib_re_formula_parse_error_one (   self       ,
                          "EXTRA_END" ,
                                                   temp       )

    ENDIF


    RETURN ( expression )

ENDROUTINE

{*******************************************************************************}
{*******************************************************************************}

GLOBAL

ROUTINE lib_re_formula_runtime_error (       context       ,
                       VALUE error_message ,
                       VALUE parameter_1   ,
                       VALUE parameter_2   )            

{
*
*
*******************************************************************************}

    DECLARE message_ptr

    IF NOT context . error THEN

        context . error = TRUE

        error_message = "FORMULA_RUNTIME_" : error_message

        message_fetch ( error_message , message_ptr )

            IF parameter_1 <> EMPTY THEN

            message_add_parameter ( message_ptr ,
                        parameter_1 )

        ENDIF
            
            IF parameter_2 <> EMPTY THEN

            message_add_parameter ( message_ptr ,
                        parameter_2 )
                    
        ENDIF


        context . error_message = message_get_text ( message_ptr , 1 )

    ENDIF                                

ENDROUTINE

{*******************************************************************************}

ROUTINE std_formula_context_action_validation_error (       context       ,
                                      VALUE error_message ,
                                      VALUE parameter_1   ,
                                      VALUE parameter_2   )

{
*
*
*******************************************************************************}

    DECLARE message_ptr

    IF NOT context . error THEN

        context . error = TRUE

        error_message = "FORMULA_VALIDATION_" : error_message

        message_fetch ( error_message , message_ptr )

            IF parameter_1 <> EMPTY THEN

            message_add_parameter ( message_ptr ,
                        parameter_1 )

        ENDIF
            
            IF parameter_2 <> EMPTY THEN

            message_add_parameter ( message_ptr ,
                        parameter_2 )
                    
        ENDIF


        context . error_message = message_get_text ( message_ptr , 1 )

    ENDIF                                

ENDROUTINE

{*******************************************************************************}

ROUTINE lib_re_formula_inequality_error (       context       ,
                          VALUE error_message ,
                            left          ,
                            right         )

{
*
*
*******************************************************************************}

    DECLARE left_text ,
        right_text

    left_text  = formula_inequality_as_text [ left  . inequality ]
    right_text = formula_inequality_as_text [ right . inequality ]

    lib_re_formula_runtime_error ( context       ,
                       error_message ,
                       left_text     ,
                       right_text    )

ENDROUTINE              
    
{*******************************************************************************}

ROUTINE lib_re_formula_get_inequality ( VALUE inequality )

{
*
*
*******************************************************************************}

    DECLARE answer

    IF blank ( inequality ) THEN

        answer = FORMULA_EQ  
                                                
    ELSEIF inequality = "<" THEN

        answer = FORMULA_LT

    ELSEIF inequality = "<=" THEN

        answer = FORMULA_LE

    ELSEIF inequality = ">" THEN

        answer = FORMULA_GT

    ELSEIF inequality = ">=" THEN

        answer = FORMULA_GE

    ELSE

        answer = FORMULA_EQ  
                                                
    ENDIF

    RETURN ( answer )

ENDROUTINE

{*******************************************************************************}

ROUTINE lib_re_formula_result_value ( VALUE test_number ,
                      VALUE name        ,
                        units       ,
                        inequality  ,
                        dilution    )                   

{
*
*
*******************************************************************************}

    DECLARE file_descriptor ,
        answer          ,
        first           ,
        second

    IF ( name        = SELECT result . name        ) AND
       ( test_number = SELECT result . test_number ) THEN   

        answer = SELECT result . text
        file_descriptor = EMPTY

    ELSE

        push_file_descriptor ( "RESULT" , file_descriptor )

        test_number = PACKED_DECIMAL ( test_number )
        
        IF test_number <> ERROR THEN

            answer = SELECT result . text
                 WHERE ( test_number = test_number ) AND
                       ( name        = name        )
                       
        ELSE
        
            answer = EMPTY
            
        ENDIF   

    ENDIF

    IF ( SELECT result . status = "E" ) OR
       ( SELECT result . status = "M" ) OR
       ( SELECT result . status = "A" ) THEN

        dilution = SELECT result . dilution_factor
                                                 
    ELSE

        dilution = 1.0
        answer   = EMPTY

    ENDIF   

    units      = SELECT result . units 
    inequality = ""

    IF answer <> EMPTY THEN

        answer = result_string ( EMPTY       ,
                         test_number ,
                         name        )

        IF answer <> EMPTY THEN

            first  = substring ( answer , 1 , 1 )
            second = substring ( answer , 2 , 1 )   
        
                IF INDEX ( "<>" , first ) <> 0 THEN

                        IF second = "=" THEN

                                inequality = first : second

                        ELSE

                                inequality = first 

                        ENDIF

                ELSEIF first = "~" THEN                                    
                        
                        inequality = first
                                                 
                ENDIF

        ENDIF

    ENDIF
                
    IF file_descriptor <> EMPTY THEN

        pop_file_descriptor ( file_descriptor )

    ENDIF

    RETURN ( answer )

ENDROUTINE

{*******************************************************************************}
GLOBAL

ROUTINE lib_re_formula_get_result (       self         ,
                          context      ,
                    value use_dilution )    

{
*
*
*******************************************************************************}

    DECLARE name          ,
        result_object ,
        test_number   ,
        answer        ,
        inequality    ,
        print_results ,
        dilution

    IF lib_re_formula_param_number ( self ) = 1 THEN

        test_number = context . test_number
        name = lib_re_formula_parameter_text ( self    ,
                               1       ,    
                               context )

    ELSEIF lib_re_formula_param_number ( self ) = 2 THEN

        test_number = lib_re_formula_parameter_text ( self    ,
                                      1       , 
                                      context )

        name = lib_re_formula_parameter_text ( self    ,
                               2       ,    
                               context )

    ELSE       

        lib_re_formula_runtime_error (  context           ,
                           "INCORRECT_PARAMS" ,
                           "RESULT"           ,
                        lib_re_formula_param_number ( self )      )

    ENDIF

    IF context . read_script THEN

        IF NOT lib_comp_has_replicate ( name ) THEN

            name = lib_comp_add_replicate ( name, 1 )
                 
        ENDIF

        formula_script_read_result ( context      ,
                         name         ,
                         inequality   ,
                         self . value ,
                         self . units )     

        self . inequality = lib_re_formula_get_inequality ( inequality )

    ELSEIF ( context . mode = FORMULA_MODE_CALCULATE ) OR
           ( context . mode = FORMULA_MODE_PRINT     ) THEN
                                    
        IF NOT lib_comp_has_replicate ( name ) THEN

            name = lib_comp_add_replicate ( name, 1 )
            
        ENDIF
        
        result_object = context . result_context . get_result ( test_number ,   
                                                                        name )

        IF result_object = EMPTY THEN

            answer = lib_re_formula_result_value ( test_number  ,
                                       name         ,
                                   self . units ,
                                   inequality   ,
                                   dilution     )
            

            IF answer = EMPTY THEN

                lib_re_formula_runtime_error (  context          ,
                                   "RESULT_NOTFOUND" ,
                                name             ,
                                EMPTY            )
            ENDIF

            self . value  = answer
    
        ELSEIF result_object . result_accepted_status () THEN

            dilution     = result_object . get_field ( "DILUTION_FACTOR" )
            self . value = result_object . result_val
            self . units = result_object . result_unit
            inequality   = result_object . get_inequality ()

        ELSE

            self . value = 0.0
            self . units = ""
            inequality   = ""
                
            lib_re_formula_runtime_error (  context          ,
                               "RESULT_NOTFOUND" ,
                            name             ,
                            EMPTY            )


        ENDIF

        IF (     use_dilution    ) AND
           ( NOT context . error ) THEN

            self . value = self . value * dilution

        ENDIF   
                                                        
        self . inequality = lib_re_formula_get_inequality ( inequality )


        IF ( context . mode = FORMULA_MODE_PRINT ) AND
           ( NOT context . error                 ) THEN

            ARRAY print_results

            print_results [ 1, 2 ] = self . value
            print_results [ 1, 3 ] = self . units
            print_results [ 1, 4 ] = self . inequality

            lib_re_formula_print_result ( name           ,
                              print_results  ,
                              1              ,
                              TRUE           )  

        ENDIF


    ELSEIF context . mode = FORMULA_MODE_BIND THEN

        IF NOT lib_comp_has_replicate ( name ) THEN

            name = lib_comp_add_replicate ( name, 1 )

        ENDIF   

        result_object = context . result_context . get_result ( test_number ,   
                                                                    name )

        IF result_object <> EMPTY THEN

            result_object . used_in_formula ( context . result_object )

        ENDIF

        self . value      = 1
        self . inequality = FORMULA_EQ
        self . units      = ""

    ELSEIF context . mode = FORMULA_MODE_TEST_PHASE1 THEN

        lib_re_formula_prompt_comp_value ( test_number       ,
                                           name              ,
                                           self . value      ,
                                           self . inequality )

        self . units = ""

    ELSEIF context . mode = FORMULA_MODE_VALIDATE THEN

        IF lib_re_formula_param_number ( self ) = 1 THEN

            context . result_context . validate_name ( name )

        ENDIF

        self . value      = 1
        self . inequality = FORMULA_EQ
        self . units      = ""

    ENDIF

ENDROUTINE

{*******************************************************************************}

ROUTINE lib_re_formula_result_function ( self )

{
*
*
*******************************************************************************}

    self . set_parameter_count_check_off()

    lib_re_formula_get_result ( self           ,
                    self . context ,
                    FALSE          )
        
ENDROUTINE

{*******************************************************************************}

ROUTINE lib_re_formula_result_dil_function ( self )

{
*
*
*******************************************************************************}

    self . set_parameter_count_check_off()

    lib_re_formula_get_result ( self           ,
                    self . context ,
                    TRUE           )
        

ENDROUTINE

{*******************************************************************************}

ROUTINE lib_re_formula_add_result_object (       result_object ,
                             context       ,
                             results       ,
                             next_pos      ,
                             found         ,
                       VALUE name          )

{
*
*
*******************************************************************************}

    IF ( result_object . result_accepted_status () ) AND
           ( numtext ( result_object . result_str )    ) THEN
                                         
        results [ next_pos , 1 ] = result_object . name
        results [ next_pos , 2 ] = result_object . result_val
        results [ next_pos , 3 ] = result_object . result_unit
        results [ next_pos , 4 ] = lib_re_formula_get_inequality (
                               result_object . get_inequality ())
    
        found = TRUE
        next_pos = next_pos + 1

    ELSEIF NOT result_object . result_accepted_status () THEN

        lib_re_formula_runtime_error (  context          ,
                           "RESULT_NOTFOUND" ,
                            name             , 
                        EMPTY            )

    ELSE            

        lib_re_formula_runtime_error (  context            ,
                           "RESULT_NOTNUMERIC" ,
                        name               , 
                        EMPTY              )

    ENDIF

ENDROUTINE
            
{*******************************************************************************}

ROUTINE lib_re_formula_find_result (      self      ,
                          context   ,
                            VALUE parameter ,   
                          results   ,
                      next_pos  )       


{
*
*
*******************************************************************************}

    DECLARE name          ,
        result_object ,
        answer        ,
        found         ,
        units         ,
        inequality    ,
        dilution

    name = lib_re_formula_parameter_text ( self      ,
                           parameter ,  
                           context   )

    IF ( context . mode = FORMULA_MODE_CALCULATE ) OR
       ( context . mode = FORMULA_MODE_PRINT     ) THEN

        found = FALSE

        IF NOT lib_comp_has_replicate ( name ) THEN

            name = lib_comp_add_replicate ( name, 1 )
    
        ENDIF   

        result_object = context . result_context . get_result ( context . test_number , 
                                                                    name )

        IF result_object = EMPTY THEN

            answer = lib_re_formula_result_value ( context . test_number ,
                                       name                  ,
                                                               units                 ,
                                       inequality            ,
                                   dilution              )  

            inequality = lib_re_formula_get_inequality ( inequality )   

            IF answer = EMPTY THEN

                lib_re_formula_runtime_error (  context          ,
                                   "RESULT_NOTFOUND" ,
                                name             ,
                                EMPTY            )

            ELSEIF numtext ( answer ) THEN

                results [ next_pos , 1 ] = name
                results [ next_pos , 2 ] = answer
                results [ next_pos , 3 ] = units
                results [ next_pos , 4 ] = inequality
    
                next_pos = next_pos + 1
                found = TRUE

            ELSE

                lib_re_formula_runtime_error (  context            ,
                                   "RESULT_NOTNUMERIC" ,
                                name               , 
                                EMPTY              )

            ENDIF
    
        ELSE

            lib_re_formula_add_result_object ( result_object ,
                               context       ,
                               results       ,
                               next_pos      ,
                               found         ,
                               name          )

        ENDIF
        
        IF ( context . mode = FORMULA_MODE_PRINT ) AND
           ( found                               ) THEN

            lib_re_formula_print_result ( name         ,
                              results      ,
                              next_pos - 1 ,
                              found        )    

        ENDIF


    ELSEIF context . mode = FORMULA_MODE_BIND THEN

        IF NOT lib_comp_has_replicate ( name ) THEN

            name = lib_comp_add_replicate ( name, 1 )

        ENDIF

        result_object = context . result_context . get_result ( context . test_number , 
                                                                    name )

        IF result_object <> EMPTY THEN

            result_object . used_in_formula ( context . result_object )

        ENDIF

    ELSEIF context . mode = FORMULA_MODE_TEST_PHASE1 THEN

        lib_re_formula_prompt_comp_value ( context . test_number ,
                                           name                  ,
                                           answer                ,
                                           inequality            )

        results [ next_pos , 1 ] = name
        results [ next_pos , 2 ] = answer
        results [ next_pos , 3 ] = ""
        results [ next_pos , 4 ] = inequality
    
        next_pos = next_pos + 1
        found = TRUE

    ELSEIF context . mode = FORMULA_MODE_VALIDATE THEN

        self . value      = 1
        self . inequality = FORMULA_EQ
        self . units      = ""

        context . result_context . validate_name ( name )

    ENDIF

ENDROUTINE

{*******************************************************************************}

ROUTINE lib_re_formula_find_replicate_result (      self      ,
                                    context   ,
                          VALUE parameter , 
                                    results   ,
                                next_pos  )     

{
*
*
*******************************************************************************}

    DECLARE name           ,
        like_clause    ,
        next_value     , 
        result_object  ,
        internal_param ,
        found          ,
        found_one      ,
        units          ,
        inequality     ,
        dilution       ,
        database_name

    name = lib_re_formula_parameter_text ( self      ,
                           parameter ,  
                           context   )     

    IF ( context . mode = FORMULA_MODE_CALCULATE ) OR
       ( context . mode = FORMULA_MODE_PRINT     ) THEN

    
        like_clause = lib_comp_build_like_clause ( name )

        database_name = SELECT result . name
                        WHERE ( test_number = context . test_number ) AND   
                          ( name   like   like_clause           )


        IF database_name = EMPTY THEN

            { Look for /1 amyway - we may be on the 
              formula test screen }

            database_name = lib_comp_add_replicate ( name ,1 )

            
            IF context . result_context . 
                get_result ( context . test_number ,    
                                         database_name         ) = EMPTY THEN
                                                                                 
                lib_re_formula_runtime_error (  context          ,
                                   "RESULT_NOTFOUND" ,
                                    name             , 
                                EMPTY            )
        
                database_name = EMPTY                     
    
            ENDIF                                

        ENDIF

        found_one = FALSE

        WHILE database_name <> EMPTY DO

            found = FALSE

            result_object = context        . 
                    result_context . 
                    get_result ( context . test_number ,    
                                                 database_name                  )
                                                                          
            IF result_object <> EMPTY  THEN

                IF ( result_object . result_accepted_status () ) THEN

                    lib_re_formula_add_result_object ( result_object  ,
                                       context        ,
                                       results        ,
                                       next_pos       ,
                                       found          ,
                                       database_name  )

                ELSEIF NOT result_object . result_entered () THEN

                    lib_re_formula_runtime_error (  context          ,
                                       "RESULT_NOTFOUND" ,
                                    database_name             ,
                                    EMPTY            )


                ENDIF                                                                   

            ELSEIF ( SELECT result . status = "E" ) OR
                   ( SELECT result . status = "M" ) OR
                   ( SELECT result . status = "A" ) THEN
            
                next_value = lib_re_formula_result_value ( SELECT result . test_number ,
                                               SELECT result . name        ,
                                                  units                ,
                                                  inequality           ,
                                          dilution             )                
                IF numtext ( next_value ) THEN

                    results [ next_pos , 1 ] = SELECT result . name
                    results [ next_pos , 2 ] = next_value
                    results [ next_pos , 3 ] = units
                    results [ next_pos , 4 ] = lib_re_formula_get_inequality ( inequality )
    
                    next_pos = next_pos + 1

                    found = TRUE

                ELSE

                    lib_re_formula_runtime_error (  context            ,
                                       "RESULT_NOTNUMERIC" ,
                                    database_name      , 
                                    EMPTY              )

                    ENDIF

            ELSEIF NOT result_object . result_entered () THEN

                lib_re_formula_runtime_error (  context          ,
                                   "RESULT_NOTFOUND" ,
                                    database_name             ,
                                EMPTY            )

            
                ENDIF   

            IF ( context . mode = FORMULA_MODE_PRINT ) AND
               ( found                               ) THEN
                                                        
                lib_re_formula_print_result ( database_name ,
                                  results       ,
                                  next_pos - 1  ,
                                  found         )   

            ENDIF

            IF found THEN

                found_one = TRUE

            ENDIF

            NEXT result                     

            database_name = SELECT result . name
    
        ENDWHILE

        IF NOT found_one THEN

            lib_re_formula_runtime_error (  context          ,
                               "RESULT_NOTFOUND" ,
                                name             ,
                            EMPTY            )

        ENDIF

    ELSEIF context . mode = FORMULA_MODE_BIND THEN

        result_object = context . result_context . 
                           get_result_first ( context . test_number ,
                                                      name                  ,
                              internal_param        )

        WHILE result_object <> EMPTY DO

            IF result_object <> context . result_object THEN

                result_object . used_in_formula ( context . result_object )

            ENDIF

            result_object = context . result_context . 
                    get_result_next ( context . test_number ,
                              name                  ,
                                  internal_param        )

        ENDWHILE            
                                                        
    ELSEIF context . mode = FORMULA_MODE_TEST_PHASE1 THEN

        lib_re_formula_prompt_comp_value ( context . test_number ,
                                           name                  ,
                                           next_value            ,
                                           inequality            )

        results [ next_pos , 1 ] = name
        results [ next_pos , 2 ] = next_value
        results [ next_pos , 3 ] = ""
        results [ next_pos , 4 ] = inequality
    
        next_pos = next_pos + 1
        found = TRUE

    ELSEIF context . mode = FORMULA_MODE_PRINT THEN

        IF formula_script_active () THEN 

            formula_script_write_end_result ()                     

        ENDIF             

    ENDIF        
        
ENDROUTINE

{*******************************************************************************}

ROUTINE lib_re_formula_read_script_result ( self      ,
                        context   ,
                        parameter ,
                        results   ,
                        next_pos  ) 

{
*                                                                              
*
******************************************************************************}

    DECLARE name       ,
        finished   ,
        inequality ,
        contents   ,
        units      ,
        temp       ,
        count
            

    finished = TRUE
    count    = 1                                        

    name = lib_re_formula_parameter_text ( self      ,
                           parameter ,  
                           context   )
    
    REPEAT
                                
        temp = lib_comp_add_replicate ( name , count )
                                                                            
        formula_script_read_result ( context    ,
                         temp       ,
                         inequality ,
                         contents   ,
                         units      )
                                         
        count = count + 1

        IF inequality <> EMPTY THEN

            results [ next_pos , 1 ] = name
            results [ next_pos , 2 ] = contents     
            results [ next_pos , 3 ] = units
            results [ next_pos , 4 ] = lib_re_formula_get_inequality ( inequality )

            next_pos = next_pos + 1
                                         
            finished = FALSE

        ELSE
                            
            finished = TRUE

        ENDIF
        
    UNTIL finished
    
 
ENDROUTINE

{*******************************************************************************}

GLOBAL

ROUTINE lib_re_formula_find_results (       self     , 
                            context  ,  
                      VALUE function ,  
                            results  ,
                            units    )  

{
*
*
*******************************************************************************}

    DECLARE parameter    ,  
        next_pos     ,
        param_number ,
        error_status 

    ARRAY results                                   

    parameter = 1
    next_pos  = 1

    param_number = lib_re_formula_param_number ( self ) 

    IF param_number > 0 THEN

                WHILE parameter <= param_number DO
                
                    IF variable_is_assigned( self . parameters[parameter] . function ) THEN
                    
              { parameter is a function so do a recursive call }
              
                        lib_re_formula_calculate( self . parameters[parameter] ,
                                          context                      ,
                                          TRUE                         )
                        
                        IF NOT context . error THEN
                        
                        results[ next_pos , 2 ] = self . parameters[parameter] . value
                        results[ next_pos , 3 ] = self . parameters[parameter] . units
                        results[ next_pos , 4 ] = self . parameters[parameter] . inequality
                        
                        next_pos = next_pos + 1
                        
                        ENDIF
                        
                    ELSE
                                               
                                                
                IF context . read_script THEN

                    lib_re_formula_read_script_result ( self      ,
                                        context   ,
                                        parameter ,
                                        results   ,
                                        next_pos  ) 

                ELSEIF global ( "RESULT_REPLICATES_ENABLED" ) THEN

                    lib_re_formula_find_replicate_result ( self      ,
                                           context   ,
                                           parameter ,
                                           results   ,
                                           next_pos  )      


                ELSE                            


                    lib_re_formula_find_result ( self      ,
                                     context   ,
                                     parameter ,    
                                     results   ,
                                     next_pos  )        


                ENDIF
                
            ENDIF
            
            parameter = parameter + 1

        ENDWHILE
                                                
    ELSE

        lib_re_formula_runtime_error (  context           ,
                           "INCORRECT_PARAMS" ,
                        function          ,
                        param_number      )

    ENDIF

    { Set all the units to the same as the first results units }

    IF size_of_array ( results ) > 0 THEN

        units = results [ 1 , 3 ]

        self . parameters[ 1 ] . value       = results[ 1 , 2 ]
        self . parameters[ 1 ] . units      = results[ 1 , 3 ]
        self . parameters[ 1 ] . inequality = results[ 1 , 4 ]

    ELSE

        units = ""

    ENDIF

    next_pos = 2

    WHILE ( next_pos <= size_of_array ( results )         ) AND 
          ( ( context . mode = FORMULA_MODE_CALCULATE   ) OR
            ( context . mode = FORMULA_MODE_PRINT       ) OR
            ( context . mode = FORMULA_MODE_TEST_PHASE1 ) ) DO

        results [ next_pos, 2 ] = unit_convert ( results [ next_pos , 2 ] ,
                                         results [ next_pos , 3 ] ,
                                         units                    ,
                                         error_status             )

        self . parameters[ next_pos ] . value = results[ next_pos , 2 ]
        self . parameters[ next_pos ] . units = results[ next_pos , 3 ]
        self . parameters[ next_pos ] . inequality = results[ next_pos , 4 ]
                                         

        IF error_status <> EMPTY THEN

            lib_re_formula_runtime_error (  context      ,
                               "ERROR_UNITS" ,
                            message_get_text ( error_status,1)  ,
                            EMPTY        )

        ENDIF

        next_pos = next_pos + 1
 
    ENDWHILE

ENDROUTINE

{******************************************************************************}

ROUTINE lib_re_formula_inequalities_opposite ( VALUE eq1 ,
                               VALUE eq2 )

{
*   Take 2 inequalities, and return whether they are "opposite".
*   I.e. if one is < or <=, and the other is > or >=
*
*******************************************************************************}

    DECLARE ret_val

    IF ( eq1 = FORMULA_LT ) OR ( eq1 = FORMULA_LE ) THEN
        ret_val = ( ( eq2 = FORMULA_GT ) OR ( eq2 = FORMULA_GE ) )
    ELSEIF ( eq1 = FORMULA_GT ) OR ( eq1 = FORMULA_GE ) THEN
        ret_val = ( ( eq2 = FORMULA_LT ) OR ( eq2 = FORMULA_LE ) )
    ELSE
        ret_val = FALSE
    ENDIF

    RETURN ( ret_val )

ENDROUTINE

{******************************************************************************}

ROUTINE lib_re_formula_check_maximum (       inequality ,
                             answer     ,
                       VALUE eq1        ,
                       VALUE val1       ,
                       VALUE eq2        ,
                       VALUE val2       )

{
*   Take 2 inequalities and values, and calculate the appropriate maximum
*
*******************************************************************************}

    DECLARE higher_val , lower_eq , higher_eq

    higher_val  = find_max_number ( val1 , val2 )

    IF higher_val = val1 THEN
        IF val1 = val2 THEN
            lower_eq  = find_min_number ( eq1 , eq2 )
            higher_eq = find_max_number ( eq1 , eq2 )
        ELSE
            higher_eq = eq1
            lower_eq  = eq2
        ENDIF
    ELSE
        lower_eq  = eq1
        higher_eq = eq2
    ENDIF

    IF eq1 = eq2 THEN
        inequality = eq1
        answer     = higher_val
    ELSEIF lib_re_formula_inequalities_opposite ( eq1 , eq2 )
        inequality = ERROR
        IF ( eq1 = FORMULA_GT ) OR ( eq1 = FORMULA_GE ) THEN
            IF higher_eq = eq1 THEN
                inequality = eq1
                answer     = val1
            ENDIF
        ELSE
            IF higher_eq = eq2 THEN
                inequality = eq2
                answer     = val2
            ENDIF
        ENDIF
    ELSEIF higher_eq = FORMULA_GT THEN
        inequality = higher_eq
        answer     = higher_val
    ELSEIF higher_eq = FORMULA_GE THEN
        inequality = higher_eq
        answer     = higher_val
    ELSEIF lower_eq = FORMULA_LT THEN
        inequality = higher_eq
        answer     = higher_val
    ELSEIF lower_eq = FORMULA_LE THEN
        inequality = higher_eq
        answer     = higher_val
    ELSEIF higher_eq = FORMULA_EQ THEN
        inequality = FORMULA_GE
        answer     = higher_val
    ELSE
        inequality = ERROR
    ENDIF

ENDROUTINE

{******************************************************************************}

ROUTINE lib_re_formula_check_minimum (       inequality ,
                             answer     ,
                       VALUE eq1        ,
                       VALUE val1       ,
                       VALUE eq2        ,
                       VALUE val2       )

{
*   Take 2 inequalities and values, and calculate the appropriate minimum
*
*******************************************************************************}

    DECLARE lower_val , lower_eq , higher_eq

    lower_val  = find_min_number ( val1 , val2 )

    IF lower_val = val1 THEN
        IF val1 = val2 THEN
            lower_eq  = find_min_number ( eq1 , eq2 )
            higher_eq = find_max_number ( eq1 , eq2 )
        ELSE
            lower_eq  = eq1
            higher_eq = eq2
        ENDIF
    ELSE
        lower_eq  = eq2
        higher_eq = eq1
    ENDIF

    IF eq1 = eq2 THEN
        inequality = eq1
        answer = lower_val
    ELSEIF lib_re_formula_inequalities_opposite ( eq1 , eq2 )
        inequality = ERROR
        IF ( eq1 = FORMULA_LT ) OR ( eq1 = FORMULA_LE ) THEN
            IF lower_eq = eq1 THEN
                inequality = eq1
                answer     = val1
            ENDIF
        ELSE
            IF lower_eq = eq2 THEN
                inequality = eq2
                answer     = val2
            ENDIF
        ENDIF
    ELSEIF lower_eq = FORMULA_LT THEN
        inequality = lower_eq
        answer = lower_val
    ELSEIF lower_eq = FORMULA_LE THEN
        inequality = lower_eq
        answer = lower_val
    ELSEIF higher_eq = FORMULA_GT THEN
        inequality = lower_eq
        answer = lower_val
    ELSEIF higher_eq = FORMULA_GE THEN
        inequality = lower_eq
        answer = lower_val
    ELSEIF lower_eq = FORMULA_EQ THEN
        inequality = FORMULA_LE
        answer = lower_val
    ELSE
        inequality = ERROR
    ENDIF

ENDROUTINE

{******************************************************************************}

ROUTINE lib_re_formula_minimum_function ( self )

{
*
*
*******************************************************************************}

    DECLARE answer, count, result_number, result_inequality, result_units,
            units, error_status

    self . use_replicates = TRUE

    result_number = self . get_parameter_numeric()
    result_inequality = self . get_parameter_inequality()
    result_units = self . get_parameter_units()
    
    self . inequality = result_inequality
    answer            = result_number
    units = result_units

    count  = 2                                      

    WHILE ( count <= self . get_no_of_params()  ) AND
          ( NOT self . context . error                 ) DO     
          
            result_number = self . get_parameter_numeric()
            result_inequality = self . get_parameter_inequality()
            result_units = self . get_parameter_units()

        result_number = unit_convert( result_number ,
                                      result_units  ,
                                      units         ,
                                      error_status  )
                                      
        IF error_status <> EMPTY THEN

            lib_re_formula_runtime_error( self . context  ,
                              "ERROR_UNITS"   , 
                              message_get_text(
                              error_status,1) ,
                              EMPTY           )

        ELSE                                 

    
            lib_re_formula_check_minimum ( self . inequality ,
                               answer            ,
                               self . inequality ,
                               answer            ,
                               result_inequality ,
                               result_number     )


            IF self . inequality = ERROR THEN

                lib_re_formula_runtime_error
                        ( self .context         ,
                          "MISMATCH_EQUALS_MIN" ,
                          EMPTY                 ,
                          EMPTY                 )

            ENDIF  
            
        ENDIF

        count = count + 1

    ENDWHILE

    self . value      = answer
    self . units      = units

ENDROUTINE

{******************************************************************************}

ROUTINE lib_re_formula_maximum_function ( self )

{
*
*
*******************************************************************************}

    DECLARE answer, count, result_number, result_inequality, result_units,
            units, error_status

    self . use_replicates = TRUE

    result_number = self . get_parameter_numeric()
    result_inequality = self . get_parameter_inequality()
    result_units = self . get_parameter_units()
    
    self . inequality = result_inequality
    answer            = result_number
    units = result_units

    count  = 2                                      

    WHILE ( count <= self . get_no_of_params()  ) AND
          ( NOT self . context . error                 ) DO     
          
            result_number = self . get_parameter_numeric()
            result_inequality = self . get_parameter_inequality()
            result_units = self . get_parameter_units()

        result_number = unit_convert( result_number ,
                                      result_units  ,
                                      units         ,
                                      error_status  )
                                      
        IF error_status <> EMPTY THEN

            lib_re_formula_runtime_error( self . context  ,
                              "ERROR_UNITS"   , 
                              message_get_text(
                              error_status,1) ,
                              EMPTY           )

        ELSE                                 

    
            lib_re_formula_check_maximum ( self . inequality ,
                               answer            ,
                               self . inequality ,
                               answer            ,
                               result_inequality ,
                               result_number     )


            IF self . inequality = ERROR THEN

                lib_re_formula_runtime_error
                        ( self .context         ,
                          "MISMATCH_EQUALS_MAX" ,
                          EMPTY                 ,
                          EMPTY                 )

            ENDIF  
            
        ENDIF

        count = count + 1

    ENDWHILE

    self . value      = answer
    self . units      = units
    
ENDROUTINE

{*******************************************************************************}

ROUTINE lib_re_formula_sum_function ( self )

{
*
*
*******************************************************************************}

    DECLARE answer, count, result_number, result_inequality, result_units
            , error_status, units
        
    self . use_replicates = TRUE

    result_number = self . get_parameter_numeric()
    self . inequality = self . get_parameter_inequality()
    result_units = self . get_parameter_units()
    units = result_units
    answer            = result_number

    count  = 2                                      

    WHILE ( ( count <= self . get_no_of_params() ) AND
            ( NOT self . context . error         ) ) DO     
    
        result_number = self . get_parameter_numeric()
        result_inequality = self . get_parameter_inequality()
        result_units = self . get_parameter_units()
        

        result_number = unit_convert( result_number ,
                                      result_units  ,
                                      units         ,
                                      error_status  )
                                      
        IF error_status <> EMPTY THEN

            lib_re_formula_runtime_error( self . context  ,
                              "ERROR_UNITS"   , 
                              message_get_text(
                              error_status,1) ,
                              EMPTY           )

        ELSE                                 

            self . inequality = formula_inequalities [ self .  inequality ,
                                   result_inequality  ]

            IF self . inequality = ERROR THEN

                lib_re_formula_runtime_error (  self . context        ,
                                   "MISMATCH_EQUALS_SUM"  ,
                                EMPTY                 ,
                                EMPTY                 )
                                
            ELSE
            
                answer = answer + result_number 
                
            ENDIF
            
        ENDIF


        count = count + 1

    ENDWHILE

    self . value      = answer
    self . units      = units

ENDROUTINE

{*******************************************************************************}

ROUTINE lib_re_formula_average_function ( self )

{
*
*
*******************************************************************************}

    DECLARE answer, count, error_status, result_number, result_units, 
            result_inequality, units
        
    count  = 1                                      
    answer = 0

    self . use_replicates = TRUE
    
    self . inequality = FORMULA_EQ

    result_number = self . get_parameter_numeric()
    
    result_inequality = self . get_parameter_inequality()
        
    units = self . get_parameter_units()
    
    result_units = units
        
        self . inequality 
            = formula_inequalities [ self .  inequality ,
                         result_inequality         ]

        IF self . inequality = ERROR THEN

            lib_re_formula_runtime_error 
                    ( self . context        ,
                      "MISMATCH_EQUALS_AVG" ,
                      EMPTY                 ,
                      EMPTY                 )

        ENDIF
        
        result_number = unit_convert( result_number , 
                                      result_units  ,
                                      units         ,
                                      error_status  )
                                       
        IF error_status <> EMPTY THEN
        
            lib_re_formula_runtime_error( self . context  ,
                                          "ERROR_UNITS"   , 
                                          message_get_text(
                                          error_status,1) ,
                                          EMPTY           )
                                          
        ENDIF                                        

        answer = answer + result_number
        
        count = count + 1

    WHILE ( count <= self . get_no_of_params() ) AND
          ( NOT self . context . error )                 DO     

        result_number = self . get_parameter_numeric()
         
        result_inequality = self . get_parameter_inequality()
        
        result_units = self . get_parameter_units()

        self . inequality 
            = formula_inequalities [ self .  inequality ,
                         result_inequality         ]

        IF self . inequality = ERROR THEN

            lib_re_formula_runtime_error 
                    ( self . context        ,
                      "MISMATCH_EQUALS_AVG" ,
                      EMPTY                 ,
                      EMPTY                 )

        ENDIF
        
        result_number = unit_convert( result_number , 
                                      result_units  ,
                                      units         ,
                                      error_status  )
                                       
        IF error_status <> EMPTY THEN
        
            lib_re_formula_runtime_error( self . context  ,
                                          "ERROR_UNITS"   , 
                                          message_get_text(
                                          error_status,1) ,
                                          EMPTY           )
                                          
        ENDIF                                        

        answer = answer + result_number

        count = count + 1
        

    ENDWHILE

    count = count - 1

    answer = answer / count

    self . value      = answer
    self . units      = units

ENDROUTINE

ROUTINE lib_re_formula_standard_function ( self )
{******************************************************************************
*******************************************************************************}

    DECLARE answer, standard_id, versions, component, found, standard_date, context
        
    self.set_parameter_count_check_off()
    context = self.context
    IF (context.mode = FORMULA_MODE_CALCULATE) OR
       (context.mode = FORMULA_MODE_PRINT) OR
       (context.mode = FORMULA_MODE_TEST_PHASE1) THEN
        found = FALSE
        IF lib_re_formula_param_number (self) = 3 THEN
            ARRAY versions
            standard_id   = lib_re_formula_parameter_text (self, 1, context)
            versions[1]   = lib_re_formula_parameter_text (self, 2, context)
            component     = lib_re_formula_parameter_text (self, 3, context)
        ELSE
            standard_id   = lib_re_formula_parameter_text (self, 1, context)
            component     = lib_re_formula_parameter_text (self, 2, context)
            standard_date = std_user_formula_date (standard_id, component, context)       
            std_vers_get_versions_on_date (standard_id, standard_date, versions) 
        ENDIF

        IF context.read_script THEN
            formula_script_read_standard (context, standard_id, self.value, self.units)
            self.inequality = FORMULA_EQ                          
        ELSEIF versions [1] <> EMPTY THEN
            IF BLANK (standard_id) THEN
                lib_re_formula_runtime_error (context, "NOT_A_STANDARD", EMPTY, EMPTY)
            ELSE
                answer = SELECT standard_concentration.amount 
                         WHERE (identity = standard_id) AND
                           (version  = versions [1]) AND
                           (name     = component)    
                IF answer <> EMPTY THEN
                    self.value = answer
                    self.units = SELECT standard_concentration.units
                    self.inequality = FORMULA_EQ
                    found = TRUE
                ELSE                          
                    SET FORMAT "999"
                    lib_re_formula_runtime_error (context, "NO_STAND_COMP", component, strip (standard_id) : "/" :                                        strip (versions [1]))
                ENDIF
            ENDIF
        ELSE
            lib_re_formula_runtime_error (context, "NO_STANDARD", standard_id, EMPTY)
        ENDIF

        IF (context.mode = FORMULA_MODE_PRINT) AND
           (NOT context.error) THEN 
            lib_re_formula_print_standard (standard_id, versions [1], component, found, self)
        ENDIF
    ELSE
        self.value      = 1.0               
        self.units      = ""
        self.inequality = FORMULA_EQ  
    ENDIF   

ENDROUTINE

{*******************************************************************************}

ROUTINE lib_re_formula_category_function ( self )

{
*
*                                                       
*******************************************************************************}
                                                      
    DECLARE name     ,
        category ,
        context
        
    self . set_parameter_count_check_off()

    context = self . context

    IF lib_re_formula_param_number ( self ) = 1 THEN

        IF ( context . mode = FORMULA_MODE_TEST_PHASE1 ) THEN

            name = "category"

        ELSE

            name = context . result_object . name
            lib_comp_get_base ( name )

        ENDIF

        category = lib_re_formula_parameter_numeric ( self    ,
                                  1       ,
                                  context )     

        self . value = lib_comp_add_category ( name     ,
                                               category ,
                                               EMPTY    )   
        
        self . units      = ""
        self . inequality = FORMULA_EQ      
                                                      
    ELSE

        lib_re_formula_runtime_error (  context           ,
                           "INCORRECT_PARAMS" ,
                           "CATEGORY"         ,
                            lib_re_formula_param_number ( self )      )

    ENDIF

ENDROUTINE


{*******************************************************************************}

ROUTINE lib_re_formula_abs_function ( self )
                                                        
{                                                     
*
*
*******************************************************************************}

    DECLARE answer

    answer   = self . get_parameter_numeric()

    IF answer < 0 THEN

        answer = -1 * answer 

    ENDIF                                 

    self . value      = answer
    self . units = self . get_parameter_units()
    self . inequality = FORMULA_EQ      

ENDROUTINE

{*******************************************************************************}

ROUTINE lib_re_formula_arcsin_function ( self )

{
*
*
*******************************************************************************}

    DECLARE answer
            
    answer   = self . get_parameter_numeric()
    
    answer   = arcsin ( answer )

    self . value      = answer
    self . units      = "deg"
    self . inequality = FORMULA_EQ      


ENDROUTINE

{*******************************************************************************}

ROUTINE lib_re_formula_cos_function ( self )

{
*
*
*******************************************************************************}

    DECLARE answer
            
    answer   = self . get_parameter_numeric()

    IF lib_re_formula_trig_parameter ( self, self . context, answer ) THEN

        answer = cos ( answer )

        self . value      = answer
        self . units      = ""
        self . inequality = FORMULA_EQ      

    ENDIF

ENDROUTINE

{*******************************************************************************}

ROUTINE lib_re_formula_exp_function ( self )

{
*
*
*******************************************************************************}

    DECLARE answer
                                                                  
    answer   = self . get_parameter_numeric()

    answer = exp ( answer )

    self . value      = answer
    self . units      = ""
    self . inequality = FORMULA_EQ      

ENDROUTINE

{*******************************************************************************}

ROUTINE lib_re_formula_ln_function ( self )

{
*
*
*******************************************************************************}
                                                      
    DECLARE answer
            
    answer   = self . get_parameter_numeric()


    answer = ln ( answer )

    self . value      = answer
    self . units      = ""
    self . inequality = FORMULA_EQ      

ENDROUTINE

{*******************************************************************************}

ROUTINE lib_re_formula_round_function ( self )

{
*
*                                                     
*******************************************************************************}

    DECLARE answer
            
    answer   = self . get_parameter_numeric()


    answer            = round ( answer )
    self . inequality = FORMULA_EQ      
    self . value      = answer

    IF NOT variable_is_assigned ( self . units ) THEN
        self . units = ""
    ENDIF
                                                      
ENDROUTINE

{*******************************************************************************}

ROUTINE lib_re_formula_sin_function ( self )

{
*                                                     
*
*******************************************************************************}

    DECLARE answer
    
    answer   = self . get_parameter_numeric()


    IF lib_re_formula_trig_parameter ( self, self . context, answer ) THEN

        answer = sin ( answer )

        self . value      = answer
        self . units      = ""
        self . inequality = FORMULA_EQ      

    ENDIF

ENDROUTINE

{*******************************************************************************}

ROUTINE lib_re_formula_tan_function ( self )
                                                        
{
*
*
*******************************************************************************}

    DECLARE answer
    
    answer   = self . get_parameter_numeric()

    IF lib_re_formula_trig_parameter ( self, self . context, answer ) THEN

        answer = tan ( answer )

        self . value      = answer              
        self . units      = ""
        self . inequality = FORMULA_EQ      

    ENDIF

ENDROUTINE

{*******************************************************************************}
                                                        
ROUTINE lib_re_formula_arccos_function ( self )

{
*
*
*******************************************************************************}

    DECLARE answer
    
    answer   = self . get_parameter_numeric()

    answer = arccos ( answer )              

    self . value      = answer
    self . units      = "deg"
    self . inequality = FORMULA_EQ      

ENDROUTINE

{*******************************************************************************}
                                                        
ROUTINE lib_re_formula_arctan_function ( self )

{
*
*
*******************************************************************************}

    DECLARE answer
    
    answer   = self . get_parameter_numeric()

    answer = arctan ( answer )              

    self . value      = answer
    self . units      = "deg"
    self . inequality = FORMULA_EQ      

ENDROUTINE

{*******************************************************************************}

ROUTINE lib_re_formula_log_function ( self )

{
*
*
*******************************************************************************}

    DECLARE answer
    
    answer   = self . get_parameter_numeric()
                                                        

    answer = log ( answer )

    self . value      = answer
    self . units      = ""
    self . inequality = FORMULA_EQ      

ENDROUTINE                                              

{*******************************************************************************}

ROUTINE lib_re_formula_random_function ( self )

{
*
*
*******************************************************************************}

    DECLARE answer
    
    answer   = self . get_parameter_numeric()
    
    answer = random ( answer )

    self . value      = answer
    self . units      = ""
    self . inequality = FORMULA_EQ      

ENDROUTINE

{*******************************************************************************}

ROUTINE lib_re_formula_sqrt_function ( self )

{
*
*
*******************************************************************************}

    DECLARE answer
    
    answer   = self . get_parameter_numeric()


    answer = sqrt ( answer )

    self . value      = answer
    self . units      = ""
    self . inequality = FORMULA_EQ      

ENDROUTINE

{*******************************************************************************}

ROUTINE lib_re_formula_trunc_function ( self )

{
*
*
*******************************************************************************}

    DECLARE answer
    
    answer   = self . get_parameter_numeric()

    answer = trunc ( answer )

    self . value      = answer
    self . units      = ""
    self . inequality = FORMULA_EQ      

ENDROUTINE

{*******************************************************************************}

ROUTINE lib_re_formula_iif_function ( self )

{
*
*                                                     
*******************************************************************************}

    DECLARE answer

    answer = self . get_parameter_bool()

    IF answer THEN

        answer = lib_re_formula_parameter( self           ,
                                           2              ,
                                           self . context )

    ELSE

        answer = lib_re_formula_parameter( self           ,
                                           3              ,
                                           self . context )

    ENDIF

    self . params_called = 3

    self . value      = answer
    self . units      = ""
    self . inequality = FORMULA_EQ

ENDROUTINE

{*******************************************************************************}
                
ROUTINE lib_re_formula_result_field_function ( self )

{
*
*
*******************************************************************************}

    DECLARE test_number     ,
        name            ,                       
        field_name      ,
        result_object   ,
        file_descriptor ,
        answer          ,
        context
        
    self . set_parameter_count_check_off()

    context = self . context

    answer = ""
                
    IF lib_re_formula_param_number ( self ) = 1 THEN
        
                test_number = ""
        name        = ""
        field_name  = lib_re_formula_parameter_text ( self    ,
                                  1       ,
                                  context )     

    ELSEIF lib_re_formula_param_number ( self ) = 2 THEN

                test_number = ""
        name        = lib_re_formula_parameter_text ( self    ,
                                  1       ,
                                  context )     
        field_name  = lib_re_formula_parameter_text ( self    ,
                                  2       ,
                                  context )     

    ELSEIF lib_re_formula_param_number ( self ) = 3 THEN

        test_number = lib_re_formula_parameter_text ( self    ,
                                  1       ,
                                  context )     
        name        = lib_re_formula_parameter_text ( self    ,
                                  2       ,
                                  context )     
        field_name  = lib_re_formula_parameter_text ( self    ,
                                  3       ,
                                  context )     

    ELSE

        lib_re_formula_runtime_error (  context           ,
                           "INCORRECT_PARAMS" ,
                           "RESULT_FIELD"     ,
                        lib_re_formula_param_number ( self )      )
                                                        
    ENDIF
    
    IF ( NOT context . error ) THEN

        IF NOT valid_field ( "RESULT" , field_name ) THEN

            lib_re_formula_runtime_error (  context          ,
                               "INV_RESULTFIELD" ,
                            field_name       ,
                            EMPTY            )

        ENDIF

    ENDIF

    IF ( context . error ) THEN

        { Error already signalled }

    ELSEIF context  . read_script THEN                  

        formula_script_read_field (  context    ,
                        "RESULT"    ,
                         field_name ,   
                         answer     )
                    

    ELSEIF ( context . mode = FORMULA_MODE_TEST_PHASE1 ) THEN

        lib_re_formula_prompt_table_field ( test_number : name ,
                                            "RESULT"           ,
                                            field_name         ,
                                            answer             )

    ELSEIF ( context . mode <> FORMULA_MODE_VALIDATE ) THEN 


        IF blank ( test_number ) THEN

            test_number = context . test_number

        ENDIF                                   
    
        IF blank ( name ) THEN                  

            name = context . result_object . name

        ENDIF
                                                      
        IF NOT lib_comp_has_replicate ( name ) THEN

            name = lib_comp_add_replicate ( name , 1 )

        ENDIF
                                                        
        result_object = context . result_context . get_result ( test_number ,   
                                                                    name )

        IF result_object = EMPTY THEN

            IF  (( context . mode = FORMULA_MODE_CALCULATE )  OR
                 ( context . mode = FORMULA_MODE_PRINT     )) AND
                (  NUMTEXT ( test_number )                  ) THEN

                push_file_descriptor ( "RESULT"         ,
                            file_descriptor )
    
                answer = SELECT result . 'field_name' 
                     WHERE test_number = test_number
                                         AND   name        = name
                        
                pop_file_descriptor ( file_descriptor )

                IF answer = EMPTY THEN

                    lib_re_formula_runtime_error (  context          ,
                                        "RESULT_NOTFOUND",
                                    name             ,
                                    EMPTY            )
    
                ENDIF

            ELSEIF  (( context . mode = FORMULA_MODE_CALCULATE )  OR
                     ( context . mode = FORMULA_MODE_PRINT     )) AND
                    (  NOT NUMTEXT ( test_number )              ) THEN

                lib_re_formula_runtime_error (  context      ,
                                    "BADTEST"    ,
                                test_number  ,
                                EMPTY        )
                                                      
            ENDIF
                                        
        ELSE
            IF context . mode = FORMULA_MODE_BIND THEN

                result_object . used_in_formula 
                        ( context . result_object )
                                        
            ELSE

                answer = SELECT result . 'field_name'
                     IN OBJECT result_object

            ENDIF

        ENDIF
                                                          
    ENDIF
                                                        
    self . text  = answer
    self . value = answer

    IF ( variable_get_type ( answer ) = "Text" ) AND
       ( numtext ( answer )                    ) AND
       ( context . mode <> FORMULA_MODE_BIND   ) THEN

        self . value = numeric ( answer )     

    ENDIF

    self . units      = ""
    self . inequality = FORMULA_EQ      
                     
    IF context . mode = FORMULA_MODE_PRINT THEN
    
        lib_re_formula_print_field (  self       ,
                          context    ,
                         "RESULT"    ,  
                          field_name ,
                          answer     )  

    ENDIF

ENDROUTINE                                            

{*******************************************************************************}
                                                
ROUTINE lib_re_formula_test_field_function ( self )

{
*
*
*******************************************************************************}

    DECLARE test_number     ,                       
        field_name      ,
        file_descriptor ,
        answer          ,
        context
        
    self . set_parameter_count_check_off()

    context = self . context

    answer = ""

    IF lib_re_formula_param_number ( self ) = 1 THEN
        
                test_number = ""
        field_name  = lib_re_formula_parameter_text ( self    ,
                                  1       ,
                                  context )     

    ELSEIF lib_re_formula_param_number ( self ) = 2 THEN

        test_number = lib_re_formula_parameter_text ( self    ,
                                  1       ,
                                  context )     
        field_name  = lib_re_formula_parameter_text ( self    ,
                                  2       ,
                                  context )     

    ELSE

        lib_re_formula_runtime_error (  context           ,
                           "INCORRECT_PARAMS" ,
                           "TEST_FIELD"       ,
                        lib_re_formula_param_number ( self )      )

    ENDIF
    
    IF ( NOT context . error ) THEN

        IF NOT valid_field ( "TEST" , field_name ) THEN

            lib_re_formula_runtime_error (  context        ,
                               "INV_TESTFIELD" ,
                            field_name     ,
                            EMPTY          )

        ENDIF

    ENDIF

    IF ( context . error ) THEN

        { Error already signalled }

    ELSEIF context  . read_script THEN

        formula_script_read_field (  context    ,
                        "TEST"      ,
                         field_name ,   
                         answer     )

    ELSEIF ( context . mode = FORMULA_MODE_TEST_PHASE1 ) THEN

        lib_re_formula_prompt_table_field ( test_number ,
                                            "TEST"      ,
                                            field_name  ,
                                            answer      )

    ELSEIF ( context . mode <> FORMULA_MODE_VALIDATE ) THEN 

        IF NOT blank ( test_number ) THEN
    
            IF ( context . mode <> FORMULA_MODE_VALIDATE ) THEN

                push_file_descriptor ( "TEST"           ,
                            file_descriptor )

                                                        
                IF test_number <> NULL THEN

                    answer = SELECT test . 'field_name' 
                         WHERE ( test_number = test_number ) 

                ELSE
                               
                    answer = NULL

                ENDIF                

                pop_file_descriptor ( file_descriptor )

                IF answer = EMPTY THEN

                    lib_re_formula_runtime_error (  context        ,
                                       "TEST_NOTFOUND" ,
                                    test_number    ,
                                    EMPTY          )

  
                ENDIF

            ENDIF
                                    
        ELSE

            answer = SELECT test . 'field_name'
                     IN OBJECT context . result_object . test_object

        ENDIF

    ENDIF
                                                        
    self . text       = answer

    self . units      = ""
    self . inequality = FORMULA_EQ              


    IF context . mode = FORMULA_MODE_PRINT THEN
                                                
        lib_re_formula_print_field (  self       ,
                          context    ,  
                         "TEST"      ,  
                          field_name ,
                          answer     )  

    ENDIF

ENDROUTINE

{*******************************************************************************}

ROUTINE lib_re_formula_units_function ( self )

{
*
*
*******************************************************************************}

    DECLARE units   ,
        answer  ,
        context
        
    self . set_parameter_count_check_off()

    context = self . context

    IF lib_re_formula_param_number ( self ) = 2 THEN

        answer = lib_re_formula_parameter_numeric ( self    ,
                                1       ,
                                context )
        
        units  = lib_re_formula_parameter_text ( self    ,
                             2       ,
                             context )

        self . value      = answer
        self . units      = units

    ELSE

        lib_re_formula_runtime_error (  context           ,
                           "INCORRECT_PARAMS" ,
                           "UNITS"            ,
                        lib_re_formula_param_number ( self )      )

    ENDIF
    
ENDROUTINE

{*******************************************************************************}

ROUTINE lib_re_formula_use_function ( self )

{
*
*
*******************************************************************************}

    DECLARE temp

    self . set_parameter_count_check_off()

    temp = self . parameters [ 1 ]

    self . inequality = temp . inequality

    IF variable_is_assigned ( temp . value ) THEN

        self . value      = temp . value

    ENDIF

    IF variable_is_assigned ( temp . text ) THEN

        self . text      = temp . text

    ENDIF

    self . units      = temp . units 

ENDROUTINE

{*******************************************************************************}

ROUTINE lib_re_formula_inst_param_function ( self )

{
*
*
*******************************************************************************}

    DECLARE param_name      ,
            file_descriptor ,
        answer          ,
        context         ,
        inst_id         ,
        units

    self . set_parameter_count_check_off()

    context = self . context

    answer  = ""
    units   = ""
    inst_id = ""

    IF lib_re_formula_param_number ( self ) = 1 THEN
        
        param_name  = lib_re_formula_parameter_text ( self    ,
                                  1       ,
                                  context )     

    ELSE

        lib_re_formula_runtime_error (  context           ,
                           "INCORRECT_PARAMS" ,
                           "INST_PARAM"       ,
                        lib_re_formula_param_number ( self )      )

    ENDIF

    IF ( context . error ) THEN

        { Error already signalled }

    ELSEIF context  . read_script THEN

        formula_script_read_inst_param ( param_name ,
                             answer     ,
                             units      )

    ELSEIF ( context . mode = FORMULA_MODE_TEST_PHASE1 ) THEN

        lib_re_formula_prompt_inst_param ( param_name   ,
                                           answer       )

    ELSEIF ( context . mode <> FORMULA_MODE_VALIDATE ) THEN 

        push_file_descriptor ( "INSTRUMENT", file_descriptor )

        inst_id = SELECT test . instrument
                 IN OBJECT context . result_object . test_object

        answer = SELECT instrument_property . value
             WHERE ( instrument = inst_id ) AND
                   ( identity   = param_name )

        units = SELECT instrument_property . units

        pop_file_descriptor ( file_descriptor )

        IF answer = EMPTY THEN

            lib_re_formula_runtime_error (  context               ,
                               "INST_PARAM_NOT_FOUND" ,
                            param_name            ,
                            inst_id               )
  
        ENDIF

    ENDIF
                                                        
    self . text = answer
    
    IF NUMTEXT ( answer ) THEN
        self . value = NUMERIC ( answer )
    ENDIF

    self . units = units
    self . inequality = FORMULA_EQ              

    IF context . mode = FORMULA_MODE_PRINT THEN
                                                
        lib_re_formula_print_inst_param ( inst_id    ,
                                          param_name ,
                              answer     ,
                              units      )

    ENDIF

ENDROUTINE

{*******************************************************************************}

ROUTINE lib_re_formula_stock_param_function ( self )

{
*
*
*******************************************************************************}

    DECLARE param_name         ,
            file_descriptor_s  ,
            file_descriptor_sb ,
        answer             ,
        context            ,
        test_num           ,
        stock_id           ,
        stock_batch        ,
        units

    self . set_parameter_count_check_off()

    context = self . context

    answer   = ""
    units    = ""
    stock_id = ""

    IF lib_re_formula_param_number ( self ) = 2 THEN
        
        stock_id    = lib_re_formula_parameter_text ( self    ,
                                  1       ,
                                  context )     

        param_name  = lib_re_formula_parameter_text ( self    ,
                                  2       ,
                                  context )     

    ELSE

        lib_re_formula_runtime_error (  context           ,
                           "INCORRECT_PARAMS" ,
                           "STOCK_PARAM"      ,
                        lib_re_formula_param_number ( self )      )

    ENDIF

    IF ( context . error ) THEN

        { Error already signalled }

    ELSEIF context  . read_script THEN

        formula_script_read_stock_param ( stock_id   ,
                              param_name ,
                              answer     ,
                              units      )

    ELSEIF ( context . mode = FORMULA_MODE_TEST_PHASE1 ) THEN

        lib_re_formula_prompt_stock_param ( param_name   ,
                                            answer       )

    ELSEIF ( context . mode <> FORMULA_MODE_VALIDATE ) THEN 

        push_file_descriptor ( "STOCK_INVENTORY",      file_descriptor_s  )
        push_file_descriptor ( "STOCK_BATCH_PROPERTY", file_descriptor_sb )

        test_num = SELECT test . test_number
                          IN OBJECT context . result_object . test_object

        stock_batch = SELECT stock_inventory . stock_batch
                      WHERE  stock = stock_id AND
                             test  = test_num
                     
        IF stock_batch <> EMPTY THEN

            answer = SELECT stock_batch_property . value
                 WHERE ( stock       = stock_id    ) AND
                           ( stock_batch = stock_batch ) AND
                       ( identity     = param_name )

            units = SELECT stock_batch_property . units

            IF answer = EMPTY THEN

                lib_re_formula_runtime_error (  context                                         ,
                                   "STOCK_PARAM_NOT_FOUND"                          ,
                                param_name                                      ,
                                STRIP ( stock_id ) : "/" : STRIP ( stock_batch ))

            ENDIF

        ELSE

            answer = EMPTY
            lib_re_formula_runtime_error (  context                ,
                               "STOCK_BATCH_NOT_FOUND" ,
                            stock_batch            ,
                            stock_id               )

        ENDIF

        pop_file_descriptor ( file_descriptor_s  )
        pop_file_descriptor ( file_descriptor_sb )

    ENDIF
                                                        
    self . text = answer
    
    IF NUMTEXT ( answer ) THEN
        self . value = NUMERIC ( answer )
    ENDIF

    self . units = units
    self . inequality = FORMULA_EQ              

    IF context . mode = FORMULA_MODE_PRINT THEN
                                                
        lib_re_formula_print_stock_param ( stock_id    ,
                                           stock_batch ,
                                           param_name  ,
                               answer      ,
                               units       )

    ENDIF

ENDROUTINE

{*******************************************************************************}

ROUTINE lib_re_formula_trig_parameter ( self, context, answer )

{
*   Convert Trig Function Parameters to the correct units.
*
*******************************************************************************}

    DECLARE success, error_status, message

    IF context . error THEN

        success = FALSE

    ELSEIF BLANK ( self . units ) OR ( self . units = "deg" ) THEN

        success = TRUE

    ELSE

        answer = unit_convert ( answer, self . units, 
                                "deg" , error_status )

        IF error_status <> EMPTY THEN

            message = message_get_text ( error_status, 1 )

            lib_re_formula_runtime_error (  context           ,
                               "ERROR_UNITS_TRIG" ,
                                    message           ,
                                    EMPTY             )

        ENDIF

        success = ( error_status = EMPTY )

    ENDIF

    RETURN ( success )

ENDROUTINE

{*******************************************************************************}

ROUTINE lib_re_formula_addition ( self    ,
                      context ,
                      left    ,
                  right   )

{
*
*
*******************************************************************************}

    DECLARE error_status

    IF NOT context . error THEN

        self . inequality = formula_inequalities [ left .  inequality  ,
                                   right . inequality ]

        IF self . inequality = ERROR THEN
    
            lib_re_formula_inequality_error ( context      ,
                              "MISMATCH_EQUALS_PLUS" ,
                              left         ,
                              right        )


        ENDIF

        IF left . units <> right . units THEN

            right . value = unit_convert ( right . value  ,
                               right . units  ,
                               left  . units  ,
                               error_status   )             

            right . units = left . units

            IF error_status <> EMPTY THEN

                lib_re_formula_runtime_error (  context           ,
                                   "ERROR_UNITS_PLUS" ,
                                        message_get_text ( error_status , 1) ,
                                        EMPTY             )

            ENDIF

            self . units = left . units

        ELSE
        
            self . units = left . units

        ENDIF

        self . value = left . value + right . value 
            
    ENDIF

ENDROUTINE

{*******************************************************************************}

ROUTINE lib_re_formula_subtraction ( self    ,
                     context ,
                     left    ,
                     right   )

{
*
*
*******************************************************************************}

    DECLARE error_status

    IF NOT context . error THEN

        self . inequality = formula_inequalities_1 [ left  . inequality  ,
                                     right . inequality ]

        IF self . inequality = ERROR THEN
    
            lib_re_formula_inequality_error ( context               ,
                              "MISMATCH_EQUALS_SUB" ,
                              left         ,
                              right        )

        ENDIF

        IF left . units <> right . units THEN

            right . value = unit_convert ( right . value  ,
                               right . units  ,
                               left . units   ,
                               error_status )           
                
            self . units       = left . units

            IF error_status <> EMPTY THEN

                lib_re_formula_runtime_error (  context                             ,
                                   "ERROR_UNITS_SUB"                    ,
                                    message_get_text ( error_status,1)  ,
                                        EMPTY                               )

            ENDIF

        ELSE
        
            self . units = left . units

        ENDIF

        self . value = left . value - right . value 
            
    ENDIF

ENDROUTINE

{*******************************************************************************}

ROUTINE lib_re_formula_comparison ( self    ,
                                    context ,
                                    left    ,
                                    right   )

{
*
*
*******************************************************************************}

    DECLARE error_status

    IF NOT context . error THEN

        self . inequality = formula_inequalities_1 [ left  . inequality  ,
                                                     right . inequality ]

        IF self . inequality = ERROR THEN
    
            lib_re_formula_inequality_error ( context               ,
                              "MISMATCH_EQUALS_SUB" ,
                              left         ,
                              right        )

        ENDIF

        IF left . units <> right . units THEN

            right . value = unit_convert ( right . value  ,
                               right . units  ,
                               left . units   ,
                               error_status )

            IF error_status <> EMPTY THEN

                lib_re_formula_runtime_error (  context                             ,
                                   "ERROR_UNITS_SUB"                    ,
                                    message_get_text ( error_status,1)  ,
                                        EMPTY                               )

            ENDIF

        ENDIF

        IF self . function = FORMULA_COMP_EQUAL THEN

            self . value = ( left . value = right . value )

        ELSEIF self . function = FORMULA_COMP_NOT_EQUAL THEN

            self . value = ( left . value <> right . value )

        ELSEIF self . function = FORMULA_COMP_LESS THEN

            self . value = ( left . value < right . value )

        ELSEIF self . function = FORMULA_COMP_LESS_OR_EQUAL THEN

            self . value = ( left . value <= right . value )

        ELSEIF self . function = FORMULA_COMP_GREATER THEN

            self . value = ( left . value > right . value )

        ELSEIF self . function = FORMULA_COMP_GREATER_OR_EQUAL THEN

            self . value = ( left . value >= right . value )

        ENDIF

        self . units = ""

    ENDIF

ENDROUTINE

{*******************************************************************************}

ROUTINE lib_re_formula_multiplication ( self    ,
                        context ,
                                        left    ,
                    right   )
{
*
*
*******************************************************************************}
                                                

    IF NOT context . error THEN

        self . inequality = formula_inequalities [ left  . inequality  ,
                                   right . inequality ]

        IF self . inequality = ERROR THEN
    
            lib_re_formula_inequality_error ( context                ,
                              "MISMATCH_EQUALS_MULT" ,
                              left         ,
                              right        )

        ENDIF

        IF blank ( left . units ) THEN
                
            self . units = right . units

        ELSEIF blank ( right . units ) THEN

            self . units = left . units

        ELSE

            self . units = "(" : strip ( left . units  ) : ")" :
                       "*" :
                       "(" : strip ( right . units ) : ")"


        ENDIF

        self . value = left . value * right . value 
            
    ENDIF

ENDROUTINE

{*******************************************************************************}

ROUTINE lib_re_formula_division ( self    ,
                              context ,
                  left    ,
                  right   )

{
*
*
*******************************************************************************}

    IF NOT context . error THEN

        self . inequality = formula_inequalities_1 [ left  . inequality  ,
                                            right . inequality ]

        IF self . inequality = ERROR THEN
    
            lib_re_formula_inequality_error ( context               ,
                              "MISMATCH_EQUALS_DIV" ,
                              left         ,
                              right        )


        ENDIF
        
        IF blank ( left . units  ) AND
           blank ( right . units ) THEN 

            self . units = ""       

        ELSEIF blank ( left . units ) THEN
                
            self . units = "1/(" : strip ( right . units ) : ")"

        ELSEIF blank ( right . units ) THEN

            self . units = left . units

        ELSE

            self . units = "(" : strip ( left . units ) : ")" :
                       "/" :
                       "(" : strip ( right . units ) : ")"


        ENDIF

        IF ( context . mode = FORMULA_MODE_CALCULATE   ) OR
           ( context . mode = FORMULA_MODE_PRINT       ) OR
           ( context . mode = FORMULA_MODE_TEST_PHASE1 ) THEN

                IF right . value <> 0.0 THEN

                    self . value = left . value / right . value 
                ELSE

                    lib_re_formula_runtime_error ( context        ,
                                       "DIVISION_ZERO",
                                    EMPTY         ,
                                    EMPTY         ) 

                ENDIF

        ELSE                            

            self . value = 1.0

        ENDIF

    ENDIF

ENDROUTINE

{*******************************************************************************}

ROUTINE lib_re_formula_power ( self    ,
                           context ,
                   left    ,
                   right   )

{
*
*
*******************************************************************************}

    IF NOT context . error THEN

        IF ( context . mode = FORMULA_MODE_CALCULATE   ) OR
           ( context . mode = FORMULA_MODE_PRINT       ) OR
           ( context . mode = FORMULA_MODE_TEST_PHASE1 ) THEN

            self . units      = left . units
            self . inequality = left . inequality
        
            self . value      = left . value ^ right . value

        ELSE

            self . value      = 1.0      
            self . units      = ""
            self . inequality = FORMULA_EQ
            
        ENDIF

    ENDIF

ENDROUTINE

{*******************************************************************************}

GLOBAL ROUTINE lib_re_formula_calculate (       self           ,
                                context        ,
                          VALUE text_is_result )

{
*
*
*******************************************************************************}
    
    DECLARE expression, component_name

    IF self . operand = FORMULA_NUMBER THEN
                    
        IF context . mode = FORMULA_MODE_VALIDATE THEN
                                                            
            { Don't want to declare these things
              everytime we go into this routine }

            DECLARE std_string ,
                is_scalar  ,
                message

            IF NOT blank ( self . units ) THEN

                IF NOT unit_validate ( self . units ,
                               std_string   ,
                               is_scalar    ,
                                   message      ) THEN                       

                    flash_message ( message_get_text ( message , 1 ) ,
                            TRUE                             )                     

                ENDIF

            ENDIF                                                   

        ENDIF                        

        self . in_equality = FORMULA_EQ

    ELSEIF self . operand = FORMULA_TEXT THEN
        

        IF text_is_result THEN

            CREATE OBJECT STD_FORMULA_EXPRESSION, expression

            expression . operand  = FORMULA_TEXT
                    expression . text     = self . text 

                    component_name = self . text

            ARRAY self . parameters 

            self . operand  = FORMULA_FUNCTION
            self . function = lib_re_formula_find_function( "RESULT" )
            self . text     = EMPTY 

            self . parameters [ 1 ] = expression

            lib_re_formula_calculate ( self           ,
                           context        ,
                           text_is_result ) 

            lib_re_formula_add_replicates( self , context , component_name )
            
        ELSE

            self . in_equality = FORMULA_EQ
            self . units       = ""

        ENDIF

    ELSEIF self . operand = FORMULA_PLUS THEN

        lib_re_formula_calculate ( self . left ,
                           context     ,
                       TRUE        )

        lib_re_formula_calculate ( self . right ,
                           context      ,
                       TRUE         )

        lib_re_formula_addition ( self         ,
                      context      ,
                      self . left  ,
                      self . right )

    ELSEIF self . operand = FORMULA_MINUS THEN


        lib_re_formula_calculate ( self . left ,
                           context     ,
                       TRUE        )    

        lib_re_formula_calculate ( self . right ,
                           context      ,
                       TRUE         )   

        lib_re_formula_subtraction ( self         ,
                             context      ,
                             self . left  ,
                             self . right )

    ELSEIF self . operand = FORMULA_COMPARISON THEN

        lib_re_formula_calculate ( self . left ,
                           context     ,
                       TRUE        )

        lib_re_formula_calculate ( self . right ,
                           context      ,
                       TRUE         )

        lib_re_formula_comparison ( self         ,
                            context      ,
                            self . left  ,
                            self . right )

    ELSEIF self . operand = FORMULA_MULTIPLY THEN

        lib_re_formula_calculate ( self . left ,
                           context     ,
                       TRUE        )    

        lib_re_formula_calculate ( self . right ,
                           context      ,
                       TRUE         )   

        lib_re_formula_multiplication ( self         ,
                            context      ,
                            self . left  ,
                            self . right )


    ELSEIF self . operand = FORMULA_DIVIDE THEN


        lib_re_formula_calculate ( self . left ,
                           context     ,
                       TRUE        )    

        lib_re_formula_calculate ( self . right ,
                           context      ,
                       TRUE         )

        lib_re_formula_division ( self         ,
                          context      ,
                          self . left  ,
                          self . right )

    ELSEIF self . operand = FORMULA_FUNCTION THEN
        
        IF NOT context . error THEN

            lib_re_formula_call_function( self , context )  
        ENDIF

    ELSEIF self . operand = FORMULA_NEGATE THEN

        lib_re_formula_calculate ( self . left ,
                           context     ,
                       TRUE        )    

        self . value      = - self . left . value
        self . units      =   self . left . units
        self . inequality =   self . left . inequality      

    ELSEIF self . operand = FORMULA_POWER THEN

        lib_re_formula_calculate ( self . left ,
                           context     ,
                       TRUE        )    

        lib_re_formula_calculate ( self . right ,
                           context      ,
                       TRUE         )   

        lib_re_formula_power ( self         ,
                       context      ,
                       self . left  ,
                       self . right )

    ENDIF

ENDROUTINE

{*******************************************************************************}

ROUTINE lib_re_formula_param_number ( self )

{
*
*
*******************************************************************************}

    DECLARE parameters

    IF variable_is_assigned ( self . parameters ) THEN

        parameters = size_of_array ( self . parameters )

    ELSE

        parameters = 0

    ENDIF

    RETURN ( parameters )

ENDROUTINE

{*******************************************************************************}

ROUTINE lib_re_formula_parameter_text (       self      ,
                    VALUE parameter ,
                              context   )

{
*
*
*******************************************************************************}

    DECLARE answer   ,
        temp

    temp = self . parameters [ parameter ]

    lib_re_formula_calculate ( temp    , 
                   context ,
                   FALSE   )    

    IF NOT context . error THEN

        IF variable_is_assigned ( temp . text ) THEN

            answer = temp . text

        ELSE

            answer = lib_utils_coerce ( temp . value, "TEXT" )

            IF answer = EMPTY THEN

                lib_re_formula_runtime_error (  context                          ,
                                       "EXPECT_TEXT"                     ,
                                    variable_get_type ( temp . text ),
                                EMPTY                            )

            ENDIF

        ENDIF

    ELSE

        answer = 1.0

    ENDIF

    RETURN ( answer )

ENDROUTINE

{*******************************************************************************}

ROUTINE lib_re_formula_parameter_numeric (       self      ,
                       VALUE parameter ,
                                 context   )

{
*
*
*******************************************************************************}

    DECLARE answer   ,
        temp

    temp = self . parameters [ parameter ]

    lib_re_formula_calculate ( temp    , 
                   context ,
                   TRUE    )    

    IF NOT context . error THEN

        IF ( variable_is_assigned ( temp . text )) AND
           ( temp . text <> EMPTY                ) THEN

            IF numtext ( temp . text ) THEN

                answer = numeric ( temp . text )
                self . units = temp . units
                self . inequality = temp . inequality

                ELSE
            
                answer = 1.0
            
                lib_re_formula_runtime_error (  context          ,
                                       "EXPECT_NUMERIC"  ,
                                    temp . text      ,
                                EMPTY            )

            ENDIF

        ELSE

            answer = temp . value 
            self . units = temp . units
            self . inequality = temp . inequality

        ENDIF

    ELSE

        answer = 1.0

    ENDIF

    RETURN ( answer )

ENDROUTINE

{*******************************************************************************}

ROUTINE lib_re_formula_parameter_bool (       self      ,
                       VALUE parameter ,
                                 context   )

{
*
*
*******************************************************************************}

    DECLARE answer   ,
        temp

    temp = self . parameters [ parameter ]

    lib_re_formula_calculate ( temp    , 
                   context ,
                   TRUE    )    

    IF NOT context . error THEN

        IF ( variable_is_assigned ( temp . text )) AND
           ( temp . text <> EMPTY                ) THEN

                        
            answer = TOUPPER( temp . text ) 
            
            IF( ( answer = "TRUE" ) OR ( answer = "T" ) ) THEN
            
                answer = TRUE
            
            ELSE
            
                context . error = TRUE
                
            ENDIF
            
        ELSE
        
            IF( variable_is_assigned( temp . value ) ) THEN
            
                answer = temp . value
                
            ELSE
            
                context . error = TRUE
                
            ENDIF

        ENDIF

    ELSE

        answer = 1.0

    ENDIF

    RETURN ( answer )

ENDROUTINE

{*******************************************************************************}

ROUTINE lib_re_formula_parameter (       self      ,
                       VALUE parameter ,
                         context   )

{
*
*
*******************************************************************************}

    DECLARE answer   ,
        temp

    temp = self . parameters [ parameter ]

    lib_re_formula_calculate ( temp    , 
                   context ,
                   TRUE    )    

    IF NOT context . error THEN

        IF( variable_is_assigned( temp . value ) ) THEN

            answer = temp . value

        ELSEIF ( variable_is_assigned ( temp . text )) AND
               ( temp . text <> EMPTY                ) THEN
                        
            answer = temp . text
            
        ELSE
        
            context . error = TRUE
                
        ENDIF

    ELSE

        answer = 1.0

    ENDIF

    RETURN ( answer )

ENDROUTINE

{*******************************************************************************}

ROUTINE lib_re_formula_doit ( expression    ,
                  context       ,
                      result_object )   

{
*
*
*******************************************************************************}

    DECLARE answer       ,
        error_status

    lib_re_formula_calculate ( expression ,     
                   context    ,
                   TRUE       ) 

    IF NOT context . error THEN

        IF variable_is_assigned ( expression . value ) THEN
            IF expression . value = ERROR THEN
                lib_re_formula_runtime_error (
                                        context           ,
                               "FINAL_NOT_NUMBER" ,
                                       "ERROR"            ,
                            EMPTY             )
            ELSE
                answer = expression . value
            ENDIF
        ELSEIF numtext ( expression . text ) THEN
            answer = numeric ( expression . text )
        ELSE
            lib_re_formula_runtime_error (  context           ,
                               "FINAL_NOT_NUMBER" ,
                            expression . text ,
                            EMPTY             )
        ENDIF

    ENDIF

    IF NOT context . error THEN

        IF blank ( result_object . result_unit ) THEN

            result_object . result_unit = expression . units

            ELSEIF strip ( expression . units ) <>
               strip ( result_object . result_unit ) THEN
    
            answer = unit_convert ( answer                      ,
                        expression . units          ,
                        result_object . result_unit ,
                        error_status                )

            IF error_status <> EMPTY THEN

                lib_re_formula_runtime_error (  context              ,
                                   "ERROR_UNITS_FINAL"   ,
                                message_get_text (error_status, 1 )  ,
                                        EMPTY                                )      
                    
            ENDIF

        ENDIF

    ENDIF

    IF context . error THEN

        answer = EMPTY

    ELSEIF lib_re_formula_value_is_numeric( answer ) THEN
    
        answer = formula_inequality_as_text [ expression . inequality ] :
                         strip ( number_to_text ( answer , "999999999.9999999999" ))

    ELSEIF NOT lib_re_formula_allow_text THEN

        answer = EMPTY 

        lib_re_formula_runtime_error (  context           ,
                           "FINAL_NOT_NUMBER" ,
                        EMPTY             ,
                        EMPTY             )

    ENDIF

    RETURN ( answer )

ENDROUTINE

{*******************************************************************************}

GLOBAL ROUTINE lib_formula_calculate ( result_object  ,
                       result_context ) 

{
*
*
*******************************************************************************}

    DECLARE context      ,
        expression   ,
        answer       

    context                  = result_object . context
    expression               = result_object . expression   

    IF context <> EMPTY THEN

        context . mode           = FORMULA_MODE_CALCULATE
        context . error          = FALSE
        context . test_number    = result_object . get_field ( "TEST_NUMBER" )
        
        object_assign_uncounted ( context . result_context, result_context )
            object_assign_uncounted ( context . result_object , result_object )

        IF expression <> EMPTY THEN

            answer = lib_re_formula_doit ( expression    ,
                                   context       ,
                                   result_object )      



        ELSE

            answer = EMPTY             
                   
          ENDIF

        context . result_object = EMPTY

    ELSE

        answer = EMPTY

    ENDIF

    
    RETURN ( answer )

ENDROUTINE

{*******************************************************************************}

GLOBAL ROUTINE lib_formula_bind ( VALUE formula        ,
                    result_object  ,
                    result_context )
 
{
*
*
*******************************************************************************}

    DECLARE parse        ,
        expression   ,
        context      ,
        worked
    
    formula = strip ( formula )

    CREATE OBJECT STD_FORMULA_CONTEXT, context

    context . mode           = FORMULA_MODE_BIND
    context . test_number    = result_object . get_field ( "TEST_NUMBER" )
 
    object_assign_uncounted ( context . result_context , result_context )
    object_assign_uncounted ( context . result_object  , result_object  )

    CREATE OBJECT STD_FORMULA_PARSE, parse

    parse . formula = formula

    lib_re_formula_find_start ( parse )

    expression = lib_re_formula_parse ( parse ) 

    IF parse . error_text = EMPTY THEN

        lib_re_formula_calculate ( expression ,
                       context    ,
                       TRUE       ) 

        result_object . expression = expression
        result_object . context    = context

        worked = TRUE
        

    ELSE

        result_object . expression = EMPTY
        result_object . context    = EMPTY

        worked = FALSE

    ENDIF

    context . result_object = EMPTY

    RETURN ( worked )

ENDROUTINE

{*******************************************************************************}

GLOBAL ROUTINE lib_formula_print ( VALUE formula        ,
                     result_object  ,
                     result_context )

{
*
*
*******************************************************************************}
                       
    DECLARE parse      ,
        expression ,
        context    ,
        answer     ,
        file_name  
    
    formula = strip ( formula )

    CREATE OBJECT STD_FORMULA_CONTEXT, context

    context . mode           = FORMULA_MODE_PRINT
    context . test_number    = result_object . get_field ( "TEST_NUMBER" )
    context . result_context = result_context
    context . result_object  = result_object


    CREATE OBJECT STD_FORMULA_PARSE, parse

    parse . formula = formula

    lib_re_formula_find_start ( parse )

    expression = lib_re_formula_parse ( parse ) 

    lib_re_formula_print_formula ( formula       ,
                       parse         ,
                       result_object )  
                            
    IF parse . error_text = EMPTY THEN

        answer = lib_re_formula_doit ( expression    ,
                           context       ,
                           result_object )      
 
        IF context . error THEN

            lib_re_formula_print_runtime_error  ( context . error_message )

                ELSE
                           
            result_object . format_text ( answer )

            answer = strip ( result_object . result_str ) : 
                     result_object . result_unit

            IF formula_script_active () THEN

                formula_script_write_answer ( answer )

            ELSE

                lib_re_formula_print_line ( EMPTY ,
                                EMPTY )
    
                lib_re_formula_print_line ( "FORMULA_PRINT_ANSWER" ,
                                 answer                )    

            ENDIF
        
        ENDIF

        result_object . expression = expression
        result_object . context    = context

    ELSE

        result_object . expression = EMPTY
        result_object . context    = EMPTY

    ENDIF

    file_name = return_formula_print_filename()
    
    flush_formula_print_file( file_name )

    context . result_object = EMPTY
                       
ENDROUTINE


{******************************************************************************}

GLOBAL ROUTINE lib_formula_definition_validate ( VALUE formula ,
                               names   ,    
                               message )    
                       
{
*   Validate the formula to see if it is good.                      
*
*******************************************************************************}

    DECLARE parse      ,
        context    ,
        expression

    CREATE OBJECT STD_FORMULA_CONTEXT, context

    context . mode           = FORMULA_MODE_VALIDATE
    context . test_number    = 1
        context . result_context = names
    
    CREATE OBJECT STD_FORMULA_PARSE, parse

    parse . formula = formula

    lib_re_formula_find_start ( parse )

    expression = lib_re_formula_parse ( parse ) 

    message = parse . error_text 
                       
    IF parse . error_text = EMPTY THEN

        lib_re_formula_calculate ( expression ,     
                       context    ,
                       TRUE       )

        IF context . error THEN

            message = context . error_message

        ENDIF

    ELSE
    
        expression . global_parricide()
        
    ENDIF

    RETURN ( message = EMPTY )

ENDROUTINE

{******************************************************************************}

GLOBAL ROUTINE lib_re_formula_test ( VALUE formula        ,
                     VALUE read_script    , 
                               result_object  ,
                           result_context ,
                           answer         , 
                           message        ) 
 
{
*
*
*******************************************************************************}
                       
    DECLARE parse       ,
        context     ,
        expression

    formula = strip ( formula )

    CREATE OBJECT STD_FORMULA_CONTEXT, context

    context . mode        = FORMULA_MODE_CALCULATE
    context . test_number = result_object . get_field ( "TEST_NUMBER" )
    context . read_script = read_script

    object_assign_uncounted ( context . result_context , result_context )
    object_assign_uncounted ( context . result_object  , result_object  )

    CREATE OBJECT STD_FORMULA_PARSE, parse

    parse . formula = formula

    lib_re_formula_find_start ( parse )

    expression = lib_re_formula_parse ( parse ) 

    IF parse . error_text = EMPTY THEN

        answer = lib_re_formula_doit ( expression    ,
                           context       ,
                           result_object )      
        
        IF context . error THEN

            answer  = ""
            message = context . error_message

        ELSE

            message = ""
            result_object . format_text ( answer )
            answer = strip ( result_object . result_str ) : 
                     result_object . result_unit

        ENDIF

        ELSE

        message = parse . error_text
        answer  = ""

    ENDIF
    
  
ENDROUTINE

{******************************************************************************}

GLOBAL ROUTINE lib_re_formula_test_callback ( VALUE formula        ,
                                              VALUE read_script    ,
                                                    answer         ,    
                                                    message        )

{
*
*
*******************************************************************************}

    DECLARE parse       ,
        context     ,
        expression

    formula = strip ( formula )

    CREATE OBJECT STD_FORMULA_CONTEXT, context

    context . mode        = FORMULA_MODE_TEST_PHASE1
    context . test_number = 0
    context . read_script = read_script

    CREATE OBJECT STD_FORMULA_PARSE, parse

    parse . formula = formula

    lib_re_formula_find_start ( parse )

    expression = lib_re_formula_parse ( parse ) 

    IF parse . error_text = EMPTY THEN

        lib_re_formula_calculate ( expression ,
                                   context    ,
                                   TRUE       )

        IF NOT context . error THEN

            IF variable_is_assigned ( expression . value ) THEN
                IF expression . value = ERROR THEN
                    lib_re_formula_runtime_error (
                                            context           ,
                                   "FINAL_NOT_NUMBER" ,
                                           "ERROR"            ,
                                EMPTY             )
                ELSE
                    answer = formula_inequality_as_text [
                                expression . inequality ] :
                             expression . value :
                             expression . units
                ENDIF
            ELSEIF numtext ( expression . text ) THEN
                answer = expression . text
            ELSE
                lib_re_formula_runtime_error (  context           ,
                                   "FINAL_NOT_NUMBER" ,
                                expression . text ,
                                EMPTY             )
            ENDIF

        ENDIF

        IF context . error THEN

            answer  = ""
            message = context . error_message

        ELSE

            message = ""

        ENDIF

    ELSE

        answer  = ""
        message = parse . error_text

    ENDIF

ENDROUTINE

{*******************************************************************************}

ROUTINE lib_re_formula_call_function ( self    ,
                       context )

{
*
*
*******************************************************************************}

    IF ( context . mode = FORMULA_MODE_CALCULATE   ) OR
       ( context . mode = FORMULA_MODE_PRINT       ) OR
       ( context . mode = FORMULA_MODE_BIND        ) OR
       ( context . mode = FORMULA_MODE_TEST_PHASE1 ) THEN

        self . attach_context( context )

        self . transition_object . formula_script_get()


        CALL_ROUTINE "call_user_routine"
             USING  self
             USING TABLE result, test, sample
             IN LIBRARY "$lib_re_formula"
             NEW CONTEXT 

        self . transition_object . formula_script_put()
        
        IF ( self . get_no_of_params_called() < 
             self . get_no_of_params()          ) AND
           ( self . parameter_count_check       ) THEN

            lib_re_formula_runtime_error( context                ,
                              "TOO_MANY_PARAMS"      ,
                              self . function . name ,
                              ""                     )

        ELSEIF  ( NOT variable_is_assigned( self . value ) ) AND
            ( NOT variable_is_assigned( self . text ) )  THEN

            lib_re_formula_runtime_error( context                ,
                              "NO_FUNCTION_RESULT"   ,
                              self . function . name ,
                              ""                     )

        ENDIF

        IF ( NOT context . error )                            AND
           ( NOT lib_re_formula_expression_is_batch( self ) ) AND
           ( NOT self . is_a_parameter )                      THEN

            IF NOT lib_re_formula_allow_text THEN

                IF NOT lib_re_formula_value_is_numeric ( self . value ) THEN            
            
                    self . value = ERROR

                ENDIF          

            ENDIF

            IF self . value = ERROR THEN

                self . return_value( EMPTY )

                lib_re_formula_runtime_error( context                ,
                                              "NON_NUMERIC_FUNCTION" ,
                                              self . function . name ,
                                              ""                     )

            ENDIF

        ENDIF

        IF ( NOT context . error ) AND 
           ( NOT variable_is_assigned( self . units ) ) THEN

            self . units = ""

        ENDIF

        IF ( NOT context .error ) AND
           ( NOT variable_is_assigned( self . inequality ) ) THEN

            self . inequality = FORMULA_EQ

        ENDIF

        self . remove_parent_expressions()

        self . zero_params_called()

    ELSEIF ( context . mode = FORMULA_MODE_VALIDATE ) THEN

        self . value = 1.0
        self . units = ""
        self . inequality = FORMULA_EQ

        self . attach_context( context )

        self . transition_object . formula_script_get()

        CALL_ROUTINE "call_user_routine"
             USING  self
             USING TABLE result, test, sample
             IN LIBRARY "$lib_re_formula"
             NEW CONTEXT 
        
        IF ( self . get_no_of_params_called() < 
             self . get_no_of_params()          ) AND
           ( self . parameter_count_check       ) THEN

            lib_re_formula_runtime_error( context                ,
                              "TOO_MANY_PARAMS"      ,
                              self . function . name ,
                              ""                     )

        ELSEIF  ( NOT variable_is_assigned( self . value ) ) AND
            ( NOT variable_is_assigned( self . text ) )  THEN

            lib_re_formula_runtime_error( context                ,
                              "NO_FUNCTION_RESULT"   ,
                              self . function . name ,
                              ""                     )

        ENDIF

        IF ( NOT context . error )                            AND
           ( NOT lib_re_formula_expression_is_batch( self ) ) AND
           ( NOT self . is_a_parameter )                      THEN

            IF NOT lib_re_formula_allow_text THEN

                IF NOT lib_re_formula_value_is_numeric ( self . value ) THEN
            
                    lib_re_formula_runtime_error( context                ,
                                                  "NON_NUMERIC_FUNCTION" ,
                                                  self . function . name ,
                                                  ""                     )          
                    self . return_value( EMPTY )

                ENDIF

            ENDIF

            IF self . value = ERROR THEN
                    lib_re_formula_runtime_error( context                ,
                                                  "FUNCTION_ERROR"       ,
                                                  self . function . name ,
                                                  ""                     )
            ENDIF

        ENDIF

        IF ( NOT context . error ) AND 
           ( NOT variable_is_assigned( self . units ) ) THEN

            self . units = ""

        ENDIF

        IF ( NOT context .error ) AND
           ( NOT variable_is_assigned( self . inequality ) ) THEN

            self . inequality = FORMULA_EQ

        ENDIF

        self . remove_parent_expressions()

        self . zero_params_called()

    ELSE

        self . value = 1.0
        self . units = ""
        self . inequality = FORMULA_EQ

    ENDIF

ENDROUTINE{ lib_re_formula_call_function }

{*******************************************************************************}

ROUTINE call_user_routine ( self )

{
*
*
*******************************************************************************}

    self . transition_object . formula_script_put()
    lib_re_formula_initialise()
    
    IF variable_is_assigned ( self . context . result_object ) THEN

        object_set_current_table (
                self . context . result_object , "RESULT" ) 
        object_set_current_table (
            self . context . result_object . test_object , "TEST" )
        object_set_current_table (
            self . context . result_object . test_object . sample_object , "SAMPLE" )

    ENDIF
    

    CALL_ROUTINE self . function . routine
         USING  self
         IN LIBRARY self . function . library
    self . transition_object . formula_script_get()

ENDROUTINE{ call_user_routine }

{*******************************************************************************}

ROUTINE lib_re_formula_get_analysis_comp ( self    ,
                           context )

{
*
*
*******************************************************************************}


ENDROUTINE{ lib_re_formula_get_analysis_comp }

{*******************************************************************************}

ROUTINE  std_formula_expression_action_flag_function_error ( self )

{
*
*
*******************************************************************************}

DECLARE context, function_name

    context = self . context
    
    function_name = self . function . name

    lib_re_formula_runtime_error( 
    context , "FUNCTION_ERROR", function_name, "" )

EXIT

ENDROUTINE{ std_formula_expression_action_flag_function_error }

{*******************************************************************************}

ROUTINE  std_formula_expression_action_flag_function_error_with_message ( self 
, 
                                                              VALUE message_id )

{
*
*
*******************************************************************************}

DECLARE context, function_name

    context = self . context
    
    function_name = self . function . name

    lib_re_formula_runtime_error( 
    context , message_id, function_name, "" )

EXIT

ENDROUTINE{ std_formula_expression_action_flag_function_error_with_message }

{*******************************************************************************}

ROUTINE  std_formula_expression_action_flag_function_error_param
                                                         (       self        ,
                                                           VALUE message_id  ,
                                                           VALUE parameter_1 )

{
*
*
*******************************************************************************}

DECLARE context, function_name

    context = self . context
    
    function_name = self . function . name

    lib_re_formula_runtime_error ( context       ,
                                   message_id    ,
                                   function_name ,
                                   parameter_1   )

    EXIT

ENDROUTINE{ std_formula_expression_action_flag_function_error_with_message }

{*******************************************************************************}

ROUTINE  std_formula_expression_action_attach_context ( self , context )

{
*
*
*******************************************************************************}

    self . context = context
    
ENDROUTINE{ std_formula_expression_action_attach_context }

{*******************************************************************************}

ROUTINE  std_formula_expression_action_attach_transition_object ( self , trans_obj )

{
*
*
*******************************************************************************}

    self . transition_object = trans_obj
    
ENDROUTINE{ std_formula_expression_action_attach_transition_object }

{*******************************************************************************}

ROUTINE  std_formula_expression_action_remove_parent_expressions ( self )

{
*
*
*******************************************************************************}

DECLARE param_number

    param_number = 1

    WHILE param_number <= self . get_no_of_params() DO
    
        IF variable_is_assigned( self . parameters[ param_number ] 
                                              . parent_expression ) THEN

            self . parameters[ param_number ] 
                     . parent_expression = EMPTY 

        ENDIF
        
        param_number = param_number + 1
        
    ENDWHILE        
    
ENDROUTINE{ std_formula_expression_action_remove_parent_expressions }

{******************************************************************************}

ROUTINE  std_formula_expression_action_global_parricide ( self )

{
*
*
*******************************************************************************}

DECLARE param_number

    IF variable_is_assigned( self . left ) THEN
    
        IF self . left <> EMPTY THEN

            self . left .global_parricide()

        ENDIF
        
    ENDIF
    
    IF variable_is_assigned( self . right ) THEN
    
        IF self . right <> EMPTY THEN

            self . right . global_parricide()

        ENDIF
        
    ENDIF

    self . remove_parent_expressions()
    
    param_number = 1 
    
    WHILE param_number <= self . get_no_of_params() DO
    
        self . parameters[param_number] . global_parricide()
        
        param_number = param_number + 1
        
    ENDWHILE
    
ENDROUTINE{ std_formula_expression_action_global_parricide }

{*******************************************************************************}

ROUTINE  std_formula_expression_action_set_parameter_count_check_off ( self )

{
*
*
*******************************************************************************}

    self . parameter_count_check = FALSE
    
ENDROUTINE{ std_formula_expression_action_set_parameter_count_check_off }

{*******************************************************************************}

ROUTINE  std_formula_expression_action_zero_params_called ( self )

{
*
*
*******************************************************************************}

    self . params_called = 0
    
ENDROUTINE{ std_formula_expression_action_zero_params_called }

{*******************************************************************************}

ROUTINE  std_formula_expression_action_get_parameter_text ( self )

{
*
*
*******************************************************************************}

DECLARE function_name, text

    self . params_called = self . params_called + 1 
    
    IF self . params_called > self . get_no_of_params() THEN
    
        lib_re_formula_runtime_error( self . context         ,
                                      "TOO_FEW_PARAMS"       ,
                                      self . function . name ,
                                      ""                     )
                                      
        EXIT
        
    ELSE
        text = lib_re_formula_parameter_text( self                 ,
                              self . params_called ,
                              self . context       )

        IF NOT ( variable_get_type( text ) = "Text" ) THEN 

            function_name = self . function . name

            lib_re_formula_runtime_error( self . context         ,
                              "INCORRECT_PARAM_TYPE" ,
                              function_name          ,
                              ""                     )

            EXIT

        ELSE

            RETURN( text )

        ENDIF
        
    ENDIF
    
ENDROUTINE{ std_formula_expression_action_get_parameter_text }

{*******************************************************************************}

ROUTINE  std_formula_expression_action_get_parameter_numeric ( self )

{
*
*
*******************************************************************************}

DECLARE function_name, num_val

    self . params_called = self . params_called + 1 
    
    IF self . params_called > self . get_no_of_params() THEN
    
        lib_re_formula_runtime_error( self . context         ,
                                      "TOO_FEW_PARAMS"       ,
                                      self . function . name ,
                                      ""                     )
                                      
        EXIT
        
    ELSE

        num_val = lib_re_formula_parameter_numeric( self                 ,
                                self . params_called ,
                                self . context       )
                                
        IF NOT( lib_re_formula_value_is_numeric( num_val ) ) THEN
        
            function_name = self . function . name

            lib_re_formula_runtime_error( self . context         ,
                              "INCORRECT_PARAM_TYPE" ,
                              function_name          ,
                              ""                     )

            EXIT

        ELSE
        
            num_val = NUMERIC( num_val )

            RETURN( num_val )

        ENDIF
        
    ENDIF
    
ENDROUTINE{ std_formula_expression_action_get_parameter_numeric }

{*******************************************************************************}

ROUTINE  std_formula_expression_action_get_parameter_bool ( self )

{
*
*
*******************************************************************************}

DECLARE function_name, bool_val

    self . params_called = self . params_called + 1 
    
    IF self . params_called > self . get_no_of_params() THEN
    
        lib_re_formula_runtime_error( self . context         ,
                                      "TOO_FEW_PARAMS"       ,
                                      self . function . name ,
                                      ""                     )
                                      
        EXIT
        
    ELSE
    
        bool_val = lib_re_formula_parameter_bool( self                 ,
                              self . params_called ,
                              self . context       )

        IF NOT ( variable_get_type( bool_val ) = "Boolean" ) THEN 

            function_name = self . function . name

            lib_re_formula_runtime_error( self . context         ,
                              "INCORRECT_PARAM_TYPE" ,
                              function_name          ,
                              ""                     )

            EXIT

        ELSE

            RETURN( bool_val )

        ENDIF
        
    ENDIF
    
ENDROUTINE{ std_formula_expression_action_get_parameter_bool }

{*******************************************************************************}

ROUTINE  std_formula_expression_action_get_parameter ( self )

{
*
*
*******************************************************************************}

DECLARE function_name, param_val

    self . params_called = self . params_called + 1 
    
    IF self . params_called > self . get_no_of_params() THEN
    
        lib_re_formula_runtime_error( self . context         ,
                                      "TOO_FEW_PARAMS"       ,
                                      self . function . name ,
                                      ""                     )
                                      
        EXIT
        
    ELSE
    
        param_val = lib_re_formula_parameter( self                 ,
                                              self . params_called ,
                                              self . context       )

        IF  self . context . error THEN 

            function_name = self . function . name

            lib_re_formula_runtime_error( self . context       ,
                              "NO_PARAM"           ,
                              function_name        ,
                              self . params_called )

            EXIT

        ELSE

            RETURN( param_val )

        ENDIF
        
    ENDIF
    
ENDROUTINE{ std_formula_expression_action_get_parameter }

{*******************************************************************************}

ROUTINE  std_formula_expression_action_get_parameter_result_set ( self )

{
*
*
*******************************************************************************}

DECLARE temp_exp, obj_db, function_name

    self . params_called = self . params_called + 1 
    
    IF self . params_called > self . get_no_of_params() THEN
    
        lib_re_formula_runtime_error( self .context          ,
                                      "TOO_FEW_PARAMS"       ,
                                      self . function . name ,
                                      ""                     )
                                      
        EXIT                                     
                                      
    ELSE                                     
    
        temp_exp = self . parameters[ self . params_called ]

        lib_re_formula_calculate ( temp_exp       , 
                       self . context ,
                       TRUE           ) 

        IF NOT self . context . error  THEN 
        
            obj_db = temp_exp . value
            
            IF variable_get_type( obj_db) <> "Object" THEN
            
                function_name = self . function . name

                lib_re_formula_runtime_error( self . context         ,
                                  "INCORRECT_PARAM_TYPE" ,
                                  function_name          ,
                                  ""                     )

                EXIT
                
            ELSEIF object_get_class_name( obj_db) <> "STDOBJECTDATABASE" THEN
                        
                function_name = self . function . name

                lib_re_formula_runtime_error( self . context         ,
                                  "INCORRECT_PARAM_TYPE" ,
                                  function_name          ,
                                  ""                     )

                EXIT
                
            ELSE                
            
                RETURN( obj_db )
                
            ENDIF

        ELSE

            EXIT

        ENDIF
        
    ENDIF
        
ENDROUTINE{ std_formula_expression_action_get_parameter_result_set }

{*******************************************************************************}

ROUTINE  std_formula_expression_action_return_value ( self, VALUE expression_value )

{
*
*
*******************************************************************************}

    self . value = expression_value
    
ENDROUTINE{ std_formula_expression_action_retur_value }

{*******************************************************************************}

ROUTINE  std_formula_expression_action_return_text ( self, VALUE expression_text )

{
*
*
*******************************************************************************}

    self . text = expression_text
    
ENDROUTINE{ std_formula_expression_action_retur_text }

{*******************************************************************************}

ROUTINE  std_formula_expression_action_return_units ( self, VALUE expression_units )

{
*
*
*******************************************************************************}

    self . units = expression_units
    
ENDROUTINE{ std_formula_expression_action_return_units }

{*******************************************************************************}

ROUTINE  std_formula_expression_action_return_inequality ( self, VALUE expression_inequality )

{
*
*
*******************************************************************************}

    self . inequality = expression_inequality 
    
ENDROUTINE{ std_formula_expression_action_return_inequality }

{*******************************************************************************}

ROUTINE  std_formula_expression_action_get_parameter_inequality ( self )

{
*
*
*******************************************************************************}

DECLARE function_name

    IF ( ( NOT  variable_is_assigned( 
        self . parameters[ self . params_called ] . inequality ) ) OR
        ( self . params_called = 0 ) )THEN
    
        function_name = self . function . name

        lib_re_formula_runtime_error( self . context   ,
                                      "FUNCTION_ERROR" ,
                                      function_name    ,
                                      ""               )
                                      
        EXIT
        
    ELSE
    
        RETURN( self . parameters[ self . params_called ] . inequality )
        
    ENDIF
    
ENDROUTINE{ std_formula_expression_action_get_parameter_inequality }

{*******************************************************************************}

ROUTINE  std_formula_expression_action_get_parameter_units ( self )

{
*
*
*******************************************************************************}

DECLARE function_name

    IF ( ( NOT  variable_is_assigned( 
        self . parameters[ self . params_called ] . units ) ) OR
        ( self . params_called = 0 ) )THEN
    
        function_name = self . function . name

        lib_re_formula_runtime_error( self . context   ,
                                      "FUNCTION_ERROR" ,
                                      function_name    ,
                                      ""               )
                                      
        EXIT
        
    ELSE
    
        RETURN( self . parameters[ self . params_called ] . units )
        
    ENDIF
    
ENDROUTINE{ std_formula_expression_action_get_parameter_units }

{*******************************************************************************}

ROUTINE  std_formula_expression_action_get_no_of_params ( self )

{
*
*
*******************************************************************************}

DECLARE no_of_params

    IF variable_is_assigned( self . parameters ) THEN

        no_of_params = size_of_array( self . parameters )
        
    ELSE
    
        no_of_params = 0
    
    ENDIF

    RETURN( no_of_params )
    
ENDROUTINE{ std_formula_expression_action_get_no_of_params }

{*******************************************************************************}

ROUTINE  std_formula_expression_action_get_no_of_params_called ( self )

{
*
*
*******************************************************************************}

    RETURN( self . params_called )
    
ENDROUTINE{ std_formula_expression_action_get_no_of_params_called }

{*******************************************************************************}

ROUTINE std_formula_transition_action_formula_script_get ( self )

{
*
*
******************************************************************************}

    self . formula_script_filename = formula_script_get_filename()
    self . formula_script_analysis = formula_script_get_analysis()
    self . formula_script_analysis_version = 
    formula_script_get_analysis_version()
    self . formula_script_position = formula_script_get_position()
    self . formula_script_line_count = formula_script_get_line_count()
    
ENDROUTINE{ std_formula_transition_action_formula_script_get }

{*******************************************************************************}

ROUTINE std_formula_transition_action_formula_script_put ( self )

{
*
*
******************************************************************************}

    formula_script_put_filename(
    self . formula_script_filename )
    formula_script_put_analysis(
    self . formula_script_analysis )
    formula_script_put_analysis_version(
    self . formula_script_analysis_version )
    formula_script_put_position(
    self . formula_script_position )
    formula_script_put_line_count( self . formula_script_line_count )
    
ENDROUTINE{ std_formula_transition_action_formula_script_put }

{*******************************************************************************}

ROUTINE create_formula_print_file( file_name )

{
* Creates a temporary file for literal output from formula 
*
******************************************************************************}

DECLARE file_ok

    
    FILE CREATE file_name , file_ok
    
    IF ( file_ok <> EMPTY ) THEN
    
        flash_message(
        GET_USER_MESSAGE( "FORMULA_PRINT_FILE_ERROR", 1)
        :file_ok, TRUE )
        
    ENDIF
    
ENDROUTINE

{*******************************************************************************}

ROUTINE return_formula_print_filename

{
* Creates a temporary file name for literal output from formula 
*
******************************************************************************}

DECLARE file_name

    file_name = FORMULA_PRINT_FILENAME
            :STRIP( STRING( GLOBAL( "PROCESS_ID" ) ) )
            :".txt"
            
    RETURN( file_name )         
            
ENDROUTINE 

{*******************************************************************************}

GLOBAL

ROUTINE lib_re_formula_write_to_print_file( VALUE text ) 

{
*
* Writes to a temporary file for literal output from formula 
*
******************************************************************************}

    write_to_formula_print_file ( text )

ENDROUTINE

{*******************************************************************************}

ROUTINE write_to_formula_print_file( VALUE text ) 

{
*
* Writes to a temporary file for literal output from formula 
*
******************************************************************************}

DECLARE file_name , file_ok

    file_name = return_formula_print_filename()
    
    IF NOT FILE EXISTS ( file_name ) THEN
    
        create_formula_print_file( file_name )
        
    ENDIF
    
    FILE EXTEND file_name, file_ok

    IF file_ok = EMPTY THEN
    
        FILE WRITE file_name, text , file_ok

        IF ( file_ok <> EMPTY ) THEN
        
            flash_message(
            GET_USER_MESSAGE( "FORMULA_PRINT_FILE_ERROR", 1)
            :file_ok, TRUE )
            
        ENDIF
        
        FILE CLOSE file_name , file_ok
        
        IF ( file_ok <> EMPTY ) THEN
        
            flash_message( 
            GET_USER_MESSAGE( "FORMULA_PRINT_FILE_ERROR", 1 )
            :file_ok, TRUE )
            
        ENDIF

    ELSE

        flash_message( 
        GET_USER_MESSAGE( "FORMULA_PRINT_FILE_ERROR", 1):
        file_ok, TRUE )
        
    ENDIF
    
ENDROUTINE

{*******************************************************************************}

ROUTINE delete_formula_print_file( file_name )

{
* Deletes a temporary file for literal output from formula 
*
******************************************************************************}

DECLARE file_ok

    
    FILE DELETE file_name , file_ok
    
    IF ( file_ok <> EMPTY ) THEN
    
        flash_message( 
        GET_USER_MESSAGE( "FORMULA_PRINT_FILE_ERROR", 1)
        :file_ok, TRUE )
        
    ENDIF
    
ENDROUTINE

{*******************************************************************************}

ROUTINE flush_formula_print_file( file_name )

{
* Flushes output from a temporary file for literal output from formula 
*
******************************************************************************}

DECLARE file_ok

    
    IF ( FILE EXISTS ( file_name ) ) THEN
    
        FILE SEND file_name , "DEFER/" , file_ok

        IF ( file_ok <> EMPTY ) THEN

            flash_message( 
            GET_USER_MESSAGE( "FORMULA_PRINT_FILE_ERROR", 1) 
            :file_ok, TRUE )

        ENDIF

        delete_formula_print_file( file_name )
        
    ENDIF
    
ENDROUTINE

{*******************************************************************************}

ROUTINE lib_re_formula_prompt_validate ( self )

{
*
* Parse the value. If its a number with an equality split them.
*
********************************************************************************}

    DECLARE result_str ,
            first_char ,
            second_char

    result_str = strip ( self . text )
    self . user_info = FORMULA_EQ

    IF numtext ( result_str ) THEN

        first_char  = substring ( result_str, 1, 1 )
        second_char = substring ( result_str, 2, 1 )

        IF first_char = "<" THEN
            IF second_char = "=" THEN
                self . user_info = FORMULA_LE
            ELSE
                self . user_info = FORMULA_LT
            ENDIF
        ELSEIF first_char = ">" THEN
            IF second_char = "=" THEN
                self . user_info = FORMULA_GE
            ELSE
                self . user_info = FORMULA_GT
            ENDIF
        ENDIF

    ENDIF

    RETURN ( TRUE )

ENDROUTINE

{*******************************************************************************}

ROUTINE lib_re_formula_prompt_comp_value ( test_number ,
                                           name        ,
                                           val         ,
                                           inequality  )

{
*
* Ask the user for a value for the specified test / component.
*
********************************************************************************}

    DECLARE screen_height, screen_width, form, value_prompt

    screen_width  = GLOBAL ( "GUI_WIDTH"  )
    screen_height = GLOBAL ( "GUI_HEIGHT" )

    PROMPT OBJECT form CLASS "STD_FORM"
    form . header           = "Result Value Prompt" {GET_USER_MESSAGE("SETUP_MENU" ,1)}
    form . row              = ( screen_height / 2 )
    form . column           = (( screen_width - 56 ) / 2 )
    form . height           = 3
    form . width            = 56

    form . add_display ( "Test" , 2, 1, PROMPT_RENDITION_NORMAL )
    IF blank ( test_number ) OR ( STRIP ( test_number ) = "0" ) THEN
        form . add_display ( "Currently selected", 16, 1, PROMPT_RENDITION_LOWERED )

    ELSE
        form . add_display ( test_number, 16, 1, PROMPT_RENDITION_LOWERED )
    ENDIF

    form . add_display ( "Result Name" , 2, 2, PROMPT_RENDITION_NORMAL )
    IF blank ( name ) THEN
        form . add_display ( "Currently selected",  16, 2, PROMPT_RENDITION_LOWERED )
    ELSE
        form . add_display ( pad ( name, " ", 40 ), 16, 2, PROMPT_RENDITION_LOWERED )
    ENDIF

    form . add_display ( "Result Value" , 2, 3, PROMPT_RENDITION_NORMAL )

    PROMPT OBJECT value_prompt

    value_prompt . column             = 16
    value_prompt . row                = 3
    value_prompt . width              = 20
    value_prompt . always_validate    = TRUE
    value_prompt . validation_routine = "lib_re_formula_prompt_validate"
    value_prompt . user_info          = FORMULA_EQ

    form . add_prompt ( value_prompt )

    form . add_frame ( "", 1, 1, 3, 56 )

    form . start_prompt ( )
    form . wait_prompt ( )
    form . end_prompt ( )

    IF ( form . get_lastkey ( ) <> "EXIT" ) AND numtext ( value_prompt . text ) THEN
        val        = value_prompt . value
        inequality = value_prompt . user_info
    ELSE
        val        = 0
        inequality = FORMULA_EQ
    ENDIF

ENDROUTINE

{*******************************************************************************}

GLOBAL

ROUTINE lib_re_formula_prompt_table_field ( VALUE key0        ,
                                            VALUE tab_name    ,
                                            VALUE field_name  ,
                                                  val         )


{
*
* Ask the user for a value for the specified table / field
*
********************************************************************************}

    DECLARE screen_height, screen_width, form, value_prompt

    screen_width  = GLOBAL ( "GUI_WIDTH"  )
    screen_height = GLOBAL ( "GUI_HEIGHT" )

    PROMPT OBJECT form CLASS "STD_FORM"
    form . header           = "Table Field Prompt" {GET_USER_MESSAGE("SETUP_MENU" ,1)}
    form . row              = ( screen_height / 2 )
    form . column           = (( screen_width - 56 ) / 2 )
    form . height           = 4
    form . width            = 56

    form . add_display ( "Table"  ,  2, 1, PROMPT_RENDITION_NORMAL )
    form . add_display ( tab_name , 16, 1, PROMPT_RENDITION_LOWERED )

    form . add_display ( "Key0" ,  2, 2, PROMPT_RENDITION_NORMAL )
    IF blank ( key0 ) OR ( STRIP ( key0 ) = "0" ) THEN
        form . add_display ( "Currently selected", 16, 2, PROMPT_RENDITION_LOWERED )

    ELSE
        form . add_display ( key0, 16, 2, PROMPT_RENDITION_LOWERED )
    ENDIF

    form . add_display ( "Field Name" ,  2, 3, PROMPT_RENDITION_NORMAL )
    form . add_display ( field_name   , 16, 3, PROMPT_RENDITION_LOWERED )

    form . add_display ( "Field Value" , 2, 4, PROMPT_RENDITION_NORMAL )

    PROMPT OBJECT value_prompt BROWSE ON 'tab_name' . 'field_name'

    value_prompt . column         = 16
    value_prompt . row            = 4
    value_prompt . format_only    = TRUE
    value_prompt . browse_routine = "$browse_field/browse_on_field"

    form . add_prompt ( value_prompt )

    form . add_frame ( "", 1, 1, 4, 56 )

    form . start_prompt ( )
    form . wait_prompt ( )
    form . end_prompt ( )

    val = value_prompt . value

    IF ( form . get_lastkey ( ) <> "EXIT" ) THEN
        coerce_to_field ( tab_name, field_name, val )
    ENDIF

ENDROUTINE

{*******************************************************************************}

ROUTINE lib_re_formula_prompt_pi_value ( val )


{
*
* Ask the user for a value for the PI tag linked to the current result
*
********************************************************************************}

    DECLARE screen_height, screen_width, form, value_prompt

    screen_width  = GLOBAL ( "GUI_WIDTH"  )
    screen_height = GLOBAL ( "GUI_HEIGHT" )

    PROMPT OBJECT form CLASS "STD_FORM"
    form . header           = "PI Tag Prompt" {GET_USER_MESSAGE("SETUP_MENU" ,1)}
    form . row              = ( screen_height / 2 )
    form . column           = (( screen_width - 56 ) / 2 )
    form . height           = 1
    form . width            = 56

    form . add_display ( "PI Tag Value" , 2, 1, PROMPT_RENDITION_NORMAL )

    PROMPT OBJECT value_prompt BROWSE ON real

    value_prompt . column         = 16
    value_prompt . row            = 1

    form . add_prompt ( value_prompt )

    form . add_frame ( "", 1, 1, 1, 56 )

    form . start_prompt ( )
    form . wait_prompt ( )
    form . end_prompt ( )

    val = value_prompt . value

ENDROUTINE

{*******************************************************************************}

ROUTINE lib_re_formula_prompt_inst_param ( VALUE inst_param ,
                                                 val        )


{
*
* Ask the user for a value for the instrument parameter inst_param
*
********************************************************************************}

    DECLARE screen_height, screen_width, form, value_prompt

    screen_width  = GLOBAL ( "GUI_WIDTH"  )
    screen_height = GLOBAL ( "GUI_HEIGHT" )

    PROMPT OBJECT form CLASS "STD_FORM"
    form . header           = "Instrument Parameter Prompt" {GET_USER_MESSAGE("SETUP_MENU" ,1)}
    form . row              = ( screen_height / 2 )
    form . column           = (( screen_width - 56 ) / 2 )
    form . height           = 1
    form . width            = 56

    form . add_display ( inst_param , 2, 1, PROMPT_RENDITION_NORMAL )

    PROMPT OBJECT value_prompt BROWSE ON real

    value_prompt . column         = 16
    value_prompt . row            = 1

    form . add_prompt ( value_prompt )

    form . add_frame ( "", 1, 1, 1, 56 )

    form . start_prompt ( )
    form . wait_prompt ( )
    form . end_prompt ( )

    val = value_prompt . value

ENDROUTINE

{*******************************************************************************}

ROUTINE lib_re_formula_prompt_stock_param ( VALUE stock_param ,
                                                  val         )


{
*
* Ask the user for a value for the stock parameter stock_param
*
********************************************************************************}

    DECLARE screen_height, screen_width, form, value_prompt

    screen_width  = GLOBAL ( "GUI_WIDTH"  )
    screen_height = GLOBAL ( "GUI_HEIGHT" )

    PROMPT OBJECT form CLASS "STD_FORM"
    form . header           = "Stock Parameter Prompt" {GET_USER_MESSAGE("SETUP_MENU" ,1)}
    form . row              = ( screen_height / 2 )
    form . column           = (( screen_width - 56 ) / 2 )
    form . height           = 1
    form . width            = 56

    form . add_display ( stock_param , 2, 1, PROMPT_RENDITION_NORMAL )

    PROMPT OBJECT value_prompt BROWSE ON real

    value_prompt . column         = 16
    value_prompt . row            = 1

    form . add_prompt ( value_prompt )

    form . add_frame ( "", 1, 1, 1, 56 )

    form . start_prompt ( )
    form . wait_prompt ( )
    form . end_prompt ( )

    val = value_prompt . value

ENDROUTINE

{*******************************************************************************}

GLOBAL

ROUTINE lib_re_formula_add_replicates ( self           ,
                                        context        ,
                                        component_name )

{
*
* Expand parameter list to include replicates
*
********************************************************************************}

DECLARE expression, replicate_count, parent_param_no, result_array, continue

    IF ( GLOBAL( "RESULT_REPLICATES_ENABLED" )          AND
       variable_is_assigned( self . parent_expression ) AND   
       ( self . parent_expression <> EMPTY )            AND
       self . parent_expression . use_replicates        AND
       NOT self . replicates_added )                    THEN

        replicate_count = 2

        continue = TRUE

        IF variable_is_assigned( context . result_context ) THEN
        
            IF object_check_property( context . result_context , "result_list" ) THEN

                result_array = context . result_context . result_list

            ELSEIF object_check_property( context . result_context , "result_array" ) THEN

                result_array = context . result_context . result_array

            ELSE

                continue = FALSE

            ENDIF
            
        ELSE
        
            continue = FALSE
            
        ENDIF

        IF continue THEN

            WHILE ( replicate_count <= size_of_array( result_array ) ) DO

                IF STRIP( component_name ):
                   GLOBAL( "RESULT_REPLICATE_CHAR" ):
                   STRIP( STRING( replicate_count ) ) = 
                      result_array [ replicate_count ] . name THEN

                    CREATE OBJECT STD_FORMULA_EXPRESSION, expression

                    expression . operand  = FORMULA_TEXT
                    expression . text = result_array [
                                replicate_count ] . name

                    parent_param_no = self . parent_expression . 
                              get_no_of_params()

                    self . parent_expression . 
                    parameters[ parent_param_no + 1 ] = expression

                    self . parent_expression . 
                    parameters[ parent_param_no + 1 ] . 
                    parent_expression = self . parent_expression

                    self . parent_expression . 
                    parameters[ parent_param_no + 1 ] . 
                    is_a_parameter = TRUE

                    expression = EMPTY

                ENDIF

                replicate_count = replicate_count + 1 

            ENDWHILE

            self . replicates_added = TRUE

        ENDIF

    ENDIF
                
ENDROUTINE { lib_re_formula_add_replicates }

{*******************************************************************************}

GLOBAL

ROUTINE lib_re_formula_value_is_numeric ( expression_value )


{
*
*
********************************************************************************}

DECLARE is_numeric, variable_type

    is_numeric = FALSE
    
    variable_type = variable_get_type( expression_value )

    variable_type = TOUPPER( variable_type )
    
    IF ( variable_type =  "REAL" )           OR
       ( variable_type =  "INTEGER" )        OR
       ( variable_type =  "PACKED DECIMAL" ) THEN
       
       is_numeric = TRUE
       
    ELSEIF ( variable_type = "TEXT" )          AND
           ( NUMTEXT( expression_value ) ) THEN
           
        expression_value = NUMERIC( expression_value )
       
        is_numeric = TRUE

    ENDIF
    
    RETURN( is_numeric )
                
ENDROUTINE { lib_re_formula_value_is_numeric }

{*******************************************************************************}

GLOBAL

ROUTINE lib_re_formula_expression_is_batch ( expression )


{
*
*
********************************************************************************}

DECLARE is_batch

    is_batch = FALSE
    
    IF object_check_property( expression, "is_batch" ) THEN
    
        IF variable_is_assigned( expression . is_batch) THEN

            is_batch = expression . is_batch

        ENDIF
    
    ENDIF
    
    RETURN( is_batch )
    
ENDROUTINE { lib_re_formula_expression_is_batch }

{*******************************************************************************}

ROUTINE lib_re_formula_find_function_in_db  ( VALUE func_name )

{
* Look for the required function in the database.
*
*******************************************************************************}

DECLARE found_func, library_name, routine_name

    found_func = EMPTY
    
    library_name = SELECT calc_function . library
                   WHERE  identity = func_name
                   
    IF library_name <> EMPTY THEN
    
        routine_name = SELECT calc_function . routine
        
        IF routine_name <> EMPTY THEN
        
            CREATE OBJECT STD_FORMULA_FUNCTION, found_func
            
            found_func . name = func_name
            found_func . library = STRIP( library_name )
            found_func . routine = STRIP( routine_name )
            
        ENDIF
        
    ENDIF
    
    RETURN( found_func )

ENDROUTINE

{*******************************************************************************}

ROUTINE lib_re_formula_find_function_in_cluster  ( VALUE func_name )

{
* Look for the required function in the cluster.
*
*******************************************************************************}

DECLARE cluster_id, found_func

    found_func = EMPTY
    
    cluster_id = STRIP( GLOBAL( "SESSION_ID" ) ):"CALC_FUNCTIONS"
    
    IF user_cluster_exists( cluster_id ) THEN
    
        IF user_global_exists( cluster_id, func_name ) THEN
        
            found_func = read_user_global( cluster_id, func_name )
            
        ENDIF
        
    ENDIF
    
    RETURN( found_func )

ENDROUTINE

{*******************************************************************************}

ROUTINE lib_re_formula_add_function_to_cluster  ( func_obj )

{
* Add the passed function object to the cluster.
*
*******************************************************************************}

DECLARE cluster_id, func_name

    cluster_id = STRIP( GLOBAL( "SESSION_ID" ) ):"CALC_FUNCTIONS"
    
    IF NOT user_cluster_exists( cluster_id ) THEN
    
        add_global_cluster( cluster_id )
        
    ENDIF
    
    func_name = func_obj . name
    
    add_user_global( cluster_id, func_name )
    
    user_global_write( cluster_id, func_name, func_obj )

ENDROUTINE

{*******************************************************************************}
{*******************************************************************************}
{*******************************************************************************}

ROUTINE GET_SMP_TEST_RESULT ( self ) 
{******************************************************************************
$LIB_RE_FORMULA
*******************************************************************************}

    {    GET_SMP_TEST_RESULT ( "NIE-492C", "N-GAM-01", "BL_Reagenz" )    }

    DECLARE context, found, smp_point, analysis, res_name, ana_ver, msg, 
            temp_table, this_job, sample_id, test_number, test_count, res_value, res_units
    
    self.set_parameter_count_check_off()
    context = self.context
    IF (context.mode = FORMULA_MODE_CALCULATE   ) OR
       (context.mode = FORMULA_MODE_PRINT       ) OR
       (context.mode = FORMULA_MODE_VALIDATE    ) OR
       (context.mode = FORMULA_MODE_TEST_PHASE1 ) THEN
        IF lib_re_formula_param_number (self) = 3 THEN
            smp_point = lib_re_formula_parameter_text (self, 1, context)
            analysis  = lib_re_formula_parameter_text (self, 2, context)
            res_name  = lib_re_formula_parameter_text (self, 3, context)
            ana_ver   = SELECT max_active_anal_ver.max_version WHERE identity = analysis
            found = TRUE
            msg = ""
            IF (context.mode = FORMULA_MODE_TEST_PHASE1 ) THEN
                IF (EMPTY = (SELECT sample_point.identity WHERE identity = smp_point)) THEN
                    msg = msg:ASCII(10):"Sample Point  '":smp_point:"'  could not be found."
                ENDIF
                IF ana_ver = EMPTY THEN
                    msg = msg:ASCII(10):"Analysis  '":analysis:"'  could not be found."
                ELSEIF (EMPTY = (SELECT versioned_component.name 
                                 WHERE analysis = analysis
                                 AND analysis_version = ana_ver
                                 AND name = res_name)) THEN
                    msg = msg:ASCII(10):"Component  '":res_name:"'  could not found in":ASCII(10):
                                         "the active version of analysis  '":analysis:"'"
                ENDIF
                IF NOT(msg = "") THEN
                    found = FALSE
                    msg = "Error in the parameters entered":ASCII(10):msg
                ELSE
                    msg = "OK"
                ENDIF
                context.error = TRUE
                context.errormessage = msg
            ENDIF
        ELSE
            msg = ("Found ":STRIP(lib_re_formula_param_number (self)):" parameters, 3 was expected.")
            context.error = TRUE
            context.errormessage = msg
        ENDIF

        IF context.mode <> FORMULA_MODE_CALCULATE THEN
            {fm("context.mode <> FORMULA_MODE_CALCULATE") }
            IF context.read_script THEN
                {fm("context.read_script") }
                formula_script_read_standard (context, smp_point, self.value, self.units)
            ELSE
                {fm("NOT context.read_script") }
                {lib_re_formula_runtime_error (context, "NO_STANDARD", smp_point, EMPTY) }
            ENDIF

            IF (context.mode = FORMULA_MODE_PRINT) AND (NOT context.error) THEN 
                {fm("context.mode = FORMULA_MODE_PRINT and":ASCII(10):
                   "NOT context.error") }
                lib_re_formula_print_standard (smp_point, analysis, res_name, found, self)
            ENDIF
            self.value = ""
        ELSE
            smp_point = lib_re_formula_parameter_text (self, 1, context)
            analysis  = lib_re_formula_parameter_text (self, 2, context)
            res_name  = lib_re_formula_parameter_text (self, 3, context)

            this_job  = SELECT sample.job_name
            push_file_descriptor( "SAMPLE" , temp_table )
                sample_id = SELECT sample.id_numeric
                            WHERE  job_name       = this_job
                              AND  sampling_point = smp_point
                              AND  (status = "V"
                                 OR status = "C"
                                 OR status = "A")
                            ORDER ON id_numeric DESCENDING  
                IF sample_id = EMPTY THEN
                    fm("No sample for sample point '":smp_point:"' is available on this job.")
                    res_value = EMPTY
                ELSE
                    test_number = SELECT test.test_number
                                  WHERE  analysis = analysis
                                  AND    sample   = sample_id
                                  AND  (status = "C"
                                     OR status = "A")
                                  ORDER ON test_count
                    test_count  = STRIP(SELECT test.test_count)
                    IF test_number = EMPTY then                 
                        fm("No ":analysis:"-analysis on sample ":ASCII(10):
                            STRIP(sample_id):" has been completed")
                        res_value = EMPTY
                    ELSE
                        res_value   = SELECT result.value
                                      WHERE test_number = test_number
                                      AND   name        = res_name
                        res_units   = SELECT result.units      
                        IF res_value = EMPTY THEN
                            fm("No result found for ":res_name:ASCII(10):
                               "on ":analysis:"/":test_count:ASCII(10):
                               "for sample ":sample_id)
                        ENDIF
                    ENDIF
                ENDIF
            pop_file_descriptor( temp_table )

            IF res_value <> EMPTY THEN
                self.value = res_value
                self.units = res_units
            ELSE
                self.value = ""
                self.units = ""
            ENDIF
        ENDIF        
    ENDIF
    
 ENDROUTINE

{*******************************************************************************}

