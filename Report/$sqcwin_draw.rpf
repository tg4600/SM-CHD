{******************************************************************************
*
* Module Name   : $sqcwin_draw
*
* Purpose       : Contains the routines for drawing the sqc charts.
*                 
*
*******************************************************************************}

SET COMPILE_OPTION DECLARE

SET NOTPROTECTED

ENABLE WINDOWS

SET NAME "DISPLAY/"

JOIN STANDARD_LIBRARY STD_UTILS
JOIN STANDARD_LIBRARY STD_PROMPT
JOIN STANDARD_LIBRARY STD_ARRAY
JOIN STANDARD_LIBRARY STD_CLASS
JOIN STANDARD_LIBRARY STD_ARRAY_SELECT
JOIN STANDARD_LIBRARY STD_MESSAGE
JOIN STANDARD_LIBRARY STD_CLIENT
JOIN LIBRARY $lib_utils
JOIN LIBRARY $toolbox
JOIN LIBRARY $sqcwin_data
JOIN LIBRARY $sqcwin_lib
JOIN LIBRARY $sqcwin_glbl
JOIN LIBRARY $sqcwin_class
JOIN LIBRARY $sqcwin_calc
JOIN LIBRARY $sqcwin_hard
JOIN LIBRARY $PROMPT_GRAPH
JOIN LIBRARY $PROMPT_TOOLBAR
JOIN LIBRARY $LIB_POPUP_MENU
JOIN LIBRARY $LIB_LIST_VIEWER
JOIN LIBRARY $LIB_PROPERTY_SHEET
JOIN LIBRARY $PROMPT_FOR_TEXT


{==============================================================================}

DECLARE configured_for_sixel, sixel_queue_name

{******************************************************************************}

GLOBAL ROUTINE get_chart_type ( sqc_chart )

{ 
* Global routine to get the chart type of the active chart associated with
* the sqc_chart object.
* 
*
* Parameters   : sqc_chart
* Return Value : n/a
*
*******************************************************************************}

DECLARE next_option, option_text, option_form, display_width, option_value,
        update_rec, prompt_line, prompt_column

	create_sqc_form( option_form )

	option_form . add_frame( 
	GET_USER_MESSAGE( "SQCWIN_CHART_TYPE_FRAME_HEADER", 1 ) ,
			  0                                     ,
			  1                                     ,
			  0                                     ,
			  option_form . width                   )

	prompt_column = (
	STRINGLENGTH( GET_USER_MESSAGE( "SQCWIN_CHART_TYPE_FRAME_HEADER", 1 ) )
	- 8 )

	next_option = 1
	prompt_line = 3
	option_text = ""
	display_width = 0
	option_value = ""

	sqc_chart . sqc_chart_type . set_by_index_number( "ORDER_NUM", next_option )

	WHILE ( next_option <= sqc_chart . sqc_chart_type . size ( ) ) DO

	    option_text = SELECT sqcwin_chart_type . chart_type
			    IN OBJECT sqc_chart . sqc_chart_type . current

	    option_value = SELECT sqcwin_chart_type . chart_active
			    IN OBJECT sqc_chart . sqc_chart_type . current

	    PROMPT OBJECT option_form . prompt_objects [next_option]
		    FORMAT boolean
			ON LINE prompt_line FROM prompt_column
			WITH ( is_check  = TRUE         ,
			       value     = option_value ,
			       user_info = next_option  ,
			       caption = option_text    )

	    next_option = next_option + 1

	    prompt_line = prompt_line + 2

	    sqc_chart . sqc_chart_type . set_by_index_number( "ORDER_NUM", next_option )

	    IF STRINGLENGTH ( option_text ) > display_width THEN

		display_width = STRINGLENGTH ( option_text )

	    ENDIF

	ENDWHILE

	option_form . user_info = sqc_chart

	option_form . border = TRUE
	option_form . proportional = TRUE
	option_form . header = GET_USER_MESSAGE( "SQCWIN_CHART_TYPE_HEADER", 1 )

	add_param_buttons (sqc_chart, option_form)

	option_form . start_prompt ()

	REPEAT

	    option_form . wait_prompt ()

	UNTIL ( valid_chart_type_selection ( option_form ) )

	IF ( option_form . get_lastkey() <> "EXIT" ) THEN

	    next_option = 1


	    WHILE ( next_option <= sqc_chart . sqc_chart_type . size ( ) ) DO

		sqc_chart . sqc_chart_type . set_by_index_number( "ORDER_NUM", next_option )
		update_rec = sqc_chart . sqc_chart_type . current


		ASSIGN sqcwin_chart_type . chart_active
		    IN OBJECT update_rec = option_form . prompt_objects [ next_option ] . value


		next_option = next_option + 1

	    ENDWHILE

	ENDIF

	option_form . end_prompt ()

	IF (sqc_chart . next_screen <> "DRAW") THEN

	    get_next_screen ( sqc_chart )

	ENDIF

ENDROUTINE

{******************************************************************************}

ROUTINE valid_chart_type_selection ( form )

{ 
* This routine ensures at least one chart is selected
* 
* 
*
* Parameters   : form
* Return Value : Return_value
*
*******************************************************************************}

DECLARE return_value, object_counter

	return_value = FALSE
	object_counter  = 1

	IF ( LASTKEY = "RIGHT" ) THEN

		WHILE ( object_counter < 6 )

		    IF ( form . prompt_objects [ object_counter ] . VALUE ) THEN
			return_value = TRUE
		    ENDIF

		    object_counter = object_counter + 1

		ENDWHILE

		IF NOT ( return_value ) THEN

		    flash_message ( SELECT_VALID_CHART_TYPE, TRUE )

		ENDIF

	ELSE

		return_value = TRUE

	ENDIF

	RETURN ( return_value )

ENDROUTINE

{******************************************************************************}

GLOBAL ROUTINE cusum_chart_params (sqc_chart)

{ 
* This routine gets the CUSUM chart parameters.
* 
* 
*
* Parameters   : sqc_chart
* Return Value : n/a
*
*******************************************************************************}


DECLARE form 
DECLARE text_one,text_two,text_three,text_four,text_five, text_col, text_length
DECLARE prompt_one,prompt_two,prompt_three,prompt_four,prompt_five, prompt_col
DECLARE type_info, chart_type_ndx
DECLARE max_dec_point, not_exiting

	chart_type_ndx = PAD ( sqc_chart . chart_id, " ", "20" ) :
			 PAD ( CUSUM               , " ", "10" )

	sqc_chart . sqc_chart_type . set_by_index ( "KEY0", chart_type_ndx )

	type_info = STRIP ( SELECT sqcwin_chart_type . chart_type IN OBJECT
			    sqc_chart . sqc_chart_type . current )

	create_sqc_form( form )
	form.help_context = "$REPORTER_FORM_PROMPT"
	form.border=TRUE
	form.header= type_info:" Chart Parameters"
	form.user_info=sqc_chart

	text_col = 10

	text_length = 
	STRINGLENGTH( GET_USER_MESSAGE ( "CUSUM_PARA_DEC_INTERVAL", 1 ) )

	prompt_col = text_col + text_length

	PROMPT OBJECT text_one
		CLASS "STD_PROMPT_TEXT"
		ON LINE 2 FROM text_col
		WITH (  raised=TRUE,
			value=GET_USER_MESSAGE ( "CUSUM_PARA_TEST_LENGTH", 1 ) )

	text_one . width = text_length

	PROMPT OBJECT text_two
		CLASS "STD_PROMPT_TEXT"
		ON LINE 4 FROM text_col
		WITH(   raised=TRUE,
			value=GET_USER_MESSAGE ( "CUSUM_PARA_TARGET_VALUE", 1 ) )

	text_two . width = text_length

	PROMPT OBJECT text_three
		CLASS "STD_PROMPT_TEXT"
		ON LINE 6 FROM text_col
		WITH(   raised=TRUE,
			value=GET_USER_MESSAGE ( "CUSUM_PARA_DEC_POINT", 1 ) )

	text_three . width = text_length

	PROMPT OBJECT text_four
		CLASS "STD_PROMPT_TEXT"
		ON LINE 8 FROM text_col
		WITH(   raised=TRUE,
			value=GET_USER_MESSAGE ( "CUSUM_PARA_DEC_INTERVAL", 1 ) )

	text_four . width = text_length

	PROMPT OBJECT text_five
		CLASS "STD_PROMPT_TEXT"
		ON LINE 10 FROM text_col
		WITH (  raised=TRUE,
			value=GET_USER_MESSAGE ( "CUSUM_PARA_DEC_SLOPE", 1 ) )

	text_five . width = text_length

	PROMPT OBJECT prompt_one
		ON LINE 2 FROM prompt_col
		BROWSE ON integer
		WITH (  minimum=0    ,
			maximum=9999 )

	prompt_one . value = SELECT sqcwin_chart_type . test_length IN OBJECT
		sqc_chart . sqc_chart_type. current

	PROMPT OBJECT prompt_two
		CLASS "STD_PROMPT_TEXT"
		ON LINE 4 FROM prompt_col
		WITH ( validation_routine = "check_valid_target_value" )

	prompt_two . width = 10

	prompt_two . value = SELECT sqcwin_chart_type . target_cusum IN OBJECT
		sqc_chart . sqc_chart_type. current

	max_dec_point = sqc_chart . sqc_point . size ()

	PROMPT OBJECT prompt_three
		ON LINE 6 FROM prompt_col
		BROWSE ON integer
		WITH (  minimum=0             ,
			maximum=max_dec_point )

	prompt_three . value = SELECT sqcwin_chart_type . subgroup_size_wanted IN OBJECT
		sqc_chart . sqc_chart_type. current

	if prompt_three . value = 1 then
	    prompt_three . value = max_dec_point
	endif

	PROMPT OBJECT prompt_four
		ON LINE 8 FROM prompt_col
		BROWSE ON integer
		WITH (  minimum=0    ,
			maximum=9999 )

	prompt_four . value = SELECT sqcwin_chart_type . y_min_chart_a IN OBJECT
		sqc_chart . sqc_chart_type. current

	PROMPT OBJECT prompt_five
		ON LINE 10 FROM prompt_col
		BROWSE ON real
		WITH (  minimum=0    ,
			maximum=9999 )

	prompt_five . value = SELECT sqcwin_chart_type . y_min_chart_b IN OBJECT
		sqc_chart . sqc_chart_type. current

	form.add_display(text_one)
	form.add_display(text_two)
	form.add_display(text_three)
	form.add_display(text_four)
	form.add_display(text_five)

	form.add_prompt(prompt_one)
	form.add_prompt(prompt_two)
	form.add_prompt(prompt_three)
	form.add_prompt(prompt_four)
	form.add_prompt(prompt_five)

	add_param_buttons (sqc_chart , form)

	form.start_prompt()
	not_exiting = TRUE

	WHILE not_exiting DO
	form.wait_prompt()

		IF ( sqc_chart . next_screen <> "EXIT") AND 
		( ( LASTKEY = "RIGHT" ) OR ( LASTKEY = "LEFT" ) )THEN

	    sqc_chart . sqc_chart_type . set_by_index ( "KEY0", chart_type_ndx )
	    ASSIGN sqcwin_chart_type . test_length IN OBJECT
		sqc_chart . sqc_chart_type. current = prompt_one . value
	    ASSIGN sqcwin_chart_type . target_cusum IN OBJECT
		sqc_chart . sqc_chart_type. current = prompt_two . value
	    ASSIGN sqcwin_chart_type . subgroup_size_wanted IN OBJECT
		sqc_chart . sqc_chart_type. current = prompt_three . value
	    ASSIGN sqcwin_chart_type . y_min_chart_a IN OBJECT
		sqc_chart . sqc_chart_type. current = prompt_four . value
	    ASSIGN sqcwin_chart_type . y_min_chart_b IN OBJECT
		sqc_chart . sqc_chart_type. current = prompt_five . value

		    not_exiting = FALSE

		ELSEIF( LASTKEY = "EXIT" ) THEN

			not_exiting = FALSE

		ENDIF
	
	ENDWHILE

	form.end_prompt()

	IF ( form . get_lastkey () <> "EXIT" ) THEN
	    do_cusum_calculations ( sqc_chart )
	ENDIF

	IF ( sqc_chart . next_screen <> "DRAW") THEN

	    get_next_screen (sqc_chart)

	ENDIF

ENDROUTINE

{******************************************************************************}

ROUTINE check_valid_target_value ( self )

{ 
* This routine validates the target value for CUSUM chart parameters.
* 
* 
*
* Parameters   : self
* Return Value : return_value
*
*******************************************************************************}

DECLARE return_value

    return_value = FALSE

    IF ( ( self . text = "M" ) OR ( self . text = "m" ) ) THEN

        return_value = TRUE

    ELSEIF STRIP ( self . text ) = "" THEN

        return_value = FALSE

    ELSEIF NUMTEXT ( self . text ) THEN

        return_value = TRUE     

    ENDIF

    IF NOT ( return_value ) THEN

        flash_message ( GET_USER_MESSAGE ( "CUSUM_PARA_ERROR_2", 1 ), TRUE )

    ENDIF

    RETURN ( return_value )

ENDROUTINE

{******************************************************************************}

GLOBAL ROUTINE indmr_chart_params (sqc_chart)

{ 
* This routine gets the Individual and Moving Range chart parameters.
* 
* 
*
* Parameters   : sqc_chart
* Return Value : n/a
*
*******************************************************************************}

DECLARE form, chosen_spec_type, prompt_upper_spec, prompt_lower_spec
DECLARE text_one,text_two,text_three, text_four,text_five
DECLARE text_spec_type, text_upper_spec, text_lower_spec, text_level
DECLARE prompt_one, prompt_four, prompt_five, prompt_six, prompt_seven,
        prompt_eight, prompt_nine

DECLARE prompt_level, prompt_spec, prompt_disable, prompt_mlp

DECLARE type_info, chart_type_ndx,  not_exiting, not_exiting_main
DECLARE prompt_two_data, prompt_two_target, prompt_two_spec, prompt_two_mlp
DECLARE prompt_three_data, prompt_three_target, prompt_three_spec, prompt_three_mlp
DECLARE use_mlp_spec, chosen_type_a_limit, chosen_type_b_limit, mlp_levels

	chart_type_ndx = PAD ( sqc_chart . chart_id, " ", "20" ) :
			 PAD ( IND_MR              , " ", "10" )

	sqc_chart . sqc_chart_type . set_by_index ( "KEY0", chart_type_ndx )
	type_info = STRIP ( SELECT sqcwin_chart_type . chart_type IN OBJECT
			    sqc_chart . sqc_chart_type . current )

	sqc_chart . tmp_chart_type = IND_MR

	create_sqc_form( form )
	form.help_context = "$REPORTER_FORM_PROMPT"
	form.border=TRUE
	form.header= type_info:" Chart Parameters"

	form.add_frame( GET_USER_MESSAGE( "SQCWIN_MAIN_NCT_20", 1 ) ,
			1      ,
			0       ,
			0       ,
			75)
	form.add_frame( GET_USER_MESSAGE( "SQCWIN_MAIN_NCT_21", 1 )      ,
			1      ,
			4       ,
			0       ,
			75)
	form.add_frame(GET_USER_MESSAGE( "SQCWIN_MAIN_NCT_22", 1 )       ,
			1      ,
			8       ,
			0       ,
			75)
	form.add_frame( GET_USER_MESSAGE( "SQCWIN_MAIN_NCT_23", 1 ),
			1      ,
			11       ,
			0       ,
			75)
	form.add_frame( GET_USER_MESSAGE( "SQCWIN_MAIN_NCT_24", 1 ) ,
			1      ,
			13       ,
			0       ,
			75)
	form . user_info = sqc_chart

	PROMPT OBJECT text_one
		CLASS "STD_PROMPT_TEXT"
		ON LINE 1 FROM ( form . width * 0.25 )
		WITH (  raised=TRUE,
			value=GET_USER_MESSAGE ( "INDMR_PARA_TEST_LENGTH", 1 ) )

	text_one . width = 
	STRINGLENGTH(GET_USER_MESSAGE ( "INDMR_PARA_TEST_LENGTH", 1 ))

	PROMPT OBJECT text_spec_type
		CLASS "STD_PROMPT_TEXT"
		ON LINE 5 FROM 15
		WITH (value=GET_USER_MESSAGE ( "INDMR_PARA_SPEC_TYPE", 1 ),
			  raised=TRUE)

	text_spec_type . width = STRINGLENGTH( GET_USER_MESSAGE ( "MEANS_PARA_SPEC_TYPE", 1 ) )

	PROMPT OBJECT text_lower_spec
		CLASS "STD_PROMPT_TEXT"
		ON LINE 7 FROM 2
		WITH (  raised=TRUE,
			value= GET_USER_MESSAGE( "SQCWIN_MAIN_LCT_15" , 1 ) )

	text_lower_spec . width = 
	STRINGLENGTH( GET_USER_MESSAGE( "SQCWIN_MAIN_LCT_15" , 1 ) )	

	PROMPT OBJECT text_upper_spec
		CLASS "STD_PROMPT_TEXT"
		ON LINE 7 
		WITH (  raised=TRUE,
			value= GET_USER_MESSAGE( "SQCWIN_MAIN_LCT_14" , 1 ) )

	text_upper_spec . width = 
	STRINGLENGTH( GET_USER_MESSAGE( "SQCWIN_MAIN_LCT_14" , 1 ) )

	PROMPT OBJECT text_level
		CLASS "STD_PROMPT_TEXT"
		ON LINE 7 FROM 55 TO 59
		WITH (  raised=TRUE,
			value= GET_USER_MESSAGE( "SQCWIN_MAIN_LCT_16" , 1 ) )

	PROMPT OBJECT text_two
		CLASS "STD_PROMPT_TEXT"
		ON LINE 9 FROM 15
		WITH (value=GET_USER_MESSAGE ( "INDMR_PARA_LIMIT_TYPE_A", 1 ),
		      raised=TRUE)

	text_two . width = STRINGLENGTH( GET_USER_MESSAGE ( "INDMR_PARA_LIMIT_TYPE_A", 1 ) )

	PROMPT OBJECT text_three
		CLASS "STD_PROMPT_TEXT"
		ON LINE 10 FROM 15
		WITH (value=GET_USER_MESSAGE ( "INDMR_PARA_LIMIT_TYPE_B", 1 ),
			raised=TRUE)

	text_three . width = STRINGLENGTH( GET_USER_MESSAGE ( "INDMR_PARA_LIMIT_TYPE_B", 1 ) )

	PROMPT OBJECT text_four
		CLASS "STD_PROMPT_TEXT"
		ON LINE 12 FROM 10 
		WITH(   raised=TRUE,
			value=GET_USER_MESSAGE ( "INDMR_PARA_TREND_TYPE_A", 1 ) )

	text_four . width = 
	STRINGLENGTH( GET_USER_MESSAGE ( "INDMR_PARA_TREND_TYPE_A", 1 ) )

	PROMPT OBJECT text_five
		CLASS "STD_PROMPT_TEXT"
		ON LINE 12
		WITH(   raised=TRUE,
			value=GET_USER_MESSAGE ( "INDMR_PARA_TREND_TYPE_B", 1 ) )

	text_five . width = 
	STRINGLENGTH( GET_USER_MESSAGE ( "INDMR_PARA_TREND_TYPE_B", 1 ) )

	PROMPT OBJECT prompt_one
		ON LINE 1 FROM 28 TO 50
		BROWSE ON INTEGER
		WITH (  minimum=0,
			maximum=9999,
			user_info = "test_length" )

	prompt_one . value = default_line_display ( sqc_chart,
						    prompt_one . user_info )

	PROMPT OBJECT prompt_spec
	       ON LINE 5 FROM 28
	       BROWSE ON boolean

	prompt_spec . is_radio = TRUE
	prompt_spec . toggled_routine = "select_spec_limits"
	prompt_spec . vgl_library = GLOBAL( "CURRENT_LIBRARY" )
	prompt_spec . user_info = "spec_radio"
	prompt_spec . caption = GET_USER_MESSAGE( "SQCWIN_MAIN_LCT_3" , 1 )

	PROMPT OBJECT prompt_disable
	       ON LINE 5 FROM 45
	       BROWSE ON boolean

	prompt_disable . is_radio = TRUE
	prompt_disable . toggled_routine = "select_disable_limits"
	prompt_disable . vgl_library = GLOBAL( "CURRENT_LIBRARY" )
	prompt_disable . user_info = "disable_radio"
	prompt_disable . caption = GET_USER_MESSAGE( "SQCWIN_MAIN_LCT_9" , 1 )

	PROMPT OBJECT prompt_mlp
	       ON LINE 5 FROM 65
	       BROWSE ON boolean

	prompt_mlp . is_radio = TRUE
	prompt_mlp . toggled_routine = "spec_type_mlp"
	prompt_mlp . vgl_library = GLOBAL( "CURRENT_LIBRARY" )
	prompt_mlp . user_info = "mlp_radio"
	prompt_mlp . caption = GET_USER_MESSAGE( "SQCWIN_MAIN_LCT_4" , 1 )

	ARRAY mlp_levels

	use_mlp_spec = use_mlp_spec_bool( sqc_chart . selection_criteria )

	IF use_mlp_spec THEN

		get_mlp_levels( sqc_chart, mlp_levels )

	ENDIF

	PROMPT OBJECT prompt_level
	ON LINE 7 FROM 60
	CHOOSE OUTOF mlp_levels
	WITH ( selected_routine = "spec_type_mlp_choose"     ,
	       leave_prompt_routine = "spec_type_mlp_choose" ,
	       user_info = "mlp_level"                       )

	IF use_mlp_spec THEN
	
		set_level_prompt_value( sqc_chart, prompt_level, mlp_levels )

	ENDIF

	IF NOT use_mlp_spec THEN

		prompt_mlp . set_enabled( FALSE )
		prompt_level . set_enabled( FALSE )
		prompt_level . set_visible( FALSE )

	ENDIF

	PROMPT OBJECT prompt_lower_spec
		ON LINE 7
		FROM ( text_lower_spec . column + text_lower_spec . width )
		BROWSE ON REAL
		WITH (  user_info = "lower_spec")

	prompt_lower_spec . value = default_line_display ( sqc_chart,
						      prompt_lower_spec . user_info )

	prompt_lower_spec . width = 10
	
	text_upper_spec . column = ( prompt_lower_spec . column + 
	                             prompt_lower_spec . width + 5   )
	
	PROMPT OBJECT prompt_upper_spec
		ON LINE 7
		FROM ( text_upper_spec . column + text_upper_spec . width )
		BROWSE ON REAL
		WITH (  user_info = "upper_spec")

	prompt_upper_spec . value = default_line_display ( sqc_chart,
						      prompt_upper_spec . user_info )
	PROMPT OBJECT prompt_two_data
	       ON LINE 9 FROM 28
	       BROWSE ON boolean

	prompt_two_data . is_radio = TRUE
	prompt_two_data . toggled_routine = "limits_type_a_data"
	prompt_two_data . vgl_library = GLOBAL( "CURRENT_LIBRARY" )
	prompt_two_data . user_info = "data_a_radio"
	prompt_two_data . caption = GET_USER_MESSAGE( "SQCWIN_MAIN_LCT_1", 1 )

	PROMPT OBJECT prompt_two_target
	       ON LINE 9 FROM 39
	       BROWSE ON boolean

	prompt_two_target . is_radio = TRUE
	prompt_two_target . toggled_routine = "limits_type_a_target"
	prompt_two_target . vgl_library = GLOBAL( "CURRENT_LIBRARY" )
	prompt_two_target . user_info = "target_a_radio"
	prompt_two_target . caption = GET_USER_MESSAGE( "SQCWIN_MAIN_LCT_2", 1 )

	PROMPT OBJECT prompt_two_spec
	       ON LINE 9 FROM 52
	       BROWSE ON boolean

	prompt_two_spec . is_radio = TRUE
	prompt_two_spec . toggled_routine = "limits_type_a_spec"
	prompt_two_spec . vgl_library = GLOBAL( "CURRENT_LIBRARY" )
	prompt_two_spec . user_info = "spec_a_radio"
	prompt_two_spec . caption = GET_USER_MESSAGE( "SQCWIN_MAIN_LCT_3", 1 )

	PROMPT OBJECT prompt_two_mlp
	       ON LINE 9 FROM 65
	       BROWSE ON boolean

	prompt_two_mlp . is_radio = TRUE
	prompt_two_mlp . toggled_routine = "limits_type_a_mlp"
	prompt_two_mlp . vgl_library = GLOBAL( "CURRENT_LIBRARY" )
	prompt_two_mlp . user_info = "mlp_a_radio"
	prompt_two_mlp . caption = GET_USER_MESSAGE( "SQCWIN_MAIN_LCT_4", 1 )

	IF NOT use_mlp_spec THEN

		prompt_two_mlp . set_enabled( FALSE )

	ENDIF

	PROMPT OBJECT prompt_three_data
	       ON LINE 10 FROM 28
	       BROWSE ON boolean

	prompt_three_data . is_radio = TRUE
	prompt_three_data . toggled_routine = "limits_type_b_data"
	prompt_three_data . vgl_library = GLOBAL( "CURRENT_LIBRARY" )
	prompt_three_data . user_info = "data_b_radio"
	prompt_three_data . caption = GET_USER_MESSAGE( "SQCWIN_MAIN_LCT_1", 1 )

	PROMPT OBJECT prompt_three_target
	       ON LINE 10 FROM 39
	       BROWSE ON boolean

	prompt_three_target . is_radio = TRUE
	prompt_three_target . toggled_routine = "limits_type_b_target"
	prompt_three_target . vgl_library = GLOBAL( "CURRENT_LIBRARY" )
	prompt_three_target . user_info = "target_b_radio"
	prompt_three_target . caption = GET_USER_MESSAGE( "SQCWIN_MAIN_LCT_2", 1 )

	PROMPT OBJECT prompt_three_spec
	       ON LINE 10 FROM 52
	       BROWSE ON boolean

	prompt_three_spec . is_radio = TRUE
	prompt_three_spec . toggled_routine = "limits_type_b_spec"
	prompt_three_spec . vgl_library = GLOBAL( "CURRENT_LIBRARY" )
	prompt_three_spec . user_info = "spec_b_radio"
	prompt_three_spec . caption = GET_USER_MESSAGE( "SQCWIN_MAIN_LCT_3", 1 )

	PROMPT OBJECT prompt_three_mlp
	       ON LINE 10 FROM 65
	       BROWSE ON boolean

	prompt_three_mlp . is_radio = TRUE
	prompt_three_mlp . toggled_routine = "limits_type_b_mlp"
	prompt_three_mlp . vgl_library = GLOBAL( "CURRENT_LIBRARY" )
	prompt_three_mlp . user_info = "mlp_b_radio"
	prompt_three_mlp . caption = GET_USER_MESSAGE( "SQCWIN_MAIN_LCT_4", 1 )

	IF NOT use_mlp_spec THEN

		prompt_three_mlp . set_enabled( FALSE )

	ENDIF

	PROMPT OBJECT prompt_four
		ON LINE 12 FROM ( text_four . column + text_four . width + 1 ) 
		BROWSE ON sqcwin_trend . identifier
		WITH (  user_info = "trend_chart_a" )

	prompt_four . width = 25

	prompt_four . value = default_line_display ( sqc_chart,
						      prompt_four . user_info )

	text_five . column = ( prompt_four . column + prompt_four . width + 1 )

	PROMPT OBJECT prompt_five
		ON LINE 12 FROM ( text_five . column + text_five . width + 1 ) 
		BROWSE ON sqcwin_trend . identifier
		WITH (  user_info = "trend_chart_b" )

	prompt_five . width = 25

	prompt_five . value = default_line_display ( sqc_chart,
						     prompt_five . user_info )

	PROMPT OBJECT prompt_six
		ON LINE 14 FROM 2
		BROWSE ON BOOLEAN
		WITH ( user_info = "display_spec",
		       is_check = TRUE           ,
		       enter_prompt_routine = "disable_prompt" )

	prompt_six . caption = GET_USER_MESSAGE ( "MEANS_PARA_DISP_SPEC", 1 ) 

	prompt_six . value = default_line_display ( sqc_chart,
						    prompt_six . user_info )

	PROMPT OBJECT prompt_seven
		ON LINE 14 FROM ( form . width * 0.25 )
		BROWSE ON BOOLEAN
		WITH ( user_info = "display_control",
		       is_check = TRUE )

	prompt_seven . caption = GET_USER_MESSAGE ( "MEANS_PARA_DISP_CONT", 1 ) 

	prompt_seven . value = default_line_display ( sqc_chart,
						      prompt_seven . user_info )

	PROMPT OBJECT prompt_eight
		ON LINE 14 FROM ( form . width * 0.5 )
		BROWSE ON BOOLEAN
		WITH ( user_info = "display_warning",
		       is_check = TRUE )

	prompt_eight . caption = GET_USER_MESSAGE ( "MEANS_PARA_DISP_WARN", 1 )

	prompt_eight . value = default_line_display ( sqc_chart,
						     prompt_eight . user_info )

	PROMPT OBJECT prompt_nine
		ON LINE 14 FROM ( form . width * 0.75 )
		BROWSE ON BOOLEAN
		WITH ( user_info = "display_one_sigma",
		       is_check = TRUE )

	prompt_nine . caption = GET_USER_MESSAGE ( "MEANS_PARA_DISP_STDDEV", 1 )

	prompt_nine . value = default_line_display ( sqc_chart,
						    prompt_nine . user_info )

	form.add_display(text_one)
	form.add_display(text_spec_type)
	form.add_display(text_upper_spec)
	form.add_display(text_lower_spec)
	IF use_mlp_spec THEN

		form . add_display( text_level )

	ENDIF
	form.add_display(text_two)
	form.add_display(text_three)
	form.add_display(text_four)
	form.add_display(text_five)

	form.add_prompt(prompt_one)
	form.add_prompt(prompt_four)
	form.add_prompt(prompt_five)
	form.add_prompt(prompt_six)
	form.add_prompt(prompt_seven)
	form.add_prompt(prompt_eight)
	form.add_prompt(prompt_nine)

	form . add_prompt( prompt_level )
	form . add_prompt( prompt_upper_spec )
	form . add_prompt( prompt_lower_spec )

	form . add_prompt( prompt_spec )
	form . add_prompt( prompt_disable )
	form . add_prompt( prompt_mlp )

	form.add_prompt(prompt_two_data)
	form.add_prompt(prompt_two_target)
	form.add_prompt(prompt_two_spec)
	form.add_prompt(prompt_two_mlp)

	form.add_prompt(prompt_three_data)
	form.add_prompt(prompt_three_target)
	form.add_prompt(prompt_three_spec)
	form.add_prompt(prompt_three_mlp)

	add_param_buttons (sqc_chart , form)

	not_exiting_main = TRUE

	WHILE not_exiting_main DO
	
		form.start_prompt()

		chosen_spec_type = default_line_display( sqc_chart, "spec_type" )
							   
		IF ( chosen_spec_type = 1 ) THEN 

			prompt_spec . set_text( TRUE )
			select_spec_limits( prompt_spec )

		ELSEIF( chosen_spec_type = 2 ) THEN

			prompt_disable . set_text( TRUE )
			select_disable_limits( prompt_disable )

		ELSEIF( chosen_spec_type = 3 ) THEN

			IF use_mlp_spec THEN

				prompt_mlp . set_text( TRUE )
				spec_type_mlp( prompt_mlp )

			ELSE

				prompt_disable . set_text( TRUE )
				select_disable_limits( prompt_disable )

			ENDIF

		ENDIF

		chosen_type_a_limit = default_line_display( sqc_chart, "limits_calc_type_a" )
		chosen_type_b_limit = default_line_display( sqc_chart, "limits_calc_type_b" )

		IF chosen_type_a_limit = 1 THEN

			prompt_two_data . set_text( TRUE )
			limits_type_a_data( prompt_two_data )

		ELSEIF chosen_type_a_limit = 2 THEN

			prompt_two_target . set_text( TRUE )
			limits_type_a_target( prompt_two_target )

		ELSEIF chosen_type_a_limit = 3 THEN

			prompt_two_spec . set_text( TRUE )
			limits_type_a_spec( prompt_two_spec )

		ELSEIF chosen_type_a_limit = 4 THEN

			IF use_mlp_spec THEN

				prompt_two_mlp . set_text( TRUE )
				limits_type_a_mlp( prompt_two_mlp )

			ELSE

				prompt_two_data . set_text( TRUE )
				limits_type_a_data( prompt_two_data )

			ENDIF

		ENDIF

		IF chosen_type_b_limit = 1 THEN

			prompt_three_data . set_text( TRUE )
			limits_type_b_data( prompt_three_data )

		ELSEIF chosen_type_b_limit = 2 THEN

			prompt_three_target . set_text( TRUE )
			limits_type_b_target( prompt_three_target )

		ELSEIF chosen_type_b_limit = 3 THEN

			prompt_three_spec . set_text( TRUE )
			limits_type_b_spec( prompt_three_spec )

		ELSEIF chosen_type_b_limit = 4 THEN

			IF use_mlp_spec THEN

				prompt_three_mlp . set_text( TRUE )
				limits_type_b_mlp( prompt_three_mlp )

			ELSE

				prompt_three_data . set_text( TRUE )
				limits_type_b_data( prompt_three_data )

			ENDIF

		ENDIF



		not_exiting = TRUE

		WHILE not_exiting DO

			form.wait_prompt()


			chosen_spec_type = default_line_display( sqc_chart, "spec_type" )

			IF ( ( LASTKEY = "RIGHT" )      AND
			     ( chosen_spec_type = 1 ) ) THEN

				IF prompt_upper_spec . value <= prompt_lower_spec . value THEN

					flash_message( "Please set upper specification higher than":
						       "lower specification", TRUE )

				ELSE

					not_exiting = FALSE

				ENDIF

			ELSEIF( ( LASTKEY = "RIGHT" ) OR
			        ( LASTKEY = "LEFT"  ) OR
			        ( LASTKEY = "EXIT"  )    ) THEN

				not_exiting = FALSE

			ENDIF


		ENDWHILE

		form.end_prompt()

		chosen_type_a_limit = default_line_display( sqc_chart, "limits_calc_type_a" )
		chosen_type_b_limit = default_line_display( sqc_chart, "limits_calc_type_b" )

		IF ( chosen_type_a_limit + chosen_type_b_limit > 2 ) AND
		   ( LASTKEY = "RIGHT"                             ) THEN

			shewhart_limits( sqc_chart             			    ,
			                 GET_USER_MESSAGE( "INDMR_PARA_LIMIT_TYPE_A", 1 ) , 
			                 GET_USER_MESSAGE( "INDMR_PARA_LIMIT_TYPE_B", 1 ) )

				IF NOT ( LASTKEY = "LEFT" ) THEN

					not_exiting_main = FALSE

				ENDIF

		ELSE

			not_exiting_main = FALSE

		ENDIF

	ENDWHILE

	IF ( LASTKEY <> "EXIT" ) THEN

		write_prompts_to_objDB ( form, 1, 10 )


		IF( chosen_spec_type = 3 ) THEN

			write_prompt_text_to_objDB( form, "mlp_level" )

		ENDIF

		IF LASTKEY = "RIGHT" THEN

			do_shewhart_calculations ( sqc_chart, INDMR )

		ENDIF

	ENDIF

	IF ( sqc_chart . next_screen <> "DRAW") THEN

	    get_next_screen (sqc_chart)

	ENDIF

ENDROUTINE

{******************************************************************************}

GLOBAL ROUTINE meanr_chart_params (sqc_chart)

{ 
* This routine gets the Mean and Range Chart parameters.
* 
* 
*
* Parameters   : sqc_chart
* Return Value : na/a
*
*******************************************************************************}

DECLARE form, chosen_spec_type, prompt_upper_spec, prompt_lower_spec
DECLARE text_one,text_two,text_three, text_four,text_five,text_six,text_seven
DECLARE text_spec_type, text_upper_spec, text_lower_spec, text_level
DECLARE prompt_one,prompt_two,prompt_three, prompt_six, prompt_seven,
        prompt_eight, prompt_nine, prompt_ten, prompt_eleven
DECLARE prompt_level, prompt_spec, prompt_disable, prompt_mlp
DECLARE subgroup_choose, type_info, chart_type_ndx,  not_exiting, not_exiting_main
DECLARE prompt_four_data, prompt_four_target, prompt_four_spec, prompt_four_mlp
DECLARE prompt_five_data, prompt_five_target, prompt_five_spec, prompt_five_mlp
DECLARE use_mlp_spec, chosen_type_a_limit, chosen_type_b_limit, mlp_levels

	chart_type_ndx = PAD ( sqc_chart . chart_id, " ", "20" ) :
			 PAD ( MEAN_RANGE          , " ", "10" )

	sqc_chart . sqc_chart_type . set_by_index ( "KEY0", chart_type_ndx )

	type_info = STRIP ( SELECT sqcwin_chart_type . chart_type IN OBJECT
			    sqc_chart . sqc_chart_type . current )

	sqc_chart . tmp_chart_type = MEAN_RANGE

	create_sqc_form( form )
	form.help_context = "$REPORTER_FORM_PROMPT"
	form.border=TRUE
	form.header= type_info:" Chart Parameters"
	form.add_frame( GET_USER_MESSAGE( "SQCWIN_MAIN_NCT_20", 1 ) ,
			1      ,
			0       ,
			0       ,
			75)
	form.add_frame( GET_USER_MESSAGE( "SQCWIN_MAIN_NCT_21", 1 )      ,
			1      ,
			4       ,
			0       ,
			75)
	form.add_frame(GET_USER_MESSAGE( "SQCWIN_MAIN_NCT_22", 1 )       ,
			1      ,
			8       ,
			0       ,
			75)
	form.add_frame( GET_USER_MESSAGE( "SQCWIN_MAIN_NCT_23", 1 ),
			1      ,
			11       ,
			0       ,
			75)
	form.add_frame( GET_USER_MESSAGE( "SQCWIN_MAIN_NCT_24", 1 ) ,
			1      ,
			13       ,
			0       ,
			75)
	form . user_info = sqc_chart

	PROMPT OBJECT text_one
		CLASS "STD_PROMPT_TEXT"
		ON LINE 1 FROM ( form . width * 0.25 )
		WITH (  raised=TRUE,
			value=GET_USER_MESSAGE ( "MEANR_PARA_SUBGROUP_CHOSEN_BY", 1 ) )

	text_one . width = 18

	PROMPT OBJECT text_two
		CLASS "STD_PROMPT_TEXT"
		ON LINE 2 FROM ( form . width * 0.25 )
		WITH(   raised=TRUE,
			value=GET_USER_MESSAGE ( "MEANR_PARA_SUBGROUP_SIZE", 1 ) )

	text_two . width = 18

	PROMPT OBJECT text_three
		CLASS "STD_PROMPT_TEXT"
		ON LINE 3 FROM ( form . width * 0.25 )
		WITH(   raised=TRUE,
			value=GET_USER_MESSAGE ( "MEANR_PARA_TEST_LENGTH", 1 ) )

	text_three . width = 18

	PROMPT OBJECT text_spec_type
		CLASS "STD_PROMPT_TEXT"
		ON LINE 5 FROM 15
		WITH (  raised=TRUE,
			value=GET_USER_MESSAGE ( "MEANR_PARA_SPEC_TYPE", 1 ) )

	text_spec_type . width = STRINGLENGTH( GET_USER_MESSAGE ( "MEANR_PARA_SPEC_TYPE", 1 ) )

	PROMPT OBJECT text_lower_spec
		CLASS "STD_PROMPT_TEXT"
		ON LINE 7 FROM 2
		WITH (  raised=TRUE,
			value=GET_USER_MESSAGE( "SQCWIN_MAIN_LCT_15" , 1 ) )

	text_lower_spec . width = 
	STRINGLENGTH( GET_USER_MESSAGE( "SQCWIN_MAIN_LCT_15" , 1 ) )	

	PROMPT OBJECT text_upper_spec
		CLASS "STD_PROMPT_TEXT"
		ON LINE 7 
		WITH (  raised=TRUE,
			value= GET_USER_MESSAGE( "SQCWIN_MAIN_LCT_14" , 1 ) )

	text_upper_spec . width = 
	STRINGLENGTH( GET_USER_MESSAGE( "SQCWIN_MAIN_LCT_14" , 1 ) )

	PROMPT OBJECT text_level
		CLASS "STD_PROMPT_TEXT"
		ON LINE 7 FROM 55 TO 59
		WITH (  raised=TRUE,
			value=GET_USER_MESSAGE( "SQCWIN_MAIN_LCT_16" , 1 ))

	PROMPT OBJECT text_four
		CLASS "STD_PROMPT_TEXT"
		ON LINE 9 FROM 20
		WITH (value=GET_USER_MESSAGE ( "MEANR_PARA_LIMIT_TYPE_A", 1 ),
			raised=TRUE)

	text_four . width = STRINGLENGTH( GET_USER_MESSAGE ( "MEANR_PARA_LIMIT_TYPE_A", 1 ) )

	PROMPT OBJECT text_five
		CLASS "STD_PROMPT_TEXT"
		ON LINE 10 FROM 20
		WITH (value=GET_USER_MESSAGE ( "MEANR_PARA_LIMIT_TYPE_B", 1 ),
			raised=TRUE)

	text_five . width = STRINGLENGTH( GET_USER_MESSAGE ( "MEANR_PARA_LIMIT_TYPE_B", 1 ) )

	PROMPT OBJECT text_six
		CLASS "STD_PROMPT_TEXT"
		ON LINE 12 FROM 15
		WITH(   raised=TRUE,
			value=GET_USER_MESSAGE ( "MEANR_PARA_TREND_TYPE_A", 1 ) )

	text_six . width = 
	STRINGLENGTH( GET_USER_MESSAGE ( "MEANS_PARA_TREND_TYPE_A", 1 ) )

	PROMPT OBJECT text_seven
		CLASS "STD_PROMPT_TEXT"
		ON LINE 12
		WITH(   raised=TRUE,
			value=GET_USER_MESSAGE ( "MEANR_PARA_TREND_TYPE_B", 1 ) )

	text_seven . width = 
	STRINGLENGTH( GET_USER_MESSAGE ( "MEANS_PARA_TREND_TYPE_B", 1 ) )


	ARRAY subgroup_choose
		subgroup_choose[1,1]="Size"
	    subgroup_choose[1,2]=SIZE
		subgroup_choose[2,1]="Date"
	    subgroup_choose[2,2]=TIME
		subgroup_choose[3,1]="Group"
	    subgroup_choose[3,2]=NAME

	PROMPT OBJECT prompt_one
		ON LINE 1 FROM ( text_one . column + text_one . width + 1 )
		CHOOSE OUTOF subgroup_choose
		WITH ( user_info            = "subgroup_chosen_by"    ,
		       leave_prompt_routine = "disable_subgroup_size" )

	prompt_one . value = default_line_display ( sqc_chart,
						    prompt_one . user_info )

	PROMPT OBJECT prompt_two
		ON LINE 2 FROM ( text_two . column + text_two . width + 1 ) 
		BROWSE ON integer
		WITH (  minimum=2,
			maximum=10,
			user_info = "subgroup_size_wanted" )

	prompt_two . value = default_line_display ( sqc_chart,
						    prompt_two . user_info )

	PROMPT OBJECT prompt_three
		ON LINE 3 FROM ( text_three . column + text_three . width + 1 )
		BROWSE ON INTEGER
		WITH (  minimum=0,
			maximum=9999,
			user_info = "test_length" )

	prompt_three . value = default_line_display ( sqc_chart,
						      prompt_three . user_info )

	use_mlp_spec = use_mlp_spec_bool( sqc_chart . selection_criteria )

	PROMPT OBJECT prompt_spec
	       ON LINE 5 FROM 28
	       BROWSE ON boolean

	prompt_spec . is_radio = TRUE
	prompt_spec . toggled_routine = "select_spec_limits"
	prompt_spec . vgl_library = GLOBAL( "CURRENT_LIBRARY" )
	prompt_spec . user_info = "spec_radio"
	prompt_spec . caption = GET_USER_MESSAGE( "SQCWIN_MAIN_LCT_3" , 1 )

	PROMPT OBJECT prompt_disable
	       ON LINE 5 FROM 45
	       BROWSE ON boolean

	prompt_disable . is_radio = TRUE
	prompt_disable . toggled_routine = "select_disable_limits"
	prompt_disable . vgl_library = GLOBAL( "CURRENT_LIBRARY" )
	prompt_disable . user_info = "disable_radio"
	prompt_disable . caption = GET_USER_MESSAGE( "SQCWIN_MAIN_LCT_9" , 1 )

	PROMPT OBJECT prompt_mlp
	       ON LINE 5 FROM 65
	       BROWSE ON boolean

	prompt_mlp . is_radio = TRUE
	prompt_mlp . toggled_routine = "spec_type_mlp"
	prompt_mlp . vgl_library = GLOBAL( "CURRENT_LIBRARY" )
	prompt_mlp . user_info = "mlp_radio"
	prompt_mlp . caption = GET_USER_MESSAGE( "SQCWIN_MAIN_LCT_4" , 1 )

	ARRAY mlp_levels

	IF use_mlp_spec THEN

		get_mlp_levels( sqc_chart, mlp_levels )

	ENDIF

	PROMPT OBJECT prompt_level
	ON LINE 7 FROM 60
	CHOOSE OUTOF mlp_levels
	WITH ( selected_routine = "spec_type_mlp_choose"     ,
	       leave_prompt_routine = "spec_type_mlp_choose" ,
	       user_info = "mlp_level"                       )

	IF use_mlp_spec THEN
	
		set_level_prompt_value( sqc_chart, prompt_level, mlp_levels )

	ENDIF

	IF NOT use_mlp_spec THEN

		prompt_mlp . set_enabled( FALSE )
		prompt_level . set_enabled( FALSE )
		prompt_level . set_visible( FALSE )

	ENDIF

	PROMPT OBJECT prompt_lower_spec
		ON LINE 7
		FROM ( text_lower_spec . column + text_lower_spec . width )		
		BROWSE ON REAL
		WITH (  user_info = "lower_spec")

	prompt_lower_spec . value = default_line_display ( sqc_chart,
						      prompt_lower_spec . user_info )


	prompt_lower_spec . width = 10
	
	text_upper_spec . column = ( prompt_lower_spec . column + 
	                             prompt_lower_spec . width + 5   )
	
	PROMPT OBJECT prompt_upper_spec
		ON LINE 7
		FROM ( text_upper_spec . column + text_upper_spec . width )
		BROWSE ON REAL
		WITH (  user_info = "upper_spec")

	prompt_upper_spec . value = default_line_display ( sqc_chart,
						      prompt_upper_spec . user_info )
	PROMPT OBJECT prompt_four_data
	       ON LINE 9 FROM 28
	       BROWSE ON boolean

	prompt_four_data . is_radio = TRUE
	prompt_four_data . toggled_routine = "limits_type_a_data"
	prompt_four_data . vgl_library = GLOBAL( "CURRENT_LIBRARY" )
	prompt_four_data . user_info = "data_a_radio"
	prompt_four_data . caption = GET_USER_MESSAGE( "SQCWIN_MAIN_LCT_1", 1 )

	PROMPT OBJECT prompt_four_target
	       ON LINE 9 FROM 39
	       BROWSE ON boolean

	prompt_four_target . is_radio = TRUE
	prompt_four_target . toggled_routine = "limits_type_a_target"
	prompt_four_target . vgl_library = GLOBAL( "CURRENT_LIBRARY" )
	prompt_four_target . user_info = "target_a_radio"
	prompt_four_target . caption = GET_USER_MESSAGE( "SQCWIN_MAIN_LCT_2", 1 )

	PROMPT OBJECT prompt_four_spec
	       ON LINE 9 FROM 52
	       BROWSE ON boolean

	prompt_four_spec . is_radio = TRUE
	prompt_four_spec . toggled_routine = "limits_type_a_spec"
	prompt_four_spec . vgl_library = GLOBAL( "CURRENT_LIBRARY" )
	prompt_four_spec . user_info = "spec_a_radio"
	prompt_four_spec . caption = GET_USER_MESSAGE( "SQCWIN_MAIN_LCT_3", 1 )

	PROMPT OBJECT prompt_four_mlp
	       ON LINE 9 FROM 65
	       BROWSE ON boolean

	prompt_four_mlp . is_radio = TRUE
	prompt_four_mlp . toggled_routine = "limits_type_a_mlp"
	prompt_four_mlp . vgl_library = GLOBAL( "CURRENT_LIBRARY" )
	prompt_four_mlp . user_info = "mlp_a_radio"
	prompt_four_mlp . caption = GET_USER_MESSAGE( "SQCWIN_MAIN_LCT_4", 1 )

	IF NOT use_mlp_spec THEN

		prompt_four_mlp . set_enabled( FALSE )

	ENDIF

	PROMPT OBJECT prompt_five_data
	       ON LINE 10 FROM 28
	       BROWSE ON boolean

	prompt_five_data . is_radio = TRUE
	prompt_five_data . toggled_routine = "limits_type_b_data"
	prompt_five_data . vgl_library = GLOBAL( "CURRENT_LIBRARY" )
	prompt_five_data . user_info = "data_b_radio"
	prompt_five_data . caption = GET_USER_MESSAGE( "SQCWIN_MAIN_LCT_1", 1 )

	PROMPT OBJECT prompt_five_target
	       ON LINE 10 FROM 39
	       BROWSE ON boolean

	prompt_five_target . is_radio = TRUE
	prompt_five_target . toggled_routine = "limits_type_b_target"
	prompt_five_target . vgl_library = GLOBAL( "CURRENT_LIBRARY" )
	prompt_five_target . user_info = "target_b_radio"
	prompt_five_target . caption = GET_USER_MESSAGE( "SQCWIN_MAIN_LCT_2", 1 )

	PROMPT OBJECT prompt_five_spec
	       ON LINE 10 FROM 52
	       BROWSE ON boolean

	prompt_five_spec . is_radio = TRUE
	prompt_five_spec . toggled_routine = "limits_type_b_spec"
	prompt_five_spec . vgl_library = GLOBAL( "CURRENT_LIBRARY" )
	prompt_five_spec . user_info = "spec_b_radio"
	prompt_five_spec . caption = GET_USER_MESSAGE( "SQCWIN_MAIN_LCT_3", 1 )

	PROMPT OBJECT prompt_five_mlp
	       ON LINE 10 FROM 65
	       BROWSE ON boolean

	prompt_five_mlp . is_radio = TRUE
	prompt_five_mlp . toggled_routine = "limits_type_b_mlp"
	prompt_five_mlp . vgl_library = GLOBAL( "CURRENT_LIBRARY" )
	prompt_five_mlp . user_info = "mlp_b_radio"
	prompt_five_mlp . caption = GET_USER_MESSAGE( "SQCWIN_MAIN_LCT_4", 1 )

	IF NOT use_mlp_spec THEN

		prompt_five_mlp . set_enabled( FALSE )

	ENDIF

	PROMPT OBJECT prompt_six
		ON LINE 12 FROM ( text_six . column + text_six . width + 1 ) 
		BROWSE ON sqcwin_trend . identifier
		WITH (  user_info = "trend_chart_a" )

	prompt_six . width = 25

	prompt_six . value = default_line_display ( sqc_chart,
						    prompt_six . user_info )

	text_seven . column = ( prompt_six . column + prompt_six . width + 1 )

	PROMPT OBJECT prompt_seven
		ON LINE 12 FROM ( text_seven . column + text_seven . width + 1 ) 
		BROWSE ON sqcwin_trend . identifier
		WITH (  user_info = "trend_chart_b" )

	prompt_seven . width = 25

	prompt_seven . value = default_line_display ( sqc_chart,
						      prompt_seven . user_info )

	PROMPT OBJECT prompt_eight
		ON LINE 14 FROM 2
		BROWSE ON BOOLEAN
		WITH ( is_check = TRUE,
		       user_info = "display_spec" )

	prompt_eight . caption = GET_USER_MESSAGE ( "MEANS_PARA_DISP_SPEC", 1 ) 

	prompt_eight . value = default_line_display ( sqc_chart,
						      prompt_eight . user_info )


	PROMPT OBJECT prompt_nine
		ON LINE 14 FROM ( form . width * 0.25 )
		BROWSE ON BOOLEAN
		WITH ( user_info = "display_control",
		       is_check = TRUE )

	prompt_nine . caption = GET_USER_MESSAGE ( "MEANS_PARA_DISP_CONT", 1 ) 

	prompt_nine . value = default_line_display ( sqc_chart,
						     prompt_nine . user_info )

	PROMPT OBJECT prompt_ten
		ON LINE 14 FROM ( form . width * 0.5 ) 
		BROWSE ON BOOLEAN
		WITH ( user_info = "display_warning",
		       is_check = TRUE )

	prompt_ten . caption = GET_USER_MESSAGE ( "MEANS_PARA_DISP_WARN", 1 )

	prompt_ten . value = default_line_display ( sqc_chart,
						    prompt_ten . user_info )

	PROMPT OBJECT prompt_eleven
		ON LINE 14 FROM ( form . width * 0.75 )
		BROWSE ON BOOLEAN
		WITH ( user_info = "display_one_sigma",
		       is_check = TRUE )

	prompt_eleven . caption = GET_USER_MESSAGE ( "MEANS_PARA_DISP_STDDEV", 1 )

	prompt_eleven . value = default_line_display ( sqc_chart,
						       prompt_eleven . user_info )


	form.add_display(text_one)
	form.add_display(text_two)
	form.add_display(text_three)
	form.add_display(text_spec_type)
	form.add_display(text_upper_spec)
	form.add_display(text_lower_spec)
	IF use_mlp_spec THEN

		form . add_display( text_level )

	ENDIF
	form.add_display(text_four)
	form.add_display(text_five)
	form.add_display(text_six)
	form.add_display(text_seven)
				     
	form.add_prompt(prompt_one)
	form.add_prompt(prompt_two)
	form.add_prompt(prompt_three)
	form.add_prompt(prompt_six)
	form.add_prompt(prompt_seven)
	form.add_prompt(prompt_eight)
	form.add_prompt(prompt_nine)
	form.add_prompt(prompt_ten)
	form.add_prompt(prompt_eleven)
	form . add_prompt( prompt_level )
	form . add_prompt( prompt_upper_spec )
	form . add_prompt( prompt_lower_spec )

	form . add_prompt( prompt_spec )
	form . add_prompt( prompt_disable )
	form . add_prompt( prompt_mlp )

	form.add_prompt(prompt_four_data)
	form.add_prompt(prompt_four_target)
	form.add_prompt(prompt_four_spec)
	form.add_prompt(prompt_four_mlp)
	form.add_prompt(prompt_five_data)
	form.add_prompt(prompt_five_target)
	form.add_prompt(prompt_five_spec)
	form.add_prompt(prompt_five_mlp)

	add_param_buttons (sqc_chart , form)

	not_exiting_main = TRUE

	WHILE not_exiting_main DO
	
		form.start_prompt()

		chosen_spec_type = default_line_display( sqc_chart, "spec_type" )
							   
		IF ( chosen_spec_type = 1 ) THEN 

			prompt_spec . set_text( TRUE )
			select_spec_limits( prompt_spec )

		ELSEIF( chosen_spec_type = 2 ) THEN

			prompt_disable . set_text( TRUE )
			select_disable_limits( prompt_disable )

		ELSEIF( chosen_spec_type = 3 ) THEN

			IF use_mlp_spec THEN

				prompt_mlp . set_text( TRUE )
				spec_type_mlp( prompt_mlp )

			ELSE

				prompt_disable . set_text( TRUE )
				select_disable_limits( prompt_disable )

			ENDIF

		ENDIF

		chosen_type_a_limit = default_line_display( sqc_chart, "limits_calc_type_a" )
		chosen_type_b_limit = default_line_display( sqc_chart, "limits_calc_type_b" )

		IF chosen_type_a_limit = 1 THEN

			prompt_four_data . set_text( TRUE )
			limits_type_a_data( prompt_four_data )

		ELSEIF chosen_type_a_limit = 2 THEN

			prompt_four_target . set_text( TRUE )
			limits_type_a_target( prompt_four_target )

		ELSEIF chosen_type_a_limit = 3 THEN

			prompt_four_spec . set_text( TRUE )
			limits_type_a_spec( prompt_four_spec )

		ELSEIF chosen_type_a_limit = 4 THEN

			IF use_mlp_spec THEN

				prompt_four_mlp . set_text( TRUE )
				limits_type_a_mlp( prompt_four_mlp )

			ELSE

				prompt_four_data . set_text( TRUE )
				limits_type_a_data( prompt_four_data )

			ENDIF

		ENDIF

		IF chosen_type_b_limit = 1 THEN

			prompt_five_data . set_text( TRUE )
			limits_type_b_data( prompt_five_data )

		ELSEIF chosen_type_b_limit = 2 THEN

			prompt_five_target . set_text( TRUE )
			limits_type_b_target( prompt_five_target )

		ELSEIF chosen_type_b_limit = 3 THEN

			prompt_five_spec . set_text( TRUE )
			limits_type_b_spec( prompt_five_spec )

		ELSEIF chosen_type_b_limit = 4 THEN

			IF use_mlp_spec THEN

				prompt_five_mlp . set_text( TRUE )
				limits_type_b_mlp( prompt_five_mlp )

			ELSE

				prompt_five_data . set_text( TRUE )
				limits_type_b_data( prompt_five_data )

			ENDIF

		ENDIF



		not_exiting = TRUE

		WHILE not_exiting DO

			form.wait_prompt()


			chosen_spec_type = default_line_display( sqc_chart, "spec_type" )

			IF ( ( LASTKEY = "RIGHT" )      AND
			     ( chosen_spec_type = 1 ) ) THEN

				IF prompt_upper_spec . value <= prompt_lower_spec . value THEN

					flash_message( "Please set upper specification higher than":
						       "lower specification", TRUE )

				ELSE

					not_exiting = FALSE

				ENDIF

			ELSEIF( ( LASTKEY = "RIGHT" ) OR 
			        ( LASTKEY = "LEFT"  ) OR
			        ( LASTKEY = "EXIT"  )    ) THEN

				not_exiting = FALSE

			ENDIF


		ENDWHILE

		form.end_prompt()

		chosen_type_a_limit = default_line_display( sqc_chart, "limits_calc_type_a" )
		chosen_type_b_limit = default_line_display( sqc_chart, "limits_calc_type_b" )

		IF ( chosen_type_a_limit + chosen_type_b_limit > 2 ) AND
		   ( LASTKEY = "RIGHT"                             ) THEN

			shewhart_limits( sqc_chart             			    ,
			                 GET_USER_MESSAGE( "SQCWIN_MAIN_NCT_6", 1 ) , 
			                 GET_USER_MESSAGE( "SQCWIN_MAIN_NCT_7", 1 ) )

				IF NOT ( LASTKEY = "LEFT" ) THEN

					not_exiting_main = FALSE

				ENDIF

		ELSE

			not_exiting_main = FALSE

		ENDIF

	ENDWHILE

	IF ( LASTKEY <> "EXIT" ) THEN

		write_prompts_to_objDB ( form, 1, 12 )


		IF( chosen_spec_type = 3 ) THEN

			write_prompt_text_to_objDB( form, "mlp_level" )

		ENDIF

		IF LASTKEY = "RIGHT" THEN

			do_shewhart_calculations ( sqc_chart, MEAN_RANGE )

		ENDIF

	ENDIF

	IF ( sqc_chart . next_screen <> "DRAW") THEN

	    get_next_screen (sqc_chart)

	ENDIF

ENDROUTINE

{******************************************************************************}

GLOBAL ROUTINE means_chart_params (sqc_chart)

{ 
* This routine gets the Mean and Standard Deviation chart parametsrs.
* 
* 
*
* Parameters   : sqc_chart
* Return Value : n/a
*
*******************************************************************************}

DECLARE form, chosen_spec_type, prompt_upper_spec, prompt_lower_spec
DECLARE text_one,text_two,text_three, text_four,text_five,text_six,text_seven
DECLARE text_spec_type, text_upper_spec, text_lower_spec, text_level
DECLARE prompt_one,prompt_two,prompt_three, prompt_six, prompt_seven,
        prompt_eight, prompt_nine, prompt_ten, prompt_eleven

DECLARE prompt_level, prompt_spec, prompt_disable, prompt_mlp

DECLARE subgroup_choose, type_info, chart_type_ndx,  not_exiting, not_exiting_main
DECLARE prompt_four_data, prompt_four_target, prompt_four_spec, prompt_four_mlp
DECLARE prompt_five_data, prompt_five_target, prompt_five_spec, prompt_five_mlp
DECLARE use_mlp_spec, chosen_type_a_limit, chosen_type_b_limit, mlp_levels

	chart_type_ndx = PAD ( sqc_chart . chart_id, " ", "20" ) :
			 PAD ( MEAN_STD            , " ", "10" )

	sqc_chart . sqc_chart_type . set_by_index ( "KEY0", chart_type_ndx )

	type_info = STRIP ( SELECT sqcwin_chart_type . chart_type IN OBJECT
			    sqc_chart . sqc_chart_type . current )

	sqc_chart . tmp_chart_type = MEAN_STD

	create_sqc_form( form )
	form.help_context = "$REPORTER_FORM_PROMPT"
	form.border=TRUE
	form.header= type_info:" Chart Parameters"
	form.add_frame( GET_USER_MESSAGE( "SQCWIN_MAIN_NCT_20", 1 ) ,
			1      ,
			0       ,
			0       ,
			75)
	form.add_frame( GET_USER_MESSAGE( "SQCWIN_MAIN_NCT_21", 1 )      ,
			1      ,
			4       ,
			0       ,
			75)
	form.add_frame(GET_USER_MESSAGE( "SQCWIN_MAIN_NCT_22", 1 )       ,
			1      ,
			8       ,
			0       ,
			75)
	form.add_frame( GET_USER_MESSAGE( "SQCWIN_MAIN_NCT_23", 1 ),
			1      ,
			11       ,
			0       ,
			75)
	form.add_frame( GET_USER_MESSAGE( "SQCWIN_MAIN_NCT_24", 1 ) ,
			1      ,
			13       ,
			0       ,
			75)
	form . user_info = sqc_chart

	PROMPT OBJECT text_one
		CLASS "STD_PROMPT_TEXT"
		ON LINE 1 FROM ( form . width * 0.25 )
		WITH ( value=GET_USER_MESSAGE ( "MEANS_PARA_SUBGROUP_CHOSEN_BY", 1 ) )

	text_one . width = 18

	PROMPT OBJECT text_two
		CLASS "STD_PROMPT_TEXT"
		ON LINE 2 FROM ( form . width * 0.25 )
		WITH( value=GET_USER_MESSAGE ( "MEANS_PARA_SUBGROUP_SIZE", 1 ) )

	text_two . width = 18

	PROMPT OBJECT text_three
		CLASS "STD_PROMPT_TEXT"
		ON LINE 3 FROM ( form . width * 0.25 )
		WITH( value=GET_USER_MESSAGE ( "MEANS_PARA_TEST_LENGTH", 1 ) )

	text_three . width = 18

	PROMPT OBJECT text_spec_type
		CLASS "STD_PROMPT_TEXT"
		ON LINE 5 FROM 15
		WITH ( value=GET_USER_MESSAGE ( "MEANS_PARA_SPEC_TYPE", 1 ) )

	text_spec_type . width = STRINGLENGTH( GET_USER_MESSAGE ( "MEANS_PARA_SPEC_TYPE", 1 ) )

	PROMPT OBJECT text_lower_spec
		CLASS "STD_PROMPT_TEXT"
		ON LINE 7 FROM 2
		WITH ( value= GET_USER_MESSAGE( "SQCWIN_MAIN_LCT_15" , 1 ) )

	text_lower_spec . width = 
	STRINGLENGTH( GET_USER_MESSAGE( "SQCWIN_MAIN_LCT_15" , 1 ) )	

	PROMPT OBJECT text_upper_spec
		CLASS "STD_PROMPT_TEXT"
		ON LINE 7 
		WITH ( value=GET_USER_MESSAGE( "SQCWIN_MAIN_LCT_14" , 1 ) )

	text_upper_spec . width = 
	STRINGLENGTH( GET_USER_MESSAGE( "SQCWIN_MAIN_LCT_14" , 1 ) )



	PROMPT OBJECT text_level
		CLASS "STD_PROMPT_TEXT"
		ON LINE 7 FROM 55 TO 59
		WITH ( value=GET_USER_MESSAGE( "SQCWIN_MAIN_LCT_16" , 1 ) )

	PROMPT OBJECT text_four
		CLASS "STD_PROMPT_TEXT"
		ON LINE 9 FROM 20
		WITH (value=GET_USER_MESSAGE ( "MEANS_PARA_LIMIT_TYPE_A", 1 ) )

	text_four . width = STRINGLENGTH( GET_USER_MESSAGE ( "MEANS_PARA_LIMIT_TYPE_A", 1 ) )

	PROMPT OBJECT text_five
		CLASS "STD_PROMPT_TEXT"
		ON LINE 10 FROM 20
		WITH (value=GET_USER_MESSAGE ( "MEANS_PARA_LIMIT_TYPE_B", 1 ) )

	text_five . width = STRINGLENGTH( GET_USER_MESSAGE ( "MEANS_PARA_LIMIT_TYPE_B", 1 ) )

	PROMPT OBJECT text_six
		CLASS "STD_PROMPT_TEXT"
		ON LINE 12 FROM 15 
		WITH( value=GET_USER_MESSAGE ( "MEANS_PARA_TREND_TYPE_A", 1 ) )

	text_six . width = 
	STRINGLENGTH( GET_USER_MESSAGE ( "MEANS_PARA_TREND_TYPE_A", 1 ) )

	PROMPT OBJECT text_seven
		CLASS "STD_PROMPT_TEXT"
		ON LINE 12
		WITH( value=GET_USER_MESSAGE ( "MEANS_PARA_TREND_TYPE_B", 1 ) )

	text_seven . width = 
	STRINGLENGTH( GET_USER_MESSAGE ( "MEANS_PARA_TREND_TYPE_B", 1 ) )


	ARRAY subgroup_choose
		subgroup_choose[1,1]="Size"
	    subgroup_choose[1,2]=SIZE
		subgroup_choose[2,1]="Date"
	    subgroup_choose[2,2]=TIME
		subgroup_choose[3,1]="Group"
	    subgroup_choose[3,2]=NAME

	PROMPT OBJECT prompt_one
		ON LINE 1 FROM ( text_one . column + text_one . width + 1 )
		CHOOSE OUTOF subgroup_choose
		WITH ( user_info            = "subgroup_chosen_by"    ,
		       leave_prompt_routine = "disable_subgroup_size" )

	prompt_one . value = default_line_display ( sqc_chart,
						    prompt_one . user_info )

	PROMPT OBJECT prompt_two
		ON LINE 2 FROM ( text_two . column + text_two . width + 1 )
		BROWSE ON integer
		WITH (  minimum=2,
			maximum=10,
			user_info = "subgroup_size_wanted" )

	prompt_two . value = default_line_display ( sqc_chart,
						    prompt_two . user_info )

	PROMPT OBJECT prompt_three
		ON LINE 3 FROM ( text_three . column + text_three . width + 1 )
		BROWSE ON INTEGER
		WITH (  minimum=0     ,
			maximum=9999  ,
			user_info = "test_length" )

	prompt_three . value = default_line_display ( sqc_chart,
						      prompt_three . user_info )

	use_mlp_spec = use_mlp_spec_bool( sqc_chart . selection_criteria )

	PROMPT OBJECT prompt_spec
	       ON LINE 5 FROM 28
	       BROWSE ON boolean

	prompt_spec . is_radio = TRUE
	prompt_spec . toggled_routine = "select_spec_limits"
	prompt_spec . vgl_library = GLOBAL( "CURRENT_LIBRARY" )
	prompt_spec . user_info = "spec_radio"
	prompt_spec . caption = GET_USER_MESSAGE( "SQCWIN_MAIN_LCT_3" , 1 )

	PROMPT OBJECT prompt_disable
	       ON LINE 5 FROM 45
	       BROWSE ON boolean

	prompt_disable . is_radio = TRUE
	prompt_disable . toggled_routine = "select_disable_limits"
	prompt_disable . vgl_library = GLOBAL( "CURRENT_LIBRARY" )
	prompt_disable . user_info = "disable_radio"
	prompt_disable . caption = GET_USER_MESSAGE( "SQCWIN_MAIN_LCT_9" , 1 )

	PROMPT OBJECT prompt_mlp
	       ON LINE 5 FROM 65
	       BROWSE ON boolean

	prompt_mlp . is_radio = TRUE
	prompt_mlp . toggled_routine = "spec_type_mlp"
	prompt_mlp . vgl_library = GLOBAL( "CURRENT_LIBRARY" )
	prompt_mlp . user_info = "mlp_radio"
	prompt_mlp . caption = GET_USER_MESSAGE( "SQCWIN_MAIN_LCT_4" , 1 )

	ARRAY mlp_levels

	IF use_mlp_spec THEN

		get_mlp_levels( sqc_chart, mlp_levels )

	ENDIF

	PROMPT OBJECT prompt_level
	ON LINE 7 FROM 60
	CHOOSE OUTOF mlp_levels
	WITH ( selected_routine = "spec_type_mlp_choose"     ,
	       leave_prompt_routine = "spec_type_mlp_choose" ,
	       user_info = "mlp_level"                       )

	IF use_mlp_spec THEN
	
		set_level_prompt_value( sqc_chart, prompt_level, mlp_levels )

	ENDIF

	IF NOT use_mlp_spec THEN

		prompt_mlp . set_enabled( FALSE )
		prompt_level . set_enabled( FALSE )
		prompt_level . set_visible( FALSE )

	ENDIF

	PROMPT OBJECT prompt_lower_spec
		ON LINE 7 
		FROM ( text_lower_spec . column + text_lower_spec . width )
		BROWSE ON REAL
		WITH (  user_info = "lower_spec")

	prompt_lower_spec . value = default_line_display ( sqc_chart,
						      prompt_lower_spec . user_info )


	prompt_lower_spec . width = 10
	
	text_upper_spec . column = ( prompt_lower_spec . column + 
	                             prompt_lower_spec . width + 5   )
	
	PROMPT OBJECT prompt_upper_spec
		ON LINE 7 
		FROM ( text_upper_spec . column + text_upper_spec . width )
		BROWSE ON REAL
		WITH (  user_info = "upper_spec")

	prompt_upper_spec . value = default_line_display ( sqc_chart,
						      prompt_upper_spec . user_info )

	PROMPT OBJECT prompt_four_data
	       ON LINE 9 FROM 28
	       BROWSE ON boolean

	prompt_four_data . is_radio = TRUE
	prompt_four_data . toggled_routine = "limits_type_a_data"
	prompt_four_data . vgl_library = GLOBAL( "CURRENT_LIBRARY" )
	prompt_four_data . user_info = "data_a_radio"
	prompt_four_data . caption = GET_USER_MESSAGE( "SQCWIN_MAIN_LCT_1", 1 )

	PROMPT OBJECT prompt_four_target
	       ON LINE 9 FROM 39
	       BROWSE ON boolean

	prompt_four_target . is_radio = TRUE
	prompt_four_target . toggled_routine = "limits_type_a_target"
	prompt_four_target . vgl_library = GLOBAL( "CURRENT_LIBRARY" )
	prompt_four_target . user_info = "target_a_radio"
	prompt_four_target . caption = GET_USER_MESSAGE( "SQCWIN_MAIN_LCT_2", 1 )

	PROMPT OBJECT prompt_four_spec
	       ON LINE 9 FROM 52
	       BROWSE ON boolean

	prompt_four_spec . is_radio = TRUE
	prompt_four_spec . toggled_routine = "limits_type_a_spec"
	prompt_four_spec . vgl_library = GLOBAL( "CURRENT_LIBRARY" )
	prompt_four_spec . user_info = "spec_a_radio"
	prompt_four_spec . caption = GET_USER_MESSAGE( "SQCWIN_MAIN_LCT_3", 1 )

	PROMPT OBJECT prompt_four_mlp
	       ON LINE 9 FROM 65
	       BROWSE ON boolean

	prompt_four_mlp . is_radio = TRUE
	prompt_four_mlp . toggled_routine = "limits_type_a_mlp"
	prompt_four_mlp . vgl_library = GLOBAL( "CURRENT_LIBRARY" )
	prompt_four_mlp . user_info = "mlp_a_radio"
	prompt_four_mlp . caption = GET_USER_MESSAGE( "SQCWIN_MAIN_LCT_4", 1 )

	IF NOT use_mlp_spec THEN

		prompt_four_mlp . set_enabled( FALSE )

	ENDIF

	PROMPT OBJECT prompt_five_data
	       ON LINE 10 FROM 28
	       BROWSE ON boolean

	prompt_five_data . is_radio = TRUE
	prompt_five_data . toggled_routine = "limits_type_b_data"
	prompt_five_data . vgl_library = GLOBAL( "CURRENT_LIBRARY" )
	prompt_five_data . user_info = "data_b_radio"
	prompt_five_data . caption = GET_USER_MESSAGE( "SQCWIN_MAIN_LCT_1", 1 )

	PROMPT OBJECT prompt_five_target
	       ON LINE 10 FROM 39
	       BROWSE ON boolean

	prompt_five_target . is_radio = TRUE
	prompt_five_target . toggled_routine = "limits_type_b_target"
	prompt_five_target . vgl_library = GLOBAL( "CURRENT_LIBRARY" )
	prompt_five_target . user_info = "target_b_radio"
	prompt_five_target . caption = GET_USER_MESSAGE( "SQCWIN_MAIN_LCT_2", 1 )

	PROMPT OBJECT prompt_five_spec
	       ON LINE 10 FROM 52
	       BROWSE ON boolean

	prompt_five_spec . is_radio = TRUE
	prompt_five_spec . toggled_routine = "limits_type_b_spec"
	prompt_five_spec . vgl_library = GLOBAL( "CURRENT_LIBRARY" )
	prompt_five_spec . user_info = "spec_b_radio"
	prompt_five_spec . caption = GET_USER_MESSAGE( "SQCWIN_MAIN_LCT_3", 1 )

	PROMPT OBJECT prompt_five_mlp
	       ON LINE 10 FROM 65
	       BROWSE ON boolean

	prompt_five_mlp . is_radio = TRUE
	prompt_five_mlp . toggled_routine = "limits_type_b_mlp"
	prompt_five_mlp . vgl_library = GLOBAL( "CURRENT_LIBRARY" )
	prompt_five_mlp . user_info = "mlp_b_radio"
	prompt_five_mlp . caption = GET_USER_MESSAGE( "SQCWIN_MAIN_LCT_4", 1 )

	IF NOT use_mlp_spec THEN

		prompt_five_mlp . set_enabled( FALSE )

	ENDIF

	PROMPT OBJECT prompt_six
		ON LINE 12 FROM ( text_six . column + text_six . width + 1 ) 
		BROWSE ON sqcwin_trend . identifier
		WITH (  user_info = "trend_chart_a" )

	prompt_six . width = 25

	prompt_six . value = default_line_display ( sqc_chart,
						    prompt_six . user_info )

	text_seven . column = ( prompt_six . column + prompt_six . width + 1 )

	PROMPT OBJECT prompt_seven
		ON LINE 12 FROM ( text_seven . column + text_seven . width + 1 ) 
		BROWSE ON sqcwin_trend . identifier
		WITH (  user_info = "trend_chart_b" )

	prompt_seven . width = 25

	prompt_seven . value = default_line_display ( sqc_chart,
						      prompt_seven . user_info )

	PROMPT OBJECT prompt_eight
		ON LINE 14 FROM 2
		BROWSE ON BOOLEAN
		WITH ( is_check = TRUE,
		       user_info = "display_spec" )

	prompt_eight . caption = GET_USER_MESSAGE ( "MEANS_PARA_DISP_SPEC", 1 ) 

	prompt_eight . value = default_line_display ( sqc_chart,
						      prompt_eight . user_info )


	PROMPT OBJECT prompt_nine
		ON LINE 14 FROM ( form . width * 0.25 )
		BROWSE ON BOOLEAN
		WITH ( user_info = "display_control",
		       is_check = TRUE )

	prompt_nine . caption = GET_USER_MESSAGE ( "MEANS_PARA_DISP_CONT", 1 ) 

	prompt_nine . value = default_line_display ( sqc_chart,
						     prompt_nine . user_info )

	PROMPT OBJECT prompt_ten
		ON LINE 14 FROM ( form . width * 0.5 )
		BROWSE ON BOOLEAN
		WITH ( user_info = "display_warning",
		       is_check = TRUE )

	prompt_ten . caption = GET_USER_MESSAGE ( "MEANS_PARA_DISP_WARN", 1 )

	prompt_ten . value = default_line_display ( sqc_chart,
						    prompt_ten . user_info )

	PROMPT OBJECT prompt_eleven
		ON LINE 14 FROM ( form . width * 0.75 )
		BROWSE ON BOOLEAN
		WITH ( user_info = "display_one_sigma",
		       is_check = TRUE )

	prompt_eleven . caption = GET_USER_MESSAGE ( "MEANS_PARA_DISP_STDDEV", 1 )

	prompt_eleven . value = default_line_display ( sqc_chart,
						       prompt_eleven . user_info )

	form.add_display(text_one)
	form.add_display(text_two)
	form.add_display(text_three)
	form.add_display(text_spec_type)
	form.add_display(text_upper_spec)
	form.add_display(text_lower_spec)
	IF use_mlp_spec THEN

		form . add_display( text_level )

	ENDIF
	form.add_display(text_four)
	form.add_display(text_five)
	form.add_display(text_six)
	form.add_display(text_seven)
				     
	form.add_prompt(prompt_one)
	form.add_prompt(prompt_two)
	form.add_prompt(prompt_three)
	form.add_prompt(prompt_six)
	form.add_prompt(prompt_seven)
	form.add_prompt(prompt_eight)
	form.add_prompt(prompt_nine)
	form.add_prompt(prompt_ten)
	form.add_prompt(prompt_eleven)
	form . add_prompt( prompt_level )
	form . add_prompt( prompt_upper_spec )
	form . add_prompt( prompt_lower_spec )

	form . add_prompt( prompt_spec )
	form . add_prompt( prompt_disable )
	form . add_prompt( prompt_mlp )

	form.add_prompt(prompt_four_data)
	form.add_prompt(prompt_four_target)
	form.add_prompt(prompt_four_spec)
	form.add_prompt(prompt_four_mlp)
	form.add_prompt(prompt_five_data)
	form.add_prompt(prompt_five_target)
	form.add_prompt(prompt_five_spec)
	form.add_prompt(prompt_five_mlp)

	add_param_buttons (sqc_chart , form)

	not_exiting_main = TRUE

	WHILE not_exiting_main DO
	
		form.start_prompt()

		chosen_spec_type = default_line_display( sqc_chart, "spec_type" )
							   
		IF ( chosen_spec_type = 1 ) THEN 

			prompt_spec . set_text( TRUE )
			select_spec_limits( prompt_spec )

		ELSEIF( chosen_spec_type = 2 ) THEN

			prompt_disable . set_text( TRUE )
			select_disable_limits( prompt_disable )

		ELSEIF( chosen_spec_type = 3 ) THEN

			IF use_mlp_spec THEN

				prompt_mlp . set_text( TRUE )
				spec_type_mlp( prompt_mlp )

			ELSE

				prompt_disable . set_text( TRUE )
				select_disable_limits( prompt_disable )

			ENDIF

		ENDIF

		chosen_type_a_limit = default_line_display( sqc_chart, "limits_calc_type_a" )
		chosen_type_b_limit = default_line_display( sqc_chart, "limits_calc_type_b" )

		IF chosen_type_a_limit = 1 THEN

			prompt_four_data . set_text( TRUE )
			limits_type_a_data( prompt_four_data )

		ELSEIF chosen_type_a_limit = 2 THEN

			prompt_four_target . set_text( TRUE )
			limits_type_a_target( prompt_four_target )

		ELSEIF chosen_type_a_limit = 3 THEN

			prompt_four_spec . set_text( TRUE )
			limits_type_a_spec( prompt_four_spec )

		ELSEIF chosen_type_a_limit = 4 THEN

			IF use_mlp_spec THEN

				prompt_four_mlp . set_text( TRUE )
				limits_type_a_mlp( prompt_four_mlp )

			ELSE

				prompt_four_data . set_text( TRUE )
				limits_type_a_data( prompt_four_data )

			ENDIF

		ENDIF

		IF chosen_type_b_limit = 1 THEN

			prompt_five_data . set_text( TRUE )
			limits_type_b_data( prompt_five_data )

		ELSEIF chosen_type_b_limit = 2 THEN

			prompt_five_target . set_text( TRUE )
			limits_type_b_target( prompt_five_target )

		ELSEIF chosen_type_b_limit = 3 THEN

			prompt_five_spec . set_text( TRUE )
			limits_type_b_spec( prompt_five_spec )

		ELSEIF chosen_type_b_limit = 4 THEN

			IF use_mlp_spec THEN

				prompt_five_mlp . set_text( TRUE )
				limits_type_b_mlp( prompt_five_mlp )

			ELSE

				prompt_five_data . set_text( TRUE )
				limits_type_b_data( prompt_five_data )

			ENDIF

		ENDIF



		not_exiting = TRUE

		WHILE not_exiting DO

			form.wait_prompt()


			chosen_spec_type = default_line_display( sqc_chart, "spec_type" )

			IF ( ( LASTKEY = "RIGHT" )      AND
			     ( chosen_spec_type = 1 ) ) THEN

				IF prompt_upper_spec . value <= prompt_lower_spec . value THEN

					flash_message( 
					GET_USER_MESSAGE( "SQCWIN_MAIN_INVALID_LIMITS", 1), TRUE )

				ELSE

					not_exiting = FALSE

				ENDIF

			ELSEIF( ( LASTKEY = "RIGHT" ) OR
			        ( LASTKEY = "LEFT"  ) OR
			        ( LASTKEY = "EXIT"  )    ) THEN

				not_exiting = FALSE

			ENDIF


		ENDWHILE

		form.end_prompt()

		chosen_type_a_limit = default_line_display( sqc_chart, "limits_calc_type_a" )
		chosen_type_b_limit = default_line_display( sqc_chart, "limits_calc_type_b" )

		IF ( chosen_type_a_limit + chosen_type_b_limit > 2 ) AND
		   ( LASTKEY = "RIGHT"                             ) THEN

			shewhart_limits( sqc_chart             			    ,
			                 GET_USER_MESSAGE( "SQCWIN_MAIN_NCT_6", 1 ) , 
			                 GET_USER_MESSAGE( "SQCWIN_MAIN_NCT_3", 1 ) )

				IF NOT ( LASTKEY = "LEFT" ) THEN

					not_exiting_main = FALSE

				ENDIF

		ELSE

			not_exiting_main = FALSE

		ENDIF

	ENDWHILE

	IF ( LASTKEY <> "EXIT" ) THEN

		write_prompts_to_objDB ( form, 1, 12 )

		IF( chosen_spec_type = 3 ) THEN

			write_prompt_text_to_objDB( form, "mlp_level" )

		ENDIF

		IF LASTKEY = "RIGHT" THEN

			do_shewhart_calculations ( sqc_chart, MEAN_STD )

		ENDIF

	ENDIF
	
	IF ( sqc_chart . next_screen <> "DRAW") THEN

	    get_next_screen (sqc_chart)

	ENDIF

ENDROUTINE

{******************************************************************************}

ROUTINE limits_type_a_data( self )

{ 
* This called when user checks the limits type a Data radio button
* 
* 
*
* Parameters   : self
* Return Value : n/a
*
*******************************************************************************}

DECLARE target_button, spec_button, mlp_button, data_b_button, target_b_button

	get_prompt( self . parent_prompt . prompt_objects ,
	            "target_a_radio", target_button       )

	get_prompt( self . parent_prompt . prompt_objects ,
	            "spec_a_radio", spec_button           )

	get_prompt( self . parent_prompt . prompt_objects ,
	            "mlp_a_radio", mlp_button             )


	get_prompt( self . parent_prompt . prompt_objects ,
	            "data_b_radio", data_b_button         )

	get_prompt( self . parent_prompt . prompt_objects ,
	            "target_b_radio", target_b_button     )


	target_button . set_text( NOT self . value )
	spec_button . set_text( NOT self . value )
	mlp_button . set_text( NOT self . value )

	IF  target_b_button . value THEN

		data_b_button . set_text( self . value )

		limits_type_b_data( data_b_button )

	ENDIF

	write_field_value_to_objDB ( self . parent_prompt ,
	                             "limits_calc_type_a" ,
                                     1                    )

ENDROUTINE

{******************************************************************************}

ROUTINE limits_type_a_target( self )

{ 
* This called when user checks the limits type a Target radio button
* 
* 
*
* Parameters   : self
* Return Value : n/a
*
*******************************************************************************}

DECLARE data_button, spec_button, mlp_button, target_b_button

	get_prompt( self . parent_prompt . prompt_objects ,
	            "data_a_radio", data_button       )

	get_prompt( self . parent_prompt . prompt_objects ,
	            "spec_a_radio", spec_button           )

	get_prompt( self . parent_prompt . prompt_objects ,
	            "mlp_a_radio", mlp_button             )

	get_prompt( self . parent_prompt . prompt_objects ,
	            "target_b_radio", target_b_button     )

	data_button . set_text( NOT self . value )
	spec_button . set_text( NOT self . value )
	mlp_button . set_text( NOT self . value )

	IF NOT target_b_button . value THEN

		target_b_button . set_text( self . value )

		limits_type_b_target( target_b_button )

	ENDIF

	write_field_value_to_objDB ( self . parent_prompt ,
	                             "limits_calc_type_a" ,
                                     2                    )

ENDROUTINE

{******************************************************************************}

ROUTINE limits_type_a_spec( self )

{ 
* This called when user checks the limits type a Specified radio button
* 
* 
*
* Parameters   : self
* Return Value : n/a
*
*******************************************************************************}

DECLARE target_button, data_button, mlp_button, spec_b_button, target_b_button

	get_prompt( self . parent_prompt . prompt_objects ,
	            "target_a_radio", target_button       )

	get_prompt( self . parent_prompt . prompt_objects ,
	            "data_a_radio", data_button           )

	get_prompt( self . parent_prompt . prompt_objects ,
	            "mlp_a_radio", mlp_button             )


	get_prompt( self . parent_prompt . prompt_objects ,
	            "spec_b_radio", spec_b_button         )

	get_prompt( self . parent_prompt . prompt_objects ,
	            "target_b_radio", target_b_button     )

	data_button . set_text( NOT self . value )
	target_button . set_text( NOT self . value )
	mlp_button . set_text( NOT self . value )

	IF  target_b_button . value THEN

		spec_b_button . set_text( self . value )

		limits_type_b_spec( spec_b_button )

	ENDIF

	write_field_value_to_objDB ( self . parent_prompt ,
	                             "limits_calc_type_a" ,
                                     3                    )

ENDROUTINE

{******************************************************************************}

ROUTINE limits_type_a_mlp( self )

{ 
* This called when user checks the limits type a MLP radio button
* 
* 
*
* Parameters   : self
* Return Value : n/a
*
*******************************************************************************}

DECLARE target_button, spec_button, data_button, mlp_b_button, target_b_button

	get_prompt( self . parent_prompt . prompt_objects ,
	            "target_a_radio", target_button       )

	get_prompt( self . parent_prompt . prompt_objects ,
	            "spec_a_radio", spec_button           )

	get_prompt( self . parent_prompt . prompt_objects ,
	            "data_a_radio", data_button             )


	get_prompt( self . parent_prompt . prompt_objects ,
	            "mlp_b_radio", mlp_b_button         )

	get_prompt( self . parent_prompt . prompt_objects ,
	            "target_b_radio", target_b_button     )

	data_button . set_text( NOT self . value )
	target_button . set_text( NOT self . value )
	spec_button . set_text( NOT self . value )

	IF  target_b_button . value THEN

		mlp_b_button . set_text( self . value )

		limits_type_b_mlp( mlp_b_button )

	ENDIF

	write_field_value_to_objDB ( self . parent_prompt ,
	                             "limits_calc_type_a" ,
                                     4                    )

ENDROUTINE

{******************************************************************************}

ROUTINE limits_type_b_data( self )

{ 
* This called when user checks the limits type b Data radio button
* 
* 
*
* Parameters   : self
* Return Value : n/a
*
*******************************************************************************}

DECLARE target_button, spec_button, mlp_button, data_a_button, target_a_button

	get_prompt( self . parent_prompt . prompt_objects ,
	            "target_b_radio", target_button       )

	get_prompt( self . parent_prompt . prompt_objects ,
	            "spec_b_radio", spec_button           )

	get_prompt( self . parent_prompt . prompt_objects ,
	            "mlp_b_radio", mlp_button             )


	get_prompt( self . parent_prompt . prompt_objects ,
	            "data_a_radio", data_a_button         )

	get_prompt( self . parent_prompt . prompt_objects ,
	            "target_a_radio", target_a_button     )


	target_button . set_text( NOT self . value )
	spec_button . set_text( NOT self . value )
	mlp_button . set_text( NOT self . value )

	IF  target_a_button . value THEN

		data_a_button . set_text( self . value )

		limits_type_a_data( data_a_button )

	ENDIF

	write_field_value_to_objDB ( self . parent_prompt ,
	                             "limits_calc_type_b" ,
                                     1                    )

ENDROUTINE

{******************************************************************************}

ROUTINE limits_type_b_target( self )

{ 
* This called when user checks the limits type b Target radio button
* 
* 
*
* Parameters   : self
* Return Value : n/a
*
*******************************************************************************}

DECLARE data_button, spec_button, mlp_button, target_a_button

	get_prompt( self . parent_prompt . prompt_objects ,
	            "data_b_radio", data_button       )

	get_prompt( self . parent_prompt . prompt_objects ,
	            "spec_b_radio", spec_button           )

	get_prompt( self . parent_prompt . prompt_objects ,
	            "mlp_b_radio", mlp_button             )

	get_prompt( self . parent_prompt . prompt_objects ,
	            "target_a_radio", target_a_button     )

	data_button . set_text( NOT self . value )
	spec_button . set_text( NOT self . value )
	mlp_button . set_text( NOT self . value )


	IF NOT target_a_button . value THEN

		target_a_button . set_text( self . value )

		limits_type_a_target( target_a_button )

	ENDIF

	write_field_value_to_objDB ( self . parent_prompt ,
	                             "limits_calc_type_b" ,
                                     2                    )

ENDROUTINE

{******************************************************************************}

ROUTINE limits_type_b_spec( self )

{ 
* This called when user checks the limits type b Specified radio button
* 
* 
*
* Parameters   : self
* Return Value : n/a
*
*******************************************************************************}

DECLARE target_button, data_button, mlp_button, spec_a_button, target_a_button

	get_prompt( self . parent_prompt . prompt_objects ,
	            "target_b_radio", target_button       )

	get_prompt( self . parent_prompt . prompt_objects ,
	            "data_b_radio", data_button           )

	get_prompt( self . parent_prompt . prompt_objects ,
	            "mlp_b_radio", mlp_button             )


	get_prompt( self . parent_prompt . prompt_objects ,
	            "spec_a_radio", spec_a_button         )

	get_prompt( self . parent_prompt . prompt_objects ,
	            "target_a_radio", target_a_button     )

	data_button . set_text( NOT self . value )
	target_button . set_text( NOT self . value )
	mlp_button . set_text( NOT self . value )


	IF  target_a_button . value THEN

		spec_a_button . set_text( self . value )

		limits_type_a_spec( spec_a_button )

	ENDIF

	write_field_value_to_objDB ( self . parent_prompt ,
	                             "limits_calc_type_b" ,
                                     3                    )

ENDROUTINE

{******************************************************************************}

ROUTINE limits_type_b_mlp( self )

{ 
* This called when user checks the limits type b MLP radio button
* 
* 
*
* Parameters   : self
* Return Value : n/a
*
*******************************************************************************}

DECLARE target_button, spec_button, data_button, mlp_a_button, target_a_button

	get_prompt( self . parent_prompt . prompt_objects ,
	            "target_b_radio", target_button       )

	get_prompt( self . parent_prompt . prompt_objects ,
	            "spec_b_radio", spec_button           )

	get_prompt( self . parent_prompt . prompt_objects ,
	            "data_b_radio", data_button             )


	get_prompt( self . parent_prompt . prompt_objects ,
	            "mlp_a_radio", mlp_a_button         )

	get_prompt( self . parent_prompt . prompt_objects ,
	            "target_a_radio", target_a_button     )

	data_button . set_text( NOT self . value )
	target_button . set_text( NOT self . value )
	spec_button . set_text( NOT self . value )


	IF  target_a_button . value THEN

		mlp_a_button . set_text( self . value )

		limits_type_a_mlp( mlp_a_button )

	ENDIF

	write_field_value_to_objDB ( self . parent_prompt ,
	                             "limits_calc_type_b" ,
                                     4                    )

ENDROUTINE

{******************************************************************************}

ROUTINE select_spec_limits( self )

{ 
* This called when user checks the Use Specified Limits radio button.
* 
* 
*
* Parameters   : self
* Return Value : n/a
*
*******************************************************************************}

DECLARE mlp_button, disable_button, upper_spec_prompt, lower_spec_prompt,
        level_prompt, disp_spec_prompt

	get_prompt( self . parent_prompt . prompt_objects ,
	            "mlp_radio", mlp_button               )

	get_prompt( self . parent_prompt . prompt_objects ,
	            "disable_radio", disable_button       )

	get_prompt( self . parent_prompt . prompt_objects ,
	            "upper_spec", upper_spec_prompt       )

	get_prompt( self . parent_prompt . prompt_objects ,
	            "lower_spec", lower_spec_prompt       )

	get_prompt( self . parent_prompt . prompt_objects ,
	            "mlp_level", level_prompt              )

	get_prompt( self . parent_prompt . prompt_objects ,
	            "display_spec", disp_spec_prompt      )


	disable_button . set_text( NOT self . value )
	mlp_button . set_text( NOT self . value )

	disp_spec_prompt . set_enabled( TRUE )

	write_field_value_to_objDB ( self . parent_prompt ,
	                             "spec_type"          ,
                                     1                    )

	upper_spec_prompt . set_enabled( TRUE )
	lower_spec_prompt . set_enabled( TRUE )
	level_prompt . set_enabled( FALSE )


ENDROUTINE

{******************************************************************************}

ROUTINE select_disable_limits( self )

{ 
* This called when user checks the Disable Limits radio button.
* 
* 
*
* Parameters   : self
* Return Value : n/a
*
*******************************************************************************}

DECLARE mlp_button, spec_button, upper_spec_prompt, lower_spec_prompt,
        level_prompt, disp_spec_prompt

	get_prompt( self . parent_prompt . prompt_objects ,
	            "mlp_radio", mlp_button               )

	get_prompt( self . parent_prompt . prompt_objects ,
	            "spec_radio", spec_button       )

	get_prompt( self . parent_prompt . prompt_objects ,
	            "upper_spec", upper_spec_prompt       )

	get_prompt( self . parent_prompt . prompt_objects ,
	            "lower_spec", lower_spec_prompt       )

	get_prompt( self . parent_prompt . prompt_objects ,
	            "mlp_level", level_prompt              )

	get_prompt( self . parent_prompt . prompt_objects ,
	            "display_spec", disp_spec_prompt      )

	spec_button . set_text( NOT self . value )
	mlp_button . set_text( NOT self . value )

	disp_spec_prompt . set_enabled( FALSE )

	write_field_value_to_objDB ( self . parent_prompt ,
	                             "spec_type"          ,
                                     2                    )

	upper_spec_prompt . set_enabled( FALSE )
	upper_spec_prompt . set_text( "0.0" )
	lower_spec_prompt . set_enabled( FALSE )
	lower_spec_prompt . set_text( "0.0" )

	level_prompt . set_enabled( FALSE )

ENDROUTINE

{******************************************************************************}

ROUTINE spec_type_mlp( self )

{ 
* This called when user checks the MLP Limits radio button.
* 
* 
*
* Parameters   : self
* Return Value : n/a
*
*******************************************************************************}

DECLARE disable_button, spec_button, upper_spec_prompt, lower_spec_prompt,
        level_prompt, disp_spec_prompt

	get_prompt( self . parent_prompt . prompt_objects ,
	            "disable_radio", disable_button               )

	get_prompt( self . parent_prompt . prompt_objects ,
	            "spec_radio", spec_button       )

	get_prompt( self . parent_prompt . prompt_objects ,
	            "upper_spec", upper_spec_prompt       )

	get_prompt( self . parent_prompt . prompt_objects ,
	            "lower_spec", lower_spec_prompt       )

	get_prompt( self . parent_prompt . prompt_objects ,
	            "mlp_level", level_prompt              )

	get_prompt( self . parent_prompt . prompt_objects ,
	            "display_spec", disp_spec_prompt      )

	spec_button . set_text( NOT self . value )
	disable_button . set_text( NOT self . value )

	disp_spec_prompt . set_enabled( TRUE )

	write_field_value_to_objDB ( self . parent_prompt ,
	                             "spec_type"          ,
                                     3                    )

	upper_spec_prompt . set_enabled( FALSE )
	lower_spec_prompt . set_enabled( FALSE )

	level_prompt . set_enabled( TRUE )

	spec_type_mlp_choose( level_prompt )
ENDROUTINE

{*******************************************************************************}

ROUTINE spec_type_mlp_choose( self )

{ 
* Routine called on selecting an MLP level in the shewhart parameters screens.
* 
*
* Parameters   : self
* Return Value : n/a
*
*******************************************************************************}

DECLARE upper_spec_prompt, lower_spec_prompt, prod_name, prod_ver, analysis, 
        component


	get_prompt( self . parent_prompt . prompt_objects ,
	            "upper_spec", upper_spec_prompt       )

	get_prompt( self . parent_prompt . prompt_objects ,
	            "lower_spec", lower_spec_prompt       )

	get_mlp_details ( self . parent_prompt . user_info ,
	                  prod_name                        , 
			  prod_ver                         ,
	                  analysis                         , 
	                  component                        )

	upper_spec_prompt . value
		  = SELECT mlp_view . max_limit
		     WHERE ( product_id = prod_name     )
		       AND   ( analysis_id = analysis  )
		       AND ( component_name = component )
		       AND   ( product_version = prod_ver )
		       AND   ( level_id = self . text )

	upper_spec_prompt . set_text( upper_spec_prompt . value )

	lower_spec_prompt . value
		  = SELECT mlp_view . min_limit
		     WHERE ( product_id = prod_name     )
		       AND ( analysis_id = analysis  )
		       AND ( component_name = component )
		       AND ( product_version = prod_ver )
		       AND ( level_id = self . text )
	lower_spec_prompt . set_text( lower_spec_prompt . value )

	self . value = self . text

ENDROUTINE

{*******************************************************************************}

GLOBAL ROUTINE shewhart_limits ( sqc_chart, VALUE chart_a, VALUE chart_b )

{ 
* This routien gets the limits parameters for a shewhart chart.
* 
* 
*
* Parameters   : sqc_chart, chart_a, chart_b
* Return Value : n/a
*
*******************************************************************************}

DECLARE limits_form, limits_type_a, limits_type_b, last_prompt, type_info

	type_info = STRIP ( SELECT sqcwin_chart_type . chart_type IN OBJECT
			    sqc_chart . sqc_chart_type . current )

	create_sqc_form( limits_form )
	limits_form.help_context = "$REPORTER_FORM_PROMPT"
	limits_form.border=TRUE
	limits_form.header= type_info:" Limits"

	limits_form . user_info = sqc_chart

	limits_type_a = default_line_display( sqc_chart, "limits_calc_type_a" )
	limits_type_b = default_line_display( sqc_chart, "limits_calc_type_b" )

	IF limits_type_a = 2 THEN

		limits_form . add_frame( chart_a             ,
		                         0                   ,	  
		                         0                   ,
		                         0                   ,
		                         limits_form . width )

		target_limits( limits_form, chart_a, 1 )

	ELSEIF limits_type_a = 3 THEN

		limits_form . add_frame( chart_a             ,
		                         0                   ,	  
		                         0                   ,
		                         0                   ,
		                         limits_form . width )

		specified_limits( limits_form, chart_a, 1 )

	ELSEIF limits_type_a = 4 THEN

		limits_form . add_frame( chart_a             ,
		                         0                   ,	  
		                         0                   ,
		                         0                   ,
		                         limits_form . width )

		mlp_limits( limits_form, chart_a, 1 )

	ELSE

		limits_form . add_frame( ""                  ,
		                         0                   ,	  
		                         0                   ,
		                         0                   ,
		                         limits_form . width )



	ENDIF

	IF limits_type_b = 2 THEN

		limits_form . add_frame( chart_b                          ,
		                         0                                ,	  
		                         ( limits_form . height / 2 - 1 ) ,
		                         0                                ,
		                         limits_form . width              )

		target_limits( limits_form, chart_b, 2 )

	ELSEIF limits_type_b = 3 THEN

		limits_form . add_frame( chart_b                          ,
		                         0                                ,	  
		                         ( limits_form . height / 2 - 1 ) ,
		                         0                                ,
		                         limits_form . width              )

		specified_limits( limits_form, chart_b, 2 )

	ELSEIF limits_type_b = 4 THEN

		limits_form . add_frame( chart_b                          ,
		                         0                                ,	  
		                         ( limits_form . height / 2 - 1 ) ,
		                         0                                ,
		                         limits_form . width              )

		mlp_limits( limits_form, chart_b, 2 )

	ELSE

		limits_form . add_frame( ""                              ,
		                         0                                ,	  
		                         ( limits_form . height / 2 - 1 ) ,
		                         0                                ,
		                         limits_form . width              )



	ENDIF

	last_prompt = sqcwin_array_size( limits_form . prompt_objects )

	add_param_buttons (sqc_chart , limits_form)

	limits_form . start_prompt()
	IF ( limits_type_a = 4 ) THEN

		level_initialise( limits_form, 1 )

	ENDIF

	IF ( limits_type_b = 4 ) THEN

		level_initialise( limits_form, 2 )

	ENDIF
	limits_form . wait_prompt()
	limits_form . end_prompt()

	IF ( LASTKEY <> "EXIT" ) THEN

		write_prompts_to_objDB ( limits_form, 1, last_prompt )

		IF limits_type_a = 4 THEN

			write_prompt_text_to_objDB( limits_form , "mlp_level_a" )

		ENDIF

		IF limits_type_b = 4 THEN

			write_prompt_text_to_objDB( limits_form , "mlp_level_b" )

		ENDIF

	ENDIF

ENDROUTINE

{*******************************************************************************}

ROUTINE target_limits( form, chart_title, VALUE chart_pos )

{ 
* This routine adds a target limit prompt to the form. 
* 
* 
*
* Parameters   : form, chart_title, chart_pos
* Return Value : n/a
*
*******************************************************************************}

DECLARE target_display, target_prompt, line_no

	IF chart_pos = 1 THEN

		line_no = 2

	ELSE

		line_no = form . height / 2 + 1

	ENDIF

	PROMPT OBJECT target_display
	CLASS "STD_PROMPT_TEXT"
	ON LINE line_no FROM 10
	WITH(   raised=TRUE, 
		value = GET_USER_MESSAGE( "SQCWIN_MAIN_LCT_2" , 1 ) )

	target_display . width = 
	STRINGLENGTH( GET_USER_MESSAGE( "SQCWIN_MAIN_LCT_2" , 1 ) )

	PROMPT OBJECT target_prompt
	ON LINE line_no 
	BROWSE ON REAL
	WITH (  minimum = -999 ,
		maximum =  999 )

	target_prompt . column = ( target_display . column + target_display . width + 1 )

	IF chart_pos = 1 THEN

		target_prompt . user_info = "target_mean"

	ELSE

		target_prompt . user_info = "target_sigma"
	ENDIF

	target_prompt . value  =
	default_line_display ( form . user_info,
			       target_prompt . user_info )

	form . add_display( target_display )
	form . add_prompt( target_prompt )

ENDROUTINE

{*******************************************************************************}

ROUTINE specified_limits( form, chart_title, VALUE chart_pos )

{ 
* This routine adds specified limits prompts to the form. 
* 
* 
*
* Parameters   : form, chart_title, chart_pos
* Return Value : n/a
*
*******************************************************************************}

DECLARE line_no, text_length, text_col
DECLARE text_one, text_two, text_three, text_four, text_five
DECLARE text_six, text_seven
DECLARE prompt_one, prompt_two, prompt_three, prompt_four, prompt_five
DECLARE prompt_six, prompt_seven, prompt_col

	IF chart_pos = 1 THEN

		line_no = 1

	ELSE

		line_no = form . height / 2

	ENDIF

	text_col = 10

	text_length = 
	STRINGLENGTH( GET_USER_MESSAGE( "SQCWIN_SHEWHART_LIMITS_LOW_CONT" , 1 ) )		

	PROMPT OBJECT text_one
	CLASS "STD_PROMPT_TEXT"
	ON LINE line_no FROM text_col
	WITH(   raised=TRUE,
		value = 
		GET_USER_MESSAGE( "SQCWIN_SHEWHART_LIMITS_UPP_CONT" , 1 ) )

	text_one . width = text_length

	prompt_col = ( text_one . column + text_one . width )

	PROMPT OBJECT prompt_one
	ON LINE line_no FROM prompt_col
	BROWSE ON real
	WITH (  minimum=-999,
		maximum=999 )

	line_no = line_no + 1

	PROMPT OBJECT text_two
	CLASS "STD_PROMPT_TEXT"
	ON LINE line_no FROM text_col
	WITH(   raised=TRUE,
		value = 
		GET_USER_MESSAGE( "SQCWIN_SHEWHART_LIMITS_UPP_WARN" , 1 ) )

	text_two  . width = text_length

	PROMPT OBJECT prompt_two
	ON LINE line_no FROM prompt_col
	BROWSE ON real
	WITH (  minimum=-999,
		maximum=999 )

	line_no = line_no + 1

	PROMPT OBJECT text_three
	CLASS "STD_PROMPT_TEXT"
	ON LINE line_no FROM text_col
	WITH(   raised=TRUE,
		value = 
		GET_USER_MESSAGE( "SQCWIN_SHEWHART_LIMITS_UPP_STD" , 1 ) )

	text_three . width = text_length

	PROMPT OBJECT prompt_three
	ON LINE line_no FROM prompt_col
	BROWSE ON real
	WITH (  minimum=-999,
		maximum=999 )

	line_no = line_no + 1

	PROMPT OBJECT text_four
	CLASS "STD_PROMPT_TEXT"
	ON LINE line_no FROM text_col
	WITH(   raised=TRUE,
		value = 
		GET_USER_MESSAGE( "SQCWIN_SHEWHART_LIMITS_TARGET" , 1 ) )

	text_four  . width = text_length

	PROMPT OBJECT prompt_four
	ON LINE line_no FROM prompt_col
	BROWSE ON real
	WITH (  minimum=-999,
		maximum=999 )

	line_no = line_no + 1

	PROMPT OBJECT text_five
	CLASS "STD_PROMPT_TEXT"
	ON LINE line_no FROM text_col
	WITH(   raised=TRUE,
		value = 
		GET_USER_MESSAGE( "SQCWIN_SHEWHART_LIMITS_LOW_STD" , 1 ) )

	text_five . width = text_length

	PROMPT OBJECT prompt_five
	ON LINE line_no FROM prompt_col
	BROWSE ON real
	WITH (  minimum=-999,
		maximum=999 )

	line_no = line_no + 1

	PROMPT OBJECT text_six
	CLASS "STD_PROMPT_TEXT"
	ON LINE line_no FROM text_col
	WITH(   raised=TRUE,
		value = 
		GET_USER_MESSAGE( "SQCWIN_SHEWHART_LIMITS_LOW_WARN" , 1 ) )

	text_six . width = text_length

	PROMPT OBJECT prompt_six
	ON LINE line_no FROM prompt_col
	BROWSE ON real
	WITH (  minimum=-999,
		maximum=999 )

	line_no = line_no + 1

	PROMPT OBJECT text_seven
	CLASS "STD_PROMPT_TEXT"
	ON LINE line_no  FROM text_col
	WITH(   raised=TRUE,
		value = 
		GET_USER_MESSAGE( "SQCWIN_SHEWHART_LIMITS_LOW_CONT" , 1 ) )

	text_seven . width = text_length

	PROMPT OBJECT prompt_seven
	ON LINE line_no FROM prompt_col
	BROWSE ON real
	WITH (  minimum=-999,
		maximum=999 )


	IF chart_pos = 1 THEN

		prompt_one  . user_info = "upper_control_a"
		prompt_two . user_info = "upper_warning_a"
		prompt_three . user_info = "upper_sigma_a"
		prompt_four . user_info = "target_value_a"
		prompt_five . user_info = "lower_sigma_a"
		prompt_six . user_info = "lower_warning_a"
		prompt_seven . user_info = "lower_control_a"

	ELSE


		prompt_one  . user_info = "upper_control_b"
		prompt_two . user_info = "upper_warning_b"
		prompt_three . user_info = "upper_sigma_b"
		prompt_four . user_info = "target_value_b"
		prompt_five . user_info = "lower_sigma_b"
		prompt_six . user_info = "lower_warning_b"
		prompt_seven . user_info = "lower_control_b"

	ENDIF

	prompt_one . value = default_line_display ( form . user_info       ,
			                            prompt_one . user_info )

	prompt_two . value = default_line_display ( form . user_info       ,
			                            prompt_two . user_info )

	prompt_three . value = default_line_display ( form . user_info         ,
			                              prompt_three . user_info )

	prompt_four . value = default_line_display ( form . user_info        ,
			                             prompt_four . user_info )

	prompt_five . value = default_line_display ( form . user_info        ,
			                             prompt_five . user_info )

	prompt_six . value = default_line_display ( form . user_info       ,
			                            prompt_six . user_info )

	prompt_seven . value = default_line_display ( form . user_info         ,
			                              prompt_seven . user_info )

	form . add_display( text_one )
	form . add_display( text_two )
	form . add_display( text_three )
	form . add_display( text_four )
	form . add_display( text_five )
	form . add_display( text_six )
	form . add_display( text_seven )

	form . add_prompt( prompt_one )
	form . add_prompt( prompt_two )
	form . add_prompt( prompt_three )
	form . add_prompt( prompt_four )
	form . add_prompt( prompt_five )
	form . add_prompt( prompt_six )
	form . add_prompt( prompt_seven )

ENDROUTINE

{*******************************************************************************}

ROUTINE mlp_limits( form, chart_title, VALUE chart_pos )

{ 
* This routine adds an MLP limit prompt to the form. 
* 
* 
*
* Parameters   : form, chart_title, chart_pos
* Return Value : n/a
*
*******************************************************************************}

DECLARE line_no, text_one, text_two, text_three, prompt_one, prompt_two, 
        prompt_three, mlp_levels, text_length, text_col, prompt_col

	ARRAY mlp_levels

	get_mlp_levels( form . user_info, mlp_levels )


	IF chart_pos = 1 THEN

		line_no = 2

	ELSE

		line_no = form . height / 2 + 1

	ENDIF
	
	text_col = 10

	text_length = 
	STRINGLENGTH( GET_USER_MESSAGE( "SQCWIN_SHEWHART_LIMITS_UPP_CONT", 1 ) )

	prompt_col = text_col + text_length

	PROMPT OBJECT text_one
	CLASS "STD_PROMPT_TEXT"
	ON LINE line_no FROM text_col
	WITH(   raised=TRUE,
		value =
		GET_USER_MESSAGE( "SQCWIN_SHEWHART_LIMITS_MLP_LEVEL" , 1 ) )

	text_one . width = text_length

	PROMPT OBJECT prompt_one
	ON LINE line_no FROM prompt_col
	CHOOSE OUTOF mlp_levels
	WITH ( selected_routine = "mlp_limits_selected"     ,
	       leave_prompt_routine = "mlp_limits_selected" )

	prompt_one . width = 10
	line_no = line_no + 1

	PROMPT OBJECT text_two
	CLASS "STD_PROMPT_TEXT"
	ON LINE line_no FROM text_col
	WITH(   raised=TRUE,
		value =
		GET_USER_MESSAGE( "SQCWIN_SHEWHART_LIMITS_UPP_CONT", 1 ) )

	text_two . width = text_length

	PROMPT OBJECT prompt_two
	ON LINE line_no FROM prompt_col
	BROWSE ON REAL
	WITH ( enabled = FALSE )

	line_no = line_no + 1

	PROMPT OBJECT text_three
	CLASS "STD_PROMPT_TEXT"
	ON LINE line_no FROM text_col
	WITH(   raised=TRUE,
		value =
		GET_USER_MESSAGE( "SQCWIN_SHEWHART_LIMITS_LOW_CONT", 1 ) )

	text_three . width = text_length

	PROMPT OBJECT prompt_three
	ON LINE line_no FROM prompt_col
	BROWSE ON REAL
	WITH ( enabled = FALSE )

	IF chart_pos = 1 THEN
		
		prompt_one . user_info = "mlp_level_a"
		prompt_two . user_info = "upper_control_a"
		prompt_three . user_info = "lower_control_a"

	ELSE

		prompt_one . user_info = "mlp_level_b"
		prompt_two . user_info = "upper_control_b"
		prompt_three . user_info = "lower_control_b"

	ENDIF

	set_level_prompt_value( form . user_info, prompt_one, mlp_levels )

	prompt_two . value =
	default_line_display ( form . user_info       ,
			       prompt_two . user_info )

	prompt_three . value =
	default_line_display ( form . user_info         ,
			       prompt_three . user_info )

	form . add_display ( text_one )
	form . add_display ( text_two )
	form . add_display ( text_three )

	form . add_prompt( prompt_one )
	form . add_prompt( prompt_two )
	form . add_prompt( prompt_three )



ENDROUTINE

{*******************************************************************************}

ROUTINE get_mlp_levels( sqc_chart, mlp_levels )

{ 
* This routine loads the mlp_levels array with the levels for the
* product associated with the sqc_chart
* 
*
* Parameters   : sqc_chart, mlp_levels
* Return Value : n/a
*
*******************************************************************************}

DECLARE prod_name, analysis, counter, prod_ver, mlp_spec_levels, component

	get_mlp_details ( sqc_chart, prod_name, prod_ver, analysis, component )

	mlp_spec_levels = SELECT DISTINCT mlp_view . level_id
			 WHERE ( product_id = prod_name     )
			 AND   ( product_version = prod_ver )
			 AND   ( analysis_id = analysis     )
			 AND   ( component_name = component )

	counter = 0

	WHILE ( mlp_spec_levels <> EMPTY ) DO

		counter = counter + 1
		mlp_levels [ counter,1 ] = mlp_spec_levels
		mlp_levels [ counter,2 ] = counter

		NEXT mlp_view
		mlp_spec_levels = SELECT mlp_view . level_id

	ENDWHILE

ENDROUTINE

{*******************************************************************************}

ROUTINE mlp_limits_selected( self )

{ 
* Routine called on selecting an MLP level in the shewharts limits screen.
* 
*
* Parameters   : self
* Return Value : n/a
*
*******************************************************************************}

DECLARE upper_prompt, lower_prompt, prod_name, prod_ver, analysis, component

	IF get_mlp_upper_lower_prompts( self, upper_prompt, lower_prompt ) THEN

		get_mlp_details ( self . parent_prompt . user_info , 
		                  prod_name                        , 
				  prod_ver                         ,
		                  analysis                         , 
		                  component                        )

		upper_prompt . value
			  = SELECT mlp_view . max_limit
			     WHERE ( product_id = prod_name     )
			       AND   ( analysis_id = analysis  )
			       AND ( component_name = component )
			       AND   ( product_version = prod_ver )
			       AND   ( level_id = self . text )

		upper_prompt . set_text( upper_prompt . value )

		lower_prompt . value
			  = SELECT mlp_view . min_limit
			     WHERE ( product_id = prod_name     )
			       AND ( analysis_id = analysis  )
			       AND ( component_name = component )
			       AND ( product_version = prod_ver )
			       AND ( level_id = self . text )

		lower_prompt . set_text( lower_prompt . value )

	ENDIF

ENDROUTINE

{*******************************************************************************}

ROUTINE get_mlp_upper_lower_prompts( self, upper_prompt, lower_prompt )

{ 
* Given an MLP level prompt from the shewhart limits form this routine 
* will find the appropriate upper and lower limits prompts. If the wrong
* prompt is passed FALSE is returned.
*
* Parameters   : self
* Return Value : success
*
*******************************************************************************}

DECLARE success, prompts_array

	success = FALSE
	
	prompts_array = self . parent_prompt . prompt_objects

	IF self . user_info = "mlp_level_a" THEN

		IF ( get_prompt( prompts_array, "upper_control_a", upper_prompt )  AND
		     get_prompt( prompts_array, "lower_control_a", lower_prompt ) ) THEN

			success = TRUE

		ENDIF

	ELSEIF self . user_info = "mlp_level_b" THEN

		IF ( get_prompt( prompts_array, "upper_control_b", upper_prompt )  AND
		     get_prompt( prompts_array, "lower_control_b", lower_prompt ) ) THEN

			success = TRUE

		ENDIF

	ENDIF

	RETURN( success )

ENDROUTINE

{*******************************************************************************}


GLOBAL ROUTINE procc_chart_params (sqc_chart)

{ 
* This routine gets the Process Capability chart parameters.
* 
* 
*
* Parameters   : sqc_chart
* Return Value : n/a
*
*******************************************************************************}

DECLARE form,dout, chosen_spec_type, use_mlp_spec
DECLARE text_one,text_two, text_four, text_lower, text_upper
DECLARE text_col, text_length
DECLARE prompt_one, prompt_two, prompt_three, prompt_four, prompt_five, prompt_lower
DECLARE prompt_upper, type_info, chart_type_ndx, not_exiting, mlp_levels, prompt_col

	ARRAY mlp_levels

	not_exiting = TRUE

	sqc_chart . tmp_chart_type = PROC_CAP

	chart_type_ndx = PAD ( sqc_chart . chart_id      , " ", "20" ) :
			 PAD ( sqc_Chart . tmp_chart_type, " ", "10" )

	sqc_chart . sqc_chart_type . set_by_index ( "KEY0", chart_type_ndx )

	type_info = STRIP ( SELECT sqcwin_chart_type . chart_type IN OBJECT
			    sqc_chart . sqc_chart_type . current )

	create_sqc_form( form )
	form.border=TRUE
	form.help_context = "$REPORTER_FORM_PROMPT"
	form.header= type_info:" Chart Parameters"
	form . user_info = sqc_chart

	text_col = 10

	text_length = 
	STRINGLENGTH( GET_USER_MESSAGE( "PROCC_PARA_NO_CELLS", 1 ) )

	PROMPT OBJECT text_one
		CLASS "STD_PROMPT_TEXT"
		ON LINE 2 FROM text_col
		WITH(   raised=TRUE,
			value=GET_USER_MESSAGE ( "PROCC_PARA_TEST_LENGTH", 1 ) )

	text_one . width = text_length

	PROMPT OBJECT text_two
		CLASS "STD_PROMPT_TEXT"
		ON LINE 4 FROM text_col
		WITH(   raised=TRUE,
			value=GET_USER_MESSAGE ( "PROCC_PARA_NO_CELLS", 1 ) )

	text_two . width = text_length

	form . add_frame( GET_USER_MESSAGE ( "PROCC_PARA_SPEC_TYPE", 1 ) ,
	                  0                                              ,
			  7                                              ,
			  0                                              ,
			  form . width                                   )

	PROMPT OBJECT text_four
		CLASS "STD_PROMPT_TEXT"
		ON LINE 10 FROM 40
		WITH (value= GET_USER_MESSAGE( "PROCC_PARA_LEVEL", 1 ) ,
		      raised=TRUE                                      )

	text_four . width = 
	STRINGLENGTH( GET_USER_MESSAGE( "PROCC_PARA_LEVEL", 1 ) )

	PROMPT OBJECT text_upper
		CLASS "STD_PROMPT_TEXT"
		ON LINE 14 
		WITH (value= GET_USER_MESSAGE( "PROCC_PARA_UPPER_SPEC", 1 ) ,
		      raised=TRUE)

	text_upper . width = 
	STRINGLENGTH( GET_USER_MESSAGE( "PROCC_PARA_UPPER_SPEC", 1 ) )

	PROMPT OBJECT text_lower
		CLASS "STD_PROMPT_TEXT"
		ON LINE 14 FROM 2
		WITH (value= GET_USER_MESSAGE( "PROCC_PARA_LOWER_SPEC", 1 ),
		      raised=TRUE)

	text_lower . width = 
	STRINGLENGTH( GET_USER_MESSAGE( "PROCC_PARA_LOWER_SPEC", 1 ) )

	prompt_col = text_col + text_length
	
	PROMPT OBJECT prompt_one
		ON LINE 2 FROM prompt_col
		BROWSE ON INTEGER
		WITH (  minimum=0,
			maximum=9999,
			user_info = "test_length" )

	prompt_one . value = default_line_display ( sqc_chart,
						    prompt_one . user_info )

	PROMPT OBJECT prompt_two
		ON LINE 4 FROM prompt_col
		BROWSE ON integer
		WITH (  minimum=1,
			maximum=99,
			user_info = "number_of_cells" )

	prompt_two . value = default_line_display ( sqc_chart,
						    prompt_two . user_info )

	ARRAY dout

	    dout[1,1]=GET_USER_MESSAGE ( "CONTROL_OPTIONS_SPEC_LIM", 1 )
	    dout[1,2]=1


        use_mlp_spec = use_mlp_spec_bool( sqc_chart . selection_criteria )

	IF use_mlp_spec THEN

		use_mlp_specification ( dout                          ,
				    sqc_chart . selection_criteria)

	ENDIF


	PROMPT OBJECT prompt_three
		ON LINE 8 FROM 15
		BROWSE ON boolean

	prompt_three . is_radio = TRUE
	prompt_three . toggled_routine = "select_user_limits"
	prompt_three . vgl_library     = global ( "current_library" )
	prompt_three . user_info = "user_radio"
	prompt_three . caption = GET_USER_MESSAGE( "PROCC_PARA_USER_LIMITS" , 1 )

	

	PROMPT OBJECT prompt_four
		ON LINE 8 FROM 40
		BROWSE ON boolean

	prompt_four . is_radio = TRUE
	prompt_four . toggled_routine = "select_mlp_limits"
	prompt_four . vgl_library     = global ( "current_library" )
	prompt_four . user_info = "mlp_radio"
	prompt_four . caption = GET_USER_MESSAGE( "PROCC_PARA_MLP_LIMITS" , 1 )

	IF NOT use_mlp_spec THEN

		prompt_four . set_enabled( FALSE )

	ENDIF


	PROMPT OBJECT prompt_five
		ON LINE 10
		CHOOSE OUTOF mlp_levels
		WITH (  user_info = "mlp_level"                   ,
			selected_routine = "procc_choose_mlp_levels" ,
			leave_prompt_routine = "procc_choose_mlp_levels" ,
			enabled = FALSE                           ,
			text = "")

	prompt_five . column = ( text_four . column + text_four . width )

	prompt_five . width = 10

	chosen_spec_type = default_line_display ( sqc_chart, "spec_type" )

	
	IF ( ( chosen_spec_type = 2 )   AND
	     use_mlp_spec             ) THEN

		prompt_four . value = TRUE

	ELSE

		prompt_three . value = TRUE

	ENDIF

	PROMPT OBJECT prompt_lower
		ON LINE 14
		BROWSE ON REAL
		WITH (  user_info = "lower_spec")

	prompt_lower . value = default_line_display ( sqc_chart,
						      prompt_lower . user_info )

	prompt_lower . width = 10

	prompt_lower . column = ( text_lower . column + text_lower . width )

	text_upper . column = ( prompt_lower . column + prompt_lower . width + 10 )

	PROMPT OBJECT prompt_upper
		ON LINE 14 
		BROWSE ON REAL
		WITH (  user_info = "upper_spec")

	prompt_upper . width = 10

	prompt_upper . value = default_line_display ( sqc_chart,
						      prompt_upper . user_info )

	prompt_upper . column = ( text_upper . column + text_upper . width )

	form.add_display(text_one)
	form.add_display(text_two)
	form . add_display( text_four )
	form . add_display( text_lower )
	form . add_display( text_upper )

	form.add_prompt(prompt_one)
	form.add_prompt(prompt_two)
	form . add_prompt ( prompt_three )
	form . add_prompt( prompt_four )
	form . add_prompt( prompt_five )
	form.add_prompt(prompt_lower)
	form.add_prompt(prompt_upper)

	add_param_buttons (sqc_chart , form)

	form.start_prompt()

	IF ( ( chosen_spec_type = 2 ) 	AND
	     use_mlp_spec             ) THEN 

		select_mlp_limits( prompt_four )

	ENDIF

	WHILE not_exiting DO	

		form.wait_prompt()

		IF ( GLOBAL( "LASTKEY" ) = "RIGHT" ) THEN

			IF prompt_lower . value < prompt_upper . value THEN

				not_exiting = FALSE

			ELSE

				flash_message( "Please set upper specification higher than":
					       "lower specification", TRUE )

			ENDIF

		ELSEIF( ( GLOBAL( "LASTKEY" ) = "EXIT" ) OR
		        ( GLOBAL( "LASTKEY" ) = "LEFT" )    ) THEN

			not_exiting = FALSE

		ENDIF

	ENDWHILE

	form.end_prompt()


	IF ( GLOBAL( "LASTKEY" ) <> "EXIT" ) AND
           ( GLOBAL( "LASTKEY" ) <> "LEFT" ) THEN

	    write_prompts_to_objDB ( form, 1, 2 )
	    write_prompts_to_objDB ( form, 5, 7 )
	    get_pc_subgroup ( sqc_chart )
	    calculate_process_capability ( sqc_chart )

	ENDIF

	IF ( sqc_chart . next_screen <> "DRAW") THEN

	    get_next_screen (sqc_chart)

	ENDIF

ENDROUTINE

{******************************************************************************}

ROUTINE select_user_limits( self )

{ 
* This called when user checks the User Specified Limits radio button
* on the Process Capability parameters screen.
* 
*
* Parameters   : self
* Return Value : n/a
*
*******************************************************************************}

DECLARE upper_spec_prompt, lower_spec_prompt, level_prompt, mlp_button

	get_prompt( self . parent_prompt . prompt_objects ,
	            "upper_spec", upper_spec_prompt       )

	get_prompt( self . parent_prompt . prompt_objects ,
	            "lower_spec", lower_spec_prompt       )

	get_prompt( self . parent_prompt . prompt_objects ,
	            "mlp_level", level_prompt             )

	get_prompt( self . parent_prompt . prompt_objects ,
	            "mlp_radio", mlp_button               )


	mlp_button . set_text( NOT self . value )

	level_prompt . set_enabled( FALSE )

	level_prompt . value = EMPTY

	upper_spec_prompt . set_enabled( TRUE )
	upper_spec_prompt . set_text( "0.0" )

	lower_spec_prompt . set_enabled( TRUE )
	lower_spec_prompt . set_text( "0.0" )

	write_field_value_to_objDB ( self . parent_prompt ,
	                             "spec_type"          ,
                                     1                    )

ENDROUTINE 

{******************************************************************************}

ROUTINE select_mlp_limits( self )

{ 
* This called when user checks the MLP Limits radio button on 
* the Process Capability parameters screen.
* 
*
* Parameters   : self
* Return Value : n/a
*
*******************************************************************************}

DECLARE prod_name, prod_ver, analysis, component, level_prompt, 
        upper_spec_prompt, lower_spec_prompt, user_button


	get_prompt( self . parent_prompt . prompt_objects ,
	            "upper_spec", upper_spec_prompt       )

	get_prompt( self . parent_prompt . prompt_objects ,
	            "lower_spec", lower_spec_prompt       )

	get_prompt( self . parent_prompt . prompt_objects ,
	            "mlp_level", level_prompt             )

	get_prompt( self . parent_prompt . prompt_objects ,
	            "user_radio", user_button               )

	get_mlp_details ( self . parent_prompt . user_info ,
	                  prod_name                        ,
			  prod_ver                         ,
	                  analysis                         , 
	                  component                        )

	get_mlp_levels( self . parent_prompt . user_info ,
	                level_prompt . choose_array      )
	
	user_button . set_text( NOT self . value )

	level_prompt . set_enabled( TRUE )


	IF level_prompt . value =  EMPTY THEN

		 level_prompt . choose_index = 
		 default_line_display ( self . parent_prompt . user_info ,
		                        level_prompt . user_info         )

		 IF ( level_prompt . choose_index =  EMPTY ) OR
		    ( level_prompt . choose_index > 
		      sqcwin_array_size( level_prompt . choose_array ) ) THEN

			level_prompt . choose_index = 1

	         ENDIF

		 level_prompt . set_text( level_prompt . choose_index )

	ENDIF

	upper_spec_prompt . value
		  = SELECT mlp_view . max_limit
		     WHERE ( product_id = prod_name     )
		       AND   ( analysis_id = analysis  )
		       AND ( component_name = component )
		       AND   ( product_version = prod_ver )
		       AND   ( level_id = level_prompt . text )

	upper_spec_prompt . set_text( upper_spec_prompt . value )
	
	upper_spec_prompt . set_enabled( FALSE )

	lower_spec_prompt . value
		  = SELECT mlp_view . min_limit
		     WHERE ( product_id = prod_name     )
		       AND ( analysis_id = analysis  )
		       AND ( component_name = component )
		       AND ( product_version = prod_ver )
		       AND ( level_id = level_prompt . text )

	lower_spec_prompt . set_text( lower_spec_prompt . value )
	
	lower_spec_prompt . set_enabled( FALSE )

	write_field_value_to_objDB ( self . parent_prompt ,
	                             "spec_type"          ,
                                     2                    )

ENDROUTINE 

{******************************************************************************}

ROUTINE procc_choose_mlp_levels( self )

{ 
* This routine browse the MLP levels for the chosen product.
* 
* 
*
* Parameters   : self
* Return Value : n/a
*
*******************************************************************************}

DECLARE prod_name, prod_ver, analysis, component, upper_spec_prompt, 
        lower_spec_prompt


	get_mlp_details ( self . parent_prompt . user_info ,
	                  prod_name                        ,
			  prod_ver                         ,
	                  analysis                         , 
	                  component                        )

	get_prompt( self . parent_prompt . prompt_objects ,
	            "upper_spec", upper_spec_prompt       )

	get_prompt( self . parent_prompt . prompt_objects ,
	            "lower_spec", lower_spec_prompt       )


	upper_spec_prompt . value
		  = SELECT mlp_view . max_limit
		     WHERE ( product_id = prod_name     )
		       AND   ( analysis_id = analysis  )
		       AND  ( component_name = component )
		       AND   ( product_version = prod_ver )
		       AND   ( level_id = self . text )

	upper_spec_prompt . set_text( upper_spec_prompt . value )

	lower_spec_prompt . value
		  = SELECT mlp_view . min_limit
		     WHERE ( product_id = prod_name     )
		       AND ( analysis_id = analysis  )
		       AND  ( component_name = component )
		       AND ( product_version = prod_ver )
		       AND ( level_id = self . text )

	lower_spec_prompt . set_text( lower_spec_prompt . value )

ENDROUTINE

{******************************************************************************}

ROUTINE validate_spectype_limits ( self )

{ 
* This routine validates the Process Capability specification limits.
* 
* 
*
* Parameters   : self
* Return Value : return_value
*
*******************************************************************************}

DECLARE sqc_chart, counter, upp_lvl, low_lvl, chart_type, return_value

	sqc_chart = self . user_info
	upp_lvl = 0
	low_lvl = 0 
	chart_type = ""
	counter = 0
	return_value = TRUE

	WHILE ( counter < sqc_chart . sqc_chart_type . size () ) DO

		counter = counter + 1
		sqc_chart . sqc_chart_type . set_by_number ( counter )

		chart_type=STRIP (
			    object_select_field (
			     sqc_chart . sqc_chart_type . current,
			     "sqcwin_chart_type"                 ,
			     "chart_type_id"                     )
				  )

		IF chart_type = PROC_CAP THEN

		    upp_lvl=object_select_field ( sqc_chart . sqc_chart_type . current,
						  "sqcwin_chart_type"                 ,
						  "upper_spec"                        )

		    low_lvl=object_select_field ( sqc_chart . sqc_chart_type . current,
						  "sqcwin_chart_type"                 ,
						  "lower_spec"                        )

		ENDIF

	ENDWHILE

	IF ( low_lvl = 0 ) AND ( upp_lvl = 0 ) THEN

		flash_message ( "Please specify an upper and lower spec before" :
			       " continuing.", TRUE )
		return_value = FALSE

	ENDIF

	RETURN( return_value )

ENDROUTINE

{******************************************************************************}

ROUTINE valid_procc_chart_parameters ( self )

{ 
* This routine validates the Process Capability chart parameters.
* 
* 
*
* Parameters   : self
* Return Value : return_value
*
*******************************************************************************}

DECLARE return_value

	return_value = TRUE

	IF ( self . prompt_objects [ 1 ] . value <=
	 self . prompt_objects [ 2 ] . value ) THEN

		flash_message ( "Please set the upper limit to be more than the lower":
				" limit", TRUE )

		return_value = FALSE

	ENDIF

	RETURN ( return_value )

ENDROUTINE

{******************************************************************************}

ROUTINE spec_value ( self )

{ 
* This routine controls the type of specification limits asked for.
* 
* 
*
* Parameters   : self
* Return Value : n/a
*
*******************************************************************************}

	IF ( self . parent_prompt . user_info . tmp_chart_type = PROC_CAP ) THEN

		IF ( self . value = 1 ) THEN
		    get_manual_spec_list ( self )
		ELSEIF ( self . value = 2 ) THEN
		    get_mlp_spec_list ( self )
		ENDIF

	ELSE

		IF ( self . value = 1 ) THEN
		    get_manual_spec_list ( self )
		    enable_spec_value ( self )
		ELSEIF ( self . value = 2 ) THEN
		    disable_spec_values ( self )
		ELSEIF ( self . value = 3 ) THEN
		    get_mlp_spec_list ( self )
		    enable_spec_value ( self )
		ENDIF

	ENDIF

ENDROUTINE

{******************************************************************************}

ROUTINE get_manual_spec_list ( self )

{ 
* This routine gets a manual specification list
* 
* 
*
* Parameters   : self
* Return Value : n/a
*
*******************************************************************************}

DECLARE form, text_one, text_two

	CREATE OBJECT PROMPT_CLASS_FORM, form

	form . height = 2
	form . width = 40
	form . row = self . row
	form . column = self . column
	form . header = "Specification"
	form . user_info = self . parent_prompt . user_info
	form . validation_routine = "valid_procc_chart_parameters"

	PROMPT OBJECT text_one
	CLASS "STD_PROMPT_TEXT"
	ON LINE 1 FROM 2 TO 25
	WITH(   raised=TRUE,
		value="Upper Specification")

	PROMPT OBJECT text_two
	CLASS "STD_PROMPT_TEXT"
	ON LINE 2 FROM 2 TO 25
	WITH(   raised=TRUE,
		value="Lower Specification")

{**MS 2003R1: Change **MS1430 HBe 20-11-2002 from SM 4.1 migrated: }
{              minimum changed from -999 to -9999                  }
{              maximum changed from  999 to  9999                  }

	PROMPT OBJECT form . prompt_objects [ 1 ]
	ON LINE 1 FROM 28
	BROWSE ON REAL
	WITH (  minimum = -9999           ,
		maximum =  9999           ,
		user_info = "upper_spec" )

	form . prompt_objects [ 1 ] . value  =
	default_line_display ( form . user_info,
			       form . prompt_objects [ 1 ] . user_info )

	PROMPT OBJECT form . prompt_objects [ 2 ]
	ON LINE 2 FROM 28
	BROWSE ON REAL
	WITH (  minimum = -9999           ,
		maximum =  9999           ,
		user_info = "lower_spec" )

{**ME 2003R1}

	form . prompt_objects [ 2 ] . value  =
	default_line_display ( form . user_info,
			       form . prompt_objects [ 2 ] . user_info )

	form . add_display ( text_one )
	form . add_display ( text_two )

	form . start_prompt ()
	form . wait_prompt ()
	form . end_prompt ()

	IF ( form . get_lastkey () <> "EXIT" ) THEN

		write_prompts_to_objDB ( form, 1, 2 )

	ENDIF

ENDROUTINE

{******************************************************************************}

ROUTINE disable_spec_values ( self )

{ 
* This routine disables the specification values display
* 
* 
*
* Parameters   : self
* Return Value : n/a
*
*******************************************************************************}

DECLARE counter, prompt_array

	prompt_array = self . parent_prompt . prompt_objects
	counter = 1

	WHILE ( counter < sqcwin_array_size ( prompt_array ) ) DO

		IF ( prompt_array [ counter ] . user_info = "display_spec" ) THEN

		    prompt_array [ counter ] . value = FALSE
		    prompt_array [ counter ] . start_prompt ()
		    prompt_array [ counter ] . repaste ()

		    prompt_array [ counter ] . set_enabled ( FALSE )

		ENDIF

		counter = counter + 1

	ENDWHILE

ENDROUTINE

{******************************************************************************}

ROUTINE enable_spec_value ( self )

{ 
* This routine enables specification values.
* 
* 
*
* Parameters   : self
* Return Value : n/a
*
*******************************************************************************}

DECLARE counter, prompt_array

	prompt_array = self . parent_prompt . prompt_objects
	counter = 1

	WHILE ( counter < sqcwin_array_size ( prompt_array ) ) DO

		IF ( prompt_array [ counter ] . user_info = "display_spec" ) THEN

		    prompt_array [ counter ] . set_enabled ( TRUE )
		    prompt_array [ counter ] . repaste ()

		ENDIF

	counter = counter + 1

	ENDWHILE

ENDROUTINE

{******************************************************************************}

ROUTINE disable_prompt ( self )

{ 
* This routine disables the specification display
* 
* 
*
* Parameters   : self
* Return Value : n/a
*
*******************************************************************************}

DECLARE counter, prompt_array

	prompt_array = self . parent_prompt . prompt_objects
	counter = 0

	WHILE ( counter < sqcwin_array_size ( prompt_array ) ) DO

		counter = counter + 1

		IF ( prompt_array [ counter ] . user_info = "spec_type" ) THEN

		    IF prompt_array [ counter ] . value = 2 THEN

			self . value = FALSE
			self . start_prompt ()
			self . repaste ()
			self . set_enabled ( FALSE )

		    ELSE

			self . set_enabled ( FALSE )

		    ENDIF

		ENDIF

	ENDWHILE

ENDROUTINE

{******************************************************************************}

ROUTINE get_mlp_spec_list ( self )

{ 
* This routine gets the MLP specification list.
* 
* 
*
* Parameters   : self
* Return Value : n/a
*
*******************************************************************************}

DECLARE form, text_one, text_two, text_three, text_four,
        selection_array, count

	ARRAY selection_array

	array_copy ( selection_array,
		 self . parent_prompt . user_info . selection_criteria )

	count = 0

	WHILE ( count < sqcwin_array_size ( selection_array ) ) DO

		count = count + 1

		IF ( selection_array [ count, 2 ] = "PRODUCT" ) THEN

		    self .parent_prompt . user_info . product_name
						 = selection_array [ count, 3 ]

		ENDIF

	ENDWHILE

	CREATE OBJECT PROMPT_CLASS_FORM, form

	form . height = 4
	form . width = 40
	form . row = self . row
	form . column = self . column
	form . header = "Specification"
	form . user_info = self . parent_prompt . user_info

	PROMPT OBJECT text_one
	CLASS "STD_PROMPT_TEXT"
	ON LINE 1 FROM 2 TO 25
	WITH(   raised=TRUE,
		value="Product    ")

	PROMPT OBJECT text_two
	CLASS "STD_PROMPT_TEXT"
	ON LINE 2 FROM 2 TO 25
	WITH(   raised=TRUE,
		value="MLP Levels ")

	PROMPT OBJECT text_three
	CLASS "STD_PROMPT_TEXT"
	ON LINE 3 FROM 2 TO 25
	WITH(   raised=TRUE,
		value="Upper Control Limit")

	PROMPT OBJECT text_four
	CLASS "STD_PROMPT_TEXT"
	ON LINE 4 FROM 2 TO 25
	WITH(   raised=TRUE,
		value="Lower Control Limit")

	PROMPT OBJECT form . prompt_objects [ 1 ]
	CLASS "STD_PROMPT_TEXT"
	ON LINE 1 FROM 28 to 39
	WITH ( value        = self . parent_prompt . user_info . product_name,
	       display_only = TRUE )

	PROMPT OBJECT form . prompt_objects [ 2 ]
	ON LINE 2 FROM 28
	WITH ( browse_routine = "browse_on_mlp_levels",
	       user_info = "mlp_level" )

	PROMPT OBJECT form . prompt_objects [ 3 ]
	ON LINE 3 FROM 28
	BROWSE ON REAL
	WITH (  minimum = -999           ,
		maximum =  999           ,
		display_only = TRUE      )

	PROMPT OBJECT form . prompt_objects [ 4 ]
	ON LINE 4 FROM 28
	BROWSE ON REAL
	WITH (  minimum = -999           ,
		maximum =  999           ,
		display_only = TRUE      )

	IF ( self . user_info = "spec_type" ) THEN

		form . prompt_objects [ 2 ] . user_info = "mlp_level"
		form . prompt_objects [ 3 ] . user_info = "upper_spec"
		form . prompt_objects [ 4 ] . user_info = "lower_spec"

	ELSEIF ( self . user_info = "limits_calc_type_a" ) THEN

		form . prompt_objects [ 2 ] . user_info = "mlp_level_a"
		form . prompt_objects [ 3 ] . user_info = "upper_control_a"
		form . prompt_objects [ 4 ] . user_info = "lower_control_a"

	ELSEIF ( self . user_info = "limits_calc_type_b" ) THEN

		form . prompt_objects [ 2 ] . user_info = "mlp_level_b"
		form . prompt_objects [ 3 ] . user_info = "upper_control_b"
		form . prompt_objects [ 4 ] . user_info = "lower_control_b"

	ENDIF

	form . prompt_objects [ 2 ] . value =
	default_line_display ( form . user_info,
			       form . prompt_objects [ 2 ] . user_info )

	form . prompt_objects [ 3 ] . value =
	default_line_display ( form . user_info,
			       form . prompt_objects [ 3 ] . user_info )

	form . prompt_objects [ 4 ] . value  =
	default_line_display ( form . user_info,
			       form . prompt_objects [ 4 ] . user_info )

	form . add_display ( text_one   )
	form . add_display ( text_two   )
	form . add_display ( text_three )
	form . add_display ( text_four  )

	form . start_prompt ()
	form . wait_prompt ()
	form . end_prompt ()

	IF ( form . get_lastkey () <> "EXIT" ) THEN

		write_prompts_to_objDB ( form, 2, 4 )

	ENDIF

ENDROUTINE

{******************************************************************************}

ROUTINE browse_on_mlp_levels ( self )

{ 
* This routine browses on MLP levels
* 
* 
*
* Parameters   : self
* Return Value : n/a
*
*******************************************************************************}

DECLARE mlp_levels, prod_name, analysis
DECLARE counter, prod_ver, mlp_spec_levels, selection_crit

	ARRAY mlp_levels ARRAYSIZE ( 0 )
	counter   = 1
	prod_ver =  EMPTY

	ARRAY selection_crit
	array_copy ( selection_crit,
		 self . parent_prompt . user_info . selection_criteria )

	prod_name = STRIP ( self . parent_prompt . prompt_objects [ 1 ] . text )

	WHILE ( counter <= sqcwin_array_size ( selection_crit ) ) DO

		IF ( selection_crit [ counter, 2 ] = "PRODUCT_VERSION" ) THEN

		    prod_ver  = selection_crit [ counter, 3 ]

		ELSEIF ( selection_crit [ counter, 2 ] = "ANALYSIS" ) THEN

		    analysis  = selection_crit [ counter, 3 ]

		ENDIF

		counter = counter + 1

	ENDWHILE

	IF ( prod_ver = EMPTY ) THEN

		prod_ver = NUMERIC (
			       STRIP (
				       SELECT MAX mlp_view . product_version
					  WHERE ( product_id  = prod_name )
				     )
				   )

		IF ( ( prod_ver = ERROR ) OR ( prod_ver = EMPTY ) ) THEN 

		    prod_ver = 1 

		ENDIF

	ENDIF

	mlp_spec_levels = SELECT DISTINCT mlp_view . level_id
			 WHERE ( product_id = prod_name     )
			 AND   ( product_version = prod_ver )

	counter = 0

	WHILE ( mlp_spec_levels <> EMPTY ) DO

		counter = counter + 1
		mlp_levels [ counter ] = mlp_spec_levels

		NEXT mlp_view
		mlp_spec_levels = SELECT mlp_view . level_id

	ENDWHILE

	browse_on_array ( 20, self . text, mlp_levels )

	self . parent_prompt . prompt_objects [ 3 ] . value
		  = SELECT mlp_view . max_limit
		     WHERE ( product_id = prod_name     )
		       AND   ( analysis_id = analysis  )
		       AND   ( product_version = prod_ver )
		       AND   ( level_id = self . text )

	self . parent_prompt . prompt_objects [ 4 ] . value
		  = SELECT mlp_view . min_limit
		     WHERE ( product_id = prod_name     )
		       AND ( analysis_id = analysis  )
		       AND ( product_version = prod_ver )
		       AND ( level_id = self . text )

	self . parent_prompt . prompt_objects [ 3 ] . start_prompt ()
	self . parent_prompt . prompt_objects [ 3 ] . repaste ()

	self . parent_prompt . prompt_objects [ 4 ] . start_prompt ()
	self . parent_prompt . prompt_objects [ 4 ] . repaste ()

	self . repaste ()

ENDROUTINE

{*******************************************************************************}

ROUTINE choose_limit_type ( self )

{ 
* This routine chooses the limit type.
* 
* 
*
* Parameters   : self
* Return Value : 
*
*******************************************************************************}

DECLARE prompt_obj, act_prompt

	IF ( self . value = 1 ) THEN

	ELSEIF ( self . value = 2 ) THEN

		target_value ( self )

	ELSEIF ( self . value = 3 ) THEN

		user_defined_value ( self )

	ELSEIF ( self . value = 4 ) THEN

		get_mlp_spec_list ( self )

	ENDIF

	act_prompt = self . parent_prompt . active_prompt

	IF ( self . value <> 2 ) THEN

		IF ( self . user_info = "limits_calc_type_a" ) THEN

		    prompt_obj = self . parent_prompt . prompt_objects [ act_prompt + 1 ]

		    IF ( prompt_obj . value = 2 ) THEN

			prompt_obj . value = self . value
			prompt_obj . text  = self . text
			prompt_obj . repaste ()

		    ENDIF

		ELSEIF ( self . user_info = "limits_calc_type_b" ) THEN

		    prompt_obj = self . parent_prompt . prompt_objects [ act_prompt - 1 ]

		    IF ( prompt_obj . value = 2 ) THEN

			prompt_obj . value = self . value
			prompt_obj . text  = self . text
			prompt_obj . repaste ()

		    ENDIF

		ENDIF

	ELSE

		IF ( self . user_info = "limits_calc_type_a" ) THEN

		    prompt_obj = self . parent_prompt . prompt_objects [ act_prompt + 1 ]
		    prompt_obj . value = self . value
		    prompt_obj . text  = self . text
		    prompt_obj . repaste ()

		ELSEIF ( self . user_info = "limits_calc_type_b" ) THEN

		    prompt_obj = self . parent_prompt . prompt_objects [ act_prompt - 1 ]
		    prompt_obj . value = self . value
		    prompt_obj . text  = self . text
		    prompt_obj . repaste ()

		ENDIF

	ENDIF

ENDROUTINE

{******************************************************************************}

ROUTINE target_value ( self )

{ 
* This routine gets the target value
* 
* 
*
* Parameters   : self
* Return Value : n/a
*
*******************************************************************************}

DECLARE form, text_one, text_two, message1, message2


	CREATE OBJECT PROMPT_CLASS_FORM, form

	form . height = 2
	form . width = 32
	form . row = self . row
	form . column = self . column
	form . header = GET_USER_MESSAGE ( "TARGET_VALUE_TARGET_HEADER", 1 ) 
	form . user_info = self . parent_prompt . user_info

	IF form . user_info . tmp_chart_type = MEAN_STD THEN

		message1 = GET_USER_MESSAGE ( "TARGET_VALUE_MEANSTD_MEAN", 1 ) 
		message2 = GET_USER_MESSAGE ( "TARGET_VALUE_MEANSTD_STD", 1 ) 

	ELSEIF form . user_info . tmp_chart_type = MEAN_RANGE THEN

		message1 = GET_USER_MESSAGE ( "TARGET_VALUE_MEANRAN_MEAN", 1 ) 
		message2 = GET_USER_MESSAGE ( "TARGET_VALUE_MEANRAN_RANGE", 1 ) 

	ELSEIF form . user_info . tmp_chart_type = IND_MR THEN

		message1 = GET_USER_MESSAGE ( "TARGET_VALUE_MR_IND", 1 ) 
		message2 = GET_USER_MESSAGE ( "TARGET_VALUE_MR_RANGE", 1 ) 

	ENDIF

	PROMPT OBJECT text_one
	CLASS "STD_PROMPT_TEXT"
	ON LINE 1 FROM 2 TO 19
	WITH(   raised=TRUE,
		value=message1)

	PROMPT OBJECT text_two
	CLASS "STD_PROMPT_TEXT"
	ON LINE 2 FROM 2 TO 19
	WITH(   raised=TRUE,
		value=message2)

	PROMPT OBJECT form . prompt_objects [ 1 ]
	ON LINE 1 FROM 22 TO 30
	BROWSE ON REAL
	WITH (  minimum = -999,
		maximum =  999,
		user_info = "target_mean" )

	form . prompt_objects [ 1 ] . value  =
	default_line_display ( form . user_info,
			       form . prompt_objects [ 1 ] . user_info )

	PROMPT OBJECT form . prompt_objects [ 2 ]
	ON LINE 2 FROM 22 TO 30
	BROWSE ON REAL
	WITH (  minimum = -999,
		maximum =  999,
		user_info = "target_sigma" )

	form . prompt_objects [ 2 ] . value  =
	default_line_display ( form . user_info,
			       form . prompt_objects [ 2 ] . user_info )

	form . add_display ( text_one )
	form . add_display ( text_two )

	form . start_prompt ()
	form . wait_prompt ()
	form . end_prompt ()

	IF ( form . get_lastkey () <> "EXIT" ) THEN

	write_prompts_to_objDB ( form, 1, 2 )

	ENDIF

ENDROUTINE

{******************************************************************************}

ROUTINE user_defined_value ( self )

{ 
* This routine gets a user defined value.
* 
* 
*
* Parameters   : self
* Return Value : n/a
*
*******************************************************************************}

DECLARE form, text_one, text_two, text_three, text_four, text_five,
        text_six, text_seven

	CREATE OBJECT PROMPT_CLASS_FORM, form

	form . height = 7
	form . width = 36
	form . row = self . row
	form . column = self . column
	form . header = "User Defined Limits"
	form . user_info = self . parent_prompt . user_info

	PROMPT OBJECT text_one
	CLASS "STD_PROMPT_TEXT"
	ON LINE 1 FROM 2 TO 23
	WITH(   raised=TRUE,
		value="Upper Control Limit")

	PROMPT OBJECT text_two
	CLASS "STD_PROMPT_TEXT"
	ON LINE 2 FROM 2 TO 23
	WITH(   raised=TRUE,
		value="Upper Warning Limit")

	PROMPT OBJECT text_three
	CLASS "STD_PROMPT_TEXT"
	ON LINE 3 FROM 2 TO 23
	WITH(   raised=TRUE,
		value="Upper Std. Limit")

	PROMPT OBJECT text_four
	CLASS "STD_PROMPT_TEXT"
	ON LINE 4 FROM 2 TO 23
	WITH(   raised=TRUE,
		value="Target Value")

	PROMPT OBJECT text_five
	CLASS "STD_PROMPT_TEXT"
	ON LINE 5 FROM 2 TO 23
	WITH(   raised=TRUE,
		value="Lower Std. Limit")

	PROMPT OBJECT text_six
	CLASS "STD_PROMPT_TEXT"
	ON LINE 6 FROM 2 TO 23
	WITH(   raised=TRUE,
		value="Lower Warning Limit")

	PROMPT OBJECT text_seven
	CLASS "STD_PROMPT_TEXT"
	ON LINE 7 FROM 2 TO 23
	WITH(   raised=TRUE,
		value="Lower Control Limit")

	PROMPT OBJECT form . prompt_objects [ 1 ]
	ON LINE 1 FROM 26 TO 35
	BROWSE ON real
	WITH (  minimum=-999,
		maximum=999 )

	PROMPT OBJECT form . prompt_objects [ 2 ]
	ON LINE 2 FROM 26 TO 35
	BROWSE ON real
	WITH (  minimum=-999,
		maximum=999 )

	PROMPT OBJECT form . prompt_objects [ 3 ]
	ON LINE 3 FROM 26 TO 35
	BROWSE ON real
	WITH (  minimum=-999,
		maximum=999 )

	PROMPT OBJECT form . prompt_objects [ 4 ]
	ON LINE 4 FROM 26 TO 35
	BROWSE ON real
	WITH (  minimum=-999,
		maximum=999 )

	PROMPT OBJECT form . prompt_objects [ 5 ]
	ON LINE 5 FROM 26 TO 35
	BROWSE ON real
	WITH (  minimum=-999,
		maximum=999 )

	PROMPT OBJECT form . prompt_objects [ 6 ]
	ON LINE 6 FROM 26 TO 35
	BROWSE ON real
	WITH (  minimum=-999,
		maximum=999 )

	PROMPT OBJECT form . prompt_objects [ 7 ]
	ON LINE 7 FROM 26 TO 35
	BROWSE ON real
	WITH (  minimum=-999,
		maximum=999 )

	IF ( self . user_info = "limits_calc_type_a" ) THEN

		form . prompt_objects [ 1 ] . user_info = "upper_control_a"
		form . prompt_objects [ 2 ] . user_info = "upper_warning_a"
		form . prompt_objects [ 3 ] . user_info = "upper_sigma_a"
		form . prompt_objects [ 4 ] . user_info = "target_value_a"
		form . prompt_objects [ 5 ] . user_info = "lower_sigma_a"
		form . prompt_objects [ 6 ] . user_info = "lower_warning_a"
		form . prompt_objects [ 7 ] . user_info = "lower_control_a"

	ELSE

		form . prompt_objects [ 1 ] . user_info = "upper_control_b"
		form . prompt_objects [ 2 ] . user_info = "upper_warning_b"
		form . prompt_objects [ 3 ] . user_info = "upper_sigma_b"
		form . prompt_objects [ 4 ] . user_info = "target_value_b"
		form . prompt_objects [ 5 ] . user_info = "lower_sigma_b"
		form . prompt_objects [ 6 ] . user_info = "lower_warning_b"
		form . prompt_objects [ 7 ] . user_info = "lower_control_b"

	ENDIF

	read_prompts_from_objDB ( form, 1, 7 )

	form . add_display ( text_one   )
	form . add_display ( text_two   )
	form . add_display ( text_three )
	form . add_display ( text_four  )
	form . add_display ( text_five  )
	form . add_display ( text_six   )
	form . add_display ( text_seven )

	form . start_prompt ()
	form . wait_prompt ()
	form . end_prompt ()

	IF ( form . get_lastkey () <> "EXIT" ) THEN

	write_prompts_to_objDB ( form, 1, 7 )

	ENDIF

ENDROUTINE

{******************************************************************************}

ROUTINE add_param_buttons (sqc_chart , form)

{ 
* This routine adds parameter buttons
* 
* 
*
* Parameters   : sqc_chart, form
* Return Value : n/a
*
*******************************************************************************}

DECLARE button_one,button_two,button_three,button_four, button_line

	form.button_style=FORM_BUTTON_NONE
	button_line = form . height - 1

	IF (sqc_chart . ok_button_only = TRUE ) THEN

		PROMPT OBJECT button_one
			CLASS "STD_PROMPT_BUTTON"
			ON LINE button_line FROM 1 TO 13
			WITH (  caption="OK",
				user_info="NEXT",
				mouse_click_routine="button_press_chart_param")

		form.add_prompt(button_one)

		PROMPT OBJECT button_two
			CLASS "STD_PROMPT_BUTTON"
			ON LINE button_line FROM form . width -26 TO form . width -14
			WITH (caption="Help",
			      send_lastkey="HELP",
			      enabled=TRUE)

		form.add_prompt(button_two)

		PROMPT OBJECT button_three
			CLASS "STD_PROMPT_BUTTON"
			ON LINE button_line FROM form . width -12 TO form . width
			WITH ( caption = "Cancel"                ,
			       user_info="EXIT"                  ,
			       mouse_click_routine="button_press_chart_param")

		form.add_prompt(button_three)

	ELSE

	    PROMPT OBJECT button_one
		    CLASS "STD_PROMPT_BUTTON"
		    ON LINE button_line FROM 1 TO 13
		    WITH (      caption="< Previous",
			    user_info="PREV",
			mouse_click_routine="button_press_chart_param")

	    form.add_prompt(button_one)

	    PROMPT OBJECT button_two
		    CLASS "STD_PROMPT_BUTTON"
		    ON LINE button_line FROM 15 TO 27
		    WITH (      caption="Next >",
			    user_info="NEXT",
			    mouse_click_routine="button_press_chart_param")

	    form.add_prompt(button_two)

	    PROMPT OBJECT button_three
		    CLASS "STD_PROMPT_BUTTON"
		    ON LINE button_line FROM form . width -26 TO form . width -14
		    WITH (  caption="Help",
			    send_lastkey="HELP")

	    form.add_prompt(button_three)

	    PROMPT OBJECT button_four
		CLASS "STD_PROMPT_BUTTON"
		ON LINE button_line FROM form . width -12 TO form . width
		WITH (  caption="Cancel",
			user_info="EXIT",
			mouse_click_routine="button_press_chart_param" )

	    form.add_prompt(button_four)

	ENDIF

ENDROUTINE

{******************************************************************************}

GLOBAL ROUTINE draw_chart (sqc_chart)

{ 
* This routine draws the chart. It is the top level draw routine.
* 
* 
*
* Parameters   : sqc_chart
* Return Value : n/a
*
*******************************************************************************}

DECLARE form

	sqc_chart . sqc_header . set_by_number (1)

	create_graph_form( sqc_chart, form )

	sqc_chart . active_array = get_active_array (sqc_chart)

	IF ( sqc_chart . edit_mode = "VIEW" ) THEN

	    run_sqc_calculations ( sqc_chart )

	ENDIF

	sqc_chart . selected_graph = sqc_chart . active_array [ 1, 1 ]
	sqc_chart . selected_chart = sqc_chart . active_array [ 1, 2 ]
	set_sqc_chart_index_value ( sqc_chart )

	set_up_std_prompt_graph_class ()            

	create_graph_object ( form )

	form . start_prompt()

		draw_graph (sqc_chart, sqc_chart . active_array[1,1], FALSE, form)

	form.wait_prompt()

	form.end_prompt()

	sqc_chart . next_screen = "EXIT"

ENDROUTINE

{******************************************************************************}

ROUTINE plot_it ( self )

{ 
* This routine calls the draw_graph routine
* 
* 
*
* Parameters   : self
* Return Value : n/a
*
*******************************************************************************}

    draw_graph (self . parent_prompt . user_info                  ,
                self . parent_prompt . user_info . selected_graph ,
                TRUE                                              ,
                self . parent_prompt                              )

ENDROUTINE

{******************************************************************************}

ROUTINE change_chart ( self )

{ 
* This routine changes the chart.
* 
* 
*
* Parameters   : self
* Return Value : n/a
*
*******************************************************************************}

DECLARE old_active_array, new_active_array, new_types_array, pos_in_array,
        new_graph_array, graph_counter, type_counter

DECLARE tmp_selected_chart, tmp_selected_graph, sqc_chart

DECLARE checker, graph_present, continue

	checker = 0

	ARRAY new_types_array

	graph_present = FALSE

	sqc_chart = self . parent_prompt . user_info

	old_active_array = get_active_array ( sqc_chart )

	pos_in_array = 0

	sqc_chart . ok_button_only = TRUE
	get_chart_type ( sqc_chart)
	sqc_chart . ok_button_only = FALSE
	new_active_array = get_active_array ( sqc_chart)
	new_graph_array = array_difference (old_active_array , new_active_array)

	pos_in_array = 1

	graph_counter = 1
	type_counter  = 1

	WHILE ( new_graph_array [ graph_counter, 2 ] <> EMPTY ) DO

		new_types_array [ type_counter ] =  new_graph_array [ graph_counter, 2 ]

		WHILE ( new_graph_array [ graph_counter, 2 ] =
			    new_types_array [ type_counter ] ) DO

		    graph_counter = graph_counter + 1

		ENDWHILE

		type_counter = type_counter + 1

	ENDWHILE

	tmp_selected_chart = sqc_chart . selected_chart
	tmp_selected_graph = sqc_chart . selected_graph

	sqc_chart . selected_chart = EMPTY
	sqc_chart . selected_graph = EMPTY

	continue = ( pos_in_array <= sqcwin_array_size ( new_types_array ) )

	WHILE continue DO

		IF (pos_in_array = 0)

			sqc_chart . ok_button_only = TRUE

			get_chart_type ( sqc_chart)

			sqc_chart . ok_button_only = FALSE

			new_active_array =
			 get_active_array ( sqc_chart)

			new_graph_array  =
			 array_difference (old_active_array , new_active_array)

			WHILE ( new_graph_array [ graph_counter, 2 ] <> EMPTY ) DO

			new_types_array [ type_counter ] =
			    new_graph_array [ graph_counter, 2 ]

			WHILE ( new_graph_array [ graph_counter, 2 ] =
				    new_types_array [ type_counter ] ) DO

			    graph_counter = graph_counter + 1

			ENDWHILE

			type_counter = type_counter + 1

			ENDWHILE

			IF ( LASTKEY = "EXIT" ) THEN

				continue = FALSE

			ENDIF

		ELSE

		    sqc_chart . ok_button_only = FALSE

		    aux_get_params ( new_types_array [ pos_in_array ] ,
				     sqc_chart )

		    sqc_chart . selected_chart = EMPTY
		    sqc_chart . selected_graph = EMPTY

		ENDIF

		IF ( LASTKEY = "LEFT" ) THEN

		    pos_in_array = pos_in_array - 1

		ELSEIF ( LASTKEY = "RIGHT" ) THEN

		    pos_in_array = pos_in_array + 1

		ELSEIF ( LASTKEY = "EXIT" ) THEN

			pos_in_array = 0

		ENDIF

		IF continue THEN
		
			continue = 
			( pos_in_array <= sqcwin_array_size ( new_types_array ) )

		ENDIF

	ENDWHILE

	WHILE ( checker < sqcwin_array_size ( new_active_array ) ) DO

		checker = checker + 1

		IF new_active_array [ 1, checker ] = tmp_selected_graph THEN

		    graph_present = TRUE

		ENDIF

	ENDWHILE

	IF ( NOT graph_present ) AND
	   ( LASTKEY <> "EXIT" ) THEN

		tmp_selected_graph = new_active_array [ 1, 1 ]
		tmp_selected_chart = new_active_array [ 1, 2 ]
		sqc_chart . selected_chart = tmp_selected_chart
		sqc_chart . selected_graph = tmp_selected_graph

		self . parent_prompt . prompt_objects [ 1 ] . value = 
		    new_active_array [ 1, 1 ]

		set_sqc_chart_index_value ( sqc_chart ) 

		draw_graph ( sqc_chart         ,
			     tmp_selected_graph,
			     FALSE             ,
			     self . parent_prompt)

	ENDIF

	sqc_chart . selected_chart = tmp_selected_chart
	sqc_chart . selected_graph = tmp_selected_graph

	IF ( LASTKEY <> "EXIT" ) THEN
	
		ARRAY sqc_chart . active_array = EMPTY
		array_copy ( sqc_chart . active_array ,
			     new_active_array         )

	ENDIF

	sqc_chart . ok_button_only = FALSE

ENDROUTINE

{******************************************************************************}

ROUTINE aux_get_params ( type , sqc_chart )

{ 
* This routine gets chart parameters
* 
* 
*
* Parameters   : type, sqc_chart
* Return Value : n/a
*
*******************************************************************************}

    IF (type = CUSUM) THEN

        cusum_chart_params (sqc_chart)

    ELSEIF (type = IND_MR) THEN

        indmr_chart_params (sqc_chart)

    ELSEIF (type = MEAN_RANGE) THEN

        meanr_chart_params (sqc_chart)

    ELSEIF (type = MEAN_STD ) THEN

        means_chart_params (sqc_chart)

    ELSEIF (type = PROC_CAP ) THEN

        procc_chart_params (sqc_chart)

    ENDIF

ENDROUTINE

{******************************************************************************}

ROUTINE graph_edit_data (self)

{ 
* This routine edits the data.
* 
* 
*
* Parameters   : 
* Return Value : 
*
*******************************************************************************}

DECLARE recalculate

	self . parent_prompt . user_info . ok_button_only = TRUE

	recalculate = edit_screen ( self . parent_prompt . user_info)

	IF recalculate THEN

	run_sqc_calculations ( self . parent_prompt . user_info )

	draw_graph ( self . parent_prompt . user_info                  ,
		     self . parent_prompt . user_info . selected_graph ,
		     FALSE                                             ,
		     self . parent_prompt                              )

	ENDIF

	self . parent_prompt . user_info . ok_button_only = FALSE

ENDROUTINE

{******************************************************************************}

ROUTINE aux_chart_params (self)

{ 
* Auxillary chart parameters routine.
* 
* 
*
* Parameters   : self
* Return Value : n/a
*
*******************************************************************************}

DECLARE chart_type_id, exitloop, counter

	chart_type_id = ""
	counter = 1
	exit_loop = FALSE

	self . parent_prompt . user_info . ok_button_only = TRUE

	WHILE NOT ( exit_loop ) DO

		IF ( self . parent_prompt . user_info .
			active_array [ counter, 1 ] =
		     self . parent_prompt . user_info . selected_graph ) THEN

		    chart_type_id = self . parent_prompt . user_info .
				       active_array [ counter, 2 ]

		    exitloop = TRUE

		ELSEIF ( self . parent_prompt . user_info .
			active_array [ counter, 1 ] = EMPTY ) THEN

		    exitloop = TRUE

		ENDIF

		counter = counter + 1

	ENDWHILE

	aux_get_params ( chart_type_id,
		     self . parent_prompt . user_info )

	self . parent_prompt . user_info . ok_button_only = FALSE

	IF ( LASTKEY <> "EXIT" ) THEN

		draw_graph ( self . parent_prompt . user_info,
			     self . parent_prompt . user_info . selected_graph,
			     FALSE ,
			     self . parent_prompt )

	ENDIF

ENDROUTINE

{******************************************************************************}

ROUTINE update_local (self)

{ 
* Saves data. 
* 
* 
*
* Parameters   : self
* Return Value : n/a
*
*******************************************************************************}

	update_database (self . parent_prompt . user_info )
	self . parent_prompt . stop_prompt ()
	self . parent_prompt . user_info . next_screen = "EXIT"

ENDROUTINE

{******************************************************************************}

ROUTINE finish_up (self)

{ 
* Termination routine.
* 
* 
*
* Parameters   : self
* Return Value : n/a
*
*******************************************************************************}

DECLARE answer

    IF ( self . caption <> GET_USER_MESSAGE ( "SQCWIN_BUT_CLOSE", 1 ) ) THEN

    	answer = confirm_with_text ("Confirm exit ?")

    ELSE

	answer = TRUE

    ENDIF

    IF (answer) THEN

        self . parent_prompt . stop_prompt ()
        self . parent_prompt . user_info . next_screen = "EXIT"

    ENDIF

ENDROUTINE

{******************************************************************************}

ROUTINE yaxis_options ( sqc_chart , graph_form )

{ 
* Y axis options routine.
* 
* 
*
* Parameters   : sqc_chart, graph_form
* Return Value : n/a
*
*******************************************************************************}

DECLARE disp_1,disp_2,disp_3,disp_4,prom_1,prom_2,prom_3,prom_4
DECLARE disp_1_txt, disp_2_txt, disp_3_txt, disp_4_txt
DECLARE form2

	PROMPT OBJECT form2
		CLASS PROMPT_CLASS_FORM

	form2.height=4
	form2.width=47
	form2.row=6
	form2.column=6
	form2.header="Y-Axis Options"

	form2 . user_info = sqc_chart
	form2 . validation_routine = "valid_yaxis_para"

	disp_1_txt = get_chart_name ( sqc_chart, TRUE ) : " Minimum"
	PROMPT OBJECT disp_1
		CLASS "STD_PROMPT_TEXT"
		ON LINE 1 FROM 2 TO 35
		WITH (value=disp_1_txt,
			raised=TRUE)

	disp_2_txt = get_chart_name ( sqc_chart, TRUE ) : " Maximum"
	PROMPT OBJECT disp_2
		CLASS "STD_PROMPT_TEXT"
		ON LINE 2 FROM 2 TO 35
		WITH (value=disp_2_txt,
			raised=TRUE)

	disp_3_txt = get_chart_name ( sqc_chart, FALSE ) : " Minimum"
	PROMPT OBJECT disp_3
		CLASS "STD_PROMPT_TEXT"
		ON LINE 3 FROM 2 TO 35
		WITH (value=disp_3_txt,
			raised=true)

	disp_4_txt = get_chart_name ( sqc_chart, FALSE ) : " Maximum"
	PROMPT OBJECT disp_4
		CLASS "STD_PROMPT_TEXT"
		ON LINE 4 FROM 2 to 35
		WITH (value=disp_4_txt,
			raised=TRUE)

	PROMPT OBJECT prom_1
		ON LINE 1 FROM 37
		BROWSE ON real
		WITH ( places = sqc_chart . decimal_places )

	PROMPT OBJECT prom_2
		ON LINE 2 FROM 37
		BROWSE ON real
		WITH ( places = sqc_chart . decimal_places )

	PROMPT OBJECT prom_3
		ON LINE 3 FROM 37
		BROWSE ON real
		WITH ( places = sqc_chart . decimal_places )

	PROMPT OBJECT prom_4
		ON LINE 4 FROM 37
		BROWSE ON real
		WITH ( places = sqc_chart . decimal_places )

	form2.add_frame("",1,1,4,form2.width)
	form2.add_display(disp_1)
	form2.add_display(disp_2)
	form2.add_display(disp_3)
	form2.add_display(disp_4)

	form2.add_prompt(prom_1)
	form2.add_prompt(prom_2)
	form2.add_prompt(prom_3)
	form2.add_prompt(prom_4)

	get_default_yaxis_values ( form2 )

	form2.start_prompt()
	form2.wait_prompt()
	form2.end_prompt()

	IF ( form2 . get_lastkey () <> "EXIT" ) THEN

	    set_default_yaxis_values ( form2 )
	    draw_graph ( sqc_chart                 ,
			 sqc_chart . selected_graph,
			 FALSE                     ,
			 graph_form )

	ENDIF

ENDROUTINE

{******************************************************************************}

ROUTINE cusum_yaxis_options ( sqc_chart , graph_form )

{ 
* Y axis parameters routine.
* 
* 
*
* Parameters   : sqc_chart, graph_form
* Return Value : n/a
*
*******************************************************************************}

DECLARE form, disp_1, disp_2, prom_1, prom_2, grobj_ndx, sqc_chart_type_row

	object_create ( form, PROMPT_CLASS_FORM )

	form . height = 2
	form . width  = 47
	form . row    = 6
	form . column = 6
	form . header = "Y-Axis Options"

	form . validation_routine = "valid_cusum_yaxis_para"
	form . user_info = sqc_chart

	PROMPT OBJECT disp_1
	CLASS "STD_PROMPT_TEXT"
		ON LINE 1 FROM 2 TO 20
		WITH ( value  = " Minimum : ",
		       raised = TRUE         )

	PROMPT OBJECT disp_2
	CLASS "STD_PROMPT_TEXT"
		ON LINE 2 FROM 2 TO 20
		WITH ( value  = " Maximum : ",
		       raised = TRUE         )

	PROMPT OBJECT prom_1
	FORMAT REAL
	ON LINE 1 FROM 22 TO 35
	WITH ( places = sqc_chart . decimal_places )

	PROMPT OBJECT prom_2
	FORMAT REAL
	ON LINE 2 FROM 22 TO 35
	WITH ( places = sqc_chart . decimal_places )

	form . add_display ( disp_1 )
	form . add_display ( disp_2 )

	form . add_prompt ( prom_1 )
	form . add_prompt ( prom_2 )

	get_default_yaxis_values ( form )

	form . start_prompt ()
	form . wait_prompt  ()
	form . end_prompt   ()

	IF ( form . get_lastkey () <> "EXIT" ) THEN

		grobj_ndx = sqc_chart . graph_obj_a_ndx

		sqc_chart . graph_object_array [ grobj_ndx ] . cusum_min =
		     form . prompt_objects [ 1 ] . value

		sqc_chart . graph_object_array [ grobj_ndx ] . cusum_max =
		     form . prompt_objects [ 2 ] . value
		sqc_chart_type_row = get_chart_type_row( sqc_chart )

		ASSIGN sqcwin_chart_type . user_defined_y_axis 
		IN OBJECT sqc_chart_type_row = TRUE

		ASSIGN sqcwin_chart_type . cusum_y_max 
		IN OBJECT sqc_chart_type_row = 
		     form . prompt_objects [ 2 ] . value

		ASSIGN sqcwin_chart_type . cusum_y_min 
		IN OBJECT sqc_chart_type_row = 
		     form . prompt_objects [ 1 ] . value

		draw_graph ( sqc_chart,
			     sqc_chart . selected_graph,
			     FALSE ,
			     graph_form )

	ENDIF

ENDROUTINE

{******************************************************************************}

ROUTINE valid_cusum_yaxis_para ( self )

{ 
* Validates CUSUM Y axis parameters.
* 
* 
*
* Parameters   : self
* Return Value : return_value
*
*******************************************************************************}

DECLARE return_value

    return_value = TRUE

    IF NOT( ( ( self . prompt_objects [ 1 ] . value = 0 ) AND
            ( self . prompt_objects [ 2 ] . value = 0 ) ) ) THEN

	    IF ( self . prompt_objects [ 2 ] . value <=
		 self . prompt_objects [ 1 ] . value )

		    flash_message ("Invalid y-axis values",TRUE)
		    return_value = FALSE

	    ENDIF

    ENDIF

    RETURN ( return_value )

ENDROUTINE

{******************************************************************************}

ROUTINE get_default_yaxis_values ( form )

{ 
* Gets default Y axis parameters.
* 
* 
*
* Parameters   : form
* Return Value : n/a
*
*******************************************************************************}

DECLARE sqc_chart, graph_a, graph_b, graph_objs

	sqc_chart = form . user_info

	graph_objs = sqc_chart . graph_object_array
	graph_a    = sqc_chart . graph_obj_a_ndx
	graph_b    = sqc_chart . graph_obj_b_ndx

					{ ================================ }
					{ If no second chart assum cusum   }
					{ ================================ }

	IF graph_b = 0 THEN

		form . prompt_objects [ 1 ] . value = graph_objs [ graph_a ] . cusum_min
		form . prompt_objects [ 2 ] . value = graph_objs [ graph_a ] . cusum_max

	ELSE

		form . prompt_objects [ 1 ] . value = graph_objs [ graph_a ] . y_min
		form . prompt_objects [ 2 ] . value = graph_objs [ graph_a ] . y_max
		form . prompt_objects [ 3 ] . value = graph_objs [ graph_b ] . y_min
		form . prompt_objects [ 4 ] . value = graph_objs [ graph_b ] . y_max

	ENDIF

ENDROUTINE

{******************************************************************************}

ROUTINE set_default_yaxis_values ( form )

{ 
* Sets default Y axis parameters.
* 
* 
*
* Parameters   : form
* Return Value : n/a
*
*******************************************************************************}

DECLARE sqc_chart, graph_a, graph_b, graph_objs, exit_loop_a,
        exit_loop_b, count, sqc_chart_type_row

	sqc_chart = form . user_info

	graph_a = get_chart_graph ( sqc_chart, TRUE  )
	graph_b = get_chart_graph ( sqc_chart, FALSE )

	graph_objs = sqc_chart . graph_object_array
	sqc_chart_type_row = get_chart_type_row( sqc_chart )

	    ASSIGN sqcwin_chart_type . user_defined_y_axis 
	    IN OBJECT sqc_chart_type_row  = TRUE

	exit_loop_A = FALSE
	exit_loop_B = FALSE
	count = 1
	
	WHILE ( NOT ( exit_loop_a ) ) DO

		IF ( graph_objs [ count ] . graph_type = graph_a ) THEN

		    graph_objs [ count ] . y_min = form . prompt_objects [ 1 ] . value
		    graph_objs [ count ] . y_max = form . prompt_objects [ 2 ] . value
		    ASSIGN sqcwin_chart_type . y_min_chart_a 
		    IN OBJECT sqc_chart_type_row = 
		    form . prompt_objects [ 1 ] . value

		    ASSIGN sqcwin_chart_type . y_max_chart_a 
		    IN OBJECT sqc_chart_type_row  = 
		    form . prompt_objects [ 2 ] . value
		    exit_loop_a = TRUE

		ENDIF

		count = count + 1

	ENDWHILE

	count = 1

	WHILE ( NOT ( exit_loop_B ) ) DO

		IF ( graph_objs [ count ] . graph_type = graph_b ) THEN

		    graph_objs [ count ] . y_min = form . prompt_objects [ 3 ] . value
		    graph_objs [ count ] . y_max = form . prompt_objects [ 4 ] . value
		    ASSIGN sqcwin_chart_type . y_min_chart_b 
		    IN OBJECT sqc_chart_type_row = 
		    form . prompt_objects [ 3 ] . value

		    ASSIGN sqcwin_chart_type . y_max_chart_b 
		    IN OBJECT sqc_chart_type_row  = 
		    form . prompt_objects [ 4 ] . value
		    exit_loop_b = TRUE

		ENDIF

		count = count + 1

	ENDWHILE

ENDROUTINE

{******************************************************************************}

ROUTINE valid_yaxis_para ( self )

{ 
* Validate Y axis parameters.
* 
* 
*
* Parameters   : self
* Return Value : return_value
*
*******************************************************************************}

DECLARE return_value

    return_value = TRUE

    IF NOT( ( self . prompt_objects [ 1 ] . value = 0 )   AND
            ( self . prompt_objects [ 2 ] . value = 0 )   AND
            ( self . prompt_objects [ 3 ] . value = 0 )   AND
            ( self . prompt_objects [ 4 ] . value = 0 ) ) THEN

	    IF ( self . prompt_objects [ 2 ] . value <=
		 self . prompt_objects [ 1 ] . value )
	    OR ( self . prompt_objects [ 4 ] . value <=
		 self . prompt_objects [ 3 ] . value) THEN

		    flash_message ("Invalid y-axis values",TRUE)

		    return_value = FALSE

	    ENDIF

    ENDIF

    RETURN ( return_value )

ENDROUTINE

{******************************************************************************}

ROUTINE recalc_limits ( sqc_chart, graph_form )

{ 
* Recalculates limits.
* 
* 
*
* Parameters   : sqc_chart, graph_form
* Return Value : n/a
*
*******************************************************************************}

DECLARE form3, display_seg, max_bound
DECLARE disp_1, disp_2, prom_1, prom_2, graph_obj

	graph_obj = 1
	display_seg = TRUE

	WHILE ( sqc_chart . selected_chart <>
		sqc_chart . graph_object_array [ graph_obj ] . chart_type ) DO

	    graph_obj = graph_obj + 1

	ENDWHILE

	PROMPT OBJECT form3
		CLASS PROMPT_CLASS_FORM

	form3 . height  = 2
	form3 . width   = 42
	form3 . row     = 6
	form3 . column  = 6
	form3 . header  = "Recalculate over a Segment"
	form3 . user_info = sqc_chart
	form3 . validation_routine = "check_segment_bounds"

	PROMPT OBJECT disp_1
	    CLASS "STD_PROMPT_TEXT"
	    ON LINE 1 FROM 2 TO 30
	    WITH ( value = "First Subgroup" ,
		   raised=TRUE              )

	PROMPT OBJECT disp_2
	    CLASS "STD_PROMPT_TEXT"
	    ON LINE 2 FROM 2 TO 30
	    WITH ( value  = "Last Subgroup" ,
		   raised = TRUE            )

	max_bound = sqc_chart . graph_object_array [ graph_obj ] . no_x +
		    sqc_chart . graph_object_array [ graph_obj ] . start_col -
		    1

	PROMPT OBJECT prom_1
	    ON LINE 1 FROM 32 TO 34
	    BROWSE ON INTEGER
	    WITH ( value = 1           ,
		   minimum = 1         ,
		   maximum = max_bound )

	PROMPT OBJECT prom_2
	    ON LINE 2 FROM 32 TO 34
	    BROWSE ON INTEGER
	    WITH ( value   = max_bound ,
		   minimum = 1         ,
		   maximum = max_bound )

	form3.add_frame("",1,1,2,form3.width)
	form3.add_display(disp_1)
	form3.add_display(disp_2)
	form3.add_prompt(prom_1)
	form3.add_prompt(prom_2)

	form3.start_prompt()
	form3.wait_prompt()
	form3.end_prompt()

	IF ( form3 . get_lastkey () <> "EXIT" ) THEN

	    calculate_limits_and_trends ( sqc_chart                 ,
					  sqc_chart . selected_chart,
					  prom_1 . value            ,
					  prom_2 . value            ,
					  display_seg               )

	    draw_graph ( sqc_chart                 ,
			 sqc_chart . selected_graph,
			 FALSE                     ,
			 graph_form )

	ENDIF

ENDROUTINE

{******************************************************************************}

ROUTINE check_segment_bounds ( self )

{ 
* Checks that a recalc segment is acceptable.
* 
* 
*
* Parameters   : self
* Return Value : return_value
*
*******************************************************************************}

DECLARE return_value, chart_type_ndx , sqc_chart, first_value,
        second_value, a_plot, b_plot, total_points, plot_point_a,
        plot_point_b, counter, bad_point_a, bad_point_b, a_bad, b_bad

	return_value = TRUE
	sqc_chart = self . user_info
	first_value  = self . prompt_objects [ 1 ] . value
	second_value = self . prompt_objects [ 2 ] . value
	chart_type_ndx = PAD ( sqc_chart . chart_id      , " ", "20" ) :
		     PAD ( sqc_chart . selected_chart, " ", "10" ) :
	   JUSTIFY ( PAD ( STRIP ( first_value )     , " ", "4"  ), "RIGHT" )

	sqc_chart . sqc_subgroup . set_by_index ( "KEY0", chart_type_ndx )

	a_plot = 0
	b_plot = 0

	a_bad = 0
	b_bad = 0

	counter = first_value

	WHILE ( ( counter <= second_value ) AND
	    ( sqc_chart . sqc_subgroup . current <> EMPTY ) ) DO

		plot_point_a = SELECT sqcwin_subgroup . a_plot IN OBJECT
				   sqc_chart . sqc_subgroup . current

		plot_point_b = SELECT sqcwin_subgroup . b_plot IN OBJECT
				   sqc_chart . sqc_subgroup . current

		bad_point_a  = SELECT sqcwin_subgroup . a_bad IN OBJECT
				   sqc_chart . sqc_subgroup . current

		bad_point_b  = SELECT sqcwin_subgroup . b_bad IN OBJECT
				   sqc_chart . sqc_subgroup . current

		IF NOT ( plot_point_a ) THEN
		    a_plot = a_plot + 1
		ENDIF

		IF NOT ( plot_point_b ) THEN
		    b_plot = b_plot + 1
		ENDIF

		IF ( bad_point_a ) THEN
		    a_bad = a_bad + 1
		ENDIF

		IF ( bad_point_b ) THEN
		    b_bad = b_bad + 1
		ENDIF

		counter = counter + 1

		chart_type_ndx = PAD ( sqc_chart . chart_id      , " ", "20" ) :
				 PAD ( sqc_chart . selected_chart, " ", "10" ) :
		       JUSTIFY ( PAD ( STRIP ( counter )         , " ", "4"  ), "RIGHT" )

		sqc_chart . sqc_subgroup . set_by_index ( "KEY0", chart_type_ndx )

	ENDWHILE

	total_points = second_value - first_value + 1

	IF ( ( a_plot = total_points ) AND ( b_plot = total_points ) ) OR
	( ( a_bad  = total_points ) AND ( b_bad  = total_points ) ) THEN

		return_value = FALSE
		flash_message ( GET_USER_MESSAGE ( "RECALC_SEGMENT_ERROR1", 1 ), TRUE )

	ELSE

		IF ( a_plot = total_points ) OR ( a_bad = total_points ) THEN
		    return_value = FALSE

		    flash_message ( GET_USER_MESSAGE ( "RECALC_SEGMENT_ERROR2", 1 )    
				    , TRUE )

		ENDIF

		IF ( b_plot = total_points ) OR ( b_bad = total_points ) THEN

		    return_value = FALSE
		    flash_message ( GET_USER_MESSAGE ( "RECALC_SEGMENT_ERROR3", 1 )    
				    , TRUE )

		ENDIF
	ENDIF

	IF ( first_value > second_value ) THEN

		flash_message ( GET_USER_MESSAGE ( "RECALC_SEGMENT_ERROR4", 1 )    
				, TRUE )
		return_value = FALSE

	ENDIF

	RETURN ( return_value )

ENDROUTINE

{******************************************************************************}

ROUTINE check_last_subgroup ( self )

{ 
* Check the last subgroup.
* 
* 
*
* Parameters   : self
* Return Value : n/a
*
*******************************************************************************}

	IF ( self . value > self . parent_prompt . prompt_objects [ 2 ] . value ) THEN

	    self . parent_prompt . prompt_objects [ 2 ] . value = self . value
	    self . parent_prompt . prompt_objects [ 2 ] . text  = self . value
	    self . parent_prompt . prompt_objects [ 2 ] . repaste ( )

	ENDIF

ENDROUTINE

{******************************************************************************}

ROUTINE check_first_subgroup ( self )

{ 
* Check first subgroup.
* 
* 
*
* Parameters   : 
* Return Value : 
*
*******************************************************************************}

	IF ( self . value < self . parent_prompt . prompt_objects [ 1 ] . value ) THEN

	    self . parent_prompt . prompt_objects [ 1 ] . value = self . value
	    self . parent_prompt . prompt_objects [ 1 ] . text  = self . value
	    self . parent_prompt . prompt_objects [ 1 ] . repaste ( )

	ENDIF

ENDROUTINE

{******************************************************************************}

ROUTINE chart_operations (self)

{ 
* Routine called by clicking mouse button on Operations button..
* 
* 
*
* Parameters   : self
* Return Value : n/a
*
*******************************************************************************}

DECLARE chart_option, sqc_chart, ops_menu



	sqc_chart = self . parent_prompt . user_info

	CREATE OBJECT POPUP_MENU_CLASS, ops_menu
	
	IF sqc_chart . selected_chart <> PROC_CAP THEN

		ops_menu . add_divider()
	
		ops_menu . add_item( GET_USER_MESSAGE( "CHART_OPS_MENU_Y_AXIS", 1 ) )

	ENDIF

	IF  NOT( ( ( sqc_chart . selected_chart = CUSUM    )    OR
	     (  sqc_chart . selected_chart = PROC_CAP ) ) ) THEN

		ops_menu . add_divider()

		ops_menu . add_item( GET_USER_MESSAGE( "CHART_OPS_MENU_SOURCE_COMMENTS", 1 ) )

		ops_menu . add_item( GET_USER_MESSAGE( "CHART_OPS_MENU_SUBGROUP_COMMENTS", 1 ) )

		IF sqc_chart . edit_mode <> "VIEW" THEN

			ops_menu . add_item( 
			           GET_USER_MESSAGE( "CHART_OPS_MENU_SUBGROUP_OPS", 1 ) )

		ENDIF

		IF size_chart ( sqc_chart ) THEN

		    ops_menu . add_divider()

		    ops_menu . add_item( GET_USER_MESSAGE( "CHART_OPS_MENU_RECALC_SEG", 1 ) )

		ENDIF

	ENDIF

	chart_option = ops_menu . start()

	IF ( chart_option = 
	         GET_USER_MESSAGE( "CHART_OPS_MENU_Y_AXIS", 1 )  ) THEN

		IF sqc_chart . selected_chart = CUSUM THEN

		    cusum_yaxis_options ( sqc_chart , self . parent_prompt )

		ELSE

		    yaxis_options ( sqc_chart, self . parent_prompt )

		ENDIF

	ELSEIF ( chart_option = 
	         GET_USER_MESSAGE( "CHART_OPS_MENU_SOURCE_COMMENTS", 1 ) ) THEN

		source_comm (sqc_chart)

	ELSEIF ( chart_option = 
	         GET_USER_MESSAGE( "CHART_OPS_MENU_SUBGROUP_COMMENTS", 1 ) ) THEN

		sub_comm (sqc_chart)

	ELSEIF ( chart_option = 
	         GET_USER_MESSAGE( "CHART_OPS_MENU_SUBGROUP_OPS", 1 ) ) THEN

		subgroup_ops (sqc_chart, self . parent_prompt )

	ELSEIF ( chart_option = 
	         GET_USER_MESSAGE( "CHART_OPS_MENU_RECALC_SEG", 1 ) ) THEN

		recalc_limits ( sqc_chart , self . parent_prompt )

	ENDIF

ENDROUTINE


{******************************************************************************}

ROUTINE graph_print_button (self)

{ 
* Routine called by clicking the print button on the graph form.
* 
* 
*
* Parameters   : self
* Return Value : n/a
*
*******************************************************************************}

	plot_it ( self )

ENDROUTINE
{******************************************************************************}

ROUTINE source_comm (sqc_chart)

{ 
* Routine to call comments routine for SOURCE
* 
* 
*
* Parameters   : sqc_chart
* Return Value : 
*
*******************************************************************************}

    comments (sqc_chart , "SOURCE", FALSE, 0, 0 )

ENDROUTINE

{******************************************************************************}

ROUTINE sub_comm (sqc_chart)

{ 
* Routine to call comments routine for SUBGROUP
* 
* 
*
* Parameters   : sqc_chart
* Return Value : 
*
*******************************************************************************}

    comments (sqc_chart , "SUBGROUP", FALSE, 0, 0 )

ENDROUTINE

{******************************************************************************}

ROUTINE comments ( sqc_chart, VALUE comm_type, VALUE use_limits, 
                   VALUE lower_limit,VALUE upper_limit         )

{ 
* Comments routine. If use_limits is TRUE then only process comments in
* the range lower_limit - upper_limit
* 
*
* Parameters   : sqc_chart, comm_type
* Return Value : n/a
*
*******************************************************************************}

DECLARE form5,grid, comments_array

	comments_array = get_comments ( sqc_chart   ,
	                                comm_type   ,
	                                use_limits  ,
	                                lower_limit ,
	                                upper_limit )

	IF ( comments_array[1,1] <> EMPTY ) THEN

	    CREATE OBJECT "STD_FORM",form5

	    form5.height=11
	    form5.width=53
	    form5.row=6
	    form5.column=2
	    form5.user_info = sqc_chart

	    IF (comm_type = "SOURCE") THEN

		form5.header="Source Data Comments"

	    ELSEIF (comm_type = "SUBGROUP")

		form5.header="Subgroup Data Comments"

	    ENDIF

	    form5.button_style=FORM_BUTTON_NONE

	    CREATE OBJECT "STD_GRID_EDITOR",grid

	    grid . user_info = comments_array

	    grid.height=8
	    grid.width=47
	    grid.row=1
	    grid.column=3
	    grid.cell_columns=2
	    grid.cell_rows = sqcwin_array_size ( grid . user_info )
	    grid.border=TRUE

	    grid.column_size[1]=3
	    grid.column_size[2]=40

	    grid.title_size_top=1
	    grid.title_separator_top=GRID_SEPARATOR_BOTH
	    grid.title_rendition_top=PROMPT_RENDITION_BOLD

	    grid.title_text_top[1,1]="No."
	    grid.title_text_top[2,1]="Comment"

	    grid.display_cell_routine="DISPLAY_TESTS"
	    grid.prompt_cell_routine="PROMPT_TESTS"

	    form5.add_prompt(grid)
	    form5.add_frame("",1,1,8,form5.width-1)

	    add_form_buttons ( form5 )

	    form5.start_prompt()
	    form5.wait_prompt()
	    form5.end_prompt()

	ELSE

	    flash_message ("No Comments", TRUE)

	ENDIF

ENDROUTINE

{******************************************************************************}

ROUTINE display_tests ( self              ,
                        VALUE cell_column ,
                        VALUE cell_row    ,
                              window      ,
                        VALUE column      ,
                        VALUE row         ,
                        VALUE cell_width  ,
                        VALUE cell_height )

{ 
* Display tests.
* 
* 
*
* Parameters   : self, cell_column, cell_row, window, column, row,
*                cell_width, cell_height
* Return Value : 
*
*******************************************************************************}

        DISPLAY STRIP ( self.user_info[cell_row,cell_column] )
                AT column,row IN WINDOW window
                TO column+cell_width-1

ENDROUTINE

{******************************************************************************}

ROUTINE prompt_tests (  self    ,
                        VALUE cell_column       ,
                        VALUE cell_row          ,
                        window                  ,
                        VALUE column            ,
                        VALUE row               ,
                        VALUE cell_width        ,
                        VALUE cell_height       )

{ 
* Prompt tests.
* 
* 
*
* Parameters   : self, cell_column, cell_row, window, column, row,
*                cell_width, cell_height
* Return Value : 
*
*******************************************************************************}

    IF ( cell_column = 1 ) THEN

        PROMPT FOR self.user_info[cell_row,cell_column]
                AT column,row IN WINDOW window
                TO column+cell_width-1
        WITH (  display_only = TRUE )

    ELSEIF ( cell_column = 2 ) THEN

        PROMPT FOR self.user_info[cell_row,cell_column]
                AT column,row IN WINDOW window
                TO column+cell_width-1
        WITH (  display_only = TRUE )

    ENDIF

ENDROUTINE

{******************************************************************************}

ROUTINE subgroup_ops ( sqc_chart, graph_form )

{ 
* subgroup operations.
* 
* 
*
* Parameters   : sqc_chart, graph_form
* Return Value : 
*
*******************************************************************************}

DECLARE form5, grid, sub_ops_array

	sub_ops_array = get_sub_ops ( sqc_chart )

	IF ( sub_ops_array[1,1] <> EMPTY ) THEN

		CREATE OBJECT "STD_FORM",form5

		form5.height=11
		form5.width=106
		form5.row=6
		form5.column=2
		form5.user_info = sqc_chart

		form5.header = "Subgroup Operations"

		form5.button_style=FORM_BUTTON_NONE

		CREATE OBJECT "STD_GRID_EDITOR",grid

		grid . user_info = sub_ops_array

		grid.height=8
		grid.width=100
		grid.row=1
		grid.column=3
		grid.cell_columns = 4
		grid.cell_rows = sqcwin_array_size ( grid . user_info )
		grid.border=TRUE

		grid . column_size [ 1 ] = 3
		grid . column_size [ 2 ] = 40
		grid . column_size [ 3 ] = 25
		grid . column_size [ 4 ] = 25

		grid . title_size_top = 2
		grid . title_separator_top = GRID_SEPARATOR_BOTH
		grid . title_rendition_top = PROMPT_RENDITION_BOLD

		grid . title_text_top [ 1, 1 ] = "No."
		grid . title_text_top [ 2, 1 ] = "Comment"
		grid . title_text_top [ 3, 1 ] = "Bad on"
		grid . title_text_top [ 3, 2 ] = get_chart_name ( sqc_chart, TRUE )
		grid . title_text_top [ 4, 1 ] = "Bad on"
		grid . title_text_top [ 4, 2 ] = get_chart_name ( sqc_chart, FALSE )

		grid . display_cell_routine = "DISPLAY_SUB_OPS"
		grid . prompt_cell_routine  = "PROMPT_SUB_OPS"

		grid . leave_cell_routine   = "set_manual_bad"

		form5 . add_prompt ( grid )
		form5 . add_frame ( "",1,1,8,form5.width-1 )

		add_form_buttons ( form5 )

		form5 . start_prompt ()
		form5 . wait_prompt  ()
		form5 . end_prompt   ()

		IF ( LASTKEY = "DO" ) THEN

			write_sub_ops ( sqc_chart , grid . user_info )

			do_shewhart_calculations ( sqc_chart ,
						   sqc_chart . selected_chart )

			draw_graph ( sqc_chart                  ,
				     sqc_chart . selected_graph ,
				     FALSE                      ,
				     graph_form )

		ENDIF

	ELSE

		flash_message ("No subgroups found", TRUE)

	ENDIF

ENDROUTINE

{******************************************************************************}

ROUTINE display_sub_ops ( self              ,
                          VALUE cell_column ,
                          VALUE cell_row    ,
                                window      ,
                          VALUE column      ,
                          VALUE row         ,
                          VALUE cell_width  ,
                          VALUE cell_height )

{ 
* Display subgroup operations.
* 
* 
*
* Parameters   : self, cell_column, cell_row, window, column, row,
*                cell_width, cell_height
* Return Value : 
*
*******************************************************************************}

    IF ( cell_column = 3 ) OR ( cell_column = 4 ) THEN
        DISPLAY self.user_info[cell_row,cell_column]
            FORMAT boolean
            AT column,row IN WINDOW window
            TO column+cell_width-1
            WITH ( is_check  = TRUE )
    ELSE
        DISPLAY self.user_info[cell_row,cell_column]
                AT column,row IN WINDOW window
                TO column+cell_width-1

    ENDIF

ENDROUTINE

{******************************************************************************}

ROUTINE prompt_sub_ops (  self              ,
                          VALUE cell_column ,
                          VALUE cell_row    ,
                                window      ,
                          VALUE column      ,
                          VALUE row         ,
                          VALUE cell_width  ,
                          VALUE cell_height )

{ 
* Prompt subgroup operations.
* 
* 
*
* Parameters   : self, cell_column, cell_row, window, column, row,
*                cell_width, cell_height
* Return Value : 
*
*******************************************************************************}

    IF ( cell_column = 1 ) THEN

        PROMPT FOR self.user_info[cell_row,cell_column]
                AT column,row IN WINDOW window
                TO column+cell_width-1
        WITH (  display_only = TRUE )

    ELSEIF ( cell_column = 2 ) THEN

        PROMPT FOR self.user_info[cell_row,cell_column]
                AT column,row IN WINDOW window
                TO column+cell_width-1

    ELSEIF ( cell_column = 3 ) OR ( cell_column = 4 ) THEN

        PROMPT FOR self.user_info [ cell_row, cell_column ]
            FORMAT boolean
            AT column,row IN WINDOW window
            TO column+cell_width-1
            WITH ( is_check  = TRUE )

    ENDIF

ENDROUTINE

{******************************************************************************}

ROUTINE add_form_buttons ( form )

{ 
* Adds form buttons
* 
* 
*
* Parameters   : form
* Return Value : 
*
*******************************************************************************}

DECLARE button_width,button_col,button_row,button_prompt

    button_width=8
    button_row=10
    button_col=1

    PROMPT OBJECT button_prompt
        CLASS "STD_PROMPT_BUTTON"
        ON LINE button_row
        FROM button_col TO button_col + button_width
        WITH ( caption="OK",
               send_lastkey = "DO" )

    form.add_prompt(button_prompt)

    button_col=(form.width-1-button_width)

    PROMPT OBJECT button_prompt
        CLASS "STD_PROMPT_BUTTON"
        ON LINE button_row
        FROM button_col TO button_col + button_width
        WITH (caption="Cancel",send_lastkey="EXIT")

    form.add_prompt(button_prompt)

ENDROUTINE

{******************************************************************************}

ROUTINE get_sub_ops ( sqc_chart )

{ 
* Gets subgroup operations.
* 
* 
*
* Parameters   : sqc_chart
* Return Value : sub_ops_array
*
*******************************************************************************}

DECLARE user_info, point_counter, sub_ops_array, comm_field
DECLARE table_field, table_ndx, exit_loop, chart_id

	ARRAY sub_ops_array

	point_counter = 1
	exit_loop = FALSE

	comm_field = "sqcwin_subgroup"
	table_field = "subgroup_number"
	user_info = sqc_chart . sqc_subgroup
	table_ndx = PAD ( sqc_chart . chart_id      , " ", "20" ) :
		PAD ( sqc_chart . selected_chart, " ", "10" ) :
		JUSTIFY ( PAD ( STRIP ( point_counter ), " ", "4" ), "RIGHT" )

	user_info . set_by_index ( "KEY0", table_ndx )

	WHILE ( NOT ( exit_loop ) ) DO

		sub_ops_array [ point_counter, 1 ] =
		      SELECT 'comm_field' . 'table_field' IN OBJECT
			  user_info . current

		sub_ops_array [ point_counter, 2 ] =
		      SELECT 'comm_field' . comments IN OBJECT
			  user_info . current

		sub_ops_array [ point_counter, 3 ] =
		      SELECT 'comm_field' . a_bad IN OBJECT
			  user_info . current

		sub_ops_array [ point_counter, 4 ] =
		      SELECT 'comm_field' . b_bad IN OBJECT
			  user_info . current

		sub_ops_array [ point_counter, 5 ] =
		      SELECT 'comm_field' . a_bad_manual IN OBJECT
			  user_info . current

		sub_ops_array [ point_counter, 6 ] =
		      SELECT 'comm_field' . b_bad_manual IN OBJECT
			  user_info . current

		point_counter = point_counter + 1

		table_ndx = PAD ( sqc_chart . chart_id      , " ", "20" ) :
			    PAD ( sqc_chart . selected_chart, " ", "10" ) :
			    JUSTIFY ( PAD ( STRIP ( point_counter ), " ", "4" ), "RIGHT" )

		user_info . set_by_index ( "KEY0", table_ndx )

		IF ( user_info . current = EMPTY ) THEN

		    exit_loop = TRUE

		ELSE

		    chart_id = SELECT 'comm_field' . chart_id IN OBJECT
				   user_info . current
		    IF ( chart_id <> sqc_chart . chart_id ) THEN

			exit_loop = TRUE

		    ENDIF

		ENDIF

	ENDWHILE

	RETURN ( sub_ops_array )

ENDROUTINE

{******************************************************************************}

ROUTINE write_sub_ops ( sqc_chart , sub_ops_array )

{ 
* Write subgroup operations.
* 
* 
*
* Parameters   : sqc_chart, sub_ops_array
* Return Value : 
*
*******************************************************************************}

DECLARE user_info, point_counter, comm_field
DECLARE table_ndx, exit_loop, chart_id

	point_counter = 1
	exit_loop = FALSE

	comm_field = "sqcwin_subgroup"
	user_info = sqc_chart . sqc_subgroup
	table_ndx = PAD ( sqc_chart . chart_id      , " ", "20" ) :
		PAD ( sqc_chart . selected_chart, " ", "10" ) :
		JUSTIFY ( PAD ( STRIP ( point_counter ), " ", "4" ), "RIGHT" )

	user_info . set_by_index ( "KEY0", table_ndx )

	WHILE ( NOT ( exit_loop ) ) DO

		ASSIGN 'comm_field' . comments IN OBJECT user_info . current =
		    sub_ops_array [ point_counter, 2 ]

		ASSIGN 'comm_field' . a_bad IN OBJECT user_info . current =
		    sub_ops_array [ point_counter, 3 ]

		ASSIGN 'comm_field' . b_bad IN OBJECT user_info . current =
		    sub_ops_array [ point_counter, 4 ]

		ASSIGN 'comm_field' . a_bad_manual IN OBJECT user_info . current =
		    sub_ops_array [ point_counter, 5 ]

		ASSIGN 'comm_field' . b_bad_manual IN OBJECT user_info . current =
		    sub_ops_array [ point_counter, 6 ]

		point_counter = point_counter + 1

		table_ndx = PAD ( sqc_chart . chart_id      , " ", "20" ) :
			    PAD ( sqc_chart . selected_chart, " ", "10" ) :
			    JUSTIFY ( PAD ( STRIP ( point_counter ), " ", "4" ), "RIGHT" )

		user_info . set_by_index ( "KEY0", table_ndx )

		IF ( user_info . current = EMPTY ) THEN

		    exit_loop = TRUE

		ELSE

		    chart_id = SELECT 'comm_field' . chart_id IN OBJECT
				   user_info . current

		    IF ( chart_id <> sqc_chart . chart_id ) THEN

			exit_loop = TRUE

		    ENDIF

		ENDIF

	ENDWHILE

ENDROUTINE

{******************************************************************************}

ROUTINE set_manual_bad (       self      ,
                         VALUE old_column,
                         VALUE old_row   )

{ 
* Manual set bad.
* 
* 
*
* Parameters   : self, old_column, old_row
* Return Value : 
*
*******************************************************************************}

    IF ( old_column = 3 ) OR ( old_column = 4 ) THEN

        IF self . user_info [ old_row, old_column ] THEN
            self . user_info [ old_row, old_column + 2 ] = TRUE
        ELSE
            self . user_info [ old_row, old_column + 2 ] = FALSE
        ENDIF

    ENDIF

ENDROUTINE

{******************************************************************************}

ROUTINE get_chart_name ( sqc_chart, VALUE chart_a )

{ 
* Gets appropraite text for given chart type.
* 
* 
*
* Parameters   : sqc_chart, chart_a
* Return Value : return_value
*
*******************************************************************************}

DECLARE return_value

	return_value = ""

	IF ( sqc_chart . selected_chart = MEAN_RANGE ) THEN

	    IF chart_a THEN

		return_value = GET_USER_MESSAGE ( "SQCWIN_GRAPH_MEAN_R_GR", 1 )

	    ELSE

		return_value = GET_USER_MESSAGE ( "SQCWIN_GRAPH_RANGE_GR", 1 )

	    ENDIF

	ELSEIF ( sqc_chart . selected_chart = MEAN_STD ) THEN

	    IF chart_a THEN

		return_value = GET_USER_MESSAGE ( "SQCWIN_GRAPH_MEAN_S_GR", 1 )

	    ELSE

		return_value = GET_USER_MESSAGE ( "SQCWIN_GRAPH_STD_GR", 1 )

	    ENDIF

	ELSEIF ( sqc_chart . selected_chart = IND_MR ) THEN

	    IF chart_a THEN

		return_value = GET_USER_MESSAGE ( "SQCWIN_GRAPH_IND_GR", 1 )

	    ELSE

		return_value = GET_USER_MESSAGE ( "SQCWIN_GRAPH_MR_GR", 1 )

	    ENDIF

	ENDIF

	return_value = STRIP ( return_value )

	RETURN ( return_value )

ENDROUTINE

{******************************************************************************}

ROUTINE save_comments ( sqc_chart, comm_type, comments_array )

{ 
* Save sqc point/subgroup comments
* 
* 
*
* Parameters   : sqc_chart, comm_type, comments_array
* Return Value : 
*
*******************************************************************************}

DECLARE comm_field, user_info, table_ndx, point_counter, exit_loop, chart_id

    point_counter = 1
    exit_loop = FALSE

    IF ( comm_type = "SUBGROUP") THEN

        comm_field = "sqcwin_subgroup"
        user_info = sqc_chart . sqc_subgroup
        table_ndx = PAD ( sqc_chart . chart_id      , " ", "20" ) :
                    PAD ( sqc_chart . selected_chart, " ", "10" ) :
          JUSTIFY ( PAD ( STRIP ( point_counter ), " ", "4" ), "RIGHT" )
    ELSE

        comm_field = "sqcwin_point"
        user_info = sqc_chart . sqc_point
        table_ndx = PAD ( sqc_chart . chart_id   , " ", "20" ) :
          JUSTIFY ( PAD ( STRIP ( point_counter ), " ",  "6" ), "RIGHT" )

    ENDIF

    user_info . set_by_index ( "KEY0", table_ndx )

    WHILE ( NOT ( exit_loop ) ) DO

        ASSIGN 'comm_field' . comments IN OBJECT
            user_info . current = comments_array [point_counter, 2]

        point_counter = point_counter + 1

        IF ( comm_type = "SUBGROUP") THEN
            table_ndx = PAD ( sqc_chart . chart_id      , " ", "20" ) :
                        PAD ( sqc_chart . selected_chart, " ", "10" ) :
              JUSTIFY ( PAD ( STRIP ( point_counter ), " ", "4" ), "RIGHT" )
        ELSE
            table_ndx = PAD ( sqc_chart . chart_id   , " ", "20" ) :
              JUSTIFY ( PAD ( STRIP ( point_counter ), " ",  "6" ), "RIGHT" )
        ENDIF

        user_info . set_by_index ( "KEY0", table_ndx )

        IF ( user_info . current = EMPTY ) THEN
            exit_loop = TRUE
        ELSE
            chart_id = SELECT 'comm_field' . chart_id IN OBJECT
                           user_info . current
            IF ( chart_id <> sqc_chart . chart_id ) THEN
                exit_loop = TRUE
            ENDIF
        ENDIF

    ENDWHILE

ENDROUTINE

{******************************************************************************}

ROUTINE get_comments (sqc_chart , comm_type, use_limits, lower_limit, upper_limit )

{ 
* Put comments into an array. If use_limits is TRUE then only get comments in
* the range lower_limit - upper_limit
* 
*
* Parameters   : sqc_chart, comm_type, use_limits, lower_limit, upper_limit
* Return Value : comments_array
*
*******************************************************************************}

DECLARE user_info, point_counter, comments_array, comm_field, table_field, 
        table_ndx, exit_loop, chart_id, select_point_txt, check_bad, is_bad

	ARRAY comments_array

	point_counter = 1

	IF use_limits THEN

		select_point_txt = NUMBER_TO_TEXT( lower_limit, "999999" )

	ELSE

		select_point_txt = NUMBER_TO_TEXT( point_counter, "999999" )

	ENDIF

	IF (comm_type = "SUBGROUP") THEN

		check_bad = FALSE
		comm_field = "sqcwin_subgroup"
		table_field = "subgroup_number"
		user_info = sqc_chart . sqc_subgroup
		table_ndx = PAD ( sqc_chart . chart_id      , " ", "20" ) :
			    PAD ( sqc_chart . selected_chart, " ", "10" ) :
		  JUSTIFY ( PAD ( STRIP ( select_point_txt ), " ", "4" ), "RIGHT" )

	ELSE

		check_bad = TRUE
		comm_field = "sqcwin_point"
		table_field = "point_number"
		user_info = sqc_chart . sqc_point
		table_ndx = PAD ( sqc_chart . chart_id   , " ", "20" ) :
		  JUSTIFY ( PAD ( STRIP ( select_point_txt ), " ",  "6" ), "RIGHT" )

	ENDIF

	user_info . set_by_index ( "KEY0", table_ndx )

	IF user_info . current = EMPTY THEN

		exit_loop = TRUE

	ELSE

		exit_loop = FALSE

	ENDIF

	WHILE ( NOT ( exit_loop ) ) DO

		IF check_bad THEN

			
			is_bad = SELECT 'comm_field' . bad IN OBJECT
			         user_info . current

			IF NOT is_bad THEN

				comments_array [point_counter, 1] =
				      SELECT 'comm_field' . 'table_field' IN OBJECT
					  user_info . current

				comments_array [point_counter, 2] =
				      SELECT 'comm_field' . comments IN OBJECT
					  user_info . current

				point_counter = point_counter + 1

			ENDIF

		ELSE

			comments_array [point_counter, 1] =
			      SELECT 'comm_field' . 'table_field' IN OBJECT
				  user_info . current

			comments_array [point_counter, 2] =
			      SELECT 'comm_field' . comments IN OBJECT
				  user_info . current

			point_counter = point_counter + 1

		ENDIF

		select_point_txt = 
		NUMBER_TO_TEXT( ( NUMERIC( select_point_txt ) + 1 ), "999999" )

		IF ( comm_type = "SUBGROUP" ) THEN

			table_ndx = PAD ( sqc_chart . chart_id      , " ", "20" ) :
				    PAD ( sqc_chart . selected_chart, " ", "10" ) :
			JUSTIFY ( PAD ( STRIP ( select_point_txt ), " ", "4" ), "RIGHT" )

		ELSE

			table_ndx = PAD ( sqc_chart . chart_id   , " ", "20" ) :
			JUSTIFY ( PAD ( STRIP ( select_point_txt ), " ",  "6" ), "RIGHT" )

		ENDIF

		user_info . set_by_index ( "KEY0", table_ndx )

		IF ( user_info . current = EMPTY ) THEN

			exit_loop = TRUE

		ELSEIF use_limits THEN

			IF ( point_counter + lower_limit -1 ) > upper_limit THEN

				exit_loop = TRUE

			ENDIF

		ELSE

			chart_id = SELECT 'comm_field' . chart_id IN OBJECT
				   user_info . current
			IF ( chart_id <> sqc_chart . chart_id ) THEN

				exit_loop = TRUE

			ENDIF

		ENDIF

	ENDWHILE

	RETURN ( comments_array )

ENDROUTINE

{******************************************************************************}

GLOBAL ROUTINE draw_graph ( sqc_chart, graph_type, VALUE hardcopy, form)

{ 
* Draw the graph.
* 
* 
*
* Parameters   : sqc_chart, graph_type, hardcopy, form
* Return Value : 
*
*******************************************************************************}

    form . reset_lower_recalc_graph()
    form . reset_lower_recalc_point()
    
    IF ( graph_type = CUSUM_GR ) THEN

        draw_cusum_graph ( sqc_chart, hardcopy , form)

    ELSEIF (graph_type = PROC_CAP_GR ) THEN

        IF ( hardcopy ) THEN

            print_process_capability ( sqc_chart )

        ELSE

            draw_process_capability ( sqc_chart , form)

        ENDIF

    ELSE

        IF ( hardcopy ) THEN

            print_shewhart_graph ( sqc_chart )

        ELSE

            draw_shewhart_graph ( sqc_chart, graph_type , form)

        ENDIF

    ENDIF

ENDROUTINE

{******************************************************************************}

GLOBAL ROUTINE create_print_form ( form , sqc_chart_obj )

{ 
* Allows the user to specify a printer and select how the layout of the chart
* is printed.
* 
*
* Parameters   : form, sqc_chart object
* Return Value : n/a
*
*******************************************************************************}

DECLARE prompt_text_start, prompt_text_width, 
        prompt_object, print_button, print_preview_button, cancel_button


    
    SET PRINTERCODES TRUE
    
    set_op_logical ()
   
    CREATE OBJECT PROMPT_CLASS_FORM, form

    prompt_text_start  = 2
    prompt_text_width  = 20
    
    form . prompt_id          = "$SQCWIN_DRAW"
    form . height             =  7
    form . width              = prompt_text_width + 40
    form . row                = 10
    form . column             = ( GLOBAL ( "SCREEN_WIDTH" ) - form . width ) / 2
    form . border             = TRUE
    form . header             = GET_USER_MESSAGE ( "SQCWIN_DRAW_PRINT_HEADER", 1 )
    form . footer             = ""
    form . confirm_required   = FALSE
    form . return_behaviour   = FORM_RETURN_WRAP
    form . help_context       = "$REPORTER_FORM_PROMPT"
    form . proportional       = TRUE
    form . user_info          = sqc_chart_obj
    form . button_style       = FORM_BUTTON_NONE

    
    PROMPT OBJECT prompt_object
        BROWSE ON printer
        ON LINE 1 FROM ( prompt_text_width + 2 )
                               
    form . add_prompt ( prompt_object )
    
    form . add_display ( GET_USER_MESSAGE("SQCWIN_PLOT_PROM_6" ,1)
                    , prompt_text_start , 1, PROMPT_RENDITION_NORMAL ) 

   
    form . add_frame ( GET_USER_MESSAGE ( "SQCWIN_DRAW_LAYOUT", 1 )        ,
               prompt_text_start -1   ,
               2                     ,
               0  ,
           form . width      -1  )
   
    form . add_frame ( GET_USER_MESSAGE ( "SQCWIN_DRAW_PRINTER", 1 )        ,
           prompt_text_start -1  ,
           0                     ,
           0  ,
           form . width      -1  )
           
    { Add layout toolbar }
    add_print_form_buttons( form )
    
    PROMPT OBJECT print_button    
           CLASS "STD_PROMPT_BUTTON"
           ON LINE 6
           FROM 5 TO 15
           WITH ( caption = GET_USER_MESSAGE ( "SQCWIN_DRAW_PRINT_BUTTON", 1 ) ,
                  mouse_click_routine = "print_button_routine", 
                  width = 10 )
                  
    form . add_prompt ( print_button )
                  
    PROMPT OBJECT print_preview_button    
           CLASS "STD_PROMPT_BUTTON"
           ON LINE 6
           FROM 25 TO 35
           WITH ( caption = GET_USER_MESSAGE ( "SQCWIN_DRAW_PREVIEW_BUTTON", 1 ) ,
                  mouse_click_routine = "print_preview_button_routine" , 
                  width = 10 )

    form . add_prompt ( print_preview_button )

    PROMPT OBJECT cancel_button    
           CLASS "STD_PROMPT_BUTTON"
           ON LINE 6
           FROM 45 TO 55
           WITH ( caption = GET_USER_MESSAGE ( "LAB_EXTRA_ACTIONS", 2 ) ,
                  mouse_click_routine = "cancel_button_routine" , 
                  width = 10 )
                  
    form . add_prompt ( cancel_button )
    

ENDROUTINE

{******************************************************************************}

ROUTINE print_button_routine ( self )

{
* Summary    : Main toggle routine for build prompt radio buttons.
*
* Parameters : self - form object
*
* Return     : None
*
*******************************************************************************}

DECLARE printer

  printer = STRIP ( self .parent_prompt . prompt_objects [ PROMPT_PRINTER ] . text )
  
  IF NOT BLANK (printer) THEN
  	SET NAME "PRINTER/" : printer

  	self . parent_prompt . set_lastkey ( "DO" )
  	self . parent_prompt . stop_prompt()
  ELSE
  
  	flash_message( GET_USER_MESSAGE ( "SQCWIN_DRAW_NO_PRINTER", 1 ), TRUE )
  ENDIF

ENDROUTINE

{******************************************************************************}

ROUTINE print_preview_button_routine ( self )

{
* Summary    : Main toggle routine for build prompt radio buttons.
*
* Parameters : self - form object
*
* Return     : None
*
*******************************************************************************}

  SET NAME "DISPLAY/"
    
  self . parent_prompt . set_lastkey ( "SELECT" )
  self . parent_prompt . stop_prompt()

ENDROUTINE


{******************************************************************************}

ROUTINE cancel_button_routine ( self )

{
* Summary    : Main toggle routine for build prompt radio buttons.
*
* Parameters : self - form object
*
* Return     : None
*
*******************************************************************************}

  SET NAME "DEFER/"
  
  
  self . parent_prompt . set_lastkey ( "EXIT" )
  self . parent_prompt . stop_prompt()

ENDROUTINE

{******************************************************************************}
ROUTINE add_print_form_buttons( form )

{ 
* Add the toolbar to print form, so print layout can be selected.
* 
* 
*
* Parameters   : form
* Return Value : n/a
*
*******************************************************************************}

DECLARE toolbar, chart_button, insert_button, above_button, below_button, 
        sep_button, rep_button

  prompt_toolbar_initialise()

  CREATE OBJECT TOOLBAR_CLASS , toolbar

  toolbar . row = 3

  CREATE OBJECT TOOLBAR_BUTTON_LARGE_CLASS , chart_button
  chart_button . is_check = TRUE
  chart_button . tooltip = GET_USER_MESSAGE ( "SQCWIN_DRAW_CHART_BUTTON" , 1 )
  chart_button . caption = GET_USER_MESSAGE ( "SQCWIN_DRAW_CHART_BUTTON" , 1 )
  chart_button . set_icon( "INT_CHART_ONLY" )
  chart_button . mouse_click_routine="toggle_routine"
  chart_button . width = 10
  chart_button . height = 2.5

  toolbar . add_item( chart_button )

  CREATE OBJECT TOOLBAR_BUTTON_LARGE_CLASS , insert_button
  insert_button . is_check = TRUE
  insert_button . tooltip = GET_USER_MESSAGE ( "SQCWIN_DRAW_INSERT_BUTTON" , 1 )
  insert_button . caption = GET_USER_MESSAGE ( "SQCWIN_DRAW_INSERT_BUTTON" , 1 )
  insert_button . set_icon( "INT_CHART_INSERT" )
  insert_button . mouse_click_routine="toggle_routine"
  insert_button . width = 10
  insert_button . height = 2.5
 
  toolbar . add_item( insert_button )

  CREATE OBJECT TOOLBAR_BUTTON_LARGE_CLASS , above_button
  above_button . is_check = TRUE
  above_button . tooltip = GET_USER_MESSAGE ( "SQCWIN_DRAW_ABOVE_BUTTON" , 1 )
  above_button . caption = GET_USER_MESSAGE ( "SQCWIN_DRAW_ABOVE_BUTTON" , 1 )
  above_button . set_icon( "INT_CHART_BEFORE" )
  above_button . mouse_click_routine="toggle_routine"
  above_button . width = 10
  above_button . height = 2.5

  toolbar . add_item( above_button )

  CREATE OBJECT TOOLBAR_BUTTON_LARGE_CLASS , below_button
  below_button . is_check = TRUE
  below_button . tooltip = GET_USER_MESSAGE ( "SQCWIN_DRAW_BELOW_BUTTON" , 1 )
  below_button . caption = GET_USER_MESSAGE ( "SQCWIN_DRAW_BELOW_BUTTON" , 1 )
  below_button . set_icon( "INT_CHART_AFTER" )
  below_button . mouse_click_routine="toggle_routine"
  below_button . width = 10
  below_button . height = 2.5

  toolbar . add_item( below_button )

  CREATE OBJECT TOOLBAR_BUTTON_LARGE_CLASS , sep_button
  sep_button . is_check = TRUE
  sep_button . tooltip = GET_USER_MESSAGE ( "SQCWIN_DRAW_SEP_BUTTON" , 1 )
  sep_button . caption = GET_USER_MESSAGE ( "SQCWIN_DRAW_SEP_BUTTON" , 1 )
  sep_button . set_icon( "INT_CHART_SEPARATE" )
  sep_button . mouse_click_routine="toggle_routine"
  sep_button . width = 10
  sep_button . height = 2.5

  toolbar . add_item( sep_button )
   
  CREATE OBJECT TOOLBAR_BUTTON_LARGE_CLASS , rep_button
  rep_button . is_check = TRUE
  rep_button . tooltip = GET_USER_MESSAGE ( "SQCWIN_DRAW_REPORT_BUTTON" , 1 )
  rep_button . caption = GET_USER_MESSAGE ( "SQCWIN_DRAW_REPORT_BUTTON" , 1 )
  rep_button . set_icon( "INT_CHART_REPORT" )
  rep_button . mouse_click_routine="toggle_routine"
  rep_button . width = 10
  rep_button . height = 2.5
  
  toolbar . add_item( rep_button )
   
  form . add_prompt( toolbar )
	
	
ENDROUTINE

{******************************************************************************}

ROUTINE toggle_routine ( self )

{
* Summary    : Main toggle routine for the layout toolbar.
*
* Parameters : self - form object
*
* Return     : None
*
*******************************************************************************}

    DECLARE form, sqc_chart

    form = self . parent_prompt
    sqc_chart = form . user_info

    IF self . tag = TOOLBAR_BUTTON_CHART THEN

      form . prompt_objects [ TOOLBAR_BUTTON_CHART  ] . set_check ( TRUE )
      form . prompt_objects [ TOOLBAR_BUTTON_INSERT ] . set_check ( FALSE )
      form . prompt_objects [ TOOLBAR_BUTTON_ABOVE  ] . set_check ( FALSE )
      form . prompt_objects [ TOOLBAR_BUTTON_BELOW  ] . set_check ( FALSE )
      form . prompt_objects [ TOOLBAR_BUTTON_SEP    ] . set_check ( FALSE )
      form . prompt_objects [ TOOLBAR_BUTTON_REPORT ] . set_check ( FALSE )
      
      sqc_chart . sqc_print_type = PRINT_TYPE_CHART

    ELSEIF  self . tag = TOOLBAR_BUTTON_INSERT THEN
      
      form . prompt_objects [ TOOLBAR_BUTTON_CHART  ] . set_check ( FALSE )
      form . prompt_objects [ TOOLBAR_BUTTON_INSERT ] . set_check ( TRUE )
      form . prompt_objects [ TOOLBAR_BUTTON_ABOVE  ] . set_check ( FALSE )
      form . prompt_objects [ TOOLBAR_BUTTON_BELOW  ] . set_check ( FALSE )
      form . prompt_objects [ TOOLBAR_BUTTON_SEP    ] . set_check ( FALSE )
      form . prompt_objects [ TOOLBAR_BUTTON_REPORT ] . set_check ( FALSE )      
      
      sqc_chart . sqc_print_type = PRINT_TYPE_INSERT
    
    ELSEIF  self . tag = TOOLBAR_BUTTON_ABOVE THEN
      
      form . prompt_objects [ TOOLBAR_BUTTON_CHART  ] . set_check ( FALSE )
      form . prompt_objects [ TOOLBAR_BUTTON_INSERT ] . set_check ( FALSE )
      form . prompt_objects [ TOOLBAR_BUTTON_ABOVE  ] . set_check ( TRUE )
      form . prompt_objects [ TOOLBAR_BUTTON_BELOW  ] . set_check ( FALSE )
      form . prompt_objects [ TOOLBAR_BUTTON_SEP    ] . set_check ( FALSE )
      form . prompt_objects [ TOOLBAR_BUTTON_REPORT ] . set_check ( FALSE )
          
      sqc_chart . sqc_print_type = PRINT_TYPE_ABOVE
    
    ELSEIF  self . tag = TOOLBAR_BUTTON_BELOW THEN
          
      form . prompt_objects [ TOOLBAR_BUTTON_CHART  ] . set_check ( FALSE )
      form . prompt_objects [ TOOLBAR_BUTTON_INSERT ] . set_check ( FALSE )
      form . prompt_objects [ TOOLBAR_BUTTON_ABOVE  ] . set_check ( FALSE )
      form . prompt_objects [ TOOLBAR_BUTTON_BELOW  ] . set_check ( TRUE )
      form . prompt_objects [ TOOLBAR_BUTTON_SEP    ] . set_check ( FALSE )
      form . prompt_objects [ TOOLBAR_BUTTON_REPORT ] . set_check ( FALSE )
          
          sqc_chart . sqc_print_type = PRINT_TYPE_BELOW
    
    ELSEIF  self . tag = TOOLBAR_BUTTON_SEP THEN
              
      form . prompt_objects [ TOOLBAR_BUTTON_CHART  ] . set_check ( FALSE )
      form . prompt_objects [ TOOLBAR_BUTTON_INSERT ] . set_check ( FALSE )
      form . prompt_objects [ TOOLBAR_BUTTON_ABOVE  ] . set_check ( FALSE )
      form . prompt_objects [ TOOLBAR_BUTTON_BELOW  ] . set_check ( FALSE )
      form . prompt_objects [ TOOLBAR_BUTTON_SEP    ] . set_check ( TRUE )
      form . prompt_objects [ TOOLBAR_BUTTON_REPORT ] . set_check ( FALSE )
              
     sqc_chart . sqc_print_type = PRINT_TYPE_SEP


    ELSEIF  self . tag = TOOLBAR_BUTTON_REPORT THEN
              
      form . prompt_objects [ TOOLBAR_BUTTON_CHART  ] . set_check ( FALSE )
      form . prompt_objects [ TOOLBAR_BUTTON_INSERT ] . set_check ( FALSE )
      form . prompt_objects [ TOOLBAR_BUTTON_ABOVE  ] . set_check ( FALSE )
      form . prompt_objects [ TOOLBAR_BUTTON_BELOW  ] . set_check ( FALSE )
      form . prompt_objects [ TOOLBAR_BUTTON_SEP    ] . set_check ( FALSE )
      form . prompt_objects [ TOOLBAR_BUTTON_REPORT ] . set_check ( TRUE )
              
      sqc_chart . sqc_print_type = PRINT_TYPE_NONE
     
    ENDIF
    
    


ENDROUTINE

{******************************************************************************}

ROUTINE set_op_logical

{ 
* Set name of output plotting file.
* 
* 
*
* Parameters   : n/a
* Return Value : n/a
*
*******************************************************************************}

DECLARE pid, hpgl_file

    IF GLOBAL ( "PLATFORM" ) <> "NT" THEN

        pid = GLOBAL ( "PROCESS_ID" )
        hpgl_file =  "SMP$GRAPHSTYLES:SQC_PLOT_": pid : ".TMP;0"
        SET LOGICAL "$HPGLFILE" TO hpgl_file

    ENDIF

ENDROUTINE

{******************************************************************************}

ROUTINE configure_output ( print_form, graph_1 )

{ 
* Configure output
* 
* 
*
* Parameters   : print_form, graph_1
* Return Value : n/a
*
*******************************************************************************}

DECLARE op_printer, op_language, sixel_device_type

	op_printer  = print_form . prompt_objects [1] . value
	op_language = print_form . prompt_objects [2] . value

	IF GLOBAL ( "PLATFORM" ) = "NT" THEN

		SET GRAPH graph_1 , GRAPH   . output_printer = " "
		SET GRAPH graph_1 , LIBRARY . output_device  = "HPGL"

	ELSE

		SET GRAPH graph_1 , GRAPH   . output_printer = op_printer

		IF op_language = "REGIS" THEN
			SET GRAPH graph_1 , LIBRARY . output_device  = "REGIS"
		ELSE
			SET GRAPH graph_1 , LIBRARY . output_device  = "HPGL"
		ENDIF

	        configured_for_sixel =  ( LEFTSTRING ( op_language, 5 ) = "SIXEL" )

	        IF ( configured_for_sixel ) THEN

			sixel_device_type = SELECT PRINTER . device_type
			              WHERE identity = op_printer

			IF ( STRIP(sixel_device_type = "QUEUE") ) THEN
				sixel_queue_name =  STRIP( SELECT PRINTER . logical_name)
			ELSE
				sixel_queue_name =  " "
			ENDIF

			SET GRAPH graph_1 , GRAPH   . output_printer = " "

		ENDIF

	ENDIF

ENDROUTINE

{******************************************************************************}

ROUTINE post_plot_complete ( print_form )

{ 
* After plotting is completed, create temporary files and add them to the sqc
* file array.
* 
*
* Parameters   : print_form
* Return Value : n/a
*
*******************************************************************************}
  DECLARE output_file, copied_file, status, file_count, chart_identity


  IF GLOBAL ( "PLATFORM" ) = "NT" THEN

      output_file = LOGICAL ( "SMP$GRAPHSTYLES" ) : "\" : 
                    "GRAPHICS" : GLOBAL ( "PROCESS_ID" ) : ".TMP"

      { Add form feed to the end of the file }
      FILE EXTEND output_file, status

      IF status = EMPTY THEN
          FILE WRITE output_file, ASCII(12) : ASCII(27) : "E", status
      ELSE 
          flash_message ( status , TRUE )
      ENDIF

      FILE CLOSE output_file, status

      { Copy new file to graph array within sqc chart object, if file
        already exists, there must be multiple charts, so create a new
        file. }
      
      chart_identity = STRIP ( print_form . user_info . chart_id )
      file_count = 1
      copied_file = "SMP$GRAPHSTYLES:": 
                    chart_identity : GLOBAL ( "PROCESS_ID" ) : "_" : 
                    STRIP( STRING(file_count) ) : ".TMP"

      WHILE ( FILE EXISTS ( copied_file ) ) DO

          file_count = file_count + 1
          copied_file = "SMP$GRAPHSTYLES:" : 
                        chart_identity : GLOBAL ( "PROCESS_ID" ) : "_" : 
                        STRIP( STRING(file_count) ) : ".TMP"

      ENDWHILE

      FILE COPY output_file, copied_file, status

      print_form . user_info . graph_file_array[ file_count ] = copied_file


  ELSE

      IF ( configured_for_sixel ) THEN
          SPAWN "@SMP$GRAPHSTYLES:PRINT_SIXEL.COM ":sixel_queue_name QUIETLY
      ENDIF

  ENDIF

ENDROUTINE

{******************************************************************************}

GLOBAL ROUTINE setup_hardcopy_params ( graph_1 )

{ 
* Set hardcopy parameters.
* 
* 
*
* Parameters   : graph_1
* Return Value : n/a
*
*******************************************************************************}

   SET GRAPH graph_1, X_ANNOTATION.TEXT_STYLE = 1   { Smal Roman Text }
   SET GRAPH graph_1, Y_ANNOTATION.TEXT_STYLE = 1

ENDROUTINE

{******************************************************************************}

GLOBAL ROUTINE print_graph_header ( sqc_chart, graph_1 )

{ 
* Set up and print graph_header.
* 
* 
*
* Parameters   : sqc_chart, graph_1
* Return Value : n/a
*
*******************************************************************************}

DECLARE chart_name, chart_date

    sqc_chart . sqc_header . set_first()

    chart_name = PAD( GET_USER_MESSAGE("SQCWIN_PC_PLOT_2" ,1), " ", 15): ": " :
                 STRIP ( SELECT sqcwin_header . identifier
                         IN OBJECT sqc_chart . sqc_header . current ) : " - " :
                 STRIP ( SELECT sqcwin_header . description
                         IN OBJECT sqc_chart . sqc_header . current )

    chart_date = PAD(GET_USER_MESSAGE("SQCWIN_PC_PLOT_1" ,1), " ", 15): ": " :
                 STRIP ( LEFTSTRING ( NOW, 17 ))

    PLOT TEXT graph_1 AT 0, 96 DEVICE_AREA USING USER_TITLE
    PLOT TEXT graph_1 AT 0, 92 DEVICE_AREA USING chart_name
    PLOT TEXT graph_1 AT 0, 90 DEVICE_AREA USING chart_date

ENDROUTINE

{******************************************************************************}

GLOBAL ROUTINE get_next_screen (sqc_chart)

{ 
* Sets the value of sqc_chart . next_screen depending on which 
* charts where chosen.
* 
*
* Parameters   : sqc_chart
* Return Value : n/a
*
*******************************************************************************}

DECLARE active_array, curr_pos, counter, current_active, current_type
DECLARE lastbut

    ARRAY active_array
    curr_pos = 0
    counter = 1

    WHILE ( counter <= sqc_chart . sqc_chart_type . size() ) DO

	sqc_chart . sqc_chart_type . set_by_index_number( "ORDER_NUM", counter )

        current_active = SELECT sqcwin_chart_type . chart_active IN OBJECT
                sqc_chart . sqc_chart_type . current
        current_type = SELECT sqcwin_chart_type . chart_type_id IN OBJECT
                sqc_chart . sqc_chart_type . current

        IF (current_active) THEN

            active_array[sqcwin_array_size(active_array)+1]=current_type

            IF (sqc_chart . next_screen = current_type) THEN

                curr_pos = sqcwin_array_size(active_array)

            ENDIF

        ENDIF

        counter = counter + 1

    ENDWHILE

    lastbut = GLOBAL("lastkey")

    IF ((curr_pos = 0) AND (lastbut = "LEFT")) THEN

        sqc_chart . next_screen = "EDIT"

    ELSEIF ((curr_pos = 1) AND (lastbut="LEFT")) THEN

        sqc_chart . next_screen = "TYPE"

    ELSEIF ((curr_pos = sqcwin_array_size (active_array)) AND (lastbut = "RIGHT")) THEN

        sqc_chart . next_screen = "DRAW"

    ELSEIF (lastbut = "RIGHT") THEN

        sqc_chart . next_screen = active_array[curr_pos + 1]

    ELSEIF (lastbut = "LEFT") THEN

        sqc_chart . next_screen = active_array[curr_pos - 1]

    ELSEIF (lastbut = "EXIT") THEN

        sqc_chart . next_screen = "EXIT"

    ENDIF

ENDROUTINE

{******************************************************************************}

GLOBAL ROUTINE get_active_array (sqc_chart)

{ 
* Returns an array of the active chart types.
* 
* 
*
* Parameters   : sqc_chart
* Return Value : active_array
*
*******************************************************************************}

DECLARE active_array, current_active, {current_type_text,} current_type
DECLARE counter, new_row_number, inner_counter, graph_obj_array

    ARRAY active_array
    ARRAY graph_obj_array

    define_graph_objects_array ( graph_obj_array )

    counter = 1
    new_row_number = 1

    WHILE ( counter <= sqc_chart . sqc_chart_type . size() ) DO

        sqc_chart . sqc_chart_type . set_by_number ( counter )

        current_active = SELECT sqcwin_chart_type . chart_active IN OBJECT
                sqc_chart . sqc_chart_type . current

        current_type = STRIP ( SELECT sqcwin_chart_type . chart_type_id IN OBJECT
                sqc_chart . sqc_chart_type . current )

        IF ( current_active ) THEN

            inner_counter = 1

            WHILE ( graph_obj_array [ inner_counter, 1 ] <> EMPTY ) DO

                IF ( graph_obj_array [ inner_counter, 1 ] = current_type ) THEN

                    active_array[new_row_number,1]=
                        graph_obj_array [ inner_counter, 2 ]
                    active_array[new_row_number,2]=current_type
                    new_row_number = new_row_number + 1

                ENDIF

                inner_counter = inner_counter + 1

            ENDWHILE

        ENDIF

        counter = counter + 1

    ENDWHILE

    return (active_array)

ENDROUTINE

{******************************************************************************}

GLOBAL ROUTINE array_difference ( old_array , new_array )

{ 
* Returns an array of the active chart types in new_array that are not
* in old_array.
* 
*
* Parameters   : old_array, new_array
* Return Value : return_array
*
*******************************************************************************}

DECLARE counter, return_array, counter2, is_there, current_row
DECLARE current_type

    ARRAY return_array

    counter=1

    WHILE (counter <= sqcwin_array_size (new_array)) DO

        current_type = new_array[counter,2]
        counter2=1
        is_there = FALSE

        WHILE (counter2 <= sqcwin_array_size (old_array)) DO

            IF ( old_array [ counter2 , 2] = current_type) THEN

                is_there = TRUE

            ENDIF

            counter2 = counter2 + 1

        ENDWHILE

        IF NOT(is_there)

            current_row = sqcwin_array_size (return_array) +1
            return_array [ current_row , 1] = new_array [counter ,1]
            return_array [ current_row , 2] = new_array [counter ,2]

        ENDIF

        counter = counter + 1

    ENDWHILE

    return (return_array)

ENDROUTINE

{******************************************************************************}

ROUTINE get_chart_type_code ( the_prompt )

{ 
* Get chart type code.
* 
* 
*
* Parameters   : the_prompt
* Return Value : return_value
*
*******************************************************************************}

DECLARE row_index, the_array, return_value

	row_index = 1

	return_value = ""

	the_array = the_prompt . parent_prompt . user_info . active_array

	WHILE ( row_index <= sqcwin_array_size ( the_array ) ) DO

	    IF ( the_array [ row_index , 1 ] = the_prompt . value ) THEN

		return_value = the_array [ row_index, 2 ]
		row_index = sqcwin_array_size ( the_array )

	    ENDIF

	    row_index = row_index + 1

	ENDWHILE

	RETURN ( return_value )

ENDROUTINE

{******************************************************************************}

ROUTINE draw_shewhart_graph (       sqc_chart  ,
                              VALUE graph_obj  ,
                                    graph_form )

{ 
* Draw Shewhart graph.
* 
* 
*
* Parameters   : sqc_chart, graph_obj, graph_form
* Return Value : n/a
*
*******************************************************************************}

DECLARE ind_graph_obj, new_test_window, x_c, y_c, test_1, test_2,
        graph_obj_array, counter, chart_type, chart_desc
            
	ARRAY graph_obj_array

	define_graph_objects_array ( graph_obj_array )

	counter = 1

	WHILE ( graph_obj_array [ counter, 1 ] <> EMPTY ) DO

		IF ( graph_obj_array [ counter, 2 ] = graph_obj ) THEN

		    chart_type = graph_obj_array [ counter, 1 ]

		ENDIF
		counter = counter + 1

	ENDWHILE

	sqc_chart . sqc_header . set_first ( )
	chart_desc = SELECT sqcwin_header . description
		 IN OBJECT sqc_chart . sqc_header . current

	graph_form . change_header( 
	STRIP ( sqc_chart . chart_id ) : " - " : STRIP ( chart_desc ) )

	new_test_window = graph_form . graph_object . start_graph()                	      


	IF ( graph_obj = MEAN_RANGE_GR ) THEN

		x_c = 2
		y_c = 2

		ind_graph_obj = MEAN_R_GR

		graph ( sqc_chart      ,
			test1          ,
			new_test_window,
			x_c            ,
			y_c            ,
			x_c + 79       ,
			y_c + 10       ,
			ind_graph_obj  ,
			chart_type     )

		x_c = 2
		y_c = 13

		ind_graph_obj = RANGE_GR

		graph ( sqc_chart      ,
			test2          ,
			new_test_window,
			x_c            , 
			y_c            ,
			x_c + 79       ,  
			y_c + 10       ,
			ind_graph_obj  ,
			chart_type     )

	ELSEIF ( graph_obj = MEAN_STD_GR ) THEN

		x_c = 2
		y_c = 2

		ind_graph_obj = MEAN_S_GR

		graph ( sqc_chart,
			test1,
			new_test_window,
			x_c,
			y_c,
			x_c + 79,
			y_c + 10,
			ind_graph_obj,
			chart_type )


		x_c = 2
		y_c = 13

		ind_graph_obj = STD_GR

		graph ( sqc_chart,
			test2,
			new_test_window,
			x_c,
			y_c,
			x_c + 79,
			y_c + 10,
			ind_graph_obj,
			chart_type )


	ELSEIF ( graph_obj = IND_MR_GR ) THEN

		x_c = 2
		y_c = 2

		ind_graph_obj = IND_GR

		graph ( sqc_chart,
			test1,
			new_test_window,
			x_c,
			y_c,
			x_c + 79,
			y_c + 10,
			ind_graph_obj,
			chart_type )


		x_c = 2
		y_c = 13

		ind_graph_obj = MR_GR

		graph ( sqc_chart,
			test2,
			new_test_window,
			x_c,
			y_c,
			x_c + 79,
			y_c + 10,
			ind_graph_obj,
			chart_type )

	ELSE

		x_c = 2
		y_c = 2

		graph ( sqc_chart,
			test2,
			new_test_window,
			x_c,
			y_c,
			x_c + 79,
			y_c + 23,
			graph_obj,
			chart_type )

	ENDIF

	sqc_chart . chart_window = new_test_window

ENDROUTINE

{******************************************************************************}

ROUTINE graph (       sqc_chart,
                      my_newtest,
                      new_test_window,
                VALUE x_c_1,
                VALUE y_c_1,
                VALUE x_c_2,
                VALUE y_c_2,
                      graph_obj,
                      chart_type)

{ 
* Draws the sqc_chart graph for a given graph object.
* 
* 
*
* Parameters   : sqc_chart, my_newtest, new_test_window, x_c_1, y_c_1,
*                x_c_2, y_c_2, graph_obj, chart_type
* Return Value : n/a
*
*******************************************************************************}

DECLARE graph_obj_ndx, end_col, exit_loop,chart_type_ndx, start_col, count, 
        graph_object, win_obj, y_start, dec_places


	graph_obj_ndx = 1

	exit_loop = FALSE

	WHILE ( NOT ( exit_loop ) )

		IF ( sqc_chart . graph_object_array [ graph_obj_ndx ] = EMPTY ) THEN

		    exit_loop = TRUE

		ELSEIF ( sqc_chart . graph_object_array [ graph_obj_ndx ] .

				   graph_type = graph_obj ) THEN
		    exit_loop = TRUE

		ELSE

		    graph_obj_ndx   = graph_obj_ndx + 1

		ENDIF

	ENDWHILE

	start_col = sqc_chart . graph_object_array [ graph_obj_ndx ] .
		     win_obj_array [ 1 ] . first_point

	end_col   = start_col +
		sqc_chart . graph_object_array [ graph_obj_ndx ] . no_x

	SET GRAPH my_new_test, X_AXIS . START_POSITION = start_col - 1
	SET GRAPH my_new_test, X_AXIS . END_POSITION   = end_col

	SET GRAPH my_new_test, X_AXIS . COLOUR         = AXIS_IN_VIEW

	SET GRAPH my_new_test, X_GRADUATION . START_POSITION = 1
	SET GRAPH my_new_test, X_ANNOTATION . COLOUR         = AXIS_IN_VIEW

	IF ( end_col < 10 ) THEN
	SET GRAPH my_new_test, X_ANNOTATION . FORMAT = "9"
	ELSEIF ( end_col < 100 ) THEN
	SET GRAPH my_new_test, X_ANNOTATION . FORMAT = "99"
	ELSEIF ( end_col < 1000 ) THEN
	SET GRAPH my_new_test, X_ANNOTATION . FORMAT = "999"
	ELSE
	SET GRAPH my_new_test, X_ANNOTATION . FORMAT = "9999"
	ENDIF

	y_start = sqc_chart . graph_object_array [ graph_obj_ndx ] . y_min

	SET GRAPH my_new_test, Y_AXIS . START_POSITION = y_start

	SET GRAPH my_new_test, Y_AXIS . END_POSITION =
	    sqc_chart . graph_object_array [ graph_obj_ndx ] . y_max

	SET GRAPH my_new_test, Y_AXIS . COLOUR = AXIS_IN_VIEW

	{set_y_format ( sqc_chart, my_new_test )

	SET GRAPH my_new_test, Y_GRADUATION . START_POSITION = 1}

	SET GRAPH my_new_test, Y_ANNOTATION . COLOUR         = AXIS_IN_VIEW

	graph_object =
	sqc_chart.graph_object_array [ graph_obj_ndx ]

	chart_type_ndx = PAD ( sqc_chart . chart_id, " ", "20" ) :
		    PAD ( chart_type          , " ", "10" )

	sqc_chart . sqc_chart_type . set_by_index ( "KEY0", chart_type_ndx )

	graph_object . disp_sp = SELECT sqcwin_chart_type . display_spec
			     IN OBJECT sqc_chart . sqc_chart_type . current

	graph_object . disp_cl = SELECT sqcwin_chart_type . display_control
			     IN OBJECT sqc_chart . sqc_chart_type . current

	graph_object . disp_wl = SELECT sqcwin_chart_type . display_warning
			     IN OBJECT sqc_chart . sqc_chart_type . current

	graph_object . disp_sd = SELECT sqcwin_chart_type . display_one_sigma
			     IN OBJECT sqc_chart . sqc_chart_type . current

	graph_object . disp_mean = TRUE

	DRAW GRAPH my_new_test
	IN WINDOW new_test_window
	FROM LINE y_c_1 + 1 TO LINE y_c_2 - 1
	FROM COLUMN x_c_1 + 1 TO COLUMN x_c_2 - 1

	count = 1

	WHILE ( count <= sqcwin_array_size ( graph_object . win_obj_array ) ) DO

		win_obj = graph_object . win_obj_array [ count ]
		plot_points ( graph_object, win_obj, my_new_test )
		count = count + 1

	ENDWHILE


	sqc_chart . sqc_header . set_by_number ( 1 )

	dec_places = SELECT sqcwin_header . decimal_places IN OBJECT
		sqc_chart . sqc_header . current

	reset_format ( dec_places )

	PLOT TEXT my_new_test
	AT    end_col,
	      sqc_chart.graph_object_array[graph_obj_ndx].mean
	AXIS_UNITS
	USING " CL = " : STRIP ( sqc_chart.graph_object_array[graph_obj_ndx].mean )

	IF ( graph_object . disp_sp ) THEN

		PLOT TEXT my_new_test
		    AT    end_col,
			  sqc_chart.graph_object_array[graph_obj_ndx].us
		    AXIS_UNITS
		    USING GET_USER_MESSAGE ( "DRAW_SHEWHART_GRAPH_US", 1 ) :
			  STRIP ( sqc_chart.graph_object_array[graph_obj_ndx].us )

		PLOT TEXT my_new_test
		    AT    end_col,
			  sqc_chart.graph_object_array[graph_obj_ndx].ls
		    AXIS_UNITS
		    USING GET_USER_MESSAGE ( "DRAW_SHEWHART_GRAPH_LS", 1 ) :
			  STRIP ( sqc_chart.graph_object_array[graph_obj_ndx].ls )

	ENDIF

	IF ( graph_object . disp_cl ) THEN

		PLOT TEXT my_new_test
		    AT    end_col,
			  sqc_chart.graph_object_array[graph_obj_ndx].ucl
		    AXIS_UNITS
		    USING GET_USER_MESSAGE ( "DRAW_SHEWHART_GRAPH_UCL", 1 ) :
			  STRIP ( sqc_chart.graph_object_array[graph_obj_ndx].ucl )

		IF ( is_second_graph ( graph_object . graph_type,
				       graph_object . lcl       ) ) THEN

		    PLOT TEXT my_new_test
			AT    end_col,
			      sqc_chart.graph_object_array[graph_obj_ndx].lcl
			AXIS_UNITS
			USING GET_USER_MESSAGE ( "DRAW_SHEWHART_GRAPH_LCL", 1 ) :
			      STRIP ( sqc_chart.graph_object_array[graph_obj_ndx].lcl )

		ENDIF

	ENDIF

	IF ( graph_object . disp_wl ) THEN

		PLOT TEXT my_new_test
		    AT    end_col,
			  sqc_chart.graph_object_array[graph_obj_ndx].uwl
		    AXIS_UNITS
		    USING GET_USER_MESSAGE ( "DRAW_SHEWHART_GRAPH_UWL", 1 ) :
			  STRIP ( sqc_chart.graph_object_array[graph_obj_ndx].uwl )

		IF ( is_second_graph ( graph_object . graph_type,
				       graph_object . lwl       ) ) THEN

		    PLOT TEXT my_new_test
			AT    end_col,
			      sqc_chart.graph_object_array[graph_obj_ndx].lwl
			AXIS_UNITS
			USING GET_USER_MESSAGE ( "DRAW_SHEWHART_GRAPH_LWL", 1 ) :
			      STRIP ( sqc_chart.graph_object_array[graph_obj_ndx].lwl )

		ENDIF

	ENDIF

	IF ( graph_object . disp_sd ) THEN

		PLOT TEXT my_new_test
		    AT    end_col,
			  sqc_chart.graph_object_array[graph_obj_ndx].usd
		    AXIS_UNITS
		    USING GET_USER_MESSAGE ( "DRAW_SHEWHART_GRAPH_USD", 1 ) :
			  STRIP ( sqc_chart.graph_object_array[graph_obj_ndx].usd )

		IF ( is_second_graph ( graph_object . graph_type,
				       graph_object . lsd       ) ) THEN

		    PLOT TEXT my_new_test
			AT    end_col,
			      sqc_chart.graph_object_array[graph_obj_ndx].lsd
			AXIS_UNITS
			USING GET_USER_MESSAGE ( "DRAW_SHEWHART_GRAPH_LSD", 1 ) :
			      STRIP ( sqc_chart.graph_object_array[graph_obj_ndx].lsd )

		ENDIF

	ENDIF

	SET GRAPH my_new_test, X_ANNOTATION . TEXT_STYLE = 1

	PLOT TEXT my_new_test
	AT 5, 105
	PERCENT
	USING sqc_chart.graph_object_array[graph_obj_ndx].y_legend

	PLOT TEXT my_new_test
	AT 50, -3
	PERCENT
	USING sqc_chart.graph_object_array[graph_obj_ndx].x_legend

ENDROUTINE

{******************************************************************************}

ROUTINE print_shewhart_graph ( sqc_chart )

{ 
* Controls the printing of shewhart graphs.
* 
* 
*
* Parameters   : sqc_chart
* Return Value : n/a
*
*******************************************************************************}

DECLARE index_a, index_b, shewhart_graph_hard1, print_form,
        shewhart_graph_hard2,
        chart_name, chart_date, chart_title

  create_print_form ( print_form , sqc_chart )
  print_form . start_prompt ()
  toggle_routine ( print_form . prompt_objects [ TOOLBAR_BUTTON_CHART ] )
       
  index_a = sqc_chart . graph_obj_a_ndx
  index_b = sqc_chart . graph_obj_b_ndx
  
  { first graph }

  setup_hardcopy_params ( shewhart_graph_hard1 )
  configure_output ( print_form, shewhart_graph_hard1 )

  sqc_chart . sqc_header . set_first()

  chart_name = PAD( GET_USER_MESSAGE("SQCWIN_PC_PLOT_2" ,1), " ", 15): ": ":
               STRIP ( SELECT sqcwin_header . identifier
  
  IN OBJECT sqc_chart . sqc_header . current ) : " - " :
            STRIP ( SELECT sqcwin_header . description
  
  IN OBJECT sqc_chart . sqc_header . current )

  chart_date = PAD(GET_USER_MESSAGE("SQCWIN_PC_PLOT_1" ,1), " ", 15) : ": " :
               STRIP ( LEFTSTRING ( NOW, 17 ))

  define_print_graph ( sqc_chart, index_a, shewhart_graph_hard1 )

  PLOT GRAPH shewhart_graph_hard1
  FROM LINE   5 TO LINE   21
  FROM COLUMN 5 TO COLUMN 75

  print_points_and_lines ( sqc_chart, index_a, shewhart_graph_hard1 )

  { title graph }

  PLOT TEXT shewhart_graph_hard1 AT 0, 96 DEVICE_AREA USING USER_TITLE
  PLOT TEXT shewhart_graph_hard1 AT 0, 92 DEVICE_AREA USING chart_name
  PLOT TEXT shewhart_graph_hard1 AT 0, 90 DEVICE_AREA USING chart_date

  chart_title = PAD ( "Chart ", " ", "15" ) : ": " :
                STRIP ( sqc_chart . graph_object_array [ index_a ] . graph_type )

  PLOT TEXT shewhart_graph_hard1 AT 0,  88 DEVICE_AREA USING chart_title

  { second graph }

  PLOT COMPLETE shewhart_graph_hard1

  post_plot_complete ( print_form )

  setup_hardcopy_params ( shewhart_graph_hard2 )
  configure_output ( print_form, shewhart_graph_hard2 )

  define_print_graph ( sqc_chart, index_b, shewhart_graph_hard2 )

  PLOT GRAPH shewhart_graph_hard2
       FROM LINE    3 TO LINE   23
       FROM COLUMN  5 TO COLUMN 75

  print_points_and_lines ( sqc_chart, index_b, shewhart_graph_hard2 )

  PLOT TEXT shewhart_graph_hard2 AT 0, 96 DEVICE_AREA USING USER_TITLE
  PLOT TEXT shewhart_graph_hard2 AT 0, 92 DEVICE_AREA USING chart_name
  PLOT TEXT shewhart_graph_hard2 AT 0, 90 DEVICE_AREA USING chart_date

  chart_title = PAD ( "Chart ", " ", "15" ) : ": " :
                STRIP ( sqc_chart . graph_object_array [ index_b ] . graph_type )

  PLOT TEXT shewhart_graph_hard2 AT 0,  88 DEVICE_AREA USING chart_title

  PLOT COMPLETE shewhart_graph_hard2

  post_plot_complete ( print_form )

  REPEAT

      print_form . wait_prompt ()

      IF ( print_form . get_lastkey() = "DO" ) OR 
         ( print_form . get_lastkey() = "SELECT" ) THEN

          create_chart_report ( sqc_chart )

          

      ENDIF

  UNTIL ( print_form . get_lastkey () = "EXIT" ) OR
        ( print_form . get_lastkey () = "DO" )
        
  delete_graph_files ( sqc_chart )

ENDROUTINE

{******************************************************************************}

ROUTINE delete_graph_files ( sqc_chart )
                                   

{ 
* Delete graph files from sqc chart file array.
* 
* 
*
* Parameters   : sqc_chart
* Return Value : n/a
*
*******************************************************************************}                         

	DECLARE graph_count, status

	graph_count = 0

	WHILE graph_count < size_of_array ( sqc_chart . graph_file_array ) DO
	 
		graph_count = graph_count + 1

		IF ( sqc_chart . graph_file_array [ graph_count ] <> EMPTY ) THEN

			FILE DELETE sqc_chart . graph_file_array [ graph_count ] , 
					status
		
			IF status <> EMPTY THEN
		
				flash_message ( status , TRUE )
		
			ENDIF

		ENDIF
	 
	ENDWHILE


ENDROUTINE
{******************************************************************************}

ROUTINE define_print_graph (       sqc_chart,
                             VALUE graph_ndx,
                                   print_obj)

{ 
* Define print graph.
* 
* 
*
* Parameters   : sqc_chart, graph_ndx, print_obj.
* Return Value : n/a
*
*******************************************************************************}

DECLARE start_col, end_col, shewhart_object , y_start

                                        { ================================= }
                                        { get the start and end positions   }
                                        { ================================= }

	shewhart_object = sqc_chart . graph_object_array [ graph_ndx ]

	start_col = shewhart_object . win_obj_array [ 1 ] . first_point

	end_col   = start_col + shewhart_object . no_x


					{ ================================= }
					{ set the x parameters              }
					{ ================================= }

	SET GRAPH print_obj, X_AXIS . START_POSITION       = start_col - 1
	SET GRAPH print_obj, X_AXIS . END_POSITION         = end_col + TRUNC ( end_col * 0.2 )

	SET GRAPH print_obj, X_AXIS . COLOUR               = AXIS_IN_VIEW

	SET GRAPH print_obj, X_GRADUATION . START_POSITION = 1
	SET GRAPH print_obj, X_ANNOTATION . COLOUR         = AXIS_IN_VIEW

	IF ( end_col < 10 ) THEN

		SET GRAPH print_obj, X_ANNOTATION . FORMAT = "9"
		ELSEIF ( end_col < 100 ) THEN
		SET GRAPH print_obj, X_ANNOTATION . FORMAT = "99"
		ELSEIF ( end_col < 1000 ) THEN
		SET GRAPH print_obj, X_ANNOTATION . FORMAT = "999"
		ELSE
		SET GRAPH print_obj, X_ANNOTATION . FORMAT = "9999"

	ENDIF

	y_start = shewhart_object . y_min

	SET GRAPH print_obj, Y_AXIS . START_POSITION = y_start - TRUNC ( y_start * 0.2 )
	SET GRAPH print_obj, Y_AXIS . END_POSITION = shewhart_object . y_max + TRUNC ( shewhart_object . y_max * 0.2 )
	SET GRAPH print_obj, Y_AXIS . COLOUR = AXIS_IN_VIEW

	set_y_format ( sqc_chart, print_obj )

	SET GRAPH print_obj, Y_GRADUATION . START_POSITION = 1

	SET GRAPH print_obj, Y_ANNOTATION . COLOUR         = AXIS_IN_VIEW

ENDROUTINE

{******************************************************************************}

ROUTINE print_points_and_lines ( sqc_chart, graph_ndx, print_obj )

{ 
* Print points and lines for each window object.
* 
* 
*
* Parameters   : sqc_chart, graph_ndx, print_obj
* Return Value : n/a
*
*******************************************************************************}

DECLARE graph_obj, end_col, count, win_obj
DECLARE dec_places

    dec_places = 0 

    graph_obj = sqc_chart.graph_object_array [ graph_ndx ]

    end_col = graph_obj . win_obj_array [ 1 ] . first_point + graph_obj . no_x

    count = 1

    WHILE ( count <= sqcwin_array_size ( graph_obj . win_obj_array ) ) DO

        win_obj = graph_obj . win_obj_array [ count ]

        print_points ( graph_obj, win_obj, print_obj )

        count = count + 1

    ENDWHILE

    sqc_chart . sqc_header . set_by_number ( 1 )

    dec_places = SELECT sqcwin_header . decimal_places IN OBJECT
                sqc_chart . sqc_header . current

    reset_format ( dec_places )

    define_display_status ( sqc_chart, graph_obj )

    PLOT TEXT print_obj
        AT    end_col, graph_obj . mean
        AXIS_UNITS
        USING " CL = " : STRIP ( graph_obj.mean )

    IF ( graph_obj . disp_sp ) THEN

        PLOT TEXT print_obj
            AT    end_col,
                  graph_obj.us
            AXIS_UNITS
            USING GET_USER_MESSAGE  ( "DRAW_SHEWHART_GRAPH_US", 1 ) : 
                                      STRIP ( graph_obj.us )

        PLOT TEXT print_obj
            AT    end_col,
                  graph_obj.ls
            AXIS_UNITS
            USING GET_USER_MESSAGE  ( "DRAW_SHEWHART_GRAPH_LS", 1 ) : 
                  STRIP ( graph_obj.ls )

    ENDIF

    IF ( graph_obj . disp_cl ) THEN

        PLOT TEXT print_obj
            AT    end_col,
                  graph_obj.ucl
            AXIS_UNITS
            USING "UCL = " : STRIP ( graph_obj.ucl )

        IF ( is_second_graph ( graph_obj . graph_type,
                               graph_obj . lcl       ) ) THEN

            PLOT TEXT print_obj
                AT    end_col,
                      graph_obj.lcl
                AXIS_UNITS
                USING "LCL = " : STRIP ( graph_obj.lcl )

        ENDIF

    ENDIF

    IF ( graph_obj . disp_wl ) THEN

        PLOT TEXT print_obj
            AT    end_col,
                  graph_obj.uwl
            AXIS_UNITS
            USING "UWL = " : STRIP ( graph_obj.uwl )

        IF ( is_second_graph ( graph_obj . graph_type,
                               graph_obj . lwl       ) ) THEN

            PLOT TEXT print_obj
                AT    end_col,
                      graph_obj.lwl
                AXIS_UNITS
                USING "LWL = " : STRIP ( graph_obj.lwl )

        ENDIF

    ENDIF

    IF ( graph_obj . disp_sd ) THEN

        PLOT TEXT print_obj
            AT    end_col,
                  graph_obj.usd
            AXIS_UNITS
            USING "USD = " : STRIP ( graph_obj.usd )

        IF ( is_second_graph ( graph_obj . graph_type,
                               graph_obj . lsd       ) ) THEN

            PLOT TEXT print_obj
                AT    end_col,
                      graph_obj.lsd
                AXIS_UNITS
                USING "LSD = " : STRIP ( graph_obj.lsd )

        ENDIF

    ENDIF

ENDROUTINE

{******************************************************************************}

ROUTINE print_points ( graph_object, graph_win_obj, my_new_test )

{ 
* Plots the points and lines of win objects.
* 
* 
*
* Parameters   : graph_object, graph_win_obj, my_new_test
* Return Value : 
*
*******************************************************************************}

DECLARE line_start, first_good, first_bad, last_point

    first_bad = 0
    first_good = 0

    IF ( graph_win_obj . display_window = TRUE ) THEN

                                        { ================================= }
                                        { reset for the present window      }
                                        { ================================= }

        IF ( sqcwin_array_size ( graph_win_obj . x_points ) > 0 ) THEN

            SET GRAPH my_new_test, CURVE . LINE_STYLE = 0
            SET GRAPH my_new_test, CURVE . COLOUR     = 0

            SET GRAPH my_new_test, GRAPH  . STYLE     = POINT_GRAPH_STYLE
            SET GRAPH my_new_test, POINTS . COLOUR    = POINTS_IN_VIEW
            SET GRAPH my_new_test, POINTS . CHARACTER = POINT_CHARACTER

            SET GRAPH my_newtest, X_AXIS . INPUT =
                graph_win_obj . x_points

            SET GRAPH my_newtest, Y_AXIS . INPUT =
                graph_win_obj . y_points

            PLOT POINT my_new_test
                USING graph_win_obj . x_points,
                      graph_win_obj . y_points

        ENDIF

        IF ( sqcwin_array_size ( graph_win_obj . x_trend ) > 0 ) THEN

            SET GRAPH my_new_test, GRAPH  . STYLE     = TREND_GRAPH_STYLE
            SET GRAPH my_new_test, POINTS . COLOUR    = TREND_IN_VIEW
            SET GRAPH my_new_test, POINTS . CHARACTER = TREND_POINT_CHARACTER

            SET GRAPH my_new_test, X_AXIS . INPUT =
                graph_win_obj . x_trend

            SET GRAPH my_new_test, Y_AXIS . INPUT =
                graph_win_obj . y_trend

            PLOT POINT my_new_test
                USING graph_win_obj . x_trend,
                      graph_win_obj . y_trend

        ENDIF

        IF ( sqcwin_array_size ( graph_win_obj . x_trend ) > 0 ) THEN

            SET GRAPH my_new_test, GRAPH  . STYLE  = BAD_GRAPH_STYLE
            SET GRAPH my_new_test, POINTS . COLOUR = BAD_IN_VIEW
            SET GRAPH my_new_test, POINTS . CHARACTER = BAD_POINT_CHARACTER

            SET GRAPH my_new_test, X_AXIS . INPUT =
                graph_win_obj . x_bad

            SET GRAPH my_new_test, Y_AXIS . INPUT =
                graph_win_obj . y_bad


            PLOT POINT my_new_test
                USING graph_win_obj . x_bad,
                      graph_win_obj . y_bad

        ENDIF

        IF ( sqcwin_array_size ( graph_win_obj . x_bad ) > 0 ) THEN

            first_bad  = graph_win_obj . x_bad [1]

        ENDIF

        IF first_bad = EMPTY THEN 
        
        	first_bad = 999999 
        	
        ENDIF

        IF ( sqcwin_array_size ( graph_win_obj . x_points ) > 0 ) THEN
        
        	first_good = graph_win_obj . x_points [1]
        
        ENDIF

        IF first_good = EMPTY THEN 
        
        	first_good = 999999 
        	
        ENDIF

        IF ( first_good < first_bad ) THEN

            line_start = first_good - 0.5

        ELSE

            line_start = first_bad  - 0.5

        ENDIF

        IF graph_win_obj . window_number = 1 THEN

            line_start = 0.5

        ENDIF

        last_point = graph_win_obj . last_point + 0.5

        SET GRAPH my_new_test, CURVE . LINE_STYLE = CENTRE_LINE_IN_VIEW
        SET GRAPH my_new_test, CURVE . COLOUR     = CENTRE_LIMITS_IN_VIEW

        PLOT LINE my_new_test
            FROM  line_start,
                  graph_win_obj . mean
            TO    last_point,
                  graph_win_obj . mean

        SET GRAPH my_new_test, CURVE . LINE_STYLE = SPEC_LINE_IN_VIEW
        SET GRAPH my_new_test, CURVE . COLOUR     = SPEC_LIMITS_IN_VIEW

        IF ( graph_object . disp_sp ) THEN

            PLOT LINE my_new_test
                FROM  line_start,
                      graph_win_obj . us
                TO    last_point,
                      graph_win_obj . us

            IF ( is_second_graph ( graph_object . graph_type,
                                   graph_object . ls       ) ) THEN

                PLOT LINE my_new_test
                    FROM  line_start,
                          graph_win_obj . ls
                    TO    last_point,
                          graph_win_obj . ls

            ENDIF

        ENDIF

        SET GRAPH my_new_test, CURVE . LINE_STYLE = CONTROL_LINE_IN_VIEW
        SET GRAPH my_new_test, CURVE . COLOUR     = CONTROL_LIMITS_IN_VIEW

        IF ( graph_object . disp_cl ) THEN

            PLOT LINE my_new_test
                FROM  line_start,
                      graph_win_obj . ucl
                TO    last_point,
                      graph_win_obj . ucl

            IF ( is_second_graph ( graph_object . graph_type,
                                   graph_object . lcl       ) ) THEN

                PLOT LINE my_new_test
                    FROM  line_start,
                          graph_win_obj . lcl
                    TO    last_point,
                          graph_win_obj . lcl

            ENDIF

        ENDIF

        IF ( graph_object . disp_wl ) THEN

            PLOT LINE my_new_test
                FROM  line_start,
                      graph_win_obj . uwl
                TO    last_point,
                      graph_win_obj . uwl

            IF ( is_second_graph ( graph_object . graph_type,
                                   graph_object . lwl       ) ) THEN

                PLOT LINE my_new_test
                    FROM  line_start,
                          graph_win_obj . lwl
                    TO    last_point,
                          graph_win_obj . lwl

            ENDIF

        ENDIF

        IF ( graph_object . disp_sd ) THEN

            PLOT LINE my_new_test
                FROM  line_start,
                      graph_win_obj . usd
                TO    last_point,
                      graph_win_obj . usd

            IF ( is_second_graph ( graph_object . graph_type,
                                   graph_object . lsd       ) ) THEN

                PLOT LINE my_new_test
                    FROM  line_start,
                          graph_win_obj . lsd
                    TO    last_point,
                          graph_win_obj . lsd

            ENDIF

        ENDIF

    ENDIF

ENDROUTINE


{******************************************************************************}

ROUTINE define_display_status ( sqc_chart, graph_object )

{ 
* Define display status.
* 
* 
*
* Parameters   : sqc_chart, graph_object
* Return Value : n/a
*
*******************************************************************************}

DECLARE chart_type_ndx

    chart_type_ndx = PAD ( sqc_chart    . chart_id  , " ", "20" ) :
                     PAD ( graph_object . chart_type, " ", "10" )

    sqc_chart . sqc_chart_type . set_by_index ( "KEY0", chart_type_ndx )

    graph_object . disp_sp = SELECT sqcwin_chart_type . display_spec
                             IN OBJECT sqc_chart . sqc_chart_type . current

    graph_object . disp_cl = SELECT sqcwin_chart_type . display_control
                             IN OBJECT sqc_chart . sqc_chart_type . current

    graph_object . disp_wl = SELECT sqcwin_chart_type . display_warning
                             IN OBJECT sqc_chart . sqc_chart_type . current

    graph_object . disp_sd = SELECT sqcwin_chart_type . display_one_sigma
                             IN OBJECT sqc_chart . sqc_chart_type . current

    graph_object . disp_mean = TRUE

ENDROUTINE

{******************************************************************************}

ROUTINE plot_points ( graph_object, graph_win_obj, my_new_test )

{ 
* Plots the points and lines of win objects.
* 
* 
*
* Parameters   : graph_object, graph_win_obj, my_new_test
* Return Value : n/a
*
*******************************************************************************}

DECLARE line_start, first_good, first_bad, last_point

    IF ( graph_win_obj . display_window = TRUE ) THEN

                                        { ================================= }
                                        { reset for the present window      }
                                        { ================================= }

        SET GRAPH my_new_test, CURVE . LINE_STYLE = 0
        SET GRAPH my_new_test, CURVE . COLOUR     = 0

        SET GRAPH my_new_test, GRAPH  . STYLE     = POINT_GRAPH_STYLE
        SET GRAPH my_new_test, POINTS . COLOUR    = POINTS_IN_VIEW
        SET GRAPH my_new_test, POINTS . CHARACTER = POINT_CHARACTER

        SET GRAPH my_newtest, X_AXIS . INPUT =
            graph_win_obj . x_points

        SET GRAPH my_newtest, Y_AXIS . INPUT =
            graph_win_obj . y_points

        PLOT POINT my_new_test
            USING graph_win_obj . x_points,
                  graph_win_obj . y_points

        SET GRAPH my_new_test, GRAPH  . STYLE     = TREND_GRAPH_STYLE
        SET GRAPH my_new_test, POINTS . COLOUR    = TREND_IN_VIEW
        SET GRAPH my_new_test, POINTS . CHARACTER = TREND_POINT_CHARACTER

        SET GRAPH my_new_test, X_AXIS . INPUT =
            graph_win_obj . x_trend

        SET GRAPH my_new_test, Y_AXIS . INPUT =
            graph_win_obj . y_trend

        PLOT POINT my_new_test
            USING graph_win_obj . x_trend,
                  graph_win_obj . y_trend

        SET GRAPH my_new_test, GRAPH  . STYLE  = BAD_GRAPH_STYLE
        SET GRAPH my_new_test, POINTS . COLOUR = BAD_IN_VIEW
        SET GRAPH my_new_test, POINTS . CHARACTER = BAD_POINT_CHARACTER

        SET GRAPH my_new_test, X_AXIS . INPUT =
            graph_win_obj . x_bad

        SET GRAPH my_new_test, Y_AXIS . INPUT =
            graph_win_obj . y_bad


        PLOT POINT my_new_test
            USING graph_win_obj . x_bad,
                  graph_win_obj . y_bad

        first_bad  = 9999999
        first_good = 9999999

        IF ( graph_win_obj . x_bad [ 1 ] <> EMPTY ) THEN

            first_bad  = graph_win_obj . x_bad [1]

        ENDIF

        IF ( graph_win_obj . x_points [ 1 ] <> EMPTY ) THEN

            first_good = graph_win_obj . x_points [1]

        ENDIF

        IF ( first_good < first_bad ) THEN

            line_start = first_good - 0.5

        ELSE

            line_start = first_bad  - 0.5

        ENDIF

        IF graph_win_obj . window_number = 1 THEN

            line_start = 0.5

        ENDIF

        last_point = graph_win_obj . last_point + 0.5

        SET GRAPH my_new_test, CURVE . LINE_STYLE = CENTRE_LINE_IN_VIEW
        SET GRAPH my_new_test, CURVE . COLOUR     = CENTRE_LIMITS_IN_VIEW

        PLOT LINE my_new_test
            FROM  line_start,
                  graph_win_obj . mean
            TO    last_point,
                  graph_win_obj . mean

        SET GRAPH my_new_test, CURVE . LINE_STYLE = SPEC_LINE_IN_VIEW
        SET GRAPH my_new_test, CURVE . COLOUR     = SPEC_LIMITS_IN_VIEW

        IF ( graph_object . disp_sp ) THEN

            PLOT LINE my_new_test
                FROM  line_start,
                      graph_win_obj . us
                TO    last_point,
                      graph_win_obj . us

            PLOT LINE my_new_test
                FROM  line_start,
                      graph_win_obj . ls
                TO    last_point,
                      graph_win_obj . ls

        ENDIF

        SET GRAPH my_new_test, CURVE . LINE_STYLE = CONTROL_LINE_IN_VIEW
        SET GRAPH my_new_test, CURVE . COLOUR     = CONTROL_LIMITS_IN_VIEW

        IF ( graph_object . disp_cl ) THEN

            PLOT LINE my_new_test
                FROM  line_start,
                      graph_win_obj . ucl
                TO    last_point,
                      graph_win_obj . ucl

            IF ( is_second_graph ( graph_object . graph_type,
                                   graph_object . lcl       ) ) THEN

                PLOT LINE my_new_test
                    FROM  line_start,
                          graph_win_obj . lcl
                    TO    last_point,
                          graph_win_obj . lcl

            ENDIF

        ENDIF

        IF ( graph_object . disp_wl ) THEN

            PLOT LINE my_new_test
                FROM  line_start,
                      graph_win_obj . uwl
                TO    last_point,
                      graph_win_obj . uwl

            IF ( is_second_graph ( graph_object . graph_type,
                                   graph_object . lwl       ) ) THEN

                PLOT LINE my_new_test
                    FROM  line_start,
                          graph_win_obj . lwl
                    TO    last_point,
                          graph_win_obj . lwl

            ENDIF

        ENDIF

        IF ( graph_object . disp_sd ) THEN

            PLOT LINE my_new_test
                FROM  line_start,
                      graph_win_obj . usd
                TO    last_point,
                      graph_win_obj . usd

            IF ( is_second_graph ( graph_object . graph_type,
                                   graph_object . lsd       ) ) THEN

                PLOT LINE my_new_test
                    FROM  line_start,
                          graph_win_obj . lsd
                    TO    last_point,
                          graph_win_obj . lsd

            ENDIF

        ENDIF

    ENDIF

ENDROUTINE

{******************************************************************************}

ROUTINE selection_criteria ( self )

{ 
* Selection criteria routine.
* 										      F
* 
*
* Parameters   : self.
* Return Value : n/a
*
*******************************************************************************}

DECLARE sqc_chart

	sqc_chart = self . parent_prompt . user_info

	sqc_chart . next_screen = "CRIT"

	sqc_chart . first_time = FALSE

	sqc_chart . ok_button_only = TRUE

	CALL_ROUTINE "chart_screens"
	    IN LIBRARY "$sqcwin_main"
	    USING sqc_chart

	IF LASTKEY <> "EXIT" THEN
	
		run_sqc_calculations( sqc_chart )

		draw_graph (sqc_chart, sqc_chart . selected_graph, FALSE, self .parent_prompt)

		sqc_chart . ok_button_only = FALSE

	ENDIF

ENDROUTINE

{******************************************************************************}

ROUTINE set_y_format ( sqc_chart, new_graph )

{ 
* Set Y format.
* 
* 
*
* Parameters   : sqc_chart, new_graph.
* Return Value : n/a
*
*******************************************************************************}

DECLARE format_string , decimal_string, counter

    format_string  = "999999999"
    decimal_string = ""

    IF ( sqc_chart . decimal_places <> 0 ) THEN

        counter = 0
        WHILE ( counter < sqc_chart . decimal_places )

            decimal_string = decimal_string : "9"
            counter = counter + 1

        ENDWHILE

        format_string = format_string : "." : decimal_string

    ENDIF

    SET GRAPH new_graph, Y_ANNOTATION . FORMAT = format_string

ENDROUTINE

{******************************************************************************}

ROUTINE draw_process_capability ( sqc_chart, graph_form )

{ 
* Draw Process Capability chart.
* 
* 
*
* Parameters   : sqc_chart, graph_form
* Return Value : n/a
*
*******************************************************************************}

DECLARE first_subgrp, last_subgrp, pts_skew, pts_kur, cap_rat, cap_ndx,
        cpk_ndx, pts_sigma, pts_mean, spec_min, spec_max, start_pos,
        end_pos, graph_obj_ndx, test_win, test, y_start, y_max, x_text,
        x_pos, pos_shift, y_col, exit_loop, y_legend, y_col_plus,
        chart_desc

    graph_obj_ndx = 1

    exit_loop = FALSE

    WHILE ( NOT ( exit_loop ) )

        IF ( sqc_chart . graph_object_array [ graph_obj_ndx ] = EMPTY ) THEN
            flash_message ( "Process Capability has invalid specifications.":
                            " It is unavaliable for drawing.", TRUE )
            RETURN ( FALSE )
        ELSEIF ( sqc_chart . graph_object_array [ graph_obj_ndx ] .
                           graph_type = PROC_CAP_GR ) THEN
            exit_loop = TRUE
        ELSE
            graph_obj_ndx   = graph_obj_ndx + 1
        ENDIF

    ENDWHILE

	IF sqc_chart . graph_object_array [ graph_obj_ndx ] . x_points [ 1 ] =
				    EMPTY THEN

		flash_message ( "No points in chart : This chart can not be drawn.",
			TRUE )

	ELSE

		first_subgrp = sqc_chart.graph_object_array[graph_obj_ndx].first_subgroup
		last_subgrp  = sqc_chart.graph_object_array[graph_obj_ndx].last_subgroup

		pts_skew = sqc_chart . graph_object_array [ graph_obj_ndx ] . skewness
		pts_kur  = sqc_chart . graph_object_array [ graph_obj_ndx ] . kurtosis
		cap_rat  = sqc_chart . graph_object_array [ graph_obj_ndx ] . cap_ratio
		cap_ndx  = sqc_chart . graph_object_array [ graph_obj_ndx ] . cap_index
		cpk_ndx  = sqc_chart . graph_object_array [ graph_obj_ndx ] . cpk_index

		pts_sigma = sqc_chart . graph_object_array [ graph_obj_ndx ] . sigma
		pts_mean  = sqc_chart . graph_object_array [ graph_obj_ndx ] . mean

		spec_min = sqc_chart . graph_object_array [ graph_obj_ndx ] . spec_min
		spec_max = sqc_chart . graph_object_array [ graph_obj_ndx ] . spec_max

		start_pos = sqc_chart . graph_object_array [ graph_obj_ndx ] . start_pos
		end_pos   = sqc_chart . graph_object_array [ graph_obj_ndx ] . end_pos

		y_max = sqc_chart . graph_object_array [ graph_obj_ndx ] . max_y

		y_legend = sqc_chart . graph_object_array [ graph_obj_ndx ] . y_legend

		sqc_chart . sqc_header . set_first ( )

		chart_desc = SELECT sqcwin_header . description
			 IN OBJECT sqc_chart . sqc_header . current

		graph_form . header = 
		STRIP ( sqc_chart . chart_id ) : " - " : STRIP ( chart_desc )

		test_win = graph_form . graph_object . start_graph()

								      { histo and norm. dist. }

		SET  GRAPH test , points       . character      = PC_CHARACTER
		SET  GRAPH test , x_graduation . start_position = end_pos + 1
		SET  GRAPH test , x_graduation . large          = 0
		SET  GRAPH test , y_graduation . start_position = -1
		SET  GRAPH test , y_graduation . large          = 0
		SET  GRAPH test , x_axis       . start_position = start_pos
		SET  GRAPH test , x_axis       . end_position   = end_pos
		SET  GRAPH test , x_annotation . format         = "9999"

		SET  GRAPH test , y_axis       . COLOUR         = PC_Y_AXIS_COLOUR
		SET  GRAPH test , curve        . COLOUR         = PC_CURVE_COLOUR
		SET  GRAPH test , x_annotation . COLOUR         = PC_INFO_COLOUR

							      { norm. dist. only      }
		SET  GRAPH test , graph        . style = 1

		SET  GRAPH test , x_axis       . input =
		     sqc_chart . graph_object_array [ graph_obj_ndx ] . x_points

		SET  GRAPH test , y_axis       . input =
		     sqc_chart . graph_object_array [ graph_obj_ndx ] . y_points

		DRAW GRAPH test IN WINDOW test_win
			    FROM LINE 5 TO LINE 25
			    FROM COLUMN 5 TO COLUMN 65
							      { histo graph only      }
		SET  GRAPH test , graph        . style = 2

		SET  GRAPH test , x_axis       . input =
		     sqc_chart . graph_object_array [ graph_obj_ndx ] . x_trend
		SET  GRAPH test , y_axis       . input =
		     sqc_chart . graph_object_array [ graph_obj_ndx ] . y_trend

		DRAW GRAPH test IN WINDOW test_win
			  FROM LINE 5 TO LINE 25
			  FROM COLUMN 5 TO COLUMN 65

		Y_START = 0.001
							  { line & text at LS         }

		PLOT LINE test FROM spec_min    , y_start TO spec_min    , ( y_max * 0.98 )
		PLOT TEXT test AT spec_min , ( y_max * 0.99 ) USING "LS"

							  { line & text at US         }

		PLOT LINE test FROM spec_max    , y_start TO spec_max    , ( y_max * 0.97 )
		PLOT TEXT test AT spec_max , ( y_max * 0.98 ) USING "US"

							  { line & text at Mean       }

		PLOT LINE test FROM pts_mean , y_start TO pts_mean , ( y_max / 10 )
		x_text = STRIP ( pts_mean )
		x_pos  = pts_mean - ( ( end_pos - start_pos ) * LENGTH( x_text ) / 100 )
		PLOT TEXT test AT x_pos , y_start USING x_text

							   { lines & text at -3s & 3s }

		pos_shift = ( end_pos - start_pos ) / 50
		PLOT LINE test FROM ( pts_mean - ( 3 * pts_sigma ) ) , y_start
			     TO ( pts_mean - ( 3 * pts_sigma ) ) , ( y_max / 10 )
		PLOT TEXT test   AT ( pts_mean - ( 3 * pts_sigma ) - pos_shift ) , y_start
			     USING "3s"
		PLOT LINE test FROM ( pts_mean + ( 3 * pts_sigma ) ) , y_start
			     TO ( pts_mean + ( 3 * pts_sigma ) ) , ( y_max / 10 )
		PLOT TEXT test   AT ( pts_mean + ( 3 * pts_sigma ) - pos_shift ) , y_start
			     USING "3s"

							  { Title "Process Capability }

		PLOT TEXT test AT 0 , 99 PERCENT USING y_legend

						    { statistical params; static text }
						    { should be messages              }

		y_col = 90
		y_col_plus = 15

		PLOT TEXT test at y_col ,     85 PERCENT USING
		"From       "

		PLOT TEXT test at y_col + y_col_plus, 85 PERCENT USING
		" : " : first_subgrp

		PLOT TEXT test at y_col , 80 PERCENT USING
		"To         "

		PLOT TEXT test at y_col + y_col_plus, 80 PERCENT USING
		" : " : last_subgrp

		PLOT TEXT test at y_col , 75 PERCENT USING
		"Skewness   "

		PLOT TEXT test at y_col + y_col_plus, 75 PERCENT USING
		" : " :  pts_skew

		PLOT TEXT test at y_col , 70 PERCENT USING
		"Kurtosis   "

		PLOT TEXT test at y_col + y_col_plus, 70 PERCENT USING
		" : " :  pts_kur

		PLOT TEXT test at y_col , 65 PERCENT USING
		"Cap Ratio  "

		PLOT TEXT test at y_col + y_col_plus, 65 PERCENT USING
		" : " :  cap_rat

		PLOT TEXT test at y_col , 60 PERCENT USING
		"Cap Index  "

		PLOT TEXT test at y_col + y_col_plus, 60 PERCENT USING
		" : " :  cap_ndx

		PLOT TEXT test at y_col , 55 PERCENT USING
		"Cpk        "

		PLOT TEXT test at y_col + y_col_plus, 55 PERCENT USING
		" : " :  cpk_ndx

		PLOT TEXT test at y_col , 50 PERCENT USING
		"Std Dev    "

		PLOT TEXT test at y_col + y_col_plus, 50 PERCENT USING
		" : " :  pts_sigma

		PLOT TEXT test at y_col , 45 PERCENT USING
		"Upper Spec "

		PLOT TEXT test at y_col + y_col_plus, 45 PERCENT USING
		" : " :  spec_max

		PLOT TEXT test at y_col , 40 PERCENT USING
		"Lower Spec "

		PLOT TEXT test at y_col + y_col_plus, 40 PERCENT USING
		" : " :  spec_min

		PLOT TEXT test at y_col , 35 PERCENT USING
		"XB-3 Std   "

		PLOT TEXT test at y_col + y_col_plus, 35 PERCENT USING
		" : " : ( pts_mean - ( 3 * pts_sigma ) )

		PLOT TEXT test at y_col , 30 PERCENT USING
		"XB+3 Std.  "

		PLOT TEXT test at y_col + y_col_plus, 30 PERCENT USING
		" : " : ( pts_mean + ( 3 * pts_sigma ) )

		sqc_chart . chart_window = test_win

	ENDIF

ENDROUTINE

{******************************************************************************}

ROUTINE print_process_capability ( sqc_chart )

{ 
* Print Process Capability Chart.
* 
* 
*
* Parameters   : sqc_chart
* Return Value : n/a
*
*******************************************************************************}

DECLARE first_subgrp, last_subgrp, pts_skew, pts_kur, cap_rat, cap_ndx,
        cpk_ndx, pts_sigma, pts_mean, spec_min, spec_max, start_pos,
        end_pos, graph_obj_ndx, test, y_start, y_max, x_text,
        x_pos, pos_shift, y_col, exit_loop, y_legend, y_col_plus,
        print_form, chart_title

    graph_obj_ndx = 1

    exit_loop = FALSE

    WHILE ( NOT ( exit_loop ) )

        IF ( sqc_chart . graph_object_array [ graph_obj_ndx ] = EMPTY ) THEN
            flash_message ( "Process Capability has invalid specifications.":
                            " It is unavaliable for drawing.", TRUE )
            RETURN ( FALSE )
        ELSEIF ( sqc_chart . graph_object_array [ graph_obj_ndx ] .
                           graph_type = PROC_CAP_GR ) THEN
            exit_loop = TRUE
        ELSE
            graph_obj_ndx   = graph_obj_ndx + 1
        ENDIF

    ENDWHILE

    first_subgrp = sqc_chart.graph_object_array[graph_obj_ndx].first_subgroup
    last_subgrp  = sqc_chart.graph_object_array[graph_obj_ndx].last_subgroup

    pts_skew = sqc_chart . graph_object_array [ graph_obj_ndx ] . skewness
    pts_kur  = sqc_chart . graph_object_array [ graph_obj_ndx ] . kurtosis
    cap_rat  = sqc_chart . graph_object_array [ graph_obj_ndx ] . cap_ratio
    cap_ndx  = sqc_chart . graph_object_array [ graph_obj_ndx ] . cap_index
    cpk_ndx  = sqc_chart . graph_object_array [ graph_obj_ndx ] . cpk_index

    pts_sigma = sqc_chart . graph_object_array [ graph_obj_ndx ] . sigma
    pts_mean  = sqc_chart . graph_object_array [ graph_obj_ndx ] . mean

    spec_min = sqc_chart . graph_object_array [ graph_obj_ndx ] . spec_min
    spec_max = sqc_chart . graph_object_array [ graph_obj_ndx ] . spec_max

    start_pos = sqc_chart . graph_object_array [ graph_obj_ndx ] . start_pos
    end_pos   = sqc_chart . graph_object_array [ graph_obj_ndx ] . end_pos

    y_max = sqc_chart . graph_object_array [ graph_obj_ndx ] . max_y

    y_legend = sqc_chart . graph_object_array [ graph_obj_ndx ] . y_legend

                                                      { histo and norm. dist. }

    SET  GRAPH test , points       . character      = PC_CHARACTER
    SET  GRAPH test , x_graduation . start_position = end_pos + 1
    SET  GRAPH test , x_graduation . large          = 0
    SET  GRAPH test , y_graduation . start_position = -1
    SET  GRAPH test , y_graduation . large          = 0
    SET  GRAPH test , x_axis       . start_position = start_pos
    SET  GRAPH test , x_axis       . end_position   = end_pos
    SET  GRAPH test , x_annotation . format         = "9999"

    SET  GRAPH test , y_axis       . COLOUR         = PC_Y_AXIS_COLOUR
    SET  GRAPH test , curve        . COLOUR         = PC_CURVE_COLOUR
    SET  GRAPH test , x_annotation . COLOUR         = PC_INFO_COLOUR

                                                      { norm. dist. only      }

    pos_shift = ( end_pos - start_pos ) / 50

    y_col = 90
    y_col_plus = 15

    create_print_form ( print_form , sqc_chart )

    print_form . start_prompt ()
    toggle_routine ( print_form . prompt_objects [ TOOLBAR_BUTTON_CHART ] )
    
    REPEAT
        print_form . wait_prompt ()

        IF ( print_form . get_lastkey() = "DO" ) OR 
           ( print_form . get_lastkey() = "SELECT" ) THEN

	    setup_hardcopy_params ( test )
            configure_output ( print_form, test )

	    SET  GRAPH test , graph        . style = 1

	    SET  GRAPH test , x_axis       . input =
		     sqc_chart . graph_object_array [ graph_obj_ndx ] . x_points

	    SET  GRAPH test , y_axis       . input =
		     sqc_chart . graph_object_array [ graph_obj_ndx ] . y_points

	    PLOT GRAPH test    FROM LINE   5 TO LINE 20
			       FROM COLUMN 1 TO COLUMN 60

	    SET  GRAPH test , graph        . style = 2

	    SET  GRAPH test , x_axis       . input =
		     sqc_chart . graph_object_array [ graph_obj_ndx ] . x_trend

	    SET  GRAPH test , y_axis       . input =
		     sqc_chart . graph_object_array [ graph_obj_ndx ] . y_trend

	    PLOT GRAPH test    FROM LINE   5 TO LINE 20
			       FROM COLUMN 1 TO COLUMN 60

	    Y_START = 0.001
							  { line & text at LS         }

	    PLOT LINE test FROM spec_min    , y_start TO spec_min    , ( y_max * 0.98 )

							  { line & text at US         }

	    PLOT LINE test FROM spec_max    , y_start TO spec_max    , ( y_max * 0.97 )

							  { line & text at Mean       }

	    PLOT LINE test FROM pts_mean , y_start TO pts_mean , ( y_max / 10 )

							   { lines & text at -3s & 3s }

	    PLOT LINE test FROM ( pts_mean - ( 3 * pts_sigma ) ) , y_start
			     TO ( pts_mean - ( 3 * pts_sigma ) ) , ( y_max / 10 )

	    PLOT LINE test FROM ( pts_mean + ( 3 * pts_sigma ) ) , y_start
			     TO ( pts_mean + ( 3 * pts_sigma ) ) , ( y_max / 10 )

							  { Title "Process Capability }


						    { statistical params; static text }
						    { should be messages              }

	    print_graph_header ( sqc_chart, test )

	    PLOT TEXT test AT spec_min , ( y_max * 0.99 ) USING "LS"

	    PLOT TEXT test AT spec_max , ( y_max * 0.98 ) USING "US"

	    x_text = STRIP ( pts_mean )
	    x_pos  = pts_mean - ( ( end_pos - start_pos ) * LENGTH( x_text ) / 100 )

	    PLOT TEXT test AT x_pos , y_start USING x_text

	    PLOT TEXT test   AT ( pts_mean - ( 3 * pts_sigma ) - pos_shift ) , y_start
			     USING "3s"

	    PLOT TEXT test   AT ( pts_mean + ( 3 * pts_sigma ) - pos_shift ) , y_start
			     USING "3s"

	    PLOT TEXT test at y_col ,     85 PERCENT USING
		"From       "

	    PLOT TEXT test at y_col + y_col_plus, 85 PERCENT USING
		" : " : first_subgrp

	    PLOT TEXT test at y_col , 80 PERCENT USING
		"To         "

	    PLOT TEXT test at y_col + y_col_plus, 80 PERCENT USING
		" : " : last_subgrp

	    PLOT TEXT test at y_col , 75 PERCENT USING
		"Skewness   "

	    PLOT TEXT test at y_col + y_col_plus, 75 PERCENT USING
		" : " :  pts_skew

	    PLOT TEXT test at y_col , 70 PERCENT USING
		"Kurtosis   "

	    PLOT TEXT test at y_col + y_col_plus, 70 PERCENT USING
		" : " :  pts_kur

	    PLOT TEXT test at y_col , 65 PERCENT USING
		"Cap Ratio  "

	    PLOT TEXT test at y_col + y_col_plus, 65 PERCENT USING
		" : " :  cap_rat

	    PLOT TEXT test at y_col , 60 PERCENT USING
		"Cap Index  "

	    PLOT TEXT test at y_col + y_col_plus, 60 PERCENT USING
		" : " :  cap_ndx

	    PLOT TEXT test at y_col , 55 PERCENT USING
		"Cpk        "

	    PLOT TEXT test at y_col + y_col_plus, 55 PERCENT USING
		" : " :  cpk_ndx

	    PLOT TEXT test at y_col , 50 PERCENT USING
		"Std.       "

	    PLOT TEXT test at y_col + y_col_plus, 50 PERCENT USING
		" : " :  pts_sigma

	    PLOT TEXT test at y_col , 45 PERCENT USING
		"Upper Spec "

	    PLOT TEXT test at y_col + y_col_plus, 45 PERCENT USING
		" : " :  spec_max

	    PLOT TEXT test at y_col , 40 PERCENT USING
		"Lower Spec "

	    PLOT TEXT test at y_col + y_col_plus, 40 PERCENT USING
		" : " :  spec_min

	    PLOT TEXT test at y_col , 35 PERCENT USING
		"XB-3 Std.  "

	    PLOT TEXT test at y_col + y_col_plus, 35 PERCENT USING
		" : " : ( pts_mean - ( 3 * pts_sigma ) )

	    PLOT TEXT test at y_col , 30 PERCENT USING
		"XB+3 Std.  "

	    PLOT TEXT test at y_col + y_col_plus, 30 PERCENT USING
		" : " : ( pts_mean + ( 3 * pts_sigma ) )

	    chart_title = PAD ( "Chart ", " ", "15" ) : ": " : STRIP ( y_legend )

	    PLOT TEXT test AT 0, 88 DEVICE_AREA USING chart_title

							      { histo graph only      }

	    PLOT COMPLETE test

	    post_plot_complete ( print_form )
	    
	    create_chart_report ( sqc_chart )
	    delete_graph_files ( sqc_chart )

	    {print_form . end_prompt()}

        ENDIF
        
    UNTIL ( print_form . get_lastkey () = "EXIT" ) OR
          ( print_form . get_lastkey () = "DO" )

ENDROUTINE

{******************************************************************************}

ROUTINE run_sqc_calculations ( sqc_chart )

{ 
* Calls the calculations.
* 
* 
*
* Parameters   : sqc_chart
* Return Value : n/a
*
*******************************************************************************}

DECLARE counter, graph_type, chart_type

    counter = 1

    chart_type = ""

    WHILE ( counter <= sqcwin_array_size ( sqc_chart . active_array ) ) DO

        graph_type = sqc_chart . active_array [ counter, 1 ]

        IF ( sqc_chart . active_array [ counter, 2 ] <> chart_type ) THEN

            chart_type = sqc_chart . active_array [ counter, 2 ]

            IF ( graph_type = CUSUM_GR ) THEN
                do_cusum_calculations ( sqc_chart )
            ELSEIF ( graph_type = PROC_CAP_GR ) THEN
                get_pc_subgroup ( sqc_chart )
                calculate_process_capability ( sqc_chart )
            ELSE
                do_shewhart_calculations  ( sqc_chart ,
                                            chart_type)
            ENDIF

        ENDIF

        counter = counter + 1

    ENDWHILE

ENDROUTINE

{******************************************************************************}

ROUTINE write_prompts_to_objDB (       form        ,
                                 VALUE first_prompt,
                                 VALUE last_prompt )

{ 
* Writes prompts to object database.
* 
* 
*
* Parameters   : form, first_prompt, last_prompt
* Return Value : n/a
*
*******************************************************************************}

DECLARE counter, chart_type_ndx

    counter = first_prompt

    chart_type_ndx = PAD ( form . user_info . chart_id      , " ", 20 ) :
                     PAD ( form . user_info . tmp_chart_type, " ", 10 )

    form . user_info . sqc_chart_type . set_by_index ( "KEY0", chart_type_ndx )

    WHILE ( counter <= last_prompt ) DO

        ASSIGN sqcwin_chart_type . 'form . prompt_objects [ counter ] . user_info'
            IN OBJECT form . user_info . sqc_chart_type . current =
                form . prompt_objects [ counter ] . value

        counter = counter + 1

    ENDWHILE

ENDROUTINE

{******************************************************************************}

ROUTINE write_prompt_text_to_objDB ( form            ,
                                     VALUE user_info )

{ 
* Writes the prompt text, for the prompt with user_info, to the chart_type
* objDB
* 
*
* Parameters   : form, user_info
* Return Value : n/a
*
*******************************************************************************}

DECLARE chart_type_ndx, the_prompt

	IF get_prompt( form . prompt_objects, user_info, the_prompt ) THEN

		chart_type_ndx = PAD ( form . user_info . chart_id      , " ", 20 ) :
			     PAD ( form . user_info . tmp_chart_type, " ", 10 )

		form . user_info . sqc_chart_type . set_by_index ( "KEY0", chart_type_ndx )

		ASSIGN sqcwin_chart_type . 'user_info' IN OBJECT 
		       form . user_info . sqc_chart_type . current =
		       the_prompt . text

	ENDIF

ENDROUTINE

{******************************************************************************}

ROUTINE write_field_value_to_objDB (   form        ,
                                 VALUE field_name  ,
                                 VALUE field_value )

{ 
* Writes the field_value to the field specified in field_name
* to the object database.
* 
* 
*
* Parameters   : form, field_value, field_name
* Return Value : n/a
*
*******************************************************************************}

DECLARE chart_type_ndx

	chart_type_ndx = PAD ( form . user_info . chart_id      , " ", 20 ) :
	     PAD ( form . user_info . tmp_chart_type, " ", 10 )

	form . user_info . sqc_chart_type . set_by_index ( "KEY0", chart_type_ndx )

	ASSIGN sqcwin_chart_type . 'field_name'
	IN OBJECT form . user_info . sqc_chart_type . current = field_value

ENDROUTINE

{******************************************************************************}

ROUTINE read_prompts_from_obj_DB (       form        ,
                                   VALUE first_prompt,
                                   VALUE last_prompt )

{ 
* Reads prompts from object database.
* 
* 
*
* Parameters   : form, first_prompt, last_prompt
* Return Value : n/a
*
*******************************************************************************}

DECLARE counter, chart_type_ndx, field_name, sqc_chart, prompt_objs

    sqc_chart = form . user_info
    prompt_objs = form . prompt_objects

    counter = first_prompt

    WHILE ( counter <= last_prompt ) DO

        chart_type_ndx = PAD ( sqc_chart . chart_id      , " ", 20 ) :
                         PAD ( sqc_chart . tmp_chart_type, " ", 10 )

        sqc_chart . sqc_chart_type . set_by_index ( "KEY0", chart_type_ndx )

        field_name = prompt_objs [ counter ] . user_info
        prompt_objs [ counter ] . value =
            object_select_field ( sqc_chart . sqc_chart_type . current,
                                  "sqcwin_chart_type"                 ,
                                  field_name                          )

        counter = counter + 1

    ENDWHILE

ENDROUTINE

{******************************************************************************}

ROUTINE button_press_chart_param ( self )

{ 
* Chart parameters button press routine.
* 
* 
*
* Parameters   : self
* Return Value : n/a
*
*******************************************************************************}

DECLARE answer

    IF self.user_info="NEXT" THEN

        SET GLOBAL "lastkey" TO "RIGHT"
        self . parent_prompt . set_lastkey ( "RIGHT" )
        self . parent_prompt . stop_prompt()

    ELSEIF self.user_info="PREV"

        SET GLOBAL "lastkey" TO "LEFT"
        self . parent_prompt . set_lastkey ( "LEFT" )
        self . parent_prompt . stop_prompt()

    ELSEIF self.user_info="EXIT"

        IF ( self . parent_prompt . user_info . ok_button_only ) THEN

            SET GLOBAL "lastkey" TO "EXIT"
            self . parent_prompt . set_lastkey ( "EXIT" )
            self . parent_prompt . stop_prompt()

        ELSE

            answer =
            confirm_with_text ( GET_USER_MESSAGE("SQCWIN_MAIN_CONF_4", 1 ))

            IF (answer) THEN
                SET GLOBAL "lastkey" TO "EXIT"
                self . parent_prompt . set_lastkey ( "EXIT" )
                self . parent_prompt . stop_prompt()
            ENDIF

        ENDIF

    ENDIF

ENDROUTINE

{******************************************************************************}

ROUTINE draw_cusum_graph ( sqc_chart, hardcopy, graph_form )

{ 
* Draw a CUSUM graph.
* 
* 
*
* Parameters   : sqc_chart, hardcopy, graph_form
* Return Value : 
*
*******************************************************************************}

DECLARE cusum_graph_obj, whatever, graph_1, print_form, point_no, 
        y_leg_pos, chart_desc

    cusum_graph_obj =
           sqc_chart . graph_object_array [ sqc_chart . graph_obj_a_ndx ]


    IF cusum_graph_obj . xpoints [ 1 ] = EMPTY THEN

        flash_message ( "No points in chart : This chart can not be drawn.",
                        TRUE )

        RETURN ( 0 )

    ENDIF

    SET GRAPH graph_1, X_AXIS.INPUT = cusum_graph_obj . x_points
    SET GRAPH graph_1, Y_AXIS.INPUT = cusum_graph_obj . y_points
    SET GRAPH graph_1, GRAPH.STYLE  = CUSUM_GRAPH_STYLE
    SET GRAPH graph_1, X_AXIS.LINE_STYLE=1
    SET GRAPH graph_1, X_AXIS.START_POSITION=cusum_graph_obj . x_points [ 1 ]
    SET GRAPH graph_1, Y_AXIS.START_POSITION=cusum_graph_obj.cusum_min * 1.1
    SET GRAPH graph_1, Y_AXIS.END_POSITION = cusum_graph_obj.cusum_max * 1.1
    SET GRAPH graph_1, X_GRADUATION.START_POSITION=1
    SET GRAPH graph_1, CURVE.COLOUR = CUSUM_CURVE_COLOUR

	IF ( hardcopy = TRUE ) THEN

		create_print_form( print_form , sqc_chart )
		print_form . start_prompt ()
		toggle_routine ( print_form . prompt_objects [ TOOLBAR_BUTTON_CHART ] )
		
		    setup_hardcopy_params ( graph_1 )
		    configure_output ( print_form, graph_1 )

		    PLOT GRAPH graph_1 FROM LINE   5 TO LINE 21
				       FROM COLUMN 1 TO COLUMN 70

		    print_graph_header ( sqc_chart, graph_1 )

		    print_cusum_graph  ( sqc_chart, cusum_graph_obj, graph_1 )

		    PLOT COMPLETE graph_1

		post_plot_complete ( print_form )
		        
		REPEAT
				
		    print_form . wait_prompt ()
		
		   IF ( print_form . get_lastkey() = "DO" ) OR 
		       ( print_form . get_lastkey() = "SELECT" ) THEN
                        create_chart_report ( sqc_chart )
	                

		    ENDIF
		
	        UNTIL ( print_form . get_lastkey () = "EXIT" ) OR
                      ( print_form . get_lastkey () = "DO" )
                      
                delete_graph_files ( sqc_chart )
		ELSE

		sqc_chart . sqc_header . set_first ( )

		chart_desc = SELECT sqcwin_header . description
			     IN OBJECT sqc_chart . sqc_header . current

		graph_form . header = 
		STRIP ( sqc_chart . chart_id ) : " - " : STRIP ( chart_desc )


		whatever = graph_form . graph_object . start_graph()                	      

		DRAW GRAPH graph_1 IN WINDOW whatever FROM COLUMN 1 TO COLUMN 77

		SET GRAPH graph_1, CURVE.COLOUR = CUSUM_SECOND_CURVE_COLOUR

		SET GRAPH graph_1, X_ANNOTATION . TEXT_STYLE = 1

		PLOT TEXT graph_1
		     AT cusum_graph_obj . x_points [ 1 ] - 0.5,
			cusum_graph_obj . cusum_max * 1.15
		     AXIS_UNITS
		     USING cusum_graph_obj . y_legend

		point_no = sqcwin_array_size ( cusum_graph_obj . x_points ) / 2
		y_leg_pos = cusum_graph_obj . cusum_min / 10

		PLOT TEXT graph_1
		     AT point_no, y_leg_pos
		     AXIS_UNITS
		     USING cusum_graph_obj . x_legend

		IF ( cusum_graph_obj . disp_dec ) THEN

		    PLOT LINE graph_1
		       FROM 0,0
		       TO cusum_graph_obj.x_dep_plus,cusum_graph_obj.dep_end_y_plus
		    PLOT TEXT graph_1
		       AT cusum_graph_obj.x_dep_plus,cusum_graph_obj.dep_end_y_plus
		       AXIS_UNITS
		       USING "Upper Departure Line"
		    PLOT LINE graph_1
			FROM 0,0
			TO cusum_graph_obj.x_dep_minus,cusum_graph_obj.dep_end_y_minus
		    PLOT TEXT graph_1
			AT cusum_graph_obj.x_dep_minus,cusum_graph_obj.dep_end_y_minus
			AXIS_UNITS
			USING "Lower Departure Line"

		ENDIF

		PLOT LINE graph_1
		    FROM cusum_graph_obj.dec_end_point_x_plus,
			 cusum_graph_obj.dec_end_point_y_plus
		    TO   cusum_graph_obj.dec_start_point_x_plus,
			 cusum_graph_obj.dec_start_point_y_plus
		PLOT TEXT graph_1
		    AT cusum_graph_obj.dec_start_point_x_plus,
		       cusum_graph_obj.dec_start_point_y_plus
		    AXIS_UNITS
		    USING "Upper Decision Line"
		PLOT LINE graph_1
		    FROM cusum_graph_obj.dec_end_point_x_minus,
			 cusum_graph_obj.dec_end_point_y_minus
		    TO   cusum_graph_obj.dec_start_point_x_minus,
			 cusum_graph_obj.dec_start_point_y_minus
		PLOT TEXT graph_1
		    AT cusum_graph_obj.dec_start_point_x_minus,
		       cusum_graph_obj.dec_start_point_y_minus
		    AXIS_UNITS
		    USING "Lower Decision Line"
		PLOT LINE graph_1
		    FROM cusum_graph_obj.dec_point,
			 cusum_graph_obj.dec_end_point_y_plus
		    TO   cusum_graph_obj.dec_point,
			 cusum_graph_obj.dec_end_point_y_minus

		SET GRAPH graph_1, CURVE.COLOUR=0

		PLOT TEXT graph_1
		    AT 60,1
		    USING "Target:"

		PLOT TEXT graph_1
		    AT 65,1
		    USING cusum_graph_obj.cusum_target

		PLOT TEXT graph_1
		    AT 60,3
		    USING "Decision Interval:"

		PLOT TEXT graph_1
		    AT 65,4
		    USING cusum_graph_obj.dec_interval

		PLOT TEXT graph_1
		    AT 60,5
		    USING "Decision Slope:"

		PLOT TEXT graph_1
		    AT 65,6
		    USING cusum_graph_obj.dec_slope

		IF (cusum_graph_obj.disp_dec) THEN

			 PLOT TEXT graph_1
			     AT 60,7
			     USING "Departure Slope:"

			 PLOT TEXT graph_1
			    AT 65,8
			    USING cusum_graph_obj.dep_slope

		ENDIF

		SET GRAPH graph_1, X_AXIS.INPUT = cusum_graph_obj . x_bad
		SET GRAPH graph_1, Y_AXIS.INPUT = cusum_graph_obj . y_bad

		SET GRAPH graph_1, POINTS . COLOUR = CUSUM_POINT_COLOUR
		SET GRAPH graph_1, POINTS . CHARACTER = CUSUM_CHARACTER

		SET GRAPH graph_1, GRAPH.STYLE  = BAD_GRAPH_STYLE

		PLOT POINT graph_1
		  USING cusum_graph_obj . x_bad,
			    cusum_graph_obj . y_bad

		sqc_chart . chart_window = whatever

	ENDIF                                        

	cusum_graph_obj = sqc_chart . graph_object_array [ sqc_chart . graph_obj_a_ndx ]

ENDROUTINE

{******************************************************************************}

ROUTINE print_cusum_graph ( sqc_chart, cusum_graph_obj, graph_1 )

{ 
* Routine to print the CUSUM graph
* 
* 
*
* Parameters   : sqc_chart, cusum_graph_obj, graph_1
* Return Value : n/a
*
*******************************************************************************}

	DECLARE chart_title

        IF ( cusum_graph_obj . disp_dec ) THEN

            PLOT LINE graph_1
               FROM 0,0
               TO cusum_graph_obj.x_dep_plus,cusum_graph_obj.dep_end_y_plus

            PLOT LINE graph_1
                FROM 0,0
                TO cusum_graph_obj.x_dep_minus,cusum_graph_obj.dep_end_y_minus

        ENDIF

    {--------------- decsion line ---------------------}

        PLOT LINE graph_1
            FROM cusum_graph_obj.dec_end_point_x_plus,
                 cusum_graph_obj.dec_end_point_y_plus
            TO   cusum_graph_obj.dec_start_point_x_plus,
                 cusum_graph_obj.dec_start_point_y_plus

        PLOT LINE graph_1
            FROM cusum_graph_obj.dec_end_point_x_minus,
                 cusum_graph_obj.dec_end_point_y_minus
            TO   cusum_graph_obj.dec_start_point_x_minus,
                 cusum_graph_obj.dec_start_point_y_minus

        PLOT LINE graph_1
            FROM cusum_graph_obj.dec_point,
                 cusum_graph_obj.dec_end_point_y_plus
            TO   cusum_graph_obj.dec_point,
                 cusum_graph_obj.dec_end_point_y_minus

    {--------------- end of decsion line  ---------------------}

        SET GRAPH graph_1, X_AXIS.INPUT = cusum_graph_obj . x_bad
        SET GRAPH graph_1, Y_AXIS.INPUT = cusum_graph_obj . y_bad

        SET GRAPH graph_1, POINTS . COLOUR = CUSUM_POINT_COLOUR
        SET GRAPH graph_1, POINTS . CHARACTER = POINT_CHARACTER

        SET GRAPH graph_1, GRAPH.STYLE  = BAD_GRAPH_STYLE

        chart_title = PAD ( "Chart ", " ", "15" ) : ": " : "CuSum Chart"

        PLOT TEXT graph_1 AT 0 , 88  DEVICE_AREA USING chart_title

        PLOT POINT graph_1
            USING cusum_graph_obj . x_bad,
                    cusum_graph_obj . y_bad

        IF ( cusum_graph_obj . disp_dec ) THEN

            PLOT TEXT graph_1
               AT cusum_graph_obj.x_dep_plus,cusum_graph_obj.dep_end_y_plus
               AXIS_UNITS
               USING "Upper Departure Line"

            PLOT TEXT graph_1
                AT cusum_graph_obj.x_dep_minus,cusum_graph_obj.dep_end_y_minus
                AXIS_UNITS
                USING "Lower Departure Line"

        ENDIF

        PLOT TEXT graph_1
            AT cusum_graph_obj.dec_start_point_x_plus,
               cusum_graph_obj.dec_start_point_y_plus
            AXIS_UNITS
            USING "Upper Decision Line"

        PLOT TEXT graph_1
            AT cusum_graph_obj.dec_start_point_x_minus,
               cusum_graph_obj.dec_start_point_y_minus
            AXIS_UNITS
            USING "Lower Decision Line"

        PLOT TEXT graph_1
            AT 60,80
            DEVICE_AREA
            USING "Target:"

        PLOT TEXT graph_1
            AT 70,80
            DEVICE_AREA
            USING cusum_graph_obj.cusum_target

        PLOT TEXT graph_1
            AT 60,75
            DEVICE_AREA
            USING "Decision Interval:"

        PLOT TEXT graph_1
            AT 70,75
            DEVICE_AREA
            USING cusum_graph_obj.dec_interval

        PLOT TEXT graph_1
            AT 60,70
            DEVICE_AREA
            USING "Decision Slope:"

        PLOT TEXT graph_1
            AT 70,70
            DEVICE_AREA
            USING cusum_graph_obj.dec_slope

ENDROUTINE

{******************************************************************************}

ROUTINE is_second_graph ( graph_type, limit_value )

{ 
* Returns false if a graph is shewhart type A and false if it is a 
* shewhart type B with a limit value of zero.
* 
*
* Parameters   : graph_type, limit_value
* Return Value : return_value
*
*******************************************************************************}

    DECLARE return_value

    return_value = TRUE

    IF ( graph_type = STD_GR   ) OR
       ( graph_type = RANGE_GR ) OR
       ( graph_type = MR_GR    ) THEN

       IF ( limit_value <= 0 ) THEN

           return_value = FALSE

       ENDIF

    ENDIF

    RETURN ( return_value )

ENDROUTINE

{******************************************************************************}

ROUTINE get_mlp_specification (       selection_crit ,
                                VALUE mlp_lim_field  ,
                                VALUE lim_type       ,
                                      prod_name      )

{ 
* Return specification limits for mlps.
* 
* 
*
* Parameters   : selection_crit, mlp_lim_field, lim_type, prod_name
* Return Value : mlp_spec_value
*
*******************************************************************************}

DECLARE counter, prod_ver, mlp_spec_value

    counter   = 1

    prod_ver = EMPTY

    WHILE ( counter <= sqcwin_array_size ( selection_crit ) ) DO

        IF ( selection_crit [ counter, 2 ] = "PRODUCT" ) THEN

            prod_name = selection_crit [ counter, 3 ]

        ELSEIF ( selection_crit [ counter, 2 ] = "PRODUCT_VERSION" ) THEN

            prod_ver  = selection_crit [ counter, 3 ]

        ENDIF

        counter = counter + 1

    ENDWHILE

    IF ( prod_ver = EMPTY ) THEN

        prod_ver = SELECT MAX mlp_view . product_version
                       WHERE ( product_id = prod_name )

    ENDIF

    mlp_spec_value = SELECT mlp_view . 'mlp_lim_field'
                         WHERE ( product_id = prod_name     )
                         AND   ( product_version = prod_ver )
                         AND   ( level_id = lim_type        )

    mlp_spec_value = NUMERIC ( STRIP ( mlp_spec_value ) )

    RETURN ( mlp_spec_value )

ENDROUTINE

{******************************************************************************}

ROUTINE use_mlp_specification (       sel_array      ,
                                      selection_crit )

{ 
* Determine whether or not mlp specifications should be used.
* 
* 
*
* Parameters   : sel_array, selection_crit
* Return Value : n/a
*
*******************************************************************************}

DECLARE counter, array_index

    counter = 1

    WHILE ( counter <= sqcwin_array_size ( selection_crit ) ) DO

        IF ( selection_crit [ counter, 2 ] = "PRODUCT" ) THEN

            array_index = sqcwin_array_size ( sel_array )
            sel_array [ array_index + 1, 1 ] =
                GET_USER_MESSAGE ( "SPEC_OPTIONS_MLP_LIMITS",1 )
            sel_array [ array_index + 1, 2 ] = array_index + 1

        ENDIF

        counter = counter + 1

    ENDWHILE

ENDROUTINE

{******************************************************************************}

ROUTINE use_mlp_spec_bool ( selection_crit )

{ 
* Determine whether or not mlp specifications should be used and return 
* TRUE or FALSE
* 
*
* Parameters   : selection_crit
* Return Value : return_val
*
*******************************************************************************}


DECLARE counter, return_val

    counter = 1
    return_val = FALSE

    WHILE ( counter <= sqcwin_array_size ( selection_crit ) ) AND 
          ( NOT return_val                              ) DO

        IF ( selection_crit [ counter, 2 ] = "PRODUCT" ) THEN

		return_val = TRUE

        ENDIF

        counter = counter + 1

    ENDWHILE

    RETURN( return_val )

ENDROUTINE

{******************************************************************************}

ROUTINE disable_subgroup_size ( self )

{ 
* Routine to disable subgroup size.
* 
* 
*
* Parameters   : self
* Return Value : n/a
*
*******************************************************************************}

    IF self . value <> SIZE THEN

        self . parent_prompt . prompt_objects [ 2 ] . set_enabled ( FALSE )

    ELSE

        self . parent_prompt . prompt_objects [ 2 ] . set_enabled ( TRUE  )

    ENDIF

ENDROUTINE

{******************************************************************************}

ROUTINE size_chart ( sqc_chart )

{ 
* Determines whether subgroups should be chosen by size or not.
* 
* 
*
* Parameters   : sqc_chart
* Return Value : return_value
*
*******************************************************************************}

DECLARE chart_type_ndx, chossen_by, return_value

    chart_type_ndx = PAD ( sqc_chart . chart_id      , " ", "20" ) :
                     PAD ( sqc_chart . selected_chart, " ", "10" )

    sqc_chart . sqc_chart_type . set_by_index ( "KEY0", chart_type_ndx )

    chossen_by = object_select_field ( sqc_chart . sqc_chart_type . current,
                                       "sqcwin_chart_type"                 ,
                                       "subgroup_chosen_by"                )

    IF chossen_by = SIZE THEN

        return_value = TRUE

    ELSE

        return_value = FALSE

    ENDIF

    RETURN ( return_value )

ENDROUTINE

{******************************************************************************}

ROUTINE browse_on_active_charts ( self )

{ 
* Change active chart to newly selected chart.
* 
* 
*
* Parameters   : self
* Return Value : n/a
*
*******************************************************************************}

DECLARE sqc_chart, count, active_array_size, active_menu, item, 
        active_choice, continue, current_graph_num


	sqc_chart = self . parent_prompt . user_info

	CREATE OBJECT POPUP_MENU_CLASS , active_menu

	count = 1
	active_array_size = sqcwin_array_size( sqc_chart . active_array )

	WHILE ( count <= active_array_size ) DO

		CREATE OBJECT POPUP_MENU_ITEM_CLASS, item
		item . text    = sqc_chart . active_array[ count , 1 ] 

		IF ( sqc_chart . active_array[ count , 1 ] =
		     sqc_chart . selected_graph               ) THEN
		
			item . checked = TRUE

			current_graph_num = count

		ENDIF

		active_menu . add( item )

		count = count + 1

	ENDWHILE

	active_choice = active_menu . start()

	count = 1

	continue = TRUE

	WHILE continue DO

		IF count > active_array_size THEN

			continue = FALSE

		ELSEIF ( active_choice = 
		         sqc_chart . active_array[ count , 1 ] ) THEN

			continue = FALSE

		ELSE

			count = count + 1

		ENDIF

	ENDWHILE

	
	IF ( ( count <= active_array_size )   AND
	     ( count <> current_graph_num ) ) THEN

		self . parent_prompt . user_info . selected_graph = active_choice

		self . parent_prompt . user_info . selected_chart =
		      sqc_chart . active_array [ count, 2 ]

		set_sqc_chart_index_value ( sqc_chart )

		self . user_info = sqc_chart . active_array [ count, 2 ]
		draw_graph ( sqc_chart                  ,
		             sqc_chart . selected_graph ,
		             FALSE                      , 
		             self . parent_prompt       )

	ENDIF

ENDROUTINE

{******************************************************************************}

ROUTINE create_graph_object ( form )

{ 
* Create a graph object to plot graphs.
* 
* 
*
* Parameters   : form
* Return Value : n/a
*
*******************************************************************************}

DECLARE graph_object

	PROMPT OBJECT graph_object
	       CLASS  PROMPT_GRAPH_CLASS  
	       WITH ( column           = 1                            ,
	              row              = 3                            ,
		      width            = 85             ,
		      height           = 18            ,
		      vgl_library      = global ( "current_library" ) ,
		      point_character  = "+"                          ,
		      selection_colour = PROMPT_COLOUR_MAGENTA        ,
		      selected_routine = "lmb_graph_callback"             ,
		      right_mouse_routine = "rmb_graph_callback"       )
                                           
	form . add_prompt ( graph_object ) 
	form . graph_object = graph_object

ENDROUTINE

{******************************************************************************}

ROUTINE create_graph_form ( sqc_chart, form )

{ 
* Create the graph form to plot graphs and hold options buttons.
* 
* 
*
* Parameters   : sqc_chart, form
* Return Value : n/a
*
*******************************************************************************}

	define_sqc_graph_form()
	CREATE OBJECT "SQC_GRAPH_FORM" , form     

	form . user_info = sqc_chart

	add_graph_form_buttons( form )


ENDROUTINE

{******************************************************************************}

ROUTINE add_graph_form_buttons( graph_form )

{ 
* Add the toolbar buttons to the graph form.
* 
* 
*
* Parameters   : graph_form
* Return Value : n/a
*
*******************************************************************************}

DECLARE toolbar, button1, button2, button3, button4, button5, button6, 
        button7, prompt1, print_button

	prompt_toolbar_initialise()

	CREATE OBJECT TOOLBAR_CLASS , toolbar


	CREATE OBJECT "STD_PROMPT_BUTTON" , button1
	button1 . caption = GET_USER_MESSAGE ( "SQCWIN_BUT_OK", 1 )
	button1 . mouse_click_routine="update_local"
	button1 . width = 10
	button1 . column = 1
	button1 . row = graph_form . height - 0.2
	
	IF ( graph_form . user_info . edit_mode <> "VIEW" ) THEN

		graph_form . add_prompt( button1 )

	ENDIF

	CREATE OBJECT TOOLBAR_BUTTON_LARGE_CLASS , button2
	button2 . tooltip = GET_USER_MESSAGE ( "CHART_OPTIONS_CHANGE_TIP", 1 )
	button2 . caption = GET_USER_MESSAGE ( "CHART_OPTIONS_CHANGE_CAP", 1 )
	button2 . set_icon( "INT_CHART_LEGEND" )
	button2 . mouse_click_routine="change_chart"
	button2 . width = 10

	toolbar . add_item( button2 )

	CREATE OBJECT TOOLBAR_BUTTON_LARGE_CLASS , button3
	button3 . tooltip = GET_USER_MESSAGE ( "CHART_OPTIONS_PARA_TIP", 1 )
	button3 . caption = GET_USER_MESSAGE ( "CHART_OPTIONS_PARA_CAP", 1 )
	button3 . set_icon( "INT_LINE_CHART" )
	button3 . mouse_click_routine="aux_chart_params"
	button3 . width = 10

	toolbar . add_item( button3 )

	CREATE OBJECT TOOLBAR_BUTTON_LARGE_CLASS , button4
	button4 . tooltip = GET_USER_MESSAGE ( "CHART_OPTIONS_EDIT_TIP", 1 )
	button4 . caption = GET_USER_MESSAGE ( "CHART_OPTIONS_EDIT_CAP", 1 )
	button4 . set_icon( "INT_EDIT_ITEM" )
	button4 . mouse_click_routine="graph_edit_data"
	button4 . width = 10

	toolbar . add_item( button4 )

	CREATE OBJECT TOOLBAR_BUTTON_LARGE_CLASS , button5
	button5 . tooltip = GET_USER_MESSAGE ( "CHART_OPTIONS_CRITERIA_TIP", 1 )
	button5 . caption = GET_USER_MESSAGE ( "CHART_OPTIONS_CRITERIA_CAP", 1 )
	button5 . set_icon( "INT_CRITERIA_EDIT" )
	button5 . mouse_click_routine="selection_criteria"

	IF NOT ( SELECT sqcwin_header . data_selection IN OBJECT
	            graph_form . user_info . sqc_header . current ) THEN

		button5 . enabled = FALSE

	ENDIF

	toolbar . add_item( button5 )

	CREATE OBJECT TOOLBAR_BUTTON_LARGE_CLASS , button6
	button6 . tooltip = GET_USER_MESSAGE ( "CHART_OPTIONS_CHART_OPS_TIP", 1 )
	button6 . caption = GET_USER_MESSAGE ( "CHART_OPTIONS_CHART_OPS_CAP", 1 )
	button6 . set_icon( "INT_SCATTER_CHART" )
	button6 . mouse_click_routine="chart_operations"
	button6 . width = 10

	toolbar . add_item( button6 )

	IF ( graph_form . user_info . edit_mode = "VIEW" ) THEN

		CREATE OBJECT "STD_PROMPT_BUTTON" , button7
		button7 . caption = GET_USER_MESSAGE ( "SQCWIN_BUT_CLOSE", 1 )
		button7 . mouse_click_routine="finish_up"
		button7 . width = 10
		button7 . column = graph_form . width - 10
		button7 . row = graph_form . height - 0.2

	ELSE
	
		CREATE OBJECT "STD_PROMPT_BUTTON" , button7
		button7 . caption = GET_USER_MESSAGE ( "SQCWIN_BUT_CANCEL", 1 )
		button7 . mouse_click_routine="finish_up"
		button7 . width = 10
		button7 . column = graph_form . width - 10
		button7 . row = graph_form . height - 0.2

	ENDIF

	graph_form . add_prompt( button7 )

	graph_form . add_panel( graph_form . width - 12                 ,
			        graph_form . height - 1                 ,
			        1                                       ,
			        button7 .width                          ,
			        PANEL_H_ALIGN_RIGHT + PANEL_H_EXPAND_ON )


	CREATE OBJECT TOOLBAR_BUTTON_LARGE_CLASS, prompt1
	prompt1 . tooltip = GET_USER_MESSAGE ( "CHART_OPTIONS_ACTIVE_TIP", 1 )
	prompt1 . caption = GET_USER_MESSAGE ( "CHART_OPTIONS_ACTIVE_CAP", 1 )
	prompt1 . set_icon( "INT_DIAGRAM" )
	prompt1 . mouse_click_routine = "browse_on_active_charts"

	toolbar . add_item( prompt1 )
	
	CREATE OBJECT TOOLBAR_BUTTON_LARGE_CLASS , print_button
	print_button . tooltip = GET_USER_MESSAGE( "CHART_OPTIONS_PRINT_TIP", 1 )
	print_button . caption = GET_USER_MESSAGE ( "CHART_OPTIONS_PRINT_CAP", 1 )
	print_button . set_icon( "INT_PRINTER" )
	print_button . mouse_click_routine="graph_print_button"
	print_button . width = 10

	toolbar . add_item( print_button )

	graph_form . add_prompt( toolbar )

	graph_form . toolbar = toolbar

ENDROUTINE

{******************************************************************************}

ROUTINE lmb_graph_callback (       self  ,
			     VALUE point )

ENDROUTINE

{******************************************************************************}

ROUTINE rmb_graph_callback( self )

{
* 
* 
* 
*
* Parameters   : 
* Return Value : n/a
*
*******************************************************************************}

DECLARE sqc_chart, click_point, point_menu, point_choice, graph_num, bad_point,
        comment_text, display_seg, lower_recalc, upper_recalc, recalc_mess,
	recalc_mess_txt, comment_header_mess


	
	IF self . point <> 0 THEN
		recalc_mess_txt = ""

		CREATE OBJECT POPUP_MENU_CLASS, point_menu

		sqc_chart = self . parent_prompt . user_info

		click_point = self . point

		get_graph_num( sqc_chart, click_point, graph_num)
		
		click_point = get_real_point_num( sqc_chart, click_point, graph_num )

		comment_text = get_subgroup_comment( sqc_chart, click_point )

		IF ( ( sqc_chart . selected_chart <> PROC_CAP )   AND
		     ( sqc_chart . selected_chart <> CUSUM    ) ) THEN


			IF NOT( BLANK( comment_text ) ) THEN
				
				IF( sqc_chart . selected_chart = IND_MR ) THEN

					point_menu . add_item(
					GET_USER_MESSAGE( "GRAPH_RMB_MENU_POINT_COMMENT", 1 ) )

					IF ( sqc_chart . edit_mode <> "VIEW" ) THEN

						point_menu . add_item(
						GET_USER_MESSAGE( "GRAPH_RMB_MENU_POINT_COMMENT_MOD", 1 ) )

					ENDIF
				ELSE

					point_menu . add_item(
					GET_USER_MESSAGE( "GRAPH_RMB_MENU_SUBGROUP_COMMENT", 1 ) )

					IF ( sqc_chart . edit_mode <> "VIEW" ) THEN

						point_menu . add_item(
						GET_USER_MESSAGE( "GRAPH_RMB_MENU_SUBGROUP_COMMENT_MOD", 1 ) )

					ENDIF
				ENDIF

			ELSEIF( sqc_chart . edit_mode <> "VIEW" ) THEN

				IF( sqc_chart . selected_chart = IND_MR ) THEN

					point_menu . add_item(
					GET_USER_MESSAGE( "GRAPH_RMB_MENU_POINT_COMMENT_ADD", 1 ) )

				ELSE

					point_menu . add_item(
					GET_USER_MESSAGE( "GRAPH_RMB_MENU_SUBGROUP_COMMENT_ADD", 1 ) )

				ENDIF

			ENDIF	
			
			IF ( sqc_chart . selected_chart = IND_MR ) THEN

				point_menu . add_item(
				GET_USER_MESSAGE( "GRAPH_RMB_MENU_SOURCE_COMMENT", 1 ) )

			ELSE

				point_menu . add_item(
				GET_USER_MESSAGE( "GRAPH_RMB_MENU_SOURCE_COMMENTS", 1 ) )
			
			ENDIF

			IF (  sqc_chart . edit_mode <> "VIEW" ) THEN 

				point_menu . add_divider()

				bad_point = is_subgroup_bad( sqc_chart, click_point, graph_num )

				IF bad_point THEN

					IF( sqc_chart . selected_chart = IND_MR ) THEN

						point_menu . add_item( 
						GET_USER_MESSAGE( "GRAPH_RMB_MENU_GOOD_POINT" , 1 ) )

					ELSE

						point_menu . add_item( 
						GET_USER_MESSAGE( "GRAPH_RMB_MENU_GOOD_SUBGROUP" , 1 ) )

					ENDIF
				ELSE

					IF( sqc_chart . selected_chart = IND_MR ) THEN

						point_menu . add_item( 
						GET_USER_MESSAGE( "GRAPH_RMB_MENU_BAD_POINT" , 1 ) )

					ELSE

						point_menu . add_item( 
						GET_USER_MESSAGE( "GRAPH_RMB_MENU_BAD_SUBGROUP" , 1 ) )

					ENDIF
				ENDIF

			ENDIF

			message_fetch( "CHART_OPS_MENU_RECALC_SEG", recalc_mess )

			lower_recalc = self . parent_prompt . get_lower_recalc_point()

			IF lower_recalc = 0 THEN

				point_menu . add_divider()

				point_menu . add_item( 
				GET_USER_MESSAGE( "GRAPH_RMB_MENU_SET_START_RECALC", 1 ) )

			ELSE
			
				IF ( ( graph_num = 
				       self . parent_prompt . get_lower_recalc_graph() )   AND
				     ( size_chart( sqc_chart )                         ) ) THEN

					IF ( lower_recalc < click_point ) THEN

						upper_recalc = click_point

						point_menu . add_divider()

						message_add_parameter( recalc_mess, lower_recalc )
						message_add_parameter( recalc_mess, upper_recalc )

						recalc_mess_txt = message_get_text( recalc_mess, 1 )
						point_menu . add_item( recalc_mess_txt )

					ELSEIF ( lower_recalc > click_point ) THEN

						upper_recalc = lower_recalc

						lower_recalc = click_point

						point_menu . add_divider()

						message_add_parameter( recalc_mess, lower_recalc )
						message_add_parameter( recalc_mess, upper_recalc )

						recalc_mess_txt = message_get_text( recalc_mess, 1 )
						point_menu . add_item( recalc_mess_txt )

					ENDIF

				ENDIF

			ENDIF
			
		ENDIF

		IF ( ( sqc_chart . selected_chart = PROC_CAP )   OR
		     ( sqc_chart . selected_chart = CUSUM    )   OR
		     ( sqc_chart . selected_chart = IND_MR   ) ) THEN

			point_menu . add_divider()

			point_menu . add_item( 
			GET_USER_MESSAGE( "GRAPH_RMB_MENU_SAMP_PROPERTY", 1 ) )
			
		ELSE

			point_menu . add_divider()

			point_menu . add_item(
			GET_USER_MESSAGE( "GRAPH_RMB_MENU_SAMP_EXPLORE", 1 ) )

		ENDIF

		point_choice = point_menu . start()

		IF ( point_choice = 
		     GET_USER_MESSAGE( "GRAPH_RMB_MENU_SAMP_EXPLORE", 1 ) ) THEN

			self . parent_prompt . reset_lower_recalc_point()

			self . parent_prompt . reset_lower_recalc_graph()

			subgroup_sample_details( sqc_chart, click_point )

		ELSEIF( point_choice = 
		        GET_USER_MESSAGE( "GRAPH_RMB_MENU_SAMP_PROPERTY", 1 ) ) THEN

			self . parent_prompt . reset_lower_recalc_point()

			self . parent_prompt . reset_lower_recalc_graph()

			point_sample_details( sqc_chart, click_point )

		ELSEIF( ( point_choice = 
		          GET_USER_MESSAGE( "GRAPH_RMB_MENU_SUBGROUP_COMMENT", 1 ) ) OR
		        ( point_choice = 
		          GET_USER_MESSAGE( "GRAPH_RMB_MENU_POINT_COMMENT", 1 )  ) ) THEN

			self . parent_prompt . reset_lower_recalc_point()

			self . parent_prompt . reset_lower_recalc_graph()

			show_subgroup_comment( sqc_chart, click_point )

		ELSEIF( ( point_choice = 
		          GET_USER_MESSAGE( "GRAPH_RMB_MENU_GOOD_SUBGROUP" , 1 ) ) OR
		        ( point_choice = 
		          GET_USER_MESSAGE( "GRAPH_RMB_MENU_GOOD_POINT" , 1 )    )  ) THEN

			self . parent_prompt . reset_lower_recalc_point()

			self . parent_prompt . reset_lower_recalc_graph()

			set_subgroup_good( sqc_chart, click_point, graph_num )

			do_shewhart_calculations ( sqc_chart ,
						   sqc_chart . selected_chart )

			draw_graph ( sqc_chart                  ,
				     sqc_chart . selected_graph ,
				     FALSE                      ,
				     self . parent_prompt       )

		ELSEIF( ( point_choice = 
		          GET_USER_MESSAGE( "GRAPH_RMB_MENU_BAD_SUBGROUP" , 1 )  ) OR
		        ( point_choice = 
		          GET_USER_MESSAGE( "GRAPH_RMB_MENU_BAD_POINT" , 1 )  ) ) THEN

			self . parent_prompt . reset_lower_recalc_point()

			self . parent_prompt . reset_lower_recalc_graph()

			set_subgroup_bad( sqc_chart, click_point, graph_num )

			do_shewhart_calculations ( sqc_chart ,
						   sqc_chart . selected_chart )

			draw_graph ( sqc_chart                  ,
				     sqc_chart . selected_graph ,
				     FALSE                      ,
				     self . parent_prompt       )

		ELSEIF( point_choice = 
		        GET_USER_MESSAGE( "GRAPH_RMB_MENU_SET_START_RECALC", 1 ) ) THEN

			self . parent_prompt . set_lower_recalc_point( click_point )

			self . parent_prompt . set_lower_recalc_graph( graph_num )
		
		ELSEIF( point_choice = recalc_mess_txt ) THEN
		
			display_seg = TRUE

			self . parent_prompt . reset_lower_recalc_point()

			self . parent_prompt . reset_lower_recalc_graph()

			calculate_limits_and_trends ( sqc_chart                  ,
						      sqc_chart . selected_chart ,
						      lower_recalc               ,
						      upper_recalc               ,
						      display_seg                )

			draw_graph ( sqc_chart                  ,
				     sqc_chart . selected_graph ,
				     FALSE                      ,
				     self . parent_prompt       )

		ELSEIF( point_choice =
		        GET_USER_MESSAGE( "GRAPH_RMB_MENU_SUBGROUP_COMMENT_ADD", 1 ) ) THEN

			self . parent_prompt . reset_lower_recalc_point()

			self . parent_prompt . reset_lower_recalc_graph()
			
			message_fetch( "GRAPH_RMB_MENU_SUBGROUP_COMMENT_ADD_NUM" ,
			               comment_header_mess                       )

			message_add_parameter( comment_header_mess ,
			                       STRIP( STRING( click_point ) ) )
		        IF ( prompt_for_text_with_default ( 
		             message_get_text( comment_header_mess, 1 )                         , 
		             GET_USER_MESSAGE( "GRAPH_RMB_MENU_COMMENT_WINDOW_PROMPT_TEXT", 1 ) ,
                                                            20                                  ,
                                                            comment_text                        ) ) THEN

				set_subgroup_comment( sqc_chart    ,
						      click_point  ,
						      comment_text )

			ENDIF

	        ELSEIF( point_choice =
		        GET_USER_MESSAGE( "GRAPH_RMB_MENU_POINT_COMMENT_ADD", 1    ) ) THEN
		
		
			self . parent_prompt . reset_lower_recalc_point()

			self . parent_prompt . reset_lower_recalc_graph()


			message_fetch( "GRAPH_RMB_MENU_POINT_COMMENT_ADD_NUM" ,
			               comment_header_mess                       )

			message_add_parameter( comment_header_mess ,
			                       STRIP( STRING( click_point ) ) )
		        IF ( prompt_for_text_with_default (  
		             message_get_text( comment_header_mess, 1 )                         , 
		             GET_USER_MESSAGE( "GRAPH_RMB_MENU_COMMENT_WINDOW_PROMPT_TEXT", 1 ) ,
                                                            20                                  ,
                                                            comment_text                        ) ) THEN

				set_subgroup_comment( sqc_chart    ,
						      click_point  ,
						      comment_text )

			ENDIF

		ELSEIF( point_choice =
		        GET_USER_MESSAGE( "GRAPH_RMB_MENU_SUBGROUP_COMMENT_MOD", 1 ) ) THEN


			self . parent_prompt . reset_lower_recalc_point()

			self . parent_prompt . reset_lower_recalc_graph()


			message_fetch( "GRAPH_RMB_MENU_SUBGROUP_COMMENT_MOD_NUM" ,
			               comment_header_mess                       )

			message_add_parameter( comment_header_mess ,
			                       STRIP( STRING( click_point ) ) )

		        IF ( prompt_for_text_with_default (  
		             message_get_text( comment_header_mess, 1 )                         , 
		             GET_USER_MESSAGE( "GRAPH_RMB_MENU_COMMENT_WINDOW_PROMPT_TEXT", 1 ) ,
                                                            20                                  ,
                                                            comment_text                        ) ) THEN

				set_subgroup_comment( sqc_chart    ,
						      click_point  ,
						      comment_text )

			ENDIF

		ELSEIF( point_choice =
		        GET_USER_MESSAGE( "GRAPH_RMB_MENU_POINT_COMMENT_MOD", 1    ) ) THEN

			self . parent_prompt . reset_lower_recalc_point()

			self . parent_prompt . reset_lower_recalc_graph()


			message_fetch( "GRAPH_RMB_MENU_POINT_COMMENT_ADD_NUM" ,
			               comment_header_mess                       )

			message_add_parameter( comment_header_mess ,
			                       STRIP( STRING( click_point ) ) )
		        IF ( prompt_for_text_with_default (  
		             message_get_text( comment_header_mess, 1 )                         , 
		             GET_USER_MESSAGE( "GRAPH_RMB_MENU_COMMENT_WINDOW_PROMPT_TEXT", 1 ) ,
                                                            20                                  ,
                                                            comment_text                        ) ) THEN

				set_subgroup_comment( sqc_chart    ,
						      click_point  ,
						      comment_text )

			ENDIF

		ELSEIF( point_choice =
		        GET_USER_MESSAGE( "GRAPH_RMB_MENU_SOURCE_COMMENT", 1 ) ) THEN

			self . parent_prompt . reset_lower_recalc_point()

			self . parent_prompt . reset_lower_recalc_graph()

			show_point_comment( sqc_chart, click_point )

		ELSEIF( point_choice =
		        GET_USER_MESSAGE( "GRAPH_RMB_MENU_SOURCE_COMMENTS", 1 ) ) THEN

			self . parent_prompt . reset_lower_recalc_point()

			self . parent_prompt . reset_lower_recalc_graph()

			show_points_comments( sqc_chart, click_point )

		ELSE

			self . parent_prompt . reset_lower_recalc_point()

			self . parent_prompt . reset_lower_recalc_graph()

		ENDIF

	ENDIF

ENDROUTINE

{******************************************************************************}

ROUTINE subgroup_sample_details( sqc_chart, selected_point )

{ 
* Displays details of sample associated with the selected point 
* on the graph.
* 
*
* Parameters   : sqc_chart, selected_point
* Return Value : n/a
*
*******************************************************************************}

DECLARE samp_view_array

	ARRAY samp_view_array

	build_samp_sel_array( sqc_chart, selected_point, samp_view_array )

	view_subgroup_samples( samp_view_array )

ENDROUTINE

{******************************************************************************}

ROUTINE get_real_point_num( sqc_chart, clicked_point, graph_num )

{
* Takes a selected point on the graph screen and converts it to the
* subgroup/source point number that was used to produce that point.
* This is needed due to bad points being plotted after good points.
*
* N.B. This assumes that the clicked_point number has, already, been
* converted to one within the range of the graph alread i.e. that the
* routine get_graph_num has been called first.
* 
*
* Parameters   : sqc_chart, point_num
* Return Value : real_point_num
*
*******************************************************************************}

DECLARE real_point_num, graph_array, counter, active_graph, continue, 
        num_graphs, good_points, bad_points, current_win_obj,
	win_obj_count, num_win_objs, total_point_count

	active_graph = find_active_graph( sqc_chart, graph_num )

	graph_array = sqc_chart . graph_object_array

	num_graphs = sqcwin_array_size( graph_array )

	IF ( ( num_graphs > 0 ) AND ( active_graph <> EMPTY ) )THEN

		continue = TRUE

	ELSE 
		continue = FALSE

	ENDIF

	counter = 1

	WHILE continue DO

		IF graph_array[ counter ] . graph_type = active_graph THEN

			continue = FALSE

		ELSE

			counter = counter + 1

			IF counter > num_graphs THEN

				continue = FALSE

			ENDIF
		ENDIF

	ENDWHILE

	IF ( active_graph <> EMPTY ) THEN

		total_point_count = 0

		num_win_objs = sqcwin_array_size( graph_array[ counter ] . win_obj_array )
		
		win_obj_count = 1

		continue = TRUE
		
		WHILE continue DO

			IF num_win_objs = 0 THEN
			
				current_win_obj = 
				graph_array[ counter ]			
			ELSE
			
				current_win_obj = 
				graph_array[ counter ] . win_obj_array[ win_obj_count ]
			
			ENDIF
		
			good_points = sqcwin_array_size( current_win_obj . x_points )

			total_point_count = total_point_count + good_points

			IF ( clicked_point <= total_point_count ) THEN

				real_point_num = 
				current_win_obj . x_points[ 
				( clicked_point - total_point_count + good_points ) ]

				continue = FALSE

			ELSE

				bad_points = sqcwin_array_size( current_win_obj . x_bad )

				total_point_count = total_point_count + bad_points

				IF ( clicked_point <= total_point_count ) THEN

					real_point_num = 
					current_win_obj . x_bad[ 
					( clicked_point - total_point_count + bad_points ) ]

					continue = FALSE

				ENDIF
			ENDIF

			win_obj_count = win_obj_count + 1

			IF win_obj_count > num_win_objs THEN

				continue = FALSE

			ENDIF

		ENDWHILE
 
	ELSE

		real_point_num = clicked_point

	ENDIF

	real_point_num = TRUNC( real_point_num )
	RETURN( real_point_num )

ENDROUTINE


{******************************************************************************}

ROUTINE view_subgroup_samples( selection_array )
{ 
* 
* Builds a list viewer for the samples in the select array (derived from
* selected sub group )
*
* Parameters   : selection_array
* Return Value : n/a
*
*******************************************************************************}

DECLARE viewer

	define_list_viewer_class()

	CREATE OBJECT LIST_VIEWER_CLASS, viewer

	viewer . header           = "Samples Info"
	viewer . autosize         = TRUE
	viewer . height           = 10
	viewer . width            = 50
	viewer . auto_status_icon = TRUE
	viewer . menu_columns     = TRUE
	viewer . menu_criteria    = TRUE
	viewer . menu_labtable    = FALSE
	viewer . menu_view        = TRUE
	viewer . show_removed     = FALSE
	viewer . criteria         = selection_array
	viewer . table            = "SAMPLE"
	viewer . display_only     = TRUE

	viewer . auto_user_table_cols ( "SAMPLE" )

	viewer . go ()
	
ENDROUTINE

{******************************************************************************}

ROUTINE build_samp_sel_array( sqc_chart, group_num, samp_view_array )
{ 
* Builds a selection array of sample ids based on the passed subgroup 
* number
* 
*
* Parameters   : sqc_chart, group_num, high_samp, low_samp
* Return Value : n/a
*
*******************************************************************************}

DECLARE sel_samp, current_row, remove_row, first_point, group_size, 
        continue, sel_point, counter


	get_point_and_size( sqc_chart, group_num, first_point, group_size)

	sqc_chart . sqc_point . set_first()

	current_row = sqc_chart . sqc_point . current

	IF ( ( first_point + group_size > 1 )   AND
	     ( current_row <> EMPTY         ) ) THEN

		continue = TRUE

	ELSE

		continue = FALSE

	ENDIF

	WHILE continue DO

		sel_point = SELECT sqcwin_point . point_number
		            IN OBJECT current_row

		IF sel_point = first_point THEN

			continue = FALSE

		ELSE

			sqc_chart . sqc_point . set_next()
			
			current_row = sqc_chart . sqc_point . current

			IF current_row = EMPTY THEN

				continue = FALSE

			ENDIF

		ENDIF

	ENDWHILE

	IF ( current_row <> EMPTY ) THEN
	
		continue = TRUE

	ELSE

		continue = FALSE

	ENDIF

	counter = 1

	WHILE continue DO

		sel_samp = SELECT sqcwin_point . sample_id
			   IN OBJECT current_row

		array_select_add( samp_view_array  ,
				  ARRAY_SELECT_EQ  ,
				  "ID_NUMERIC"     ,
				  sel_samp         )

		array_select_add( samp_view_array ,
				  ARRAY_SELECT_OR ,
				  ""              ,
				  ""              )

		counter = counter + 1

		sqc_chart . sqc_point . set_next()

		current_row = sqc_chart . sqc_point . current

		IF ( ( current_row = EMPTY )    OR
		     ( counter > group_size ) ) THEN

		     continue = FALSE

		ENDIF

	ENDWHILE

	remove_row = sqcwin_array_size( samp_view_array )

	array_remove_slice( samp_view_array, 1, remove_row )

	array_select_add( samp_view_array        , 
			  ARRAY_SELECT_ORDER     ,
			  "ID_NUMERIC"           ,
			  ARRAY_SELECT_ASCENDING )

ENDROUTINE
{******************************************************************************}

ROUTINE point_sample_details( sqc_chart, chosen_point )
{ 
* Displays the property sheet for the sample associated with the chosen point.
* 
* 
*
* Parameters   : sqc_chart, chosen_point
* Return Value : n/a
*
*******************************************************************************}


 DECLARE samp_odb, select_array, chosen_samp, property

	chosen_samp = get_samp_id_for_point( sqc_chart, chosen_point )

	CREATE OBJECT "STD_OBJECT_DATABASE" , samp_odb
 	
 	samp_odb . initialise ( "SAMPLE" )
 	
 	ARRAY select_array
 	
 	array_select_add ( select_array    ,
 	                   ARRAY_SELECT_EQ ,
 	                   "ID_NUMERIC"    ,
 	                   chosen_samp     )
 	
 	samp_odb . select ( select_array )
 

	CREATE OBJECT PROPERTY_SHEET_EX_CLASS, property

	property . display_only = TRUE

	property . initialise()

	property . container = samp_odb

	property . automatic()

	property . go()
  	
	
ENDROUTINE

{******************************************************************************}

ROUTINE get_samp_id_for_point( sqc_chart, chosen_point )

{ 
* Returns the sample id_numeric for the chosen_point. 
* 
* 
*
* Parameters   : sqc_chart, chosen_point
* Return Value : sample_id
*
*******************************************************************************}

DECLARE point_num_txt, sample_id

        sample_id = 0
        
        point_num_txt = STRIP(STRING(chosen_point))
        point_num_txt = PAD(point_num_txt," ",6)
        point_num_txt = JUSTIFY(point_num_txt,"RIGHT")

	sqc_chart . sqc_point . add_index( "point_number" )
	sqc_chart . sqc_point . set_by_index( "point_number", point_num_txt )

	IF sqc_chart . sqc_point . current <> EMPTY THEN

		sample_id = SELECT sqcwin_point . sample_id
		            IN OBJECT sqc_chart . sqc_point . current

	ENDIF

	RETURN( sample_id )
	
ENDROUTINE
{******************************************************************************}

ROUTINE get_point_and_size( sqc_chart, group_num, first_point, group_size)

{ 
* Given the selected subgroup number, this routine will return the first
* point in that subgroup and the number of points in the subgroup.
* 
*
* Parameters   : sqc_chart, group_num
* Return Value : n/a
*
*******************************************************************************}

DECLARE group_num_txt, current_row, key_field

	group_num_txt = STRIP(STRING(group_num))
        group_num_txt = PAD(group_num_txt," ",4)
        group_num_txt = JUSTIFY(group_num_txt,"RIGHT")

	key_field = PAD ( sqc_chart . chart_id      , " ", "20" ) :
		    PAD ( sqc_chart . selected_chart, " ", "10" ) :
		    group_num_txt

	current_row = sqc_chart . sqc_subgroup .  get_by_index ( "KEY0" , key_field )

	IF current_row <> EMPTY THEN

		first_point = SELECT sqcwin_subgroup . first_point
			      IN OBJECT current_row

		group_size = SELECT sqcwin_subgroup . subgroup_size
			     IN OBJECT current_row

	ELSE

		first_point = 0
		group_size = 0

	ENDIF

ENDROUTINE
{******************************************************************************}

ROUTINE show_subgroup_comment( sqc_chart, subgroup )
{ 
* Shows the comment assocaited with the subgroup selected on the graph
* 
* 
*
* Parameters   : sqc_chart, subgroup
* Return Value : n/a
*
*******************************************************************************}

DECLARE sel_key, current_row, comment_text

	sel_key = PAD ( sqc_chart . chart_id      , " ", "20" ) :
		  PAD ( sqc_chart . selected_chart, " ", "10" ) :
	 JUSTIFY ( PAD ( STRIP ( subgroup ), " ", "4" ), "RIGHT" )


	current_row = sqc_chart . sqc_subgroup . get_by_index( "KEY0", sel_key )
	
	
	IF ( current_row <>  EMPTY ) THEN

		comment_text = SELECT sqcwin_subgroup . comments
			       IN OBJECT current_row

		flash_message( comment_text, TRUE )

	ENDIF

ENDROUTINE
		
{******************************************************************************}

ROUTINE show_point_comment( sqc_chart, point_num )

{ 
* Returns the comment for the source data point referred to by point_num
* 
* 
*
* Parameters   : sqc_chart, point_num
* Return Value : n/a
*
*******************************************************************************}

DECLARE sel_key, comment_text, current_row, buttons, header_mess,
        header_text, header_length

	sel_key = PAD ( sqc_chart . chart_id      , " ", "20" ) :
	          JUSTIFY ( PAD ( STRIP ( point_num ), " ", "6" ), "RIGHT" )


	current_row = sqc_chart . sqc_point . get_by_index( "KEY0", sel_key )
	
	IF ( current_row <>  EMPTY ) THEN

		comment_text = SELECT sqcwin_point . comments
			       IN OBJECT current_row

		comment_text = STRIP( comment_text )

		IF( NOT BLANK( comment_text ) ) THEN

			buttons = MB_OK + MB_ICONINFORMATION

			message_fetch( "GRAPH_RMB_MENU_SOURCE_COMMENT_NUM" ,
				       header_mess                       )

			message_add_parameter( header_mess ,
					       STRIP( STRING( point_num ) ) )

			header_text = message_get_text( header_mess, 1 )

			header_length = STRINGLENGTH( header_text )

			IF ( header_length > STRINGLENGTH( comment_text ) ) THEN

				comment_text = PAD( comment_text, " ", header_length )

			ENDIF

			client_message_box ( comment_text , header_text , buttons )

		ENDIF

	ENDIF

ENDROUTINE

{******************************************************************************}

ROUTINE show_points_comments( sqc_chart, point_num )

{ 
* Shows the comments for the source data points associated with the
* selected graph point.
* 
*
* Parameters   : 
* Return Value : n/a
*
*******************************************************************************}

DECLARE first_point, group_size, last_point

	get_point_and_size( sqc_chart, point_num, first_point, group_size)

	last_point = first_point + group_size - 1

	comments (sqc_chart , "SOURCE", TRUE, first_point, last_point )

ENDROUTINE

{******************************************************************************}

ROUTINE get_subgroup_row( sqc_chart, group_num )

{ 
* Return the appropriate row from sqcwin_subgroup based on the chart 
* details and the subgroup number.
* 
*
* Parameters   : sqc_chart, group_num
* Return Value : current_row
*
*******************************************************************************}

DECLARE group_num_txt, current_row, key_field

	group_num_txt = STRIP(STRING(group_num))
        group_num_txt = PAD(group_num_txt," ",4)
        group_num_txt = JUSTIFY(group_num_txt,"RIGHT")

	key_field = PAD ( sqc_chart . chart_id      , " ", "20" ) :
		    PAD ( sqc_chart . selected_chart, " ", "10" ) :
		    group_num_txt

	current_row = sqc_chart . sqc_subgroup .  get_by_index ( "KEY0" , key_field )

	RETURN( current_row )

ENDROUTINE

{******************************************************************************}

ROUTINE get_subgroup_comment( sqc_chart, group_num )

{ 
* Returns the comment text from the appropriate row in sqcwin_subgroup
* 
* 
*
* Parameters   : sqc_chart, group_num
* Return Value : comment_text
*
*******************************************************************************}

DECLARE current_row, comment_text

	current_row = get_subgroup_row( sqc_chart, group_num )

	IF ( current_row <> EMPTY ) THEN

		comment_text = SELECT sqcwin_subgroup . comments
		               IN OBJECT current_row

	ELSE

		comment_text = ""

	ENDIF

	RETURN( comment_text )

ENDROUTINE 

{******************************************************************************}

ROUTINE set_subgroup_comment( sqc_chart, group_num, comment_text )

{ 
* Assigns comment text in the appropriate row in sqcwin_subgroup
* 
* 
*
* Parameters   : sqc_chart, group_num, comment_text
* Return Value : status
*
*******************************************************************************}

DECLARE current_row, status

	current_row = get_subgroup_row( sqc_chart, group_num )

	IF ( current_row <> EMPTY ) THEN

		ASSIGN sqcwin_subgroup . comments 
		IN OBJECT current_row = comment_text

		status = TRUE

	ELSE

		status = FALSE

	ENDIF

	RETURN( status )

ENDROUTINE 

{******************************************************************************}

ROUTINE set_subgroup_status( sqc_chart, group_num, graph_num, VALUE is_bad )

{ 
* Sets either a_bad_manual or b_bad_manual to either true or false. 
* 
* 
*
* Parameters   : sqc_chart, group_num, graph_num, is_bad
* Return Value : return_status
*
*******************************************************************************}

DECLARE return_status, current_row

	current_row = get_subgroup_row( sqc_chart, group_num )

	IF ( current_row <> EMPTY ) THEN

		IF graph_num = 1 THEN

			ASSIGN sqcwin_subgroup . a_bad_manual 
			IN OBJECT current_row = is_bad

			return_status = TRUE

		ELSEIF graph_num = 2

			ASSIGN sqcwin_subgroup . b_bad_manual 
			IN OBJECT current_row = is_bad

			return_status = TRUE

		ELSE

			return_status = FALSE

		ENDIF

	ELSE

		return_status = FALSE

	ENDIF

	RETURN( return_status )

ENDROUTINE 

{******************************************************************************}

ROUTINE set_subgroup_bad( sqc_chart, group_num, graph_num )

{ 
* Sets the a_bad_manual or b_bad_manual status to TRUE in the appropriate
* row in sqcwin_subgroup
* 
*
* Parameters   : sqc_chart, group_num, graph_num
* Return Value : status
*
*******************************************************************************}

DECLARE status

	IF ( set_subgroup_status( sqc_chart, group_num, graph_num, TRUE ) ) THEN

		status = TRUE

	ELSE

		status = FALSE

	ENDIF

	RETURN( status )

ENDROUTINE 

{******************************************************************************}

ROUTINE set_subgroup_good( sqc_chart, group_num, graph_num )

{ 
* Sets the a_bad_manual or b_bad_manual status to FALSE in the appropriate
* row in sqcwin_subgroup
* 
*
* Parameters   : sqc_chart, group_num, graph_num
* Return Value : status
*
*******************************************************************************}

DECLARE status

	IF ( set_subgroup_status( sqc_chart, group_num, graph_num, FALSE ) ) THEN

		status = TRUE

	ELSE

		status = FALSE

	ENDIF

	RETURN( status )

ENDROUTINE 

{******************************************************************************}

ROUTINE is_subgroup_bad( sqc_chart, group_num, graph_num )

{ 
* Returns the status of a_bad_manual or b_bad_manual from the appropriate
* row in sqcwin_subgroup.
* 
*
* Parameters   : sqc_chart, group_num, graph_num
* Return Value : is_bad
*
*******************************************************************************}

DECLARE is_bad, current_row

	is_bad = EMPTY
		
	current_row = get_subgroup_row( sqc_chart, group_num )

	IF ( current_row <> EMPTY ) THEN

		IF graph_num = 1 THEN

			is_bad = SELECT sqcwin_subgroup . a_bad_manual 
			         IN OBJECT current_row

		ELSEIF graph_num = 2 THEN

			is_bad = SELECT sqcwin_subgroup . b_bad_manual
			         IN OBJECT current_row

		ENDIF

	ENDIF

	RETURN( is_bad )

ENDROUTINE

{******************************************************************************}

ROUTINE get_graph_num(sqc_chart, point_num, graph_num)
{ 
* For the given sqc_chart and point information works out whether the currently
* selected point is on graph a or graph b of a shewhart chart. 
* 
*
* Parameters   : sqc_chart, point_num, graph_num
* Return Value : n/a
*
*******************************************************************************}

	IF sqc_chart . selected_chart = MEAN_RANGE THEN

		IF sqc_chart . selected_graph = MEAN_RANGE_GR THEN

			check_point_num(sqc_chart, graph_num, point_num, MEAN_R_GR)

		ELSEIF sqc_chart . selected_graph = MEAN_R_GR THEN

			graph_num = 1

		ELSEIF sqc_chart . selected_graph = RANGE_GR THEN

			graph_num = 2

		ENDIF

	ELSEIF sqc_chart . selected_chart = MEAN_STD


		IF sqc_chart . selected_graph = MEAN_STD_GR THEN

			check_point_num(sqc_chart, graph_num, point_num, MEAN_S_GR)

		ELSEIF sqc_chart . selected_graph = MEAN_S_GR THEN

			graph_num = 1

		ELSEIF sqc_chart . selected_graph = STD_GR THEN

			graph_num = 2

		ENDIF

	ELSEIF sqc_chart . selected_chart = IND_MR

		IF sqc_chart . selected_graph = IND_MR_GR THEN

			check_point_num(sqc_chart, graph_num, point_num, IND_GR)

		ELSEIF sqc_chart . selected_graph = IND_GR THEN

			graph_num = 1

		ELSEIF sqc_chart . selected_graph = MR_GR THEN

			graph_num = 2

		ENDIF

	ELSE

		graph_num = 1

	ENDIF

ENDROUTINE

{******************************************************************************}

ROUTINE check_point_num(sqc_chart, graph_num, point_num, VALUE graph_type)

{ 
* 
* 
* 
*
* Parameters   : 
* Return Value : n/a
*
*******************************************************************************}

DECLARE continue, graph_array, num_graph_a_points, num_graphs, counter

	graph_array = sqc_chart . graph_object_array

	num_graphs = sqcwin_array_size( graph_array )

	IF num_graphs > 0 THEN

		continue = TRUE

	ELSE

		continue = FALSE

	ENDIF

	counter = 1

	WHILE continue DO

		IF graph_array[ counter ] . graph_type = graph_type THEN

			num_graph_a_points = graph_array[ counter ] . no_x

			continue = FALSE

		ELSE

			counter = counter + 1

			IF counter > num_graphs THEN

				continue = FALSE

			ENDIF

		ENDIF

	ENDWHILE

	IF point_num > num_graph_a_points THEN

		point_num = point_num - num_graph_a_points

		graph_num = 2

	ELSE

		graph_num = 1

	ENDIF


ENDROUTINE

{******************************************************************************}

ROUTINE find_active_graph(sqc_chart, graph_num)

{ 
* Returns the the graph that the user is selecting points for. Routine 
* get_graph_num should have been calle prior to calling this routine 
* in order to ensure graph_num has the correct value.
* 
*
* Parameters   : sqc_chart, graph_num
* Return Value : active_graph
*
*******************************************************************************}

DECLARE active_graph

	active_graph = EMPTY

	IF sqc_chart . selected_chart = MEAN_RANGE THEN

	
		IF sqc_chart . selected_graph = MEAN_RANGE_GR THEN

			IF graph_num = 1

				active_graph = MEAN_R_GR

			ELSE	
				active_graph = RANGE_GR

			ENDIF

		ELSE

			active_graph = sqc_chart . selected_graph

		ENDIF

	ELSEIF sqc_chart . selected_chart = MEAN_STD THEN

		IF sqc_chart . selected_graph = MEAN_STD_GR THEN

			IF graph_num = 1 THEN

				active_graph = MEAN_S_GR

			ELSE

				active_graph = STD_GR

			ENDIF

		ELSE

			active_graph = sqc_chart . selected_graph

		ENDIF

	ELSEIF sqc_chart . selected_chart = IND_MR THEN

		IF sqc_chart . selected_graph = IND_MR_GR THEN

			IF graph_num = 1 THEN

				active_graph = IND_GR

			ELSE

				active_graph = MR_GR

			ENDIF

		ELSE

			active_graph = sqc_chart . selected_graph

		ENDIF

	ELSEIF sqc_chart . selected_chart = CUSUM THEN

			active_graph = sqc_chart . selected_graph
			
	ENDIF

	RETURN( active_graph )

ENDROUTINE

{******************************************************************************}

ROUTINE set_level_prompt_value( sqc_chart, level_prompt, levels_array )

{ 
* 
* 
* 
*
* Parameters   : level_prompt
* Return Value : n/a
*
*******************************************************************************}

DECLARE level_id, counter, num_levels

	level_id = default_line_display ( sqc_chart, level_prompt . user_info )

	level_id = STRIP( level_id )

	num_levels = sqcwin_array_size( levels_array )

	counter = 1

	WHILE ( counter <= num_levels ) DO

		IF( level_id = STRIP( levels_array[ counter, 1 ] ) ) THEN

			level_prompt . value = levels_array[ counter, 2 ]
			
			level_prompt . set_text( level_prompt . value )

			counter = num_levels + 1

		ELSE
	
			counter = counter + 1 

		ENDIF

	ENDWHILE

ENDROUTINE

{******************************************************************************}

ROUTINE level_initialise( limits_form, VALUE a_or_b )

{ 
* This routine calls the mlp_level selected routine to initialise the
* the upper and lower prompt values properly.
* 
*
* Parameters   : limits_form, a_or_b
* Return Value : n/a
*
*******************************************************************************}

DECLARE mlp_prompt

	IF ( a_or_b = 1 ) THEN

		get_prompt( limits_form . prompt_objects ,
		            "mlp_level_a", mlp_prompt    )

	ELSEIF( a_or_b = 2 ) THEN

		get_prompt( limits_form . prompt_objects ,
		            "mlp_level_b", mlp_prompt    )

	ENDIF

	mlp_limits_selected( mlp_prompt )

ENDROUTINE

{******************************************************************************}
ROUTINE get_chart_type_row( sqc_chart )

{ 
* Return the appropriate row from sqcwin_chart_type based on the chart 
* details.
* 
*
* Parameters   : sqc_chart
* Return Value : current_row
*
*******************************************************************************}

DECLARE current_row, key_field

	key_field = PAD ( sqc_chart . chart_id      , " ", "20" ) :
		    PAD ( sqc_chart . selected_chart, " ", "10" )

	current_row = sqc_chart . sqc_chart_type .  get_by_index ( "KEY0" , key_field )

	RETURN( current_row )

ENDROUTINE

{******************************************************************************}
