{****************************************************************************
*
* Module Name   : LIT_AUTO_COMMIT.RPF
*
* Purpose       : Auto and Manual Commit/Archive processing
*
* Document Ref. :
*
* Specification :
*
* Portability   :
*
* Re-entrant    :
*
* Notes         :
*
******************************************************************************
*
* Modification History
*
* Version   Date        Author           Modify Details
* _________ ___________ _______________  _____________________________________
* 1.0       04JUL2007   LIT              Created
* LIT001    20Feb2008   LIT              prompts on LTE display only if previous field not set
* LIT002    20Feb2008   LIT              removed identity_full from write in action_write_criteria
*
******************************************************************************}

ENABLE WINDOWS

SET NAME "DEFER/"
SET NOTPROTECTED
SET COMPILE_OPTION DECLARE

JOIN STANDARD_LIBRARY STD_ARRAY
JOIN STANDARD_LIBRARY STD_ARRAY_SELECT
JOIN STANDARD_LIBRARY STD_BROWSE
JOIN STANDARD_LIBRARY STD_CLASS
JOIN STANDARD_LIBRARY STD_CLIENT
JOIN STANDARD_LIBRARY STD_DATABASE
JOIN STANDARD_LIBRARY STD_GENERAL
JOIN STANDARD_LIBRARY STD_PROMPT
JOIN STANDARD_LIBRARY STD_STRUCTURE
JOIN STANDARD_LIBRARY STD_USER_GLOBAL
JOIN STANDARD_LIBRARY STD_VGL
JOIN STANDARD_LIBRARY STD_WINDOW

JOIN LIBRARY $CRITERIA_SAVED
JOIN LIBRARY $CRITERIA_LIB
JOIN LIBRARY $DESKTOP

JOIN LIBRARY $LABTABLIB

JOIN LIBRARY $LIB_LIST_VIEWER
JOIN LIBRARY $LIB_UTILS
JOIN LIBRARY $LIB_LIST_CHOOSER

JOIN LIBRARY $LIST_EDITOR
JOIN LIBRARY $LIB_LIST_CHOOSER

JOIN LIBRARY $PROMPT_LIST
JOIN LIBRARY $PROMPT_SPLIT
JOIN LIBRARY $PROMPT_TREE
JOIN LIBRARY $PROMPT_WINDOW


{******************************************************************************
*
* GLOBAL Constants - must exist in config_header table
*
*******************************************************************************}

GLOBAL CONSTANT GLBL_COMMIT_VIEW_MODE          = "COMMIT_VIEW_MODE"         { global for which mode in  (std) }
GLOBAL CONSTANT GLBL_SETCOM_TABLE_SET_GLOBAL   = "COMMITTED_TABLE_SET"      { global set commit source  (std) }

GLOBAL CONSTANT GLBL_AUTO_COMMIT_ENABLE        = "AUTO_COMMIT_ENABLE"       { global boolean active or not    }
GLOBAL CONSTANT GLBL_AUTO_COMMIT_DEBUG_LEVEL   = "AUTO_COMMIT_DEBUG_LEVEL"  { global for debug level          }
GLOBAL CONSTANT GLBL_AUTO_COMMIT_MAX_COUNT     = "AUTO_COMMIT_MAX"          { global for max at one time      }
GLOBAL CONSTANT GLBL_AUTO_COMMIT_ARCHIVE_CSV   = "AUTO_COMMIT_ARCHIVE_CSV"  { global if csv for archives      }
GLOBAL CONSTANT GLBL_AUTO_COMMIT_ORACLE_TRACE  = "AUTO_COMMIT_ORACLE_TRACE" { global enable trace for tuning  }
GLOBAL CONSTANT GLBL_AUTO_COMMIT_SHORT_REPORT  = "AUTO_COMMIT_SHORT_REPORT" { global for short reports        }
GLOBAL CONSTANT GLBL_AUTO_COMMIT_CHECK_ALL     = "AUTO_COMMIT_CHECK_ALL"    { global check all tablesets      }
GLOBAL CONSTANT GLBL_AUTO_COMMIT_DISABLE_AUDIT = "AUTO_COMMIT_DISABLE_AUDIT"{ global disable auditing ArCom   }

GLOBAL CONSTANT GLBL_AUTO_COMMIT_SYSTEM        = "AUTO_COMMIT_SYSTEM"       { global disable auditing ArCom   }


{******************************************************************************
*
* CLASSes created and used
*
*******************************************************************************}


CONSTANT CLASS_AUTO_COMMIT                     = "ac_object"                  { main class for auto commit    }
CONSTANT CLASS_MESSAGES                        = "msg"                        { main class for messages       }
CONSTANT CLASS_STD_OLE_AUTOMATION_SERVER       = "STD_OLE_AUTOMATION_SERVER"  { class COM for FSO             }


{******************************************************************************
*
* LOCAL Constants
*
*******************************************************************************}

CONSTANT C_7ZA_EXE                             = "7za.exe"
CONSTANT C_7ZIP_ZIP_CREATE_CMD                 = " a "

CONSTANT C_MESSAGE_POINTERS                    = "LIT_MESSAGE_POINTERS"
CONSTANT C_SQL_TRACE_ON                        = "ALTER SESSION SET SQL_TRACE=TRUE"
CONSTANT C_SQL_TRACE_OFF                       = "ALTER SESSION SET SQL_TRACE=FALSE"

CONSTANT C_TRIGGER_LIBRARY                     = "LIT_AUTO_COMMIT_USER" { library for triggers                }

CONSTANT C_AUTO_COMMIT_VIEW                    = "AUTO_COMMIT_VIEW"     { view of active auto_commit_header's }
CONSTANT C_AUTO_COMMIT_BG_VIEW                 = "AUTO_COMMIT_BG_VIEW"  { view of WDT auto_commit_header's    }

CONSTANT C_ESIG_DATA_ALL_VIEW                  = "ESIG_DATA_ALL_VIEW"   { ghost esig's on partial commits     }
CONSTANT C_ESIG_DATA_ALL_VIEW_2                = "ESIG_DATA_ALL"

CONSTANT C_AUDIT_TRANS_ALL_VIEW                = "AUDIT_TRANSACTION_ALL_VIEW"   { ghost audits                }
CONSTANT C_AUDIT_TRANS_ALL_VIEW_2              = "AUDIT_VIEW_ALL"

CONSTANT C_MLP_EXPORT_ID                       = "PDS_PROTO_MLP"

    { ------------------------------------------------------------- }
    { Statuses on batch tables for conditions to allow              }
    { ------------------------------------------------------------- }

CONSTANT C_PROTO_TYPES                         = "#GLOBAL#EXT#"         { Allowed proto types for arcom       }
CONSTANT C_PDS_STATUS                          = "FX"                   { check condition statuses on pds     }
CONSTANT C_JOB_STATUS                          = "AX"                   { check condition on jobs             }
CONSTANT C_STANDARD_STATUSES                   = "BX"                   { check condition standard versions   }
CONSTANT C_BATCH_STATUSES                      = "AX"                   { check conditions on batches         }
CONSTANT C_COA_STATUSES                        = "AX"                   { check conditions on COA             }
CONSTANT C_WORKSHEET_STATUS                    = "CX"                   { check conditions on Anal WKS        }
CONSTANT C_SAMPLE_STATUSES                     = "AX"                   { check conditions sample             }

CONSTANT C_REPORT_MODE                         = "REPORTING"            { Master menu only do report          }
CONSTANT C_TABLESET_ACTIVE                     = "ACTIVE"               { the active database                 }
CONSTANT C_TABLESET_ARCHIVE                    = "ARCHIVE"              { take out of the database            }
CONSTANT C_TABLESET_DELETE                     = "DELETE"               { REALLY take out of the database     }
CONSTANT C_TABLESET_REMOVE                     = "REMOVE"               { set removeflag on static data       }
CONSTANT C_TABLESET_RETAIN                     = "RETAIN"               { special can only be desconsign      }
CONSTANT C_TABLESET_COMMIT                     = "COMMIT"               { on line tablesets                   }
CONSTANT C_TABLESET_COMMIT_MOVE                = "COMMIT_MOVE"          { on line tablesets                   }
CONSTANT C_TABLESET_EXPORT                     = "EXPORT"               { COPY the database for export        }
CONSTANT C_COMMIT_MODE_DECONSIGN               = "DECONSIGN"            { on line tablesets                   }
CONSTANT C_REMOVE_FLAG                         = "REMOVE"               { remove static data                  }
CONSTANT C_DELETE_FLAG                         = "DELETE"               { remove then delete static           }
CONSTANT C_EXPORT_FLAG                         = "EXPORT"               { only do CSV archive of data         }
CONSTANT C_EXPORT_PREFIX                       = "EXPORTGLB_"           { prefix (smp_version) for import data}

    { ------------------------------------------------------------- }
    { Tableset types determine what can go to where                 }
    { ------------------------------------------------------------- }

CONSTANT C_CRITERIA_PREFIX                     = "AC"                   { ease of migrate criteria            }
CONSTANT C_ACTIVE_TABLESET                     = "ACTIVE"               { SMP Active tables                   }
CONSTANT C_ARCHIVE_TABLESET                    = "ARCHIVE_TABLE_SET"    { Default archive table set id        }
CONSTANT C_COMMIT_TABLESET                     = "DEFAULT_TABLE_SET"    { Default commit table set id         }
CONSTANT C_RETAIN_TABLESET                     = "RETENTION"            { Special retain cannot archive       }
CONSTANT C_DELETE_TABLESET                     = "DELETE"               { Dummy tableset when deleting data   }

    { ------------------------------------------------------------- }
    { Fields that are on archived base tables                       }
    { ------------------------------------------------------------- }

CONSTANT C_CONSIGN_ID                          = "CONSIGN_ID"           { field name required on base tables  }
CONSTANT C_CONSIGN_SEQUENCE                    = "CONSIGN_SEQUENCE"     { field name required on base tables  }
CONSTANT C_CONSIGN_DATE                        = "CONSIGN_DATE"         { field name required on base tables  }

CONSTANT C_ACE_LOGFILE_TRANSACTION             = "AutoCommitLogFile"    { transaction id for log/report       }

CONSTANT C_STD_OBJECT_DATABASE                 = "STD_OBJECT_DATABASE"  { object database                     }
CONSTANT C_VIEW_OBJECT_DATABASE                = "VIEW_OBJECT_DATABASE" { view object database                }

    { ------------------------------------------------------------- }
    { Menuproc mnemonics for interactive list review                }
    { ------------------------------------------------------------- }

CONSTANT C_MENU_JOB_HEADER_DISPLAY             = "DJS"                  { menu proc mnemonic's                }
CONSTANT C_MENU_PDS_STUDY_DISPLAY              = "DSD"                  { menu proc mnemonic's                }
CONSTANT C_MENU_PDS_PROTO_DISPLAY              = "DPC"                  { menu proc mnemonic's                }
CONSTANT C_MENU_MLP_HEADER_DISPLAY             = "DMP"                  { menu proc mnemonic's                }
CONSTANT C_MENU_ANALYSIS_DISPLAY               = "DAL"                  { menu proc mnemonic's                }
CONSTANT C_MENU_STANDARD_DISPLAY               = "DSN"                  { menu proc mnemonic's                }
CONSTANT C_MENU_BATCH_HEADER_DISPLAY           = "BDP"                  { menu proc mnemonic's                }
CONSTANT C_MENU_LOT_DETAILS_DISPLAY            = "DLO"                  { menu proc mnemonic's                }
CONSTANT C_MENU_SAMPLE_DISPLAY                 = "DFS"                  { menu proc mnemonic's                }
CONSTANT C_MENU_TEST_SCHED_HEADER_DISPLAY      = "DTL"                  { menu proc mnemonic's                }

CONSTANT C_MAX_SAVE_SET                        = 14                     { max special arrays saved            }
CONSTANT C_MAX_IDENTITIES                      = 6                      { CANNOT CHANGE - max we can handle   }
CONSTANT C_MAX_TABLE_LENGTH                    = 20                     { max_len of a table name             }
CONSTANT C_REAL_FORMAT                         = "99.9999999999999999E9999"      { Allow maximum resolution   }
CONSTANT C_DATE_FORMAT                         = "DD-MM-YYYY H24:MI:SS.CC"       {  for reals and dates       }
CONSTANT C_DELIMIT_CHAR                        = ASCII ( 34 )                    { CSV file save              }
CONSTANT C_NULL_VALUE                          = NULL {"<NULL>"}                        { Archive/csv null           }

    { ------------------------------------------------------------- }
    { Message levels for debug messages to logfile                  }
    { ------------------------------------------------------------- }

CONSTANT C_MSG_NONE                            = 0                      { log message levels                  }
CONSTANT C_MSG_LOW                             = 1                      { detailed verbose information        }
CONSTANT C_MSG_MED                             = 5                      { warning issues                      }
CONSTANT C_MSG_HIGH                            = 10                     { error or config issue               }
CONSTANT C_MSG_FULL                            = 11                     { highest value always writes to log  }

    { ------------------------------------------------------------- }
    { Optional tablenames that could be on the system               }
    { ------------------------------------------------------------- }

CONSTANT C_CERTIFICATE_TABLE                   = "CERTIFICATE"          { compile when no TABLE on system     }
CONSTANT C_CERTIFICATE_TEXT                    = "CERTIFICATE_TEXT"
CONSTANT C_CERTIFICATE_RESULTS                 = "CERTIFICATE_RESULTS"
CONSTANT C_CERTIFICATE_COMMENTS                = "CERTIFICATE_COMMENTS"
CONSTANT C_SMP_TABLE                           = "SMP_TABLE_ARCOM"      { file_directory / file_extension      }

CONSTANT C_PDS_PROTO_TABLE                     = "PDS_PROTO"
CONSTANT C_PDS_STUDY                           = "PDS_STUDY"
CONSTANT C_PDS_PROTO_PULL_TABLE                = "PDS_PROTO_PULL"

    { ------------------------------------------------------------- }
    { Optional fields to update auto execution record               }
    { ------------------------------------------------------------- }

CONSTANT C_COUNT_LOT_DETAILS                   = "COUNT_LOT_DETAILS"    { optional fields for execution       }
CONSTANT C_COUNT_LOT_RELATION                  = "COUNT_LOT_RELATION"   { optional fields for execution       }

CONSTANT C_COUNT_LIST_RESULT                   = "COUNT_LIST_RESULT"    { optional fields for execution       }
CONSTANT C_COUNT_LABEL                         = "COUNT_LABEL"          { optional fields for execution       }
CONSTANT C_COUNT_LABEL_LINES                   = "COUNT_LABEL_LINES"    { optional fields for execution       }
CONSTANT C_COUNT_WORKSHEET                     = "COUNT_WORKSHEET"      { optional fields for execution       }

CONSTANT C_COUNT_CERTIFICATE                   = "COUNT_CERTIFICATE"    { optional fields for execution COA   }
CONSTANT C_COUNT_COA_COMMENT                   = "COUNT_COA_COMMENT"    { optional fields for execution COA   }
CONSTANT C_COUNT_COA_RESULT                    = "COUNT_COA_RESULT"     { optional fields for execution COA   }
CONSTANT C_COUNT_COA_TEXT                      = "COUNT_COA_TEXT"       { optional fields for execution COA   }

CONSTANT C_COUNT_BATCH                         = "COUNT_BATCH"          { optional fields for execution Batch }
CONSTANT C_COUNT_BATCH_ENTRY                   = "COUNT_BATCH_ENTRY"    { optional fields for execution Batch }

CONSTANT C_COUNT_MLP                           = "COUNT_MLP"            { optional fields for execution MLP   }
CONSTANT C_COUNT_MLP_SCHEDULE                  = "COUNT_MLP_SCHEDULE"   { optional fields for execution MLP   }
CONSTANT C_COUNT_MLP_ANALYSIS                  = "COUNT_MLP_ANALYSIS"   { optional fields for execution MLP   }
CONSTANT C_COUNT_MLP_COMPONENTS                = "COUNT_MLP_COMPONENTS" { optional fields for execution MLP   }
CONSTANT C_COUNT_MLP_VALUES                    = "COUNT_MLP_VALUES"     { optional fields for execution MLP   }

CONSTANT C_COUNT_ANALYSIS                      = "COUNT_ANALYSIS"       { optional fields for execution ANAL  }
CONSTANT C_COUNT_COMPONENTS                    = "COUNT_COMPONENTS"     { optional fields for execution ANAL  }
CONSTANT C_COUNT_CL_HEADER                     = "COUNT_CL_HEADER"      { optional fields for execution ANAL  }
CONSTANT C_COUNT_CL_ENTRY                      = "COUNT_CL_ENTRY"       { optional fields for execution ANAL  }

CONSTANT C_COUNT_STANDARDS                     = "COUNT_STANDARDS"      { optional fields for execution STD   }
CONSTANT C_COUNT_STANDARD_CONC                 = "COUNT_STD_CONC"       { optional fields for execution STD   }

CONSTANT C_COUNT_DISP_HEADER                   = "COUNT_DISP_HEADER"    { optional fields for execution DISP  }
CONSTANT C_COUNT_DISP_COMMENT                  = "COUNT_DISP_COMMENT"   { optional fields for execution DISP  }

{******************************************************************************
*
* GLOBAL Variables
*
*******************************************************************************}

DECLARE GLBL_system_array   ,              { reserve tables not system wide     }
        ret_val             ,              { generic return value from routines }
        ac_object           ,              { the main object for all processing }
        tmp                 ,              { generic tmpString                  }
        msg                 ,              { messages for languages....         }
        prompt_details                     { old fashioned LTE                  }

{******************************************************************************}
{  OLD FASHIONED LTE VARIABLES                                                 }
{******************************************************************************}

DECLARE name_of_table           ,
    directory               ,
    extn                    ,
    help_context            ,
    default_value           ,
    input_mess              ,
    header_mess             ,
    footer_mess             ,
    display_footer_mess     ,
    displayed_name_of_table ,
    fields_to_output        ,
    special_actions_report  ,
    labtable_messages       ,
    default_table_set

{BLOCK edited by CONSULT-02. Recived errors if the properties remained in the object.}
DECLARE start_letter,
msg_57,
{msg_58,
 msg_59,}
msg_60,
msg_61,
msg_62,
msg_63,
msg_64,
msg_65,
msg_66,
{msg_67,}
msg_68,
msg_69,
msg_70,
msg_71,
msg_72,
msg_73,
msg_74,
msg_75,
msg_76,
msg_77,
msg_78,
msg_79,
msg_80,
msg_81,
msg_82,
msg_83,
msg_84,
msg_85,
msg_86,
msg_87,
msg_88,
msg_89,
{msg_90,}
msg_91,
msg_92,
msg_93,
msg_94,
msg_95,
msg_96,
msg_97,
msg_98,
msg_99,
msg_100,
{msg_101,
 msg_102,}
msg_103,
msg_104,
msg_105,
msg_106,
msg_107,
msg_108,
msg_109,
msg_110,
msg_111,
msg_112,
msg_113,
{msg_114,}
msg_115,
msg_116,
msg_117,
msg_118,
msg_119,
msg_120,
msg_121,
msg_122,
{msg_123,}
msg_124,
msg_125,
msg_126,
msg_127,
msg_128,
msg_129,
msg_130

{END BLOCK edited by CONSULT-02}

fm("LIT_AUTO_COMMIT_CANNOT_RUN_LIBRARY")
EXIT        { cannot be ran directly from anywhere... }

{******************************************************************************
*
* Routines -    MENU_%     - routines that are designed to call from a menu
*               MAIN_%     - main routines shared by interactive/background
*               ac_object% - actions of the main processing object
*               prompt_%   - routines called from interface for lists/lte's
*               internal_% - routines used internally in the program
*
*******************************************************************************}

ROUTINE MENU_comm_change_desktop ( VALUE in_commit_mode )

    DECLARE temp_menu         ,
        ok                ,
        client_name       ,
        errors            ,
        def_page

    ok = TRUE

    IF ( ACTIVE_REPORT_COUNT () > 1 ) THEN

        ok = confirm_with_message ( "COM_MODE_CHANGE_WARNING" )

    ENDIF

    IF ( ok ) AND ( CAN_ACCESS_MENU ( 9991 ) ) THEN

        in_commit_mode = NOT GLOBAL ( "COMMIT_VIEW_MODE" )

        SET GLOBAL "COMMIT_VIEW_MODE" TO in_commit_mode

        IF GLOBAL ( "TERMTYPE" ) = "GUI" THEN

            MENUPROC 9991 , GLOBAL ( "SMW_MENU" )

        ELSE

            temp_menu = GLOBAL ( "USRDEFMENUFILENAME" )
            SET GLOBAL "USRDEFMENUFILENAME" TO GLOBAL ( "USRCOMMENUFILENAME" )
            SET GLOBAL "USRCOMMENUFILENAME" TO temp_menu

        ENDIF

        def_page    = "default.htm"
        errors      = client_get_resource_name ( "HTML\Default\", client_name )

        IF ( errors = EMPTY ) AND ( in_commit_mode ) THEN

            def_page = STRIP(GLOBAL ( GLBL_SETCOM_TABLE_SET_GLOBAL )) : ".htm"

        ENDIF

        client_set_desktop_url ( client_name : def_page )

    ENDIF

ENDROUTINE  { MENU_comm_change_desktop }

{******************************************************************************}

GLOBAL ROUTINE MENU_ac_background_loop ( a_mode )

    DECLARE ac_db      ,
                 ac_ar      ,
                 ac_id      ,
                 ach_table  ,
                 debug_level,
                 cur_array

    ach_table = C_AUTO_COMMIT_BG_VIEW     { <- ** SPECIAL VIEW ** }
    ac_object = EMPTY

    IF ( GLOBAL ( GLBL_AUTO_COMMIT_ENABLE ) ) THEN

        debug_level = GLOBAL ( GLBL_AUTO_COMMIT_DEBUG_LEVEL )

        { ------------------------------------------------ }
        { If debug level blank or empty force to lowest    }
        { ------------------------------------------------ }

        IF ( debug_level = EMPTY ) OR ( BLANK ( debug_level ) ) OR ( NOT NUMTEXT ( debug_level ) ) THEN
            debug_level = C_MSG_LOW
        ENDIF

        internal_initialize_messages(msg)

        { ------------------------------------------------ }
        { Background will loop for all in table            }
        { ------------------------------------------------ }

        ARRAY ac_ar

            ARRAY_SELECT_ADD ( ac_ar, ARRAY_SELECT_EQ, "ENABLED"          , TRUE  )      { user can toggle      }
            ARRAY_SELECT_ADD ( ac_ar, ARRAY_SELECT_EQ, "MANUAL_BACKGROUND", FALSE )      { is bcakground only   }

            CREATE OBJECT C_STD_OBJECT_DATABASE, ac_db
                ac_db.initialise ( ach_table )
                ac_db.select ( ac_ar )
                ac_db.set_first()

            WHILE ( ac_db.current <> EMPTY )

            ac_id = SELECT 'ach_table'.IDENTITY IN OBJECT ac_db.current

            ARRAY cur_array
                ARRAY_SELECT_ADD ( cur_array, ARRAY_SELECT_EQ, "IDENTITY", ac_id  )

            MAIN_ac_process ( ac_object, ac_id, ac_db.current, ach_table, cur_array, FALSE, debug_level, FALSE, FALSE )

                ac_db.set_next()

            ENDWHILE

        ac_db = EMPTY

    ENDIF   { auto commit enabled }

    EXIT

ENDROUTINE { MENU_ac_background_loop }

{******************************************************************************}

ROUTINE MENU_obsolete_commit ( VALUE menu_id )

    fm("LIT_AUTO_COMMIT_MENU_OBSOLETE")

ENDROUTINE    { MENU_obsolete_commit }

{******************************************************************************}

ROUTINE MENU_interactive_commit ( VALUE menu_id )

    DECLARE ac_object   ,
                 report_only ,
                 select_array,
                 archive_csv ,
                 table_id    ,
                 ac_id

    { ------------------------------------------------ }
    { Get all user messages (global vgl variables)     }
    { ------------------------------------------------ }

    internal_initialize_messages(msg)

    ac_object   = EMPTY
    report_only = FALSE
    archive_csv = FALSE
    ac_id       = EMPTY

    { ---------------------------------------------------------- }
    { report mode is from master menu, unless not called by menu }
    { ---------------------------------------------------------- }

    IF ( NUMTEXT ( menu_id ) ) THEN

        report_only = SELECT MASTER_MENU.ACTION_TYPE WHERE PROCEDURE_NUM = menu_id
        table_id    = SELECT MASTER_MENU.TABLE_NAME

    ELSE

        report_only = EMPTY
        table_id    = ""

    ENDIF

    { ----------------------------------------------------------- }
    { Action type sets report only and archive csv as well        }
    { ----------------------------------------------------------- }

    IF ( report_only = EMPTY ) OR ( report_only = C_REPORT_MODE ) THEN

        report_only = TRUE

    ELSEIF ( report_only = "LIST" ) THEN

        report_only = FALSE
        archive_csv = TRUE

    ELSE

        report_only = FALSE

    ENDIF

    { ------------------------------------------------ }
    { Get an identity to work upon - only enabled ones }
    { ------------------------------------------------ }

    ARRAY select_array
    ARRAY_SELECT_ADD ( select_array, ARRAY_SELECT_EQ, "ENABLED"           , TRUE  )      { always check Enabled    }
    ARRAY_SELECT_ADD ( select_array, ARRAY_SELECT_EQ, "ENABLE_RMB"        , FALSE )      { RMB's are only explorer }
    ARRAY_SELECT_ADD ( select_array, ARRAY_SELECT_EQ, "MANUAL_BACKGROUND" , TRUE  )      { interactive check WDT   }
    ARRAY_SELECT_ADD ( select_array, ARRAY_SELECT_EQ, "REMOVEFLAG"        , FALSE )      { removeflag on all       }

    { ------------------------------------------------ }
    { When in archive there is only one way...         }
    { ------------------------------------------------ }

    IF ( archive_csv ) THEN

        ARRAY_SELECT_ADD ( select_array, ARRAY_SELECT_EQ, "COMMIT_DESTINATION", "EXPORT" )      { require export only }

        ac_id = SELECT AUTO_COMMIT_HEADER.IDENTITY WHERE IDENTITY = table_id

    ELSE

        ARRAY_SELECT_ADD ( select_array, ARRAY_SELECT_NE, "COMMIT_DESTINATION", "EXPORT" )      { do not allow export     }

    ENDIF

    { ----------------------------------------------- }
    { User selects which one then we are on the way   }
    { ----------------------------------------------- }

    IF ( ac_id <> EMPTY ) OR ( internal_input_ach_identity ( "AUTO_COMMIT_HEADER", msg_72, msg_73, select_array, ac_id ) ) THEN

        interactive_commit ( ac_id, report_only, ac_object, TRUE, archive_csv )

    ENDIF  { user input an identity }

ENDROUTINE   { MENU_interactive_commit }

{******************************************************************************}

GLOBAL ROUTINE interactive_commit ( VALUE ac_id       ,
                                    VALUE report_only ,
                                          ac_object   ,
                                    VALUE review_mode ,
                                    VALUE export_mode )

    DECLARE ach_db      ,
                 ac_db       ,
                 debug_level ,
                 select_array,
                 ach_table


    default_table_set         = GLOBAL ( GLBL_SETCOM_TABLE_SET_GLOBAL )

    { ------------------------------------------------ }
    { If debug level blank or empty force to lowest    }
    { ------------------------------------------------ }

    internal_initialize_messages(msg)

    debug_level = GLOBAL ( GLBL_AUTO_COMMIT_DEBUG_LEVEL )

    IF ( debug_level = EMPTY ) OR ( BLANK ( debug_level ) ) OR ( NOT NUMTEXT ( debug_level ) ) THEN
        debug_level = C_MSG_LOW
    ENDIF

    { ------------------------------------------------ }
    { Do the work only when config says it is ok       }
    { ------------------------------------------------ }

    IF ( GLOBAL ( GLBL_AUTO_COMMIT_ENABLE ) = TRUE ) THEN

        { ------------------------------------------------ }
        { If ac_object is not empty came from RMB          }
        { ------------------------------------------------ }

        IF ( ac_object <> EMPTY ) THEN
            ach_table = "AUTO_COMMIT_HEADER"
        ELSE
            ach_table = C_AUTO_COMMIT_VIEW
        ENDIF

        ARRAY select_array

        ARRAY_SELECT_ADD ( select_array, ARRAY_SELECT_EQ, "IDENTITY", ac_id )

        CREATE OBJECT C_STD_OBJECT_DATABASE, ac_db
            ac_db.initialise ( ach_table )
            ac_db.select ( select_array )
            ac_db.set_first()
            ach_db = ac_db.current

        { ------------------------------------------------------------------- }
        { If ac_object is not empty then we were called from RMB else menu    }
        { ------------------------------------------------------------------- }

        IF ( ach_db <> EMPTY ) THEN

            MAIN_ac_process( ac_object, ac_id, ach_db, ach_table, select_array, report_only, debug_level, review_mode, export_mode )

        ELSE

            tmp = internal_translate_message ("LIT_AUTO_COMMIT_INVALID_ACH_IDENTITY"):ac_id
            {fm(tmp)}

        ENDIF

        ach_db = EMPTY
        ac_db  = EMPTY

        SET GLOBAL GLBL_SETCOM_TABLE_SET_GLOBAL TO default_table_set

    ELSE

        fm(msg.03)

    ENDIF  { auto_commit_enable }

ENDROUTINE   { interactive_commit }

{******************************************************************************}

ROUTINE MAIN_ac_process (       ac_object   ,
                          VALUE ac_id       ,
                                ach_db      ,
                                ach_table   ,
                                select_array,
                          VALUE report_only ,
                          VALUE debug_level ,
                          VALUE review_mode ,
                          VALUE export_mode )

    DECLARE do_trace, disable_audit, save_old_audit

    { --------------------------------------------------------------------- }
    { Assume an error, unless all is valid, and if so, do the arcom...      }
    { --------------------------------------------------------------------- }

    ret_val  = FALSE
    do_trace = GLOBAL ( GLBL_AUTO_COMMIT_ORACLE_TRACE )

    { --------------------------------------------------------------------- }
    { Enable tuning if needed by config item                                }
    { --------------------------------------------------------------------- }

    IF ( do_trace ) THEN

        execute_sql(C_SQL_TRACE_ON)

    ENDIF



    { --------------------------------------------------------------------- }
    { Enable/Disable auditing during ArCom based upon configuration         }
    { --------------------------------------------------------------------- }

    save_old_audit = GLOBAL ( "AUDIT_SUPPRESSION" )
    disable_audit  = GLOBAL ( GLBL_AUTO_COMMIT_DISABLE_AUDIT )

    IF ( disable_audit ) THEN

        SET GLOBAL "AUDIT_SUPPRESSION" TO "ALL"

    ENDIF

    define_list_chooser_class ( )
    define_list_viewer_class  ( )

    { --------------------------------------------------------------------- }
    { This is the heart of the program - check if all ok and if so do it    }
    { --------------------------------------------------------------------- }

    IF ( internal_initialize_auto_commit( ac_object, ach_db, ac_id, ach_table, select_array, report_only, debug_level, review_mode, export_mode, FALSE ) ) THEN

        window_set_status ( ach_table )

        IF ( ac_object.ac_process() ) THEN

            ret_val             = TRUE
            ac_object.error_msg = msg.33

        ENDIF

    ENDIF

    { --------------------------------------------------------------------- }
    { Very special case for PDS_PROTO MLP act like a complete cycle         }
    { --------------------------------------------------------------------- }

    IF ( ret_val ) AND ( ac_object.pds_product <> EMPTY ) AND ( ac_object.pds_product <> "" ) THEN

        ac_object.ach_view_dbase   = EMPTY
        ac_object.ac_dbase         = EMPTY

        window_set_status ( ac_object.pds_product )

        ret_val = ac_object.process_pds_proto_mlp()

    ENDIF

    { ----------------------------------------------------- }
    { Turn off trace, all done with database                }
    { ----------------------------------------------------- }

    IF ( do_trace ) THEN

        execute_sql(C_SQL_TRACE_OFF)

    ENDIF


    { ----------------------------------------------------- }
    { Show the report                                       }
    { ----------------------------------------------------- }

    IF ( ret_val ) THEN

        IF ( ac_object.do_archive_csv ) THEN

            IF ( ( ac_object.count_base > 0 ) OR ( ac_object.count_pds_study > 0 ) ) AND ( ac_object.archive_csv_zip_files() ) THEN

                ac_object.archive_csv_update_export()

            ENDIF

        ENDIF

        IF ( GLOBAL ( "MODE" ) = "INTERACTIVE" ) THEN

            IF ( ac_object.ace_show_short_report ) AND FILE EXISTS ( ac_object.ace_short_report ) THEN

                FILE CLOSE ac_object.ace_short_report
                WriteToLog("FILE SEND ":ac_object.ace_short_report:", DISPLAY/")
                SLEEP FOR INTERVAL("0 00:00:01")
                FILE SEND ac_object.ace_short_report, "DISPLAY/"

            ELSEIF FILE EXISTS ( ac_object.ace_report ) THEN

                WriteToLog("FILE SEND ":ac_object.ace_report:", DISPLAY/")
                FILE SEND ac_object.ace_report, "DISPLAY/"

            ELSEIF ( NOT ac_object.do_archive_csv ) THEN   { there is no report for CSV output }

                IF FILE EXISTS ( ac_object.ace_logfile ) THEN

                    WriteToLog("FILE SEND ":ac_object.ace_logfile:", DISPLAY/")
                    FILE SEND ac_object.ace_logfile, "DISPLAY/"

                ENDIF

            ENDIF

        ENDIF  { reports only shown when interactive }

    ENDIF { retval }

    { --------------------------------------------------------------------- }
    { Clear up all sorts of memory of all objects made                      }
    { --------------------------------------------------------------------- }
    ac_object.close_logfile ( ret_val )

    ac_object.ach_view_dbase   = EMPTY
    ac_object.ac_dbase         = EMPTY
    ac_object                  = EMPTY

    { ----------------------------------------------------- }
    { Revert auditing back to what it was...                }
    { ----------------------------------------------------- }

    IF ( disable_audit ) THEN

        SET GLOBAL "AUDIT_SUPPRESSION" TO save_old_audit

    ENDIF

    RETURN ( ret_val )

ENDROUTINE   {  MAIN_ac_process }

{******************************************************************************}

ROUTINE internal_define_auto_commit

    DEFINE CLASS CLASS_AUTO_COMMIT INHERIT "STD_OBJECT_DATABASE"
        PROPERTIES
            "smp_version"                  , { Version of lims for smp_tablesets               }
            "smp_version_number"           , { Version number of smp_tablsets                  }
            "ach_identity"                 , { key1 ...  auto_commit_header                    }
            "ach_base_table"               , { the base table name for auto_commit_header      }
            "ach_field_identity"           , { the identity field of the master (base) table   }
            "ach_commit_view"              , { the view (has mandatory) for criteria select    }
            "ach_commit_criteria"          , { criteria for the master record for select       }
            "ach_commit_source"            , { the actual source tableset name                 }
            "ach_commit_source_type"       , { the type (archive,commit,active,retain) source  }
            "ach_commit_source_prefix"     , { prefix of source tableset <deconsign>           }
            "ach_commit_destination"       , { the actual destination tableset name            }
            "ach_commit_destination_type"  , { type of tableset destination (arc/com/act)      }
            "ach_commit_destination_prefix", { prefix of destination tableset                  }
            "ach_description"              , { description from auto_commit_header             }
            "ach_modified_on"              , { modified_on from auto_commit_header             }
            "ach_modified_by"              , { modified_by from auto_commit_header             }
            "ach_report_details"           , { boolean details if report includes systemtables }
            "ach_explorer_rmb"             , { if the ach allows an rmb off of explorer        }
            "ach_list_dbase"               , { chained set of arcom's to do when csv export    }
            "ach_list_record"              , { a specific record ffrom ach_list_dbase          }
            "ach_new_version"              , { in export mode enable new version               }
            "ach_new_entry_code"           , { in export mode enable new version               }
            "ac_criteria_modified_on"      , { modified_on from criteria_saved                 }
            "ac_criteria_modified_by"      , { modified_by from criteria_saved                 }
            "ac_criteria_description"      , { description from criteria_saved                 }
            "ac_start_time"                , { keep when the cycle actually started            }
            "ace_execute_interval"         , { calc from start to finish how long it all took  }
            "ac_id_field_1"                , { the 1rst identity field of base table           }
            "do_consign"                   , { Boolean if we consign or deconsign              }
            "do_DELETE"                    , { Boolean if we DELETE                            }
            "do_REMOVEFLAG"                , { Boolean if we set removeflag on static          }
            "do_archive_csv_enabled"       , { Boolean config if csv enabled at all            }
            "do_archive_csv"               , { Boolean if we archive csv (EXPORT)              }
            "do_csv_of_archives"           , { Boolean if we archive csv prior to delete       }
            "del_archive_save_csv"         , { Boolean if we archive csv prior to delete       }
            "commit_mode"                  , { mode (archive,commit,move,deconsign)            }
            "check_all_tablesets"          , { config item if static checks all tablesets      }
            "count_base"                   , { # of master records done in a cycle             }
            "count_sample"                 , { # of samples                                    }
            "count_test"                   , { # of tests                                      }
            "count_result"                 , { # of results                                    }
            "count_pds_job"                , { # of pds Jobs                                   }
            "count_pds_study"              , { # of pds study                                  }
            "count_pds_axis_point"         , { # of pds study axis point records               }
            "count_pds_study_pull"         , { # of pds study pull records                     }
            "count_pds_basetime"           , { # of pds study pull records                     }
            "count_pds_layer"              , { # of pds study layer records                    }
            "count_pds_condition"          , { # of pds study condition records                }
            "count_audit_data"             , { # of        records done in a cycle             }
            "count_audit_event"            , { # of        records done in a cycle             }
            "count_audit_trans"            , { # of        records done in a cycle             }
            "count_esig_data"              , { # of        records done in a cycle             }
            "count_esig_event"             , { # of        records done in a cycle             }
            "count_inc_header"             , { # of        records done in a cycle             }
            "count_inc_result"             , { # of        records done in a cycle             }
            "count_inspector"              , { # of        records done in a cycle             }
            "count_labelprint"             , { # of        records done in a cycle             }
            "count_labelprint_lines"       , { # of        records done in a cycle             }
            "count_worksheet"              , { # of        records done in a cycle             }
            "count_list_result"            , { # of        records done in a cycle             }
            "count_certificate"            , { # of        records done in a cycle             }
            "count_coa_comment"            , { # of        records done in a cycle             }
            "count_coa_result"             , { # of        records done in a cycle             }
            "count_coa_text"               , { # of        records done in a cycle             }
            "count_batch_header"           , { # of        records done in a cycle             }
            "count_batch_entry"            , { # of        records done in a cycle             }
            "count_standard_versions"      , { # of        records done in a cycle             }
            "count_std_conc"               , { # of        records done in a cycle             }
            "count_versioned_analysis"     , { # of        records done in a cycle             }
            "count_versioned_component"    , { # of        records done in a cycle             }
            "count_v_cl_header"            , { # of        records done in a cycle             }
            "count_v_cl_entry"             , { # of        records done in a cycle             }
            "count_mlp_header"             , { # of        records done in a cycle             }
            "count_mlp_schedule"           , { # of        records done in a cycle             }
            "count_mlp_analysis"           , { # of        records done in a cycle             }
            "count_mlp_components"         , { # of        records done in a cycle             }
            "count_mlp_values"             , { # of        records done in a cycle             }
            "count_disp_header"            , { # of        records done in a cycle             }
            "count_disp_comment"           , { # of        records done in a cycle             }
            "count_lot_details"            , { # of        records done in a cycle             }
            "count_lot_relation"           , { # of        records done in a cycle             }
            "count_tsched_entry"           , { # of        records done in a cycle             }
            "cpu_destination"              , { user input of CPU to send export CSV data       }
            "jstr_enabled"                 , {                                                 }
            "test_schedule_enabled"        , { boolean if test schedules are done              }
            "list_result_enabled"          , { boolean if lists are arcom'ed                   }
            "disposition_enabled"          , { boolean if dispositions are enabled             }
            "labels_enabled"               , { boolean if lables are enabled                   }
            "worksheets_enabled"           , { boolean if worksheets are enabled               }
            "worksheets_mode"              , { boolean if worksheets are base table            }
            "certificates_enabled"         , { boolean if COA IFMs are enabled                 }
            "mlp_enabled"                  , { boolean if MLPs are enabled                     }
            "analysis_enabled"             , { boolean if Analyses are enabled                 }
            "standard_enabled"             , { boolean if Standard Versions are enabled        }
            "batches_enabled"              , { boolean if Batches are enabled                  }
            "lot_enabled"                  , { boolean if LOT is enabled                       }
            "continue"                     , { boolean if cycle continues or terminates        }
            "user_library"                 , { if one is made the call triggers from here      }
            "user_info"                    , { for user triggers                               }
            "ace_logfile"                  , { id of the logfile for detailed messages         }
            "ace_report"                   , { id of the report (formatted) output             }
            "ace_short_report"             , { id of the SHORT report (formatted) output       }
            "ace_show_short_report"        , { config if short report is displayed             }
            "ace_full_id"                  , { full id for auto_commit_execution (logfiles)    }
            "ace_file_id"                  , { filename only for all files and csv archive     }
            "ace_zip_file_id"              , { full filename of csv archive set                }
            "ace_csv_file_id"              , { each file as it is archived                     }
            "ace_csv_field_names"          , { each table/field names as it is archived        }
            "ace_archive_set"              , { Array of all archived data                      }
            "ace_order_number"             , { auto_commit_execution.order_number              }
            "user_tables"                  , { array of auto_commit_list values                }
            "system_tables"                , { array of auto commit system values              }
            "required_array"               , { array of system required tables                 }
            "base_table_identity"          , { each record being committed (its identity)      }
            "pds_identity"                 , { Special for PDS                                 }
            "pds_orig_job"                 , { Special for PDS                                 }
            "pds_study_job"                , { Special for PDS                                 }
            "pds_mode"                     , { Special for PDS Boolean if in this mode         }
            "pds_proto_mode"               , { Special for PDS Boolean if in this mode         }
            "pds_array_t_factor"           , { Array ...                                       }
            "pds_array_l_factor"           , { Array ...                                       }
            "pds_array_c_factor"           , { Array ...                                       }
            "pds_product"                  , { Single reference of the mlp to get              }
            "pds_product_version"          , { Single reference of the mlp version             }
            "pds_config"                   , { Single reference of the config to get           }
            "array_base_identities"        , { Array of base identities for exported           }
            "array_test_schedules"         , { Array for static save off of pds_proto          }
            "array_analysis"               , { Array of all analysis references (anal/limit)   }
            "array_mlp_levels"             , { Array of levels for static data save            }
{}          "array_param_link"             ,
            "array_text_phrase"            , { Array of all phrase references analysis         }
            "array_limit_phrase"           , { Array of limit phrase references                }
            "array_limit_calc"             , { Array of limit or calculations (anal/limit)     }
            "array_list_result"            , { Array of limit or calculations (anal/limit)     }
            "array_criteria_saved"         , { Array of all phrase references analysis         }
            "G_LEN_MLP"                    , { Field Size of mlp_header.identity               }
            "G_LEN_PDS"                    , { Field Size of pds_proto.identity                }
            "G_LEN_ANAL"                   , { Field Size of analysis.identity                 }
            "G_LEN_STD"                    , { Field Size of standard.identity                 }
            "list_mode"                    , { chained arcom running in list mode              }
            "ac_dbase_select_array"        , { select array read to do the auto commmit        }
            "ac_dbase"                     , { object database of the base_table (actual data) }
            "ac_dbase_size"                , { size (number records) of ac_dbase               }
            "ach_view_dbase"               , { object database of the auto_commit_header       }
            "a_table_no_prefix"            , { current table being processed with no prefix    }
            "a_table"                      , { current table being processed                   }
            "a_field"                      , { array where a_field_1 =  of current process     }
            "a_select_field"               , { array table.<a_select_field_1> of current       }
            "a_identity"                   , { array for fields for current table process      }
            "a_identity_full"              , { cat all a_identity array into single variable   }
            "a_destination"                , { current destination table                       }
            "a_current_select"             , { a_current_rec current record pointer            }
            "a_special_id"                 , { inc/esig audit/esig special id                  }
            "a_special_table"              , { inc/esig audit/esig special table               }
            "save_set"                     , { array of 1.2.3 all of above 3 variable arrays   }
            "report_only"                  , { boolean flag TRUE when doing only a report      }
            "cycle_count"                  , { counter cycles up and down user tables          }
            "start_processing"             , { boolean if go down tree to process recs         }
            "processed_a_record"           , { boolean if we really did a record               }
            "do_decrement_mode"            , { boolean for pds versus all other modes          }
            "no_user_tables"               , { SIZE of array user_tables                       }
            "save_count"                   , { counter for each record of ANY table            }
            "max_count"                    , { max records that can be done in one cycle       }
            "list_review"                  , { list form that allows interactive veto          }
            "rmb_object"                   , { rmb selection object                            }
            "rmb_var_type"                 , { rmb array, object or empty                      }
            "review_mode"                  , { interactive RMB review before processing        }
            "current_routine"              , { current library for log messages                }
            "debug_level"                  , { config item for level of messages in logfile    }
            "error_msg"                    , { generic error message                           }
            "check_value"                  , { Check condition warning message                 }
            "save_pds_view"                , { PDS mode must save and reset                    }
            "original_status"                { Keep track of status                            }

        ACTIONS

            "ac_process"                , {  main starting point for arcom                    }
            "ac_process_1_record"       , {  called by ac_process for each record             }
            "set_key0_fields"           , {  sets all the identity fields for full id         }
            "review_list"               , {  called by ac_process form for review             }
            "choose_from_list"          , {  called by review_list to setup form for review   }
            "item_list_review"          , {  get first selected for multiple key0             }
            "item_get_next"             , {  get next list item when multiple key0            }
            "load_criteria"             , {  loads the criteria_saved table                   }
            "write_criteria"            , {  writes the criteria array to log or report       }
            "check_conditions"          , {  checks if table's children are ready to commit   }
            "a_mode"                    , {  does the type_n (commit,move,deconsign,archive)  }
            "commit"                    , {  type_1 does a commit  (active->commit)           }
            "commit_move"               , {  type_2 does a commit  (commit->commit)           }
            "archive"                   , {  type_3 does a archive (commit->archive)          }
            "deconsign"                 , {  type_4 does a deconsign (archive/commit/active)  }
            "remove"                    , {  ...special of static set removeflag              }
            "delete"                    , {  ...special of archive tableset delete            }
            "delete_archive"            , {  does the delete and archive if config to do      }
            "export"                    , {  exports data to external systems                 }
            "archive_csv_data"          , {  if archive enabled save data for write files     }
            "archive_csv_set_fields"    , {  Build and save fields/sizes archive tables       }
            "archive_csv_all_files"     , {  After all is done for delete write all files     }
            "archive_csv_1_file"        , {  Write each file type during archive              }
            "archive_csv_zip_files"     , {  Zip then delete csv files for archive            }
            "archive_csv_update_export" , {  update exported table with key0's                }
            "archive_csv_write_array"   , {  formats the string for output to csv             }
            "archive_csv_double_quote"  , {  during csv write make " into ""                  }
            "archive_csv_set_filename"  , {  if archive enabled save data for write files     }
            "validate_ach"              , {  validates the auto commit header for settings    }
            "make_destination"          , {  makes destination name based upon commit/consign }
            "update_destination"        , {  saves where csv files are sent to CPU's          }
            "select_destination"        , {  user input for which cpu's to copy csv's to      }
            "get_auto_commit_list"      , {  gets records from auto_commit_list table         }
            "default_auto_commit_list"  , {  gets records from auto_commit_list table         }
            "validate_default_ac_list"  , {  gets records from auto_commit_list table         }
            "get_system_tables"         , {  gets records from auto commit system             }
            "set_source_tableset"       , {  sets the input source tableset from ach          }
            "create_logfile"            , {  creates all files for log and report             }
            "create_rpt_files"          , {  creates all files for log and report             }
            "close_logfile"             , {  closes all files (log and report)                }
            "write_reports"             , {  output write all the stuff we did                }
            "update_execution"          , {  update the execute table with all counts         }
            "select_table"              , {  performs select for an entity (recursive)        }
            "commit_table"              , {  performs commit on table (recursive)             }
            "set_commit_mode"           , {  sets the mode for type_n (commit,deconsign)      }
            "set_master_fields"         , {  sets field pointer to ACH if master table has em }
            "set_table_no_prefix"       , {  sets table without a prefix for system tables    }
            "get_next_entity"           , {  gets next entity for processing (recursive)      }
            "save_current_set"          , {  save current set of data (recursive)             }
            "decrement_current_set"     , {  decrement current set of data (recursive)        }
            "process_pds_proto_mlp"     , {  special export of mlp from pds proto             }
            "show_final_report"         , {  Output report to interactive users               }
            "commit_pds_job"            , {  commits job(s) for PDS study                     }
            "commit_system_tables"      , {  commits all system data for each level           }
            "consign_audits"            , {  special for audit and all its tables consign     }
            "consign_esigs"             , {  special for esig and all its tables consign      }
            "consign_incidents"         , {  special for incidents and all its tables consign }
            "consign_labels"            , {  special for labels and all its tables consign    }
            "consign_inspectors"        , {  special for inspectors consign                   }
            "consign_worksheets"        , {  special for worksheets consign                   }
            "consign_disposition"       , {  special for disposition (optional) table         }
            "consign_disp_comments"     , {  special for disp_comments (optional) table       }
            "consign_wsheets"           , {  special for wsheet table                         }
            "system_consign"            , {  calls commit system tables and does consign      }
            "report_only"               , {  boolean and action to only report the data       }
            "report_details"            , {  details if doing a report                        }
            "dump_ac_object"            , {  details if error crash                           }
            "call_trigger"              , {  call a user trigger                              }
            "esig_event_last_1"         , {  Esig_Event last_one                              }
            "audit_trans_last_1"        , {  Audit transaction last_one                       }
            "toggle_pds_objects"        , {  set pds and job objects to work multiple studies }
            "table_special_process"     , {  process static data referenced in base set       }
            "table_special_file"        , {  process each table/record for complex files      }
            "table_special_table"       , {  process each table/record from above action      }
            "table_special_save"          {  save data to process later for static pointers   }

    END CLASS

ENDROUTINE    { internal_define_auto_commit }

{******************************************************************************}

ROUTINE internal_initialize_auto_commit (       ac_object      ,
                                                ach_db         ,
                                                ac_id          ,
                                                ach_table      ,
                                                select_array   ,
                                          VALUE report_only    ,
                                          VALUE debug_level    ,
                                          VALUE review_mode    ,
                                          VALUE export_mode    ,
                                          VALUE do_mlp_for_pds )

    DECLARE an_array   ,
                i          ,
                a_rec      ,
                save_object,
                a_semi

    { ------------------------------------------------------ }
    { If called from RMB (explorer) then save this select    }
    { ------------------------------------------------------ }

    save_object = ac_object

    { ------------------------------------------------------ }
    { Things done one time to the ac_object                  }
    { ------------------------------------------------------ }

    IF NOT ( GLOBAL ( "LIBRARY_INITIALISED" ) ) THEN

        internal_define_auto_commit()
        internal_define_view_object_database()

    ENDIF

    { ------------------------------------------------------ }
    { For each cycle the ac_object EXCEPT MLP for PDS        }
    { ------------------------------------------------------ }


    IF NOT do_mlp_for_pds THEN

        CREATE OBJECT CLASS_AUTO_COMMIT, ac_object

    ENDIF

    { ------------------------------------------------------ }
    { Set values done for each cycle of the auto commit      }
    { ------------------------------------------------------ }

    ARRAY ac_object.save_set

    ac_object.report_only               = report_only
    ac_object.save_count                = 0
    ac_object.count_base                = 0
    ac_object.count_sample              = 0
    ac_object.count_test                = 0
    ac_object.count_result              = 0
    ac_object.count_list_result         = 0
    ac_object.count_tsched_entry        = 0

    ac_object.count_audit_data          = 0
    ac_object.count_audit_event         = 0
    ac_object.count_audit_trans         = 0
    ac_object.count_esig_data           = 0
    ac_object.count_esig_event          = 0
    ac_object.count_inc_header          = 0
    ac_object.count_inc_result          = 0
    ac_object.count_inspector           = 0

    ac_object.count_pds_job             = 0
    ac_object.count_pds_study           = 0
    ac_object.count_pds_axis_point      = 0
    ac_object.count_pds_study_pull      = 0
    ac_object.count_pds_basetime        = 0
    ac_object.count_pds_layer           = 0
    ac_object.count_pds_condition       = 0

    ac_object.count_certificate         = 0
    ac_object.count_coa_comment         = 0
    ac_object.count_coa_result          = 0
    ac_object.count_coa_text            = 0

    ac_object.count_batch_header        = 0
    ac_object.count_batch_entry         = 0

    ac_object.count_standard_versions   = 0
    ac_object.count_std_conc            = 0

    ac_object.count_versioned_analysis  = 0
    ac_object.count_versioned_component = 0
    ac_object.count_v_cl_header         = 0
    ac_object.count_v_cl_entry          = 0

    ac_object.count_mlp_header          = 0
    ac_object.count_mlp_schedule        = 0
    ac_object.count_mlp_analysis        = 0
    ac_object.count_mlp_components      = 0
    ac_object.count_mlp_values          = 0

    ac_object.count_worksheet           = 0
    ac_object.count_labelprint          = 0
    ac_object.count_labelprint_lines    = 0

    ac_object.count_disp_header         = 0
    ac_object.count_disp_comment        = 0

    ac_object.count_lot_details         = 0
    ac_object.count_lot_relation        = 0

    ac_object.ac_start_time             = NOW

    ac_object.do_decrement_mode         = TRUE
    ac_object.continue                  = TRUE
    ac_object.do_consign                = TRUE
    ac_object.ach_report_details        = TRUE

    ac_object.do_archive_csv            = FALSE    { only when exporting...         }
    ac_object.do_csv_of_archives        = FALSE    { only when from Archive sets... }
    ac_object.do_DELETE                 = FALSE
    ac_object.do_REMOVEFLAG             = FALSE
    ac_object.start_processing          = FALSE
    ac_object.pds_mode                  = FALSE
    ac_object.pds_proto_mode            = FALSE
    ac_object.processed_a_record        = FALSE

    ac_object.list_result_enabled       = FALSE
    ac_object.labels_enabled            = FALSE
    ac_object.worksheets_enabled        = FALSE
    ac_object.worksheets_mode           = FALSE
    ac_object.certificates_enabled      = FALSE
    ac_object.disposition_enabled       = FALSE
    ac_object.lot_enabled               = FALSE
    ac_object.mlp_enabled               = FALSE
    ac_object.analysis_enabled          = FALSE
    ac_object.standard_enabled          = FALSE
    ac_object.batches_enabled           = FALSE
    ac_object.jstr_enabled              = FALSE
    ac_object.test_schedule_enabled     = FALSE
    ac_object.list_mode                 = FALSE

    ac_object.pds_product               = EMPTY
    ac_object.pds_product_version       = EMPTY
    ac_object.pds_config                = EMPTY
    ac_object.commit_mode               = EMPTY
    ac_object.ac_dbase                  = EMPTY
    ac_object.user_info                 = EMPTY
    ac_object.pds_identity              = EMPTY
    ac_object.pds_orig_job              = EMPTY
    ac_object.pds_study_job             = EMPTY

    ac_object.rmb_object                = save_object                                 { has items to select }
    ac_object.rmb_var_type              = VARIABLE_GET_TYPE ( ac_object.rmb_object )
    ac_object.report_only               = report_only                 { passed param if mode is report           }
    ac_object.review_mode               = review_mode                 { passed param if mode is review           }
    ac_object.debug_level               = debug_level                 { passed param from a config.header        }
    ac_object.ach_view_dbase            = ach_db                      { copy of auto_commit_header (caller)      }
    ac_object.error_msg                 = msg.23                      { default error (crash check)              }
    ac_object.ach_identity              = ac_id                       { passed param auto_commit_header.identity }

    { ------------------------------------------------------------------------- }
    { Get some field sizes used throughout the code                             }
    { ------------------------------------------------------------------------- }

    GET_FIELD_DETAILS mlp_header.identity        , "FIELD_SIZE", ac_object.G_LEN_MLP
    GET_FIELD_DETAILS pds_proto.identity         , "FIELD_SIZE", ac_object.G_LEN_PDS
    GET_FIELD_DETAILS versioned_analysis.identity, "FIELD_SIZE", ac_object.G_LEN_ANAL
    GET_FIELD_DETAILS standard.identity          , "FIELD_SIZE", ac_object.G_LEN_STD

    { ------------------------------------------------------------------------- }
    { Get data from the current auto commit header for options during output    }
    { ------------------------------------------------------------------------- }

    ac_object.ach_base_table            = SELECT 'ach_table'.BASE_TABLE         IN OBJECT ach_db
    ac_object.ach_commit_view           = SELECT 'ach_table'.COMMIT_VIEW        IN OBJECT ach_db
    ac_object.ach_commit_source         = SELECT 'ach_table'.COMMIT_SOURCE      IN OBJECT ach_db
    ac_object.ach_commit_destination    = SELECT 'ach_table'.COMMIT_DESTINATION IN OBJECT ach_db
    ac_object.ach_description           = SELECT 'ach_table'.DESCRIPTION        IN OBJECT ach_db
    ac_object.ach_modified_on           = SELECT 'ach_table'.MODIFIED_ON        IN OBJECT ach_db
    ac_object.ach_modified_by           = SELECT 'ach_table'.MODIFIED_BY        IN OBJECT ach_db
    ac_object.ach_explorer_rmb          = SELECT 'ach_table'.ENABLE_RMB         IN OBJECT ach_db

    ac_object.save_pds_view             = ac_object.ach_commit_view

    ac_object.ach_new_version           = SELECT 'ach_table'.NEW_VERSION        IN OBJECT ach_db
    ac_object.ach_new_entry_code        = SELECT 'ach_table'.NEW_ENTRY_CODE     IN OBJECT ach_db

    { ------------------------------------------------------------------------- }
    { Make sure new version and entry code really exist for table...            }
    { ------------------------------------------------------------------------- }

    IF ( NOT VALID_FIELD ( ac_object.ach_base_table, "ENTRY_CODE" ) ) THEN

        ac_object.ach_new_entry_code = FALSE

    ENDIF

    GET_TABLE_DETAILS 'ac_object.ach_base_table', "VERSION_FIELD", a_semi

    IF ( a_semi = EMPTY ) THEN

        ac_object.ach_new_version = FALSE

    ENDIF

    { ------------------------------------------------------------------------- }
    { The base table sets the output type and update for reports etc            }
    { ------------------------------------------------------------------------- }

    IF     ( INDEX ( ac_object.ach_base_table, "BATCH_HEADER" ) > 0 ) THEN

        ac_object.batches_enabled = TRUE

    ELSEIF ( INDEX ( ac_object.ach_base_table, "CERTIFICATE" ) > 0  ) THEN

        ac_object.certificates_enabled = TRUE
        ac_object.do_decrement_mode    = FALSE   { *** gets each table as if not in heirarchy *** }

    ELSEIF ( INDEX ( ac_object.ach_base_table, "LOT_DETAILS" ) > 0  ) THEN

        ac_object.lot_enabled = TRUE

    ELSEIF ( INDEX ( ac_object.ach_base_table, "TEST_SCHED_HEADER" ) > 0  ) THEN

        ac_object.test_schedule_enabled = TRUE

    ELSEIF ( INDEX ( ac_object.ach_base_table, "MLP_HEADER" ) > 0   ) THEN

        ac_object.mlp_enabled       = TRUE
        ac_object.do_decrement_mode = FALSE   { *** gets each table as if not in heirarchy *** }

    ELSEIF ( INDEX ( ac_object.ach_base_table, "STANDARD_VERSIONS") > 0  ) THEN

        ac_object.standard_enabled = TRUE

    ELSEIF ( INDEX ( ac_object.ach_base_table, "VERSIONED_ANALYSIS" ) > 0 ) THEN

        ac_object.analysis_enabled  = FALSE
        ac_object.do_decrement_mode = FALSE   { *** gets each table as if not in heirarchy *** }

    ELSEIF ( INDEX ( ac_object.ach_base_table, "WORKSHEET" ) > 0 ) THEN

        ac_object.worksheets_mode = TRUE

    ELSEIF ( INDEX ( ac_object.ach_base_table, "SAMPLE"     ) > 0 ) THEN

        ac_object.jstr_enabled = TRUE

    ELSEIF ( INDEX ( ac_object.ach_base_table, "LABELPRINT" ) > 0 ) THEN                           { LIT 12-Dec-2010 START  }

        ac_object.labels_enabled    = TRUE
        ac_object.do_decrement_mode = FALSE   { *** gets each table as if not in heirarchy *** }   { LIT 12-Dec-2010 END  }

    ELSEIF ( INDEX ( ac_object.ach_base_table, "JOB_HEADER" ) > 0 ) THEN

        ac_object.jstr_enabled = TRUE

    ELSEIF ( INDEX ( ac_object.ach_base_table, "PDS_STUDY"  ) > 0 ) THEN

        ac_object.jstr_mode = TRUE
        ac_object.pds_mode     = TRUE

    ELSEIF ( INDEX ( ac_object.ach_base_table, "PDS_PROTO"  ) > 0 ) THEN

        ac_object.pds_mode       = TRUE
        ac_object.pds_proto_mode = TRUE

    ELSE

        { should be a custom mode handled by custom trigger }

    ENDIF

    { --------------------------------------------------------------------- }
    { Build the id of the commit criteria so it can be read later on....    }
    { --------------------------------------------------------------------- }

    ac_object.ach_commit_criteria = C_CRITERIA_PREFIX : PAD ( SUBSTITUTE ( ac_object.ach_identity, " ", "" ), " ", 20 )

    { --------------------------------------------------------------------- }
    { Save the 1rst field name of identity for list index                   }
    { --------------------------------------------------------------------- }

    GET_TABLE_DETAILS 'ac_object.ach_base_table', "KEY0_FIELD", ac_object.ach_field_identity

    ac_object.ac_id_field_1 = ac_object.ach_field_identity[1]

    { -------------------------------------------------------------- }
    { Max cycle for any one process                                  }
    { -------------------------------------------------------------- }

    ac_object.max_count = NUMERIC ( GLOBAL (  GLBL_AUTO_COMMIT_MAX_COUNT ) )

    IF ( ac_object.max_count = EMPTY ) OR ( BLANK ( ac_object.max_count ) ) OR ( NOT NUMTEXT ( ac_object.max_count ) ) THEN

        ac_object.max_count = 10

    ENDIF

    { -------------------------------------------------------------- }
    { Config if we do CSV's on archive                               }
    { -------------------------------------------------------------- }

    ac_object.do_archive_csv         = FALSE
    ac_object.do_archive_csv_enabled = SELECT CONFIG_HEADER.VALUE WHERE IDENTITY = GLBL_AUTO_COMMIT_ARCHIVE_CSV
    ac_object.del_archive_save_csv = GLOBAL ( GLBL_AUTO_COMMIT_ARCHIVE_CSV )

    IF ( ac_object.do_archive_csv_enabled = EMPTY ) OR ( BLANK ( ac_object.do_archive_csv_enabled ) )  THEN

        ac_object.do_archive_csv_enabled = FALSE
        ac_object.do_archive_csv         = FALSE

    ELSEIF ( export_mode ) THEN

        ac_object.do_archive_csv         = TRUE
        ac_object.do_archive_csv_enabled = TRUE
        ac_object.ace_show_short_report = FALSE
    ENDIF

    { -------------------------------------------------------------- }
    { Config if we check all tablesets when static is removed        }
    { -------------------------------------------------------------- }

    ac_object.check_all_tablesets = SELECT CONFIG_HEADER.VALUE WHERE IDENTITY = GLBL_AUTO_COMMIT_CHECK_ALL

    IF ( ac_object.check_all_tablesets = EMPTY ) OR ( BLANK ( ac_object.check_all_tablesets ) )  THEN

        ac_object.check_all_tablesets = FALSE

    ENDIF

    ARRAY ac_object.a_field                       { key0 array of where <field = > values   }
    ARRAY ac_object.a_select_field                { key0 array of       <select  > values   }
    ARRAY ac_object.a_identity                    { key0 array of select = < identity >     }
    ARRAY ac_object.ace_csv_field_names           { Archive/csv fields for each table       }
    ARRAY ac_object.ace_archive_set               { Archive/csv data all records each table }
    ARRAY ac_object.ace_csv_file_id               { Each table/file for archive             }

    ARRAY ac_object.pds_array_c_factor            { Special tables for pds archive          }
    ARRAY ac_object.pds_array_t_factor            { ...                                     }
    ARRAY ac_object.pds_array_l_factor            { ...                                     }
    ARRAY ac_object.array_test_schedules          { Special keep each pointer for export    }
    ARRAY ac_object.array_analysis                { ...                                     }
    ARRAY ac_object.array_mlp_levels              { ...                                     }
    ARRAY ac_object.array_text_phrase             { ...                                     }
    ARRAY ac_object.array_criteria_saved          { ...                                     }
    ARRAY ac_object.array_limit_phrase            { ...                                     }
    ARRAY ac_object.array_limit_calc              { ...                                     }
    ARRAY ac_object.array_list_result             { ...                                     }
    ARRAY ac_object.array_base_identities         { Keep array of all base identities       }
{}  ARRAY ac_object.array_param_link
    { --------------------------------------------------------------------- }
    { Figure out the trigger library and if it is a valid library           }
    { --------------------------------------------------------------------- }

    ac_object.user_library = SELECT REPORT.IDENTITY
                                  WHERE IDENTITY = C_TRIGGER_LIBRARY
                                  AND REMOVEFLAG = FALSE

    { --------------------------------------------------------------------- }
    { Create the logfile and archive report filenames for saving data       }
    { --------------------------------------------------------------------- }

    ac_object.ace_order_number = SELECT MAX AUTO_COMMIT_EXECUTION.ORDER_NUMBER
                                 WHERE IDENTITY = ac_object.ach_identity


    IF ac_object.ace_order_number = EMPTY THEN
        ac_object.ace_order_number = PACKED_DECIMAL ( 1 )
    ELSE
        ac_object.ace_order_number = PACKED_DECIMAL ( ac_object.ace_order_number + 1 )
    ENDIF

    ac_object.ace_full_id = ac_object.ach_identity : ac_object.ace_order_number
    ac_object.ace_file_id = STRIP(ac_object.ach_identity)

    { ------------------------------------------------------------------------ }
    { When data is export mode the kit is made package compatible              }
    { ------------------------------------------------------------------------ }

    IF ( export_mode ) THEN

        ac_object.ace_file_id = C_EXPORT_PREFIX : STRIP ( GLOBAL ( "AUTO_COMMIT_SYSTEM" ) ) :"_": ac_object.ace_file_id

        IF ( ac_object.ach_new_version ) THEN

            ac_object.ace_file_id = ac_object.ace_file_id : "-NV"

        ENDIF

        IF ( ac_object.ach_new_entry_code ) THEN

            ac_object.ace_file_id = ac_object.ace_file_id : "-NC"

        ENDIF

    ENDIF

    ac_object.ace_file_id = STRIP ( ac_object.ace_file_id ) :"_": STRIP ( ac_object.ace_order_number )
    a_rec                 = LOGICAL ("SMP$ARCHIVEFILES")
    a_semi                = INDEX ( a_rec, ";" )

    IF ( a_semi > 0 ) THEN

        a_rec = LEFTSTRING ( a_rec, a_semi - 1 ) : "\" : ac_object.ace_file_id

    ELSE

        a_rec = a_rec : "\" : ac_object.ace_file_id
    ENDIF

    ac_object.ace_logfile     = a_rec : "\" : ac_object.ace_file_id : ".log"
    ac_object.ace_report      = a_rec : "\" : ac_object.ace_file_id : ".txt"
    ac_object.ace_zip_file_id = a_rec : "\" : ac_object.ace_file_id : ".arc"

    { -------------------------------------------------------------------------------- }
    { Some want long detailed reports, others want it simple and quick keys only       }
    { -------------------------------------------------------------------------------- }

    ac_object.ace_show_short_report = GLOBAL ( GLBL_AUTO_COMMIT_SHORT_REPORT )

    IF ( ac_object.ace_show_short_report = EMPTY ) OR ( BLANK ( ac_object.ace_show_short_report ) ) THEN

        ac_object.ace_show_short_report = FALSE

    ENDIF

    { -------------------------------------------------------------------------------- }
    { If we do short report then set the filename, otherwise it is empty and not done  }
    { -------------------------------------------------------------------------------- }

    ac_object.ace_short_report = a_rec : "\" : ac_object.ace_file_id : ".cnt"

    { -------------------------------------------------------------------- }
    { If the archive subdir for the set does not exist make it now...      }
    { -------------------------------------------------------------------- }

    IF ( NOT FILE EXISTS ( a_rec ) ) THEN

        internal_create_directory ( a_rec )

    ENDIF

    { --------------------------------------------------------------------- }
    { Set smp version and version number for tablesets                      }
    { --------------------------------------------------------------------- }

    ARRAY an_array

    ac_object.smp_version        = PAD ( SUBSTITUTE ( smp_version_number(), " ", "" ), " ", 10 )
    ac_object.smp_version_number = array_select_max ( "SMP_TABLESETS", "VERSION_NUMBER", an_array )

    IF ac_object.smp_version_number = EMPTY THEN
        ac_object.smp_version_number = PACKED_DECIMAL ( 1 )
    ELSE
        ac_object.smp_version_number = PACKED_DECIMAL ( ac_object.smp_version_number )
    ENDIF

    { --------------------------------------------------------------------- }
    { From here on we can start logging the issues...                       }
    { --------------------------------------------------------------------- }

    ac_object.create_logfile()

    { --------------------------------------------------------------------- }
    { Read prefixes and auto_commit_tables and required system tables       }
    { --------------------------------------------------------------------- }

    ac_object.ach_commit_destination_type   = SELECT SMP_TABLESETS.TABLE_SET_MODE
                                              WHERE SMP_VERSION    = ac_object.smp_version
                                              AND   VERSION_NUMBER = ac_object.smp_version_number
                                              AND   TABLE_SET_ID   = ac_object.ach_commit_destination

    IF ( ( ac_object.ach_commit_destination_type = EMPTY ) OR ( BLANK (ac_object.ach_commit_destination_type) ) ) THEN

        ret_val = FALSE

    ELSE

        ac_object.ach_commit_destination_prefix = STRIP ( SELECT SMP_TABLESETS.TABLE_SET_PREFIX )

        ac_object.ach_commit_source_type        = SELECT SMP_TABLESETS.TABLE_SET_MODE
                                                  WHERE SMP_VERSION    = ac_object.smp_version
                                                  AND   VERSION_NUMBER = ac_object.smp_version_number
                                                  AND   TABLE_SET_ID   = ac_object.ach_commit_source

        IF ( ac_object.ach_commit_source_type = EMPTY ) OR ( BLANK (ac_object.ach_commit_source_type) ) THEN

            ret_val = FALSE

        ELSE

            ac_object.ach_commit_source_prefix = STRIP ( SELECT SMP_TABLESETS.TABLE_SET_PREFIX )

            IF ( ac_object.set_commit_mode() ) THEN

                { --------------------------------------------------------------------- }
                { Read in the system table array for deducing system commit tables      }
                { --------------------------------------------------------------------- }

                ARRAY GLBL_system_array

                i     = 0
                a_rec = SELECT SMP_TABLE_ARCOM.SYSTEM_TABLE
                            WHERE SMP_VERSION    = ac_object.smp_version
                            AND   VERSION_NUMBER = ac_object.smp_version_number
                            AND   REQUIRED       = FALSE

                WHILE ( a_rec <> EMPTY ) DO

                    i                    = i + 1
                    GLBL_system_array[i] = a_rec

                    NEXT SMP_TABLE_ARCOM
                    a_rec = SELECT SMP_TABLE_ARCOM.SYSTEM_TABLE

                ENDWHILE

                { --------------------------------------------------------------------- }
                { Functionality added late check that all X tables exist                }
                { --------------------------------------------------------------------- }

                ARRAY ac_object.required_array

                i     = 0
                a_rec = SELECT SMP_TABLE_ARCOM.SYSTEM_TABLE
                            WHERE SMP_VERSION    = ac_object.smp_version
                            AND   VERSION_NUMBER = ac_object.smp_version_number
                            AND   REQUIRED       = TRUE

                IF ( a_rec <> EMPTY ) THEN

                    WHILE ( a_rec <> EMPTY ) DO

                        i                             = i + 1
                        ac_object.required_array[i,1] = STRIP ( ac_object.ach_commit_source_prefix ) : STRIP ( a_rec )
                        ac_object.required_array[i,2] = TRUE

                        IF ac_object.required_array[i,1] = "ARCHIVE_AUDIT_TRANSACTION" THEN
                            ac_object.required_array[i,1] = "ARCHIVE_AUDIT_TRANS"
                        ENDIF

                        NEXT SMP_TABLE_ARCOM
                        a_rec = SELECT SMP_TABLE_ARCOM.SYSTEM_TABLE

                    ENDWHILE

                ELSE

                    ac_object.required_array[1,1] = EMPTY
                    ac_object.required_array[1,2] = EMPTY

                ENDIF

            ELSE

                ret_val = FALSE

            ENDIF  { ret_val from set_commit_mode }

        ENDIF   { ret_val from source lookup }

    ENDIF  { ret_val from destination lookup }

    { --------------------------------------------------------------------- }
    { Do some validation checking, records may have been error table loaded }
    { --------------------------------------------------------------------- }

    IF  ( ret_val ) AND ( ac_object.validate_ach() ) THEN

        { --------------------------------------------------------------------- }
        { Dump all data known so far to the logfile                             }
        { --------------------------------------------------------------------- }

        ac_object.current_routine = "internal_initialize_auto_commit "

        ac_object.dump_ac_object()

        { --------------------------------------------------------------------- }
        { Get the dependent tables (auto_commit_list)                           }
        { --------------------------------------------------------------------- }

        ret_val = ac_object.get_auto_commit_list()

        { --------------------------------------------------------------------- }
        { Determine which automatic tables actually have destination's defined  }
        { --------------------------------------------------------------------- }

        ret_val = ret_val AND ( ac_object.get_system_tables() )

        { --------------------------------------------------------------------- }
        { Now set the source (active, or a committed tableset)                  }
        { --------------------------------------------------------------------- }

        ret_val = ret_val AND ( ac_object.set_source_tableset() )

        { --------------------------------------------------------------------- }
        { Get the auto commit list we may be doing archive csv and chain...     }
        { --------------------------------------------------------------------- }

        IF ( VALID_TABLE ( "AUTO_COMMIT_LIST" ) ) AND ( ret_val ) THEN

            CREATE OBJECT C_STD_OBJECT_DATABASE, ac_object.ach_list_dbase
                ac_object.ach_list_dbase.initialise ( "AUTO_COMMIT_LIST" )
                ac_object.ach_list_dbase.select ( select_array )
                ac_object.ach_list_dbase.set_first()

            ac_object.ach_list_record = ac_object.ach_list_dbase.current

        ENDIF

    ENDIF   { validation checking, size array }

    { ----------------------------------------------------- }
    { Let the logfile know what condition is being returned }
    { ----------------------------------------------------- }

    IF NOT ( ret_val ) THEN

        ret_val                   = FALSE
        ac_object.error_msg       = msg.08:" ":ac_object.ach_identity
        ac_object.current_routine = "internal_initialize_auto_commit "
        internal_log_message ( ac_object, ac_object.current_routine:ac_object.error_msg, C_MSG_FULL )

    ELSE

        ac_object.current_routine = "internal_initialize_auto_commit "
        internal_log_message ( ac_object, ac_object.current_routine : ret_val, C_MSG_LOW )

    ENDIF

    RETURN ( ret_val )

ENDROUTINE    { internal_initialize_auto_commit }

{******************************************************************************}

ROUTINE ac_object_action_show_final_report ( ac_object, VALUE ret_val )

    IF ( ret_val ) THEN

        tmp = internal_translate_message ( "LIT_AUTO_COMMIT_EXPORT_COMPLETED" ) : ac_object.ace_report
        window_set_status ( tmp )

        IF ( ac_object.do_archive_csv ) THEN

            IF ( ( ac_object.count_base > 0 ) OR ( ac_object.count_pds_study > 0 ) ) AND ( ac_object.archive_csv_zip_files() ) THEN

                ac_object.archive_csv_update_export()

                IF FILE EXISTS ( ac_object.ace_report ) THEN

                    WriteToLog("FILE SEND ":ac_object.ace_report:", DISPLAY/")
                    FILE SEND ac_object.ace_report, "DISPLAY/"

                ENDIF

            ELSEIF ( ac_object.count_base = 0 ) AND ( ac_object.count_pds_study = 0 )THEN

                tmp = internal_translate_message ( "LIT_AUTO_COMMIT_EXPORT_NO_DATA" ) : ac_object.ace_report

                fm(tmp)

            ELSE

                ret_val             = FALSE
                ac_object.error_msg = msg_130
                fm("LIT_AUTO_COMMIT_EXPORT_ZIP_ERROR")

            ENDIF

        ELSEIF ( ac_object.ace_show_short_report ) AND FILE EXISTS ( ac_object.ace_short_report ) THEN

            WriteToLog("FILE SEND ":ac_object.ace_short_report:", DISPLAY/")
            FILE SEND ac_object.ace_short_report, "DISPLAY/"

        ELSEIF FILE EXISTS ( ac_object.ace_report ) THEN

            WriteToLog("FILE SEND ":ac_object.ace_report:", DISPLAY/")
            FILE SEND ac_object.ace_report, "DISPLAY/"

        ELSE

            tmp = internal_translate_message ("LIT_AUTO_COMMIT_FILE_NOT_FOUND") : ac_object.ace_report
            fm(tmp : ac_object.ace_report)

        ENDIF

    ELSEIF FILE EXISTS ( ac_object.ace_logfile ) THEN

        IF FILE EXISTS ( ac_object.ace_report ) THEN

            WriteToLog("FILE SEND ":ac_object.ace_report:", DISPLAY/")
            FILE SEND ac_object.ace_report, "DISPLAY/"

        ENDIF

        WriteToLog("FILE SEND ":ac_object.ace_logfil:", DISPLAY/")
        FILE SEND ac_object.ace_logfile, "DISPLAY/"

    ENDIF  { retval }

ENDROUTINE  { ac_object_action_show_final_report }

{******************************************************************************}

ROUTINE ac_object_action_set_commit_mode ( ac_object )

    ac_object.current_routine = "ac_object_action_set_commit_mode "
    ret_val                   = TRUE

    { ------------------------------------------------------------------ }
    { The commit mode is set and must be confirmed that it is ok         }
    { ------------------------------------------------------------------ }

    IF ( ac_object.ach_commit_source           = ac_object.ach_commit_destination )
    OR ( ac_object.ach_commit_source_type      = EMPTY                            )
    OR ( ac_object.ach_commit_destination_type = EMPTY                            ) THEN

        ret_val             = FALSE
        ac_object.error_msg = msg.09
        tmp                 = ac_object.current_routine : msg.09

        internal_log_message ( ac_object, tmp, C_MSG_FULL )

    ELSEIF ( ac_object.ach_commit_source_type = C_TABLESET_REMOVE  ) THEN

        ac_object.commit_mode   = C_TABLESET_REMOVE
        ac_object.do_REMOVEFLAG = TRUE

    ELSEIF ( ac_object.ach_commit_source_type = C_TABLESET_ACTIVE  ) THEN

        IF ( ac_object.ach_commit_destination_type = C_TABLESET_RETAIN  ) THEN

            ac_object.commit_mode = C_TABLESET_COMMIT

        ELSEIF ( ac_object.ach_commit_destination_type = C_TABLESET_COMMIT  ) THEN

            ac_object.commit_mode = C_TABLESET_COMMIT

        ELSEIF ( ac_object.ach_commit_destination_type = C_TABLESET_ARCHIVE  ) THEN

            ac_object.commit_mode = C_TABLESET_COMMIT

        ELSEIF ( ac_object.ach_commit_destination_type = C_TABLESET_DELETE  ) THEN

            ac_object.commit_mode = C_TABLESET_DELETE
            ac_object.do_DELETE   = TRUE

        ELSEIF ( ac_object.ach_commit_destination_type = C_TABLESET_REMOVE  ) THEN

            ac_object.commit_mode   = C_TABLESET_REMOVE
            ac_object.do_REMOVEFLAG = TRUE

        ELSEIF ( ac_object.ach_commit_destination_type = C_TABLESET_EXPORT  ) THEN

            ac_object.commit_mode    = C_TABLESET_EXPORT
            ac_object.do_archive_csv = ac_object.do_archive_csv_enabled

        ELSE

            ret_val             = FALSE
            ac_object.error_msg = msg.16
            tmp                 = ac_object.current_routine : msg.16

            internal_log_message ( ac_object, tmp, C_MSG_FULL )

        ENDIF

    ELSEIF ( ac_object.ach_commit_source_type = C_TABLESET_ARCHIVE ) THEN

        IF ( ac_object.ach_commit_destination_type = C_TABLESET_RETAIN  ) THEN

            ac_object.commit_mode = C_TABLESET_COMMIT_MOVE

        ELSEIF ( ac_object.ach_commit_destination_type = C_TABLESET_COMMIT  ) THEN

            ac_object.commit_mode = C_TABLESET_COMMIT_MOVE

        ELSEIF ( ac_object.ach_commit_destination_type = C_TABLESET_ACTIVE  ) THEN

            ac_object.commit_mode = C_COMMIT_MODE_DECONSIGN
            ac_object.do_consign  = FALSE

        ELSEIF ( ac_object.ach_commit_destination_type = C_TABLESET_DELETE  ) THEN

            ac_object.commit_mode = C_TABLESET_DELETE
            ac_object.do_DELETE   = TRUE
            ac_object.do_archive_csv = ac_object.do_archive_csv_enabled

        ELSEIF ( ac_object.ach_commit_destination_type = C_TABLESET_REMOVE  ) THEN

            ac_object.commit_mode   = C_TABLESET_REMOVE
            ac_object.do_REMOVEFLAG = TRUE
            ac_object.do_archive_csv = ac_object.do_archive_csv_enabled

        ELSE
            ret_val             = FALSE
            ac_object.error_msg = msg.47
            tmp                 = ac_object.current_routine : msg.47

            internal_log_message ( ac_object, tmp, C_MSG_FULL )

        ENDIF

    ELSEIF ( ac_object.ach_commit_source_type = C_TABLESET_RETAIN  ) THEN

        IF ( ac_object.ach_commit_destination_type = C_TABLESET_COMMIT  ) THEN

            ac_object.commit_mode = C_TABLESET_COMMIT_MOVE

        ELSEIF ( ac_object.ach_commit_destination_type = C_TABLESET_ACTIVE ) THEN

            ac_object.commit_mode = C_COMMIT_MODE_DECONSIGN
            ac_object.do_consign  = FALSE

        ELSE
            ret_val             = FALSE
            ac_object.error_msg = msg.48
            tmp                 = ac_object.current_routine : msg.48

            internal_log_message ( ac_object, tmp, C_MSG_FULL )

        ENDIF

    ELSEIF ( ac_object.ach_commit_source_type = C_TABLESET_COMMIT  ) THEN

        IF     ( ac_object.ach_commit_destination_type = C_TABLESET_ARCHIVE ) THEN

            ac_object.commit_mode = C_TABLESET_ARCHIVE

        ELSEIF ( ac_object.ach_commit_destination_type = C_TABLESET_RETAIN  ) THEN

            ac_object.commit_mode = C_TABLESET_COMMIT_MOVE

        ELSEIF ( ac_object.ach_commit_destination_type = C_TABLESET_COMMIT  ) THEN

            ac_object.commit_mode = C_TABLESET_COMMIT_MOVE

        ELSEIF ( ac_object.ach_commit_destination_type = C_TABLESET_ACTIVE ) THEN

            ac_object.commit_mode = C_COMMIT_MODE_DECONSIGN
            ac_object.do_consign  = FALSE

        ELSE

            ret_val             = FALSE
            ac_object.error_msg = msg.49
            tmp                 = ac_object.current_routine : msg.49

            internal_log_message ( ac_object, tmp, C_MSG_FULL )

        ENDIF
    ELSE

        ret_val             = FALSE
        ac_object.error_msg = msg.50
        tmp                 = ac_object.current_routine : msg.50

        internal_log_message ( ac_object, tmp, C_MSG_FULL )

    ENDIF


    RETURN ( ret_val )

ENDROUTINE    { ac_object_action_set_commit_mode }

{******************************************************************************}

ROUTINE ac_object_action_dump_ac_object ( ac_object )

    tmp = ac_object.current_routine : msg.12
    internal_log_message ( ac_object, tmp, C_MSG_LOW )
    tmp = "ac_object.smp_version                   = " : ac_object.smp_version
    internal_log_message ( ac_object, tmp, C_MSG_LOW )
    tmp = "ac_object.smp_version_number            = " : ac_object.smp_version_number
    internal_log_message ( ac_object, tmp, C_MSG_LOW )
    tmp = "ac_object.ach_identity                  = " : ac_object.ach_identity
    internal_log_message ( ac_object, tmp, C_MSG_LOW )
    tmp = "ac_object.ach_base_table                = " : ac_object.ach_base_table
    internal_log_message ( ac_object, tmp, C_MSG_LOW )
    tmp = "ac_object.ach_commit_view               = " : ac_object.ach_commit_view
    internal_log_message ( ac_object, tmp, C_MSG_LOW )
    tmp = "ac_object.ach_commit_source             = " : ac_object.ach_commit_source
    internal_log_message ( ac_object, tmp, C_MSG_LOW )
    tmp = "ac_object.ach_commit_source_type        = " : ac_object.ach_commit_source_type
    internal_log_message ( ac_object, tmp, C_MSG_LOW )
    tmp = "ac_object.ach_commit_source_prefix      = " : ac_object.ach_commit_source_prefix
    internal_log_message ( ac_object, tmp, C_MSG_LOW )
    tmp = "ac_object.ach_commit_destination        = " : ac_object.ach_commit_destination
    internal_log_message ( ac_object, tmp, C_MSG_LOW )
    tmp = "ac_object.ach_commit_destination_type   = " : ac_object.ach_commit_destination_type
    internal_log_message ( ac_object, tmp, C_MSG_LOW )
    tmp = "ac_object.ach_commit_destination_prefix = " : ac_object.ach_commit_destination_prefix
    internal_log_message ( ac_object, tmp, C_MSG_LOW )
    tmp = "ac_object.commit_mode                   = " : ac_object.commit_mode
    internal_log_message ( ac_object, tmp, C_MSG_LOW )
    tmp = "ac_object.user_library                  = " : ac_object.user_library
    internal_log_message ( ac_object, tmp, C_MSG_LOW )
    tmp = "ac_object.report_only                   = " : ac_object.report_only
    internal_log_message ( ac_object, tmp, C_MSG_LOW )
    tmp = "ac_object.ach_explorer_rmb              = " : ac_object.ach_explorer_rmb
    internal_log_message ( ac_object, tmp, C_MSG_LOW )
    tmp = "ac_object.do_consign                    = " : ac_object.do_consign
    internal_log_message ( ac_object, tmp, C_MSG_LOW )
    tmp = "ac_object.do_archive_csv                = " : ac_object.do_archive_csv
    internal_log_message ( ac_object, tmp, C_MSG_LOW )
    tmp = "ac_object.error_msg                     = " : ac_object.error_msg
    internal_log_message ( ac_object, tmp, C_MSG_LOW )

ENDROUTINE    { ac_object_action_dump_ac_object }

{******************************************************************************}

ROUTINE ac_object_action_ac_process( ac_object )

    { --------------------------------------------------------------------------- }
    {* For this record, load the criteria and then commit data found by criteria *}
    { --------------------------------------------------------------------------- }

        DECLARE old_base_id

    ac_object.current_routine = "ac_object_action_ac_process "
    ret_val                   = TRUE
    old_base_id               = ""

    IF ( ac_object.load_criteria() ) THEN

        ac_object.count_base = 0
        ac_object.continue   = TRUE

        { ------------------------------------------------ }
        {  Create an object database for all commit types  }
        { ------------------------------------------------ }

        CREATE OBJECT C_VIEW_OBJECT_DATABASE, ac_object.ac_dbase
            ac_object.ac_dbase.ac_object = ac_object
            ac_object.ac_dbase.max_count = ac_object.max_count
            ac_object.ac_dbase.initialise ( ac_object.ach_commit_view )
            ac_object.ac_dbase.select     ( ac_object.ac_dbase_select_array )
            ac_object.ac_dbase.set_first()

        { ------------------------------------------------ }
        { If dbase is empty show the log/user              }
        { ------------------------------------------------ }

        ac_object.ac_dbase_size = ac_object.ac_dbase.size()
        ac_object.ac_dbase.add_index ( ac_object.ac_id_field_1 )

        IF ( ac_object.ac_dbase_size = 0 ) THEN

            ac_object.error_msg       = msg.42
            ac_object.current_routine = "ac_object_action_ac_process "

            internal_log_message ( ac_object, ac_object.current_routine:ac_object.error_msg, C_MSG_MED )

            { ----------------------------------------------------- }
            { Write criteria to log, report done when finished      }
            { ----------------------------------------------------- }

            ac_object.write_criteria()

            FILE WRITE ac_object.ace_report      , msg.42, tmp
            FILE WRITE ac_object.ace_short_report, msg.42, tmp

        ELSEIF ( NOT ac_object.review_mode ) THEN

            { ----------------------------------------------------- }
            { Write criteria to log, report done when finished      }
            { ----------------------------------------------------- }

            ac_object.write_criteria()

            WHILE ( ac_object.ac_dbase.current <> EMPTY ) AND ( ac_object.continue ) AND ( ret_val ) DO

                ac_object.set_key0_fields()

                IF ( ac_object.report_only ) AND ( old_base_id = ac_object.base_table_identity ) THEN

                    { skip }

                ELSE
                    ret_val = ac_object.ac_process_1_record()

                    IF ( ac_object.processed_a_record ) THEN

                        FILE WRITE ac_object.ace_report, msg.52, tmp     { - - - - separator line written }
                        FILE WRITE ac_object.ace_report, msg.33 : ac_object.ach_base_table : ac_object.base_table_identity , tmp
                        FILE WRITE ac_object.ace_report, msg.52, tmp     { - - - - separator line written }

                        FILE WRITE ac_object.ace_short_report, msg.33 : ac_object.ach_base_table : ac_object.base_table_identity , tmp

                    ENDIF
                ENDIF

                ac_object.ac_dbase.set_next()

                IF ( ac_object.count_base >= ac_object.max_count ) THEN

                    ac_object.continue = FALSE

                ENDIF

                old_base_id = ac_object.base_table_identity

            ENDWHILE

        ELSE

            ret_val = ac_object.review_list()

        ENDIF

        { ---------------------------------------------------------- }
        { If archive mode and csv is enabled then save the data      }
        { ---------------------------------------------------------- }

        IF ( ret_val ) AND ( ( ac_object.do_archive_csv ) OR ( ac_object.del_archive_save_csv ) ) THEN

            ret_val = ac_object.archive_csv_all_files()

            IF ( ret_val ) THEN     { needed when delete of removeflags }
                COMMIT
            ELSE
                ROLLBACK

            ENDIF

        ENDIF

        ac_object.current_routine = "ac_object_action_ac_process "
        internal_log_message ( ac_object, ac_object.current_routine : ac_object.ac_dbase_size, C_MSG_LOW )

    ENDIF  { nothing to select - returned false }

    { ----------------------------------------------------- }
    { Let the logfile know what condition                   }
    { ----------------------------------------------------- }

    ac_object.current_routine = "ac_object_action_ac_process "
    internal_log_message ( ac_object, ac_object.current_routine : ret_val, C_MSG_LOW )

    RETURN ( ret_val )

ENDROUTINE { ac_object_action_ac_process }

{******************************************************************************}

ROUTINE ac_object_action_process_pds_proto_mlp ( ac_object )

DECLARE select_array,
        ac_db       ,
        ach_db      ,
        ac_id       ,
        ach_table   ,
        report_only ,
        debug_level ,
        review_mode ,
        export_mode ,
        save_product,
        save_version

    ret_val      = TRUE
    ach_table    = "AUTO_COMMIT_HEADER"
    report_only  = FALSE
    debug_level  = 0
    review_mode  = FALSE
    export_mode  = TRUE
    ac_id        = C_MLP_EXPORT_ID
    save_product = ac_object.pds_product
    save_version = ac_object.pds_product_version

    ac_object.current_routine = "ac_object_action_process_pds_proto_mlp "

    internal_log_message ( ac_object, ac_object.current_routine:ac_object.ach_commit_view, C_MSG_LOW )

    { ----------------------------------------------------------------------- }
    { Reset object so that it believes that an MLP is what started all        }
    { ----------------------------------------------------------------------- }

    ARRAY select_array

    ARRAY_SELECT_ADD ( select_array, ARRAY_SELECT_EQ, "IDENTITY", C_MLP_EXPORT_ID )

    CREATE OBJECT C_STD_OBJECT_DATABASE, ac_db
        ac_db.initialise ( ach_table )
        ac_db.select ( select_array )
        ac_db.set_first()
        ach_db = ac_db.current

    IF  ( ach_db <> EMPTY )
    AND ( internal_initialize_auto_commit( ac_object, ach_db, ac_id, ach_table, select_array, report_only, debug_level, review_mode, export_mode, TRUE ) ) THEN

        { ----------------------------------------------------------------------- }
        { Next set selection for the pds's mlp and version and do complete cycle  }
        { ----------------------------------------------------------------------- }

        ac_object.max_count           = 1              { only do this one MLP      }
        ac_object.review_mode         = FALSE          { do not show review screen }
        ac_object.pds_product         = save_product
        ac_object.pds_product_version = save_version

        ARRAY ac_object.ac_dbase_select_array

        ARRAY_SELECT_ADD ( ac_object.ac_dbase_select_array, ARRAY_SELECT_EQ, "IDENTITY", ac_object.pds_product )

        IF ( ac_object.pds_product_version <> EMPTY ) THEN

            ac_object.pds_product_version = PACKED_DECIMAL ( ac_object.pds_product_version )

            IF ( ac_object.pds_product_version <> ERROR ) THEN

                ARRAY_SELECT_ADD ( ac_object.ac_dbase_select_array, ARRAY_SELECT_EQ, "PRODUCT_VERSION", ac_object.pds_product_version )

            ELSE

                ac_object.pds_product_version = EMPTY

            ENDIF

        ENDIF

        ac_object.rmb_object   = ac_object.ac_dbase_select_array
        ac_object.rmb_var_type = "Array"

        ret_val = ac_object.ac_process()

    ELSE

        internal_log_message ( ac_object, " AUTO_COMMIT_HEADER ":C_MLP_EXPORT_ID, C_MSG_FULL )
        fm(" AUTO_COMMIT_HEADER ":C_MLP_EXPORT_ID)

    ENDIF

    { ----------------------------------------------------------------------- }
    { Let the log file know how thing came out in this routine                }
    { ----------------------------------------------------------------------- }

    ac_object.current_routine = "ac_object_action_process_pds_proto_mlp "

    internal_log_message ( ac_object, ac_object.current_routine:ac_object.ach_commit_view:"** ":ret_val:" **", C_MSG_LOW )

    RETURN ( ret_val )

ENDROUTINE  { ac_object_action_process_pds_proto_mlp }

{******************************************************************************}

ROUTINE ac_object_action_ac_process_1_record ( ac_object )

    ret_val                   = TRUE
    ac_object.current_routine = "ac_object_action_ac_process_1_record "

    internal_log_message ( ac_object, ac_object.current_routine:ac_object.ach_commit_view, C_MSG_LOW )

    { ----------------------------------------------------------------------- }
    { Allow one last veto if user is running interactive else internal checks }
    { ----------------------------------------------------------------------- }

    IF NOT ( ac_object.check_conditions() ) THEN

        ret_val = TRUE   { not a disastrous failure... just conditions don't allow arcom }

    ELSE

        IF ( NOT ac_object.report_only ) THEN

            { -------------------------------------------------------------- }
            { During delete mode commit is in calling routine...             }
            { -------------------------------------------------------------- }

            IF NOT ( TRANSACTION_IS_WRITE() ) THEN

                START WRITE TRANSACTION ( STRIP ( ac_object.ace_report ) )

            ENDIF

        ENDIF

        { ----------------------------------------------------------------------- }
        { This is what actually does all the work and the commit/rollback         }
        { ----------------------------------------------------------------------- }

        IF ( ac_object.?ac_object.commit_mode?() ) THEN

            IF ( ac_object.pds_mode ) THEN

                ac_object.count_pds_study                                  = ac_object.count_pds_study + 1
                ac_object.array_base_identities[ac_object.count_pds_study] = ac_object.base_table_identity

                IF ( INDEX ( ac_object.ach_base_table, "PDS_STUDY" ) > 0 ) AND ( ac_object.commit_pds_job() ) THEN

                    ac_object.count_base = ac_object.count_base + 1

                    ac_object.toggle_pds_objects ( "PDS_STUDY" )

                ELSEIF ( INDEX ( ac_object.ach_base_table, "PDS_PROTO" ) > 0 ) THEN

                    ac_object.current_routine = "ac_object_action_ac_process_1_record ":ac_object.base_table_identity:retval
                    internal_log_message ( ac_object, ac_object.current_routine, C_MSG_FULL )

                ELSE

                    ROLLBACK

                    ret_val                   = FALSE
                    ac_object.current_routine = "ac_object_action_ac_process_1_record ":ret_val

                    internal_log_message ( ac_object, ac_object.current_routine, C_MSG_FULL )

                ENDIF   { commit of job off of PDS failed OR is a proto not a study }

            ELSE

                ac_object.count_base                                   = ac_object.count_base + 1
                ac_object.array_base_identities[ac_object.count_base]  = ac_object.base_table_identity

            ENDIF

            { -------------------------------------------------------------- }
            { Commit all or rollback - excecpt on delete...                  }
            { -------------------------------------------------------------- }

            IF NOT ( ac_object.report_only ) AND ( ret_val ) THEN

                { -------------------------------------------------------------- }
                { Post process of base tables and children now any special ones  }
                { -------------------------------------------------------------- }

                IF ( ac_object.do_archive_csv ) THEN

                    retval = ac_object.table_special_process()

                ELSEIF ( ac_object.do_DELETE ) THEN

                    ac_object.current_routine = "ac_object_action_ac_process_1_record <Defer Commit> ":ret_val
                    internal_log_message ( ac_object, ac_object.current_routine, C_MSG_LOW )

                ELSEIF ( retval ) THEN

                    COMMIT

                ELSE

                    ROLLBACK

                ENDIF

            ELSE

                ROLLBACK

            ENDIF   { retval from low level routine had an error or we are report only }

        ELSE

            ROLLBACK

            ret_val = FALSE
            ac_object.current_routine = "ac_object_action_ac_process_1_record ":ret_val
            internal_log_message ( ac_object, ac_object.current_routine, C_MSG_FULL )

        ENDIF   { commit_mode returned false }

    ENDIF   { skip veto }

    ac_object.current_routine = "ac_object_action_ac_process_1_record ":ac_object.count_base
    internal_log_message ( ac_object, ac_object.current_routine, C_MSG_LOW )

    RETURN ( ret_val )

ENDROUTINE { ac_object_action_ac_process_1_record }

{******************************************************************************}

ROUTINE ac_object_action_table_special_process ( ac_object )

DECLARE a_id, a_cnt, a_table, max_vers, a_EMPTY, phrase_list, phrase, phrases, i
ARRAY phrases

    ac_object.current_routine = "ac_object_action_table_special_process "
    internal_log_message ( ac_object, ac_object.current_routine, C_MSG_LOW )

    retval  = TRUE
    a_EMPTY = EMPTY

    { ------------------------------------------------------- }
    { Write a separator line for this section of identities   }
    { ------------------------------------------------------- }

    FILE WRITE ac_object.ace_report      , msg.52, tmp

    { --------------------------------------------------------------------- }
    { First see if there is an attachment for this table/record             }
    { --------------------------------------------------------------------- }

    retval = ac_object.table_special_file ( ac_object.ach_base_table, ac_object.base_table_identity )

    { --------------------------------------------------------------------- }
    { Do each special table as if it were a csv save on its own...          }
    { --------------------------------------------------------------------- }

    IF ( ac_object.pds_config <> EMPTY ) AND ( retval ) THEN

        retval = ac_object.table_special_table(  "PDS_CONFIG", "IDENTITY", ac_object.pds_config, EMPTY, a_EMPTY )

    ENDIF

    { --------------------------------------------------------------------- }
    { We could have many different c_factor                                 }
    { --------------------------------------------------------------------- }

    a_cnt = 1

    WHILE ( ac_object.pds_array_c_factor[a_cnt] <> EMPTY ) AND ( retval ) DO

        a_id   = ac_object.pds_array_c_factor[a_cnt]
        retval = ac_object.table_special_table ( "C_FACTOR", "IDENTITY", a_id, EMPTY, a_EMPTY )
        a_cnt  = a_cnt + 1

    ENDWHILE

    { --------------------------------------------------------------------- }
    { We could have many different T_factor                                 }
    { --------------------------------------------------------------------- }

    a_cnt = 1

    WHILE ( ac_object.pds_array_t_factor[a_cnt] <> EMPTY ) AND ( retval ) DO

        a_id   = ac_object.pds_array_t_factor[a_cnt]
        retval = ac_object.table_special_table ( "TIME_FACTOR", "IDENTITY", a_id, EMPTY, a_EMPTY )
        a_cnt  = a_cnt + 1

    ENDWHILE

    { --------------------------------------------------------------------- }
    { We could have many different l_factor                                 }
    { --------------------------------------------------------------------- }

    a_cnt = 1

    WHILE ( ac_object.pds_array_l_factor[a_cnt] <> EMPTY ) AND ( retval ) DO

        a_id   = ac_object.pds_array_l_factor[a_cnt]
        retval = ac_object.table_special_table ( "LAYER_FACTOR", "IDENTITY", a_id, EMPTY, a_EMPTY )
        a_cnt  = a_cnt + 1

    ENDWHILE

    { --------------------------------------------------------------------- }
    { We could have many different mlp levels                               }
    { --------------------------------------------------------------------- }

    a_cnt = 1

    WHILE ( ac_object.array_mlp_levels[a_cnt] <> EMPTY ) AND ( retval ) DO

        a_id   = ac_object.array_mlp_levels[a_cnt]
        retval = ac_object.table_special_table ( "MLP_LEVEL", "LEVEL_ID", a_id, EMPTY, a_EMPTY )
        a_cnt  = a_cnt + 1

    ENDWHILE

    { --------------------------------------------------------------------- }
    { We could have many different test schedules                           }
    { --------------------------------------------------------------------- }

    a_cnt = 1

    WHILE ( ac_object.array_test_schedules[a_cnt] <> EMPTY ) AND ( retval ) DO

        a_id   = ac_object.array_test_schedules[a_cnt]
        retval = ac_object.table_special_table ( "TEST_SCHED_HEADER", "IDENTITY", a_id, EMPTY, a_EMPTY )
        retval = ac_object.table_special_table ( "TEST_SCHED_ENTRY" , "IDENTITY", a_id, EMPTY, a_EMPTY )
        a_cnt  = a_cnt + 1

    ENDWHILE

    { --------------------------------------------------------------------- }
    { We could have many different analyses                                 }
    { --------------------------------------------------------------------- }

    a_cnt = 1

    WHILE ( ac_object.array_analysis[a_cnt] <> EMPTY ) AND ( retval ) DO

        max_vers = 0
        a_id     = ac_object.array_analysis[a_cnt]
        WriteToLog("VERSIONED_ANALYSIS.IDENTITY: ":a_id:", ANALYSIS_VERSION: ":max_vers)
        retval   = ac_object.table_special_table ( "VERSIONED_ANALYSIS"  , "IDENTITY", a_id, "ANALYSIS_VERSION", max_vers )   { ** max version only }
        WriteToLog("VERSIONED_COMPONENT.ANALYSIS":a_id:", ANALYSIS_VERSION: ":max_vers)
        retval   = ac_object.table_special_table ( "VERSIONED_COMPONENT" , "ANALYSIS", a_id, "ANALYSIS_VERSION", max_vers )
        WriteToLog("VERSIONED_C_L_HEADER.ANALYSIS: ":a_id:"ANALYSIS_VERSION: ":max_vers)
        retval   = ac_object.table_special_table ( "VERSIONED_C_L_HEADER", "ANALYSIS", a_id, "ANALYSIS_VERSION", max_vers )
        WriteToLog("VERSIONED_C_L_ENTRY.ANALYSIS: ":a_id:", ANALYSIS_VERSION: ":max_vers)
        retval   = ac_object.table_special_table ( "VERSIONED_C_L_ENTRY" , "ANALYSIS", a_id, "ANALYSIS_VERSION", max_vers )
        WriteToLog("Done")
        WriteToLog("")

        IF ( VALID_TABLE ( "ANALYSIS_LANGUAGE" ) ) THEN
            retval = ac_object.table_special_table ( "ANALYSIS_LANGUAGE", "ANALYSIS", a_id, "ANALYSIS_VERSION", max_vers )
        ENDIF

        IF ( VALID_TABLE ( "COMPONENT_LANGUAGE" ) ) THEN
            retval = ac_object.table_special_table ( "COMPONENT_LANGUAGE", "ANALYSIS", a_id, "ANALYSIS_VERSION", max_vers )

        ENDIF

        a_cnt = a_cnt + 1

    ENDWHILE


    { --------------------------------------------------------------------- }
    { We could have a bunch of phrases                                      }
    { --------------------------------------------------------------------- }

    a_cnt = 1

    WHILE ( ac_object.array_text_phrase[a_cnt] <> EMPTY ) AND ( retval ) DO

        a_table = "PHRASE_HEADER"
        a_id    = ac_object.array_text_phrase[a_cnt]
        retval  = ac_object.table_special_table ( a_table, "IDENTITY", a_id, EMPTY, a_EMPTY )

        { ------------------------------------------------------- }
        { Got phrases, now get entries for the phrases            }
        { ------------------------------------------------------- }

        IF ( retval ) THEN

            a_table = "PHRASE"
            retval  = ac_object.table_special_table ( a_table, "PHRASE_TYPE", a_id, EMPTY, a_EMPTY )

        ENDIF  { retval from headers... }

        a_cnt  = a_cnt + 1

    ENDWHILE

    { --------------------------------------------------------------------- }
    { We could have a bunch of entity_criteria                                      }
    { --------------------------------------------------------------------- }

    a_cnt = 1

    WHILE ( ac_object.array_criteria_saved[a_cnt] <> EMPTY ) AND ( retval ) DO

        a_table = "CRITERIA_SAVED"
        a_id    = ac_object.array_criteria_saved[a_cnt]
        retval  = ac_object.table_special_table ( a_table, "IDENTITY", a_id, EMPTY, a_EMPTY )

        { ------------------------------------------------------- }
        { Got criteria, now get condition for criteria            }
        { ------------------------------------------------------- }

        IF ( retval ) THEN

            a_table = "CRITERIA_CONDITION"
            retval  = ac_object.table_special_table ( a_table, "CRITERIA_SAVED", a_id, EMPTY, a_EMPTY )

        ENDIF  { retval from headers... }

        { ------------------------------------------------------- }
        { Got criteria, now get order for criteria                }
        { ------------------------------------------------------- }

        IF ( retval ) THEN

            a_table = "CRITERIA_ORDER"
            retval  = ac_object.table_special_table ( a_table, "CRITERIA_SAVED", a_id, EMPTY, a_EMPTY )

        ENDIF  { retval from headers... }

        a_cnt  = a_cnt + 1

    ENDWHILE

    { --------------------------------------------------------------------- }
    { Include phrases used in VERSIONED_ANALYSIS or MLP_HEADER              }
    { --------------------------------------------------------------------- }

    IF (INDEX(ac_object.ach_base_table, "VERSIONED_ANALYSIS") > 0) THEN
        phrase_list = "ANAL_TYPE,INST_TYPE,COA_GROUP,CONDI_01,MEDIA_01,QAM_DATE,Q_INSTRUCT,APPR_STAT,STAT_TYPE"
    ELSEIF (INDEX(ac_object.ach_base_table, "MLP_HEADER") > 0) THEN
        phrase_list = "MLP_GROUP,MLP_SUBGRP,SAMP_TYPE,DISP_RESP,AMOUNT_01,CERT_TYPE,SAP_CERT,APPR_STAT,MLP_APPLIC,MAT_TYPE"
    ELSE
        phrase_list = ""
    ENDIF

    WHILE LENGTH(phrase_list) > 0 DO
        i = INDEX(phrase_list, ",")
        IF i > 0 THEN
            phrase = LEFTSTRING(phrase_list, i - 1)
            phrase_list = STRIP(SUBSTRING(phrase_list, i + 1, LENGTH(phrase_list)))
        ELSE
            phrase = phrase_list
            phrase_list = ""
        ENDIF
        phrases[size_of_array(phrases) + 1] = phrase
    ENDWHILE

    i = 1
    WHILE i <= size_of_array(phrases) DO
        retval  = ac_object.table_special_table ( "PHRASE_HEADER", "IDENTITY",    phrases[i], EMPTY, a_EMPTY )
        retval  = ac_object.table_special_table ( "PHRASE",        "PHRASE_TYPE", phrases[i], EMPTY, a_EMPTY )
        i = i + 1
    ENDWHILE

    { --------------------------------------------------------------------- }
    { We could have a bunch of LIMIT phrases                                }
    { --------------------------------------------------------------------- }

    a_cnt = 1

    WHILE ( ac_object.array_limit_phrase[a_cnt] <> EMPTY ) AND ( retval ) DO

        a_table = "LIMIT_PHRASE_HEADER"
        a_id    = ac_object.array_text_phrase[a_cnt]
        retval  = ac_object.table_special_table ( a_table, "IDENTITY", a_id, EMPTY, a_EMPTY )

        { ------------------------------------------------------- }
        { Got phrases, now get entries for the phrases            }
        { ------------------------------------------------------- }

        IF ( retval ) THEN

            a_table = "LIMIT_PHRASE_ENTRY"
            retval  = ac_object.table_special_table ( a_table, "LIMIT_PHRASE", a_id, EMPTY, a_EMPTY )

        ENDIF  { retval from headers... }

        a_cnt  = a_cnt + 1

    ENDWHILE

    { --------------------------------------------------------------------- }
    { We could have many different limit_calculations / calculations        }
    { --------------------------------------------------------------------- }

    a_cnt = 1

    WHILE ( ac_object.array_limit_calc[a_cnt] <> EMPTY ) AND ( retval ) DO

        a_table = "CALCULATION"

        IF ( INDEX ( ac_object.ach_base_table, "MLP_HEADER" ) > 0 ) THEN

            a_table = "LIMIT_" : a_table

        ENDIF

        a_id   = ac_object.array_limit_calc[a_cnt]
        retval = ac_object.table_special_table ( a_table, "IDENTITY", a_id, EMPTY, a_EMPTY )
        a_cnt  = a_cnt + 1

    ENDWHILE

    { --------------------------------------------------------------------- }
    { We could have many different list_results                             }
    { --------------------------------------------------------------------- }

    a_cnt = 1

    WHILE ( ac_object.array_list_result[a_cnt] <> EMPTY ) AND ( retval ) DO

        a_id   = ac_object.array_list_result[a_cnt]
        retval = ac_object.table_special_table ( "LIST_RESULT_FORMAT", "IDENTITY", a_id, EMPTY, a_EMPTY )
        a_cnt  = a_cnt + 1

    ENDWHILE

    { --------------------------------------------------------------------- }
    { CLEAR all these arrays so they can be used for next record            }
    { --------------------------------------------------------------------- }

    ARRAY ac_object.pds_array_c_factor    { only done when pds                                     }
    ARRAY ac_object.pds_array_t_factor
    ARRAY ac_object.pds_array_l_factor

    ARRAY ac_object.array_test_schedules  { base table or off of pds / mlp's                       }
    ARRAY ac_object.array_list_result     { only if a list off of an analysis                      }
    ARRAY ac_object.array_analysis        { base table or via special on pds, mlp and test scheds  }
    ARRAY ac_object.array_mlp_levels      { only done on mlp's                                     }
    ARRAY ac_object.array_limit_calc      { does limit calc on mlp          and calcs on analysis  }
    ARRAY ac_object.array_text_phrase     { does phrase on analysis                                }
    ARRAY ac_object.array_limit_phrase    { does limit_phrase_header on mlp                        }
    ARRAY ac_object.array_criteria_saved  { does entity criteria on analysis                       }
{}  ARRAY ac_object.array_param_link
    RETURN ( retval )

ENDROUTINE  {  ac_object_action_table_special_process }

{******************************************************************************}

ROUTINE ac_object_action_table_special_table (       ac_object     ,
                                               VALUE a_table       ,
                                               VALUE a_field       ,
                                               VALUE a_id          ,
                                               VALUE version_field ,
                                                     version_value )

    DECLARE found_id

    ac_object.current_routine = "ac_object_action_table_special_table ":a_table:a_id
    retval   = TRUE
    found_id = EMPTY
    WriteToLog(a_table:".":a_field:": '":a_id:"', ":version_field:": '":version_value:"'")

    { ----------------------------------------------------------- }
    { Select the record then call archive for that one record     }
    { ----------------------------------------------------------- }

    IF ( version_field = EMPTY ) THEN

        found_id = SELECT 'a_table'.'a_field' WHERE 'a_field' = a_id

    ELSEIF ( version_value > 0 ) THEN

        found_id = SELECT 'a_table'.'a_field' WHERE 'a_field' = a_id  AND 'version_field' = version_value

    ELSE

        version_value = SELECT MAX 'a_table'.'version_field' WHERE 'a_field' = a_id

        IF ( version_value <> EMPTY ) THEN

            found_id = SELECT 'a_table'.'a_field' WHERE 'a_field' = a_id  AND 'version_field' = version_value

        ENDIF

    ENDIF

    { ---------------------------------------------------------------------------- }
    { If we have a record then save its data and any attached files to record      }
    { ---------------------------------------------------------------------------- }

    IF ( found_id = EMPTY ) THEN

        internal_log_message ( ac_object, ac_object.current_routine : a_id : " NOT FOUND ", C_MSG_HIGH )

    ELSE

        WHILE ( found_id <> EMPTY ) DO

            retval = ac_object_action_archive_csv_data ( ac_object, a_table  )

            IF ( retval ) THEN

                { -------------------------------------------------------- }
                { Save this record and any attached files...               }
                { -------------------------------------------------------- }

                ac_object.table_special_save(a_table)
                ac_object.table_special_file ( a_table, a_id )

                internal_log_message ( ac_object, ac_object.current_routine : a_table : ac_object.a_identity_full, C_MSG_LOW )

                FILE WRITE ac_object.ace_report      , msg_124 : PAD ( a_table, " ", 40 ) : ac_object.a_identity_full, tmp
                FILE WRITE ac_object.ace_short_report, msg_124 : PAD ( a_table, " ", 40 ) : ac_object.a_identity_full, tmp

            ENDIF

            NEXT 'a_table'
            found_id = SELECT 'a_table'.'a_field'

        ENDWHILE

    ENDIF { have to find at least one reference }

    RETURN ( retval )

ENDROUTINE  {  ac_object_action_table_special_table }

{******************************************************************************}

ROUTINE ac_object_action_table_special_file (        ac_object,
                                               VALUE a_table  ,
                                               VALUE a_id     )


    DECLARE a_dir   ,
                 arc_dir ,
                 a_semi  ,
                 a_file  ,
                 a_ext

    ac_object.current_routine = "ac_object_action_table_file_archive ":a_table:a_id
    internal_log_message ( ac_object, ac_object.current_routine, C_MSG_LOW )

    { ------------------------------------------------------- }
    { If the identity pass has commas then it is cmpd key     }
    { ------------------------------------------------------- }

    IF ( INDEX ( a_id, "," ) > 0 ) THEN

        a_id = SUBSTITUTE ( a_id, ",", "_" )
        a_id = SUBSTITUTE ( a_id, " ", ""  )

    ENDIF

    { ------------------------------------------------------- }
    { Next see if there is a way to lookup attachment dir's   }
    { ------------------------------------------------------- }

    IF ( VALID_TABLE ( C_SMP_TABLE ) ) THEN

        a_dir = STRIP ( SELECT 'C_SMP_TABLE'.FILE_LOGICAL WHERE SYSTEM_TABLE = a_table  )
        a_ext = STRIP ( SELECT 'C_SMP_TABLE'.FILE_EXTENSION                           )

    ELSE

        a_dir = EMPTY
        a_ext = EMPTY

    ENDIF

    { ------------------------------------------------------- }
    { Finally if attach dir find file and copy it...          }
    { ------------------------------------------------------- }

    IF ( a_dir <> EMPTY ) AND ( NOT BLANK ( a_dir ) ) AND ( INDEX ( a_dir, "--------------" ) = 0 ) THEN

        arc_dir = LOGICAL ( "SMP$ARCHIVEFILES" )
        a_semi  = INDEX ( arc_dir, ";" )

        IF ( a_semi > 0 ) THEN

            arc_dir = LEFTSTRING ( arc_dir, a_semi - 1 )

        ENDIF

        a_file = STRIP ( a_dir )   : "\" : STRIP ( a_id ) : "." : STRIP ( a_ext )
        a_dir  = STRIP ( arc_dir ) : "\" : STRIP ( ac_object.ace_file_id ) : "\" : SUBSTITUTE ( a_dir, "$", "_" )

        IF ( internal_create_directory ( a_dir ) ) THEN

            IF FILE EXISTS ( a_file ) THEN

                FILE COPY a_file, a_dir : "\" : STRIP ( a_id ) : "." : STRIP ( a_ext ), tmp

                IF tmp = EMPTY THEN

                    FILE WRITE ac_object.ace_report      , msg_126 : PAD ( a_table, " ", 40 ) : a_id, tmp
                    FILE WRITE ac_object.ace_short_report, msg_126 : PAD ( a_table, " ", 40 ) : a_id, tmp

                ENDIF
            ENDIF
        ENDIF

        { --------------------------------------------------------------------- }
        { If we have attached file then must have UNINSTALL subdir              }
        { --------------------------------------------------------------------- }

        a_dir  = STRIP ( arc_dir ) : "\" : STRIP ( ac_object.ace_file_id ) : "\UNINSTALL"

        internal_create_directory ( a_dir )


    ENDIF  { dir exists for reference file from identity of record }

    retval = TRUE

    RETURN ( retval )

ENDROUTINE  {  ac_object_action_table_special_file }

{******************************************************************************}

ROUTINE ac_object_action_commit_pds_job ( ac_object )

    DECLARE a_job

    ac_object.current_routine = "ac_object_action_commit_pds_job "

    { ----------------------------------------------------------- }
    { Switch modes to JOB and do this PDS's job                   }
    { ----------------------------------------------------------- }

    ret_val = ac_object.toggle_pds_objects ( "JOB_HEADER" )

    IF ( ret_val ) THEN

        { ----------------------------------------------------------- }
        { Set the select array to this specific job only              }
        { ----------------------------------------------------------- }

        ac_object.jstr_enabled = TRUE    { allows the report to have JSTR counts }

        ARRAY ac_object.ac_dbase_select_array
        ARRAY_SELECT_ADD ( ac_object.ac_dbase_select_array, ARRAY_SELECT_EQ, "JOB_NAME", ac_object.a_identity_full )

        a_job = ac_object.a_identity_full

        { ----------------------------------------------------------- }
        { Now you process just as if we started at the job level      }
        { ----------------------------------------------------------- }

        ret_val = ac_object.select_table()


        { ----------------------------------------------------------- }
        { Now find do the Study job                       }
        { ----------------------------------------------------------- }

        IF ( ret_val ) AND ( ac_object.pds_study_job <> EMPTY ) AND ( a_job <> ac_object.pds_study_job ) THEN

            ARRAY ac_object.ac_dbase_select_array
            ARRAY_SELECT_ADD ( ac_object.ac_dbase_select_array, ARRAY_SELECT_EQ, "JOB_NAME", ac_object.pds_study_job )

            ac_object.a_identity_full = ac_object.pds_study_job
            ac_object.a_identity[1]   = ac_object.pds_study_job

            ret_val = ac_object.select_table()

        ENDIF

        { ----------------------------------------------------------- }
        { Now find do the Study T-0 (original) job                }
        { ----------------------------------------------------------- }

        IF ( ac_object.pds_orig_job <> EMPTY ) THEN

            ARRAY ac_object.ac_dbase_select_array
            ARRAY_SELECT_ADD ( ac_object.ac_dbase_select_array, ARRAY_SELECT_EQ, "JOB_NAME", ac_object.pds_orig_job )

            ac_object.a_identity_full = ac_object.pds_orig_job
            ac_object.a_identity[1]   = ac_object.pds_orig_job

            ret_val = ac_object.select_table()

        ENDIF

    ENDIF

    RETURN ( ret_val )

ENDROUTINE   { ac_object_commit_pds_job }

{******************************************************************************}

ROUTINE ac_object_action_set_key0_fields ( ac_object )

    DECLARE i, part

    ac_object.current_routine = "ac_object_action_set_key0_fields "

    { ------------------------------------------------------------------ }
    { Cater for multi key0 base table, such as PDS                       }
    { ------------------------------------------------------------------ }

    ac_object.base_table_identity = ""
    ac_object.a_identity_full     = ""
    i                             = 1

    WHILE ( ac_object.ach_field_identity[i] <> EMPTY ) DO

        part = SELECT 'ac_object.ach_commit_view'.'ac_object.ach_field_identity[i]' IN OBJECT ac_object.ac_dbase.current

        ac_object.a_identity[i]       = part
        ac_object.base_table_identity = ac_object.base_table_identity : part
        ac_object.a_identity_full     = ac_object.a_identity_full     : part { full key0 }
        i                             = i + 1

        IF ( ac_object.ach_field_identity[i] <> EMPTY ) THEN

            ac_object.base_table_identity = ac_object.base_table_identity : ","

        ENDIF

    ENDWHILE

    { ------------------------------------------------------------------ }
    { Save special field for PDS study                                   }
    { ------------------------------------------------------------------ }

    IF ( INDEX ( ac_object.ach_base_table, "PDS_STUDY" ) > 0 ) OR ( INDEX ( ac_object.ach_base_table, "PDS_PROTO" ) > 0 ) THEN

        ac_object.pds_identity = ac_object.a_identity[1]
        ac_object.pds_mode     = TRUE

    ENDIF

    internal_log_message ( ac_object, ac_object.current_routine:ac_object.base_table_identity:ac_object.a_identity_full, C_MSG_LOW )

    RETURN ( TRUE )

ENDROUTINE { ac_object_action_set_key0_fields }

{******************************************************************************}

ROUTINE ac_object_action_review_list ( ac_object )

    DECLARE form        ,
                 form_1      ,
                 form_2      ,
                 split       ,
                 sub_split   ,
                 count       ,
                 a_array     ,
                 max_ok      ,
                 list_review2

    max_ok                    = TRUE
    ret_val                   = TRUE
    ac_object.current_routine = "ac_object_action_review_list "

    internal_log_message ( ac_object, ac_object.current_routine:" ** " : ac_object.ac_dbase_size, C_MSG_LOW )

    { ---------------------------------------------------------- }
    { Make a list form for check box of all records found        }
    { ---------------------------------------------------------- }

    set_up_std_prompt_list_class()
    set_up_std_prompt_split_class()
    set_up_std_prompt_tree_class()

    CREATE OBJECT "STD_FORM", form
        form.header = STRIP ( ac_object.ac_dbase.table ) : "/" : msg.46
        form.height = GLOBAL ( "GUI_HEIGHT") - 26
        form.width  = GLOBAL ( "GUI_WIDTH" ) - 26
        form.column = 2
        form.row    = 2

    CREATE OBJECT "STD_FORM", form_1
    form_1.height = form.height / 2
    form_1.width  = form.width  - 4

    CREATE OBJECT "STD_FORM", form_2
    form_2.height = form.height / 2
    form_2.width  = form.width  - 4

    CREATE OBJECT PROMPT_SPLIT_CLASS , split
        split.height = form.height - 5
        split.width  = form.width  - 6
        split.row    = 1
        split.column = 2
        split.set_size         ( 1 , 2  )                    { believe this does the top bottom   }
        split.set_row_height   ( 1 , form.height - 6 )       { HEIGHT OF TOP PANE }

    CREATE OBJECT PROMPT_SPLIT_CLASS , sub_split
        sub_split.height = form.height - 1
        sub_split.width  = form.width  - 6
        sub_split.set_size ( 1 , 1 )                         { this does the top/bottom - also... }
        sub_split.set_column_width ( 1 , form.width - 6 )
        sub_split.set_column_width ( 2 , form.width - 6 )
        sub_split.add_form ( 1 , 1 , form_2 )

    { --------------------------------------------------------------------------- }
    { List on the BOTTOM pane is what is thrown out - don't keep with ac_object   }
    { --------------------------------------------------------------------------- }

    CREATE OBJECT LIST_VIEWER_CLASS, list_review2
        list_review2.vgl_library          = global ( "current_library" )
        list_review2.row                  = 1
        list_review2.column               = 1
        list_review2.width                = form.width  - 8
        list_review2.height               = 3
        list_review2.user_info            = ac_object
        list_review2.table                = ac_object.ac_dbase.table
        list_review2.auto_size            = TRUE
        list_review2.menu_criteria        = FALSE
        list_review2.menu_refresh         = FALSE
        list_review2.use_images ( EMPTY, 0 )

    list_review2.add_column ( ac_object.ach_base_table, 20 )
    list_review2.add_column ( msg_91                  , 50 )

    { --------------------------------------------------------------------------- }
    { List on the top pane is kept with ac_object cause it does stuff...          }
    { --------------------------------------------------------------------------- }

    CREATE OBJECT LIST_VIEWER_CLASS, ac_object.list_review
        ac_object.list_review.vgl_library          = GLOBAL ( "current_library" )
        ac_object.list_review.row                  = 1
        ac_object.list_review.column               = 1
        ac_object.list_review.width                = form.width  - 8
        ac_object.list_review.height               = form.height - 9
        ac_object.list_review.default_callback     = "LIT_AUTO_COMMIT/internal_review_list_click_routine"
        ac_object.list_review.default_action       = EMPTY
        ac_object.list_review.user_info            = ac_object
        ac_object.list_review.table                = ac_object.ac_dbase.table
        ac_object.list_review.auto_size            = TRUE
        ac_object.list_review.menu_columns         = TRUE
        ac_object.list_review.menu_refresh         = FALSE
        ac_object.list_review.menu_property        = FALSE
        ac_object.list_review.menu_criteria        = FALSE
        ac_object.list_review.menu_auto_criteria   = FALSE

    { ***** Actions ***** }

    ac_object.list_review.auto_user_table_cols ( ac_object.ac_dbase.table )
    {ac_object.list_review.auto_browse_cols ( ac_object.ac_dbase.table )}
    ac_object.list_review.create_list()

    { **** Create ODB *** }

    CREATE OBJECT "STD_OBJECT_DATABASE", ac_object.list_review.odb
        ac_object.list_review.odb.initialise  ( ac_object.ac_dbase.table )

    { ----------------------------------------------------------- }
    { Build the list and put all the data onto the list           }
    { ----------------------------------------------------------- }

    ARRAY a_array

    count = 1

    WHILE ( ac_object.ac_dbase.current <> EMPTY ) AND ( max_ok ) DO

        ac_object.set_key0_fields()

        IF NOT internal_array_slice ( a_array, ac_object.a_identity_full, tmp ) THEN

            IF ( ac_object.check_conditions() ) THEN

                ac_object.list_review.odb.add ( ac_object.ac_dbase.current )

            ELSE


                list_review2.insert_item ( ac_object.a_identity_full, 12 )
                list_review2.set_item ( 2, ac_object.check_value )

                internal_log_message ( ac_object, ac_object.current_routine:" ** CONDITION ** ":ac_object.a_identity_full, C_MSG_LOW )

            ENDIF

            a_array[count] = ac_object.a_identity_full
            count          = count + 1

        ELSE

            internal_log_message ( ac_object, ac_object.current_routine:" * DUPLICATE * ":ac_object.a_identity_full, C_MSG_LOW )

        ENDIF

        ac_object.ac_dbase.set_next()

        IF ( count > ac_object.max_count ) THEN

            max_ok = FALSE
            internal_log_message ( ac_object, ac_object.current_routine:" * MAX_COUNT * ":ac_object.a_identity_full, C_MSG_LOW )

        ENDIF

    ENDWHILE

    { ---------------------------------------------------------- }
    { Add the prompts and let the user click away veto items     }
    { ---------------------------------------------------------- }

    form_1.add_prompt ( ac_object.list_review )
    form_1.prompt_objects[1].display_data()

    form_2.add_prompt ( list_review2 )

    split.add_form (  1, 1, form_1 )
    split.add_split(  1, 2, sub_split )

    form.add_prompt ( split )
    form.userinfo = form_1

    ret_val = ac_object.choose_from_list(form)

    ac_object.current_routine = "ac_object_action_review_list ":ret_val
    internal_log_message ( ac_object, ac_object.current_routine, C_MSG_LOW )

    RETURN ( ret_val )

ENDROUTINE { ac_object_action_review_list }

{******************************************************************************}

ROUTINE ac_object_action_choose_from_list ( ac_object, form )

    DECLARE max_ok     ,
                 item       ,
                 item_text  ,
                 found_it   ,
                 a_array    ,
                 i

    max_ok  = TRUE
    ret_val = TRUE
    i       = 0

    ARRAY a_array

    form.start_prompt ()

    REPEAT

        form.wait_prompt ()

        IF ( form.get_lastkey() = "EXIT" ) THEN

            max_ok = FALSE
            item   = EMPTY

        ELSEIF ( form.get_lastkey() = "DO" ) THEN

            { -------------------------------------------------------------- }
            { First write all that were "selected" as selection criteria     }
            { -------------------------------------------------------------- }

            ac_object.item_list_review ( item, item_text )

            WHILE ( item <> EMPTY ) DO

                ac_object.ac_dbase.set_first()

                WHILE (  ac_object.ac_dbase.current <> EMPTY ) DO

                    ac_object.set_key0_fields()

                    IF ( ac_object.a_identity_full = item_text ) THEN

                        IF NOT ( internal_array_slice ( a_array, item_text, tmp ) ) THEN

                            i          = i + 1
                            a_array[i] = ac_object.a_identity_full

                            FILE WRITE ac_object.ace_report      , msg_57 : ac_object.a_identity_full, tmp
                            FILE WRITE ac_object.ace_short_report, msg_57 : ac_object.a_identity_full, tmp

                        ENDIF

                    ENDIF

                    ac_object.ac_dbase.set_next()

                ENDWHILE

                ac_object.item_get_next( item, item_text )

            ENDWHILE

            FILE WRITE ac_object.ace_report, msg.52, tmp     { - - - - separator line written }

            { -------------------------------------------------------------- }
            { Now actually do each one that was selected                     }
            { -------------------------------------------------------------- }

            ac_object.ac_start_time = NOW
            found_it                = FALSE
            ac_object.item_list_review ( item, item_text )

            WHILE ( item <> EMPTY ) AND ( ret_val ) DO

                IF ( INDEX ( ac_object.ac_dbase.table, "SAMP_TEST" ) > 0 ) THEN   { good ole key0 requirement on view }

                    item_text = LEFTSTRING ( item_text, 10 )

                ENDIF

                ac_object.ac_dbase.set_first()

                WHILE (  ac_object.ac_dbase.current <> EMPTY ) AND ( NOT found_it ) DO

                    ac_object.set_key0_fields()

                    IF ( ac_object.a_identity_full = item_text ) THEN

                        window_set_status ( item_text )

                        ac_object.write_criteria()   { write what was chosen... }

                        ret_val  = ac_object.ac_process_1_record()
                        found_it = TRUE

                    ENDIF

                    ac_object.ac_dbase.set_next()

                ENDWHILE

                found_it = FALSE
                ac_object.item_get_next ( item, item_text)

                { ----------------------------------------------------- }
                { PDS PROTO can only do one table at a time due to MLP  }
                { ----------------------------------------------------- }

                IF ( STRIP ( ac_object.ach_base_table ) = "PDS_PROTO" ) THEN

                    item = EMPTY

                ENDIF

            ENDWHILE

        ENDIF

    UNTIL ( item = EMPTY ) OR ( NOT max_ok )

    { save the user columns that the users has chosen }

    form.userinfo.prompt_objects[1].column_save_user_table ( ac_object.ac_dbase.table )

    form.end_prompt()

    RETURN ( ret_val )

ENDROUTINE { ac_object_action_choose_from_list }

{***************************************************************************}

ROUTINE ac_object_action_item_list_review ( self, item, item_text )

    DECLARE row

    item      = ac_object.list_review.get_first_selected(item_text)

    IF ( item <> EMPTY ) THEN

        row       = ac_object.list_review.get_row ( item, FALSE )
        item_text = get_key0_string_object( ac_object.list_review.table, row )

    ELSE

        item_text = EMPTY

    ENDIF

ENDROUTINE  { ac_object_action_item_list_review }

{***************************************************************************}

ROUTINE ac_object_action_item_get_next ( self, item, item_text )

    DECLARE row

    item = ac_object.list_review.get_next_selected(item_text)

    IF item <> EMPTY THEN
        row       = ac_object.list_review.get_row ( item, FALSE )
        item_text = get_key0_string_object( ac_object.list_review.table, row )
    ELSE
        item_text = EMPTY
    ENDIF


ENDROUTINE  { ac_object_action_item_get_next }

{***************************************************************************}

ROUTINE internal_review_list_click_routine ( self )

    DECLARE temp , item

    item = self.get_first_selected ( temp )

    IF ( item <> EMPTY ) THEN

        IF self.user_info.ach_base_table = "JOB_HEADER" THEN

            item = MENUNUMBER ( C_MENU_JOB_HEADER_DISPLAY )

        ELSEIF self.user_info.ach_base_table = "PDS_STUDY" THEN

            item = MENUNUMBER ( C_MENU_PDS_STUDY_DISPLAY )

        ELSEIF self.user_info.ach_base_table = "PDS_PROTO" THEN

            item = MENUNUMBER ( C_MENU_PDS_PROTO_DISPLAY )

        ELSEIF self.user_info.ach_base_table = "STANDARD_VERSIONS" THEN

            item = MENUNUMBER ( C_MENU_STANDARD_DISPLAY )

        ELSEIF self.user_info.ach_base_table = "MLP_HEADER" THEN

            item = MENUNUMBER ( C_MENU_MLP_HEADER_DISPLAY )

        ELSEIF self.user_info.ach_base_table = "VERSIONED_ANALYSIS" THEN

            item = MENUNUMBER ( C_MENU_ANALYSIS_DISPLAY )

        ELSEIF self.user_info.ach_base_table = "BATCH_HEADER" THEN

            item = MENUNUMBER ( C_MENU_BATCH_HEADER_DISPLAY )

        ELSEIF self.user_info.ach_base_table = "LOT_DETAILS" THEN

            item = MENUNUMBER ( C_MENU_LOT_DETAILS_DISPLAY )

        ELSEIF self.user_info.ach_base_table = "SAMPLE" THEN

            item = MENUNUMBER ( C_MENU_SAMPLE_DISPLAY )

        ELSEIF self.user_info.ach_base_table = "TEST_SCHED_HEADER" THEN

            item = MENUNUMBER ( C_MENU_TEST_SCHED_HEADER_DISPLAY )

        ELSE

            item = SELECT MASTER_MENU.MNEMONIC
                                  WHERE TABLE_NAME  = self.user_info.ach_base_table
                                  AND   ACTION_TYPE = "DISPLAY"

        ENDIF

        IF ( item <> ERROR ) AND ( item <> EMPTY ) AND ( item <> 0 ) AND ( temp <> EMPTY ) THEN

            MENUPROC item USING temp

        ENDIF

    ENDIF

ENDROUTINE  { internal_review_list_click_routine }

{******************************************************************************}

ROUTINE ac_object_action_load_criteria( ac_object )

    DECLARE ac_id

    { ----------------------------------------------------- }
    { Load and use any saved criteria as starting point     }
    { ----------------------------------------------------- }

    ARRAY ac_object.ac_dbase_select_array
    ac_object.current_routine = "ac_object_action_load_criteria "
    ret_val                   = TRUE

    { ----------------------------------------------------- }
    { Criteria read from saved or passed from Explorer      }
    { ----------------------------------------------------- }

    IF ( ac_object.rmb_object <> EMPTY ) THEN

        ac_object.ac_criteria_modified_on  = NOW
        ac_object.ac_criteria_modified_by  = OPERATOR
        ac_object.ac_criteria_description  = msg.55
        ac_object.ach_commit_criteria      = msg_57

        { ----------------------------------------------------- }
        { Rmb can be array when from RMB or object when PDS job }
        { ----------------------------------------------------- }

        IF ( ac_object.rmb_var_type = "Array" ) THEN

            ac_object.ac_dbase_select_array = ac_object.rmb_object

        ELSE

            ARRAY ac_object.ac_dbase_select_array

        ENDIF

    ELSEIF ( ac_object.ach_commit_view = EMPTY ) OR ( BLANK ( ac_object.ach_commit_view ) ) THEN

        ARRAY ac_object.ac_dbase_select_array

        ret_val             = FALSE
        ac_object.error_msg = ac_object.ach_identity : msg.17

        internal_log_message ( ac_object, ac_object.current_routine : ac_object.error_msg, C_MSG_FULL )

    ELSEIF ( ac_object.ach_commit_criteria <> EMPTY ) AND ( ac_object.ach_commit_criteria <> "" ) THEN

        ARRAY ac_object.ac_dbase_select_array

        ac_id   = criteria_saved_form_full_name ( ac_object.ach_commit_view, ac_object.ach_commit_criteria          )
        ret_val = criteria_saved_load_criteria  ( ac_object.ach_commit_view, ac_id, ac_object.ac_dbase_select_array )

        { ------------------------------------------------------------------------ }
        { Any parameters in the criteria are not allowed - future may prompt       }
        { ------------------------------------------------------------------------ }

        IF ( ret_val ) THEN

            ret_val = criteria_lib_parameter_count( ac_object.ac_dbase_select_array ) = 0

            IF NOT ret_val THEN

                ac_object.error_msg = msg.34 :" ** PARAMETER ** ": ac_object.ach_commit_view : ac_object.ach_commit_criteria
                internal_log_message ( ac_object, ac_object.current_routine:ac_object.error_msg, C_MSG_FULL )

            ENDIF

        ENDIF

        IF NOT ret_val THEN

            ac_object.error_msg = msg.34 : ac_object.ach_commit_view : ac_object.ach_commit_criteria
            internal_log_message ( ac_object, ac_object.current_routine:ac_object.error_msg, C_MSG_FULL )

        ENDIF

    ELSEIF ( ac_object.ach_commit_criteria = EMPTY ) OR ( BLANK ( ac_object.ach_commit_criteria ) ) THEN

        ARRAY ac_object.ac_dbase_select_array

        ac_object.ac_criteria_modified_on = NOW
        ac_object.ac_criteria_modified_by = OPERATOR
        ac_object.ac_criteria_description = msg.56

        internal_log_message ( ac_object, ac_object.current_routine:msg.05, C_MSG_HIGH )

    ENDIF

    { ----------------------------------------------------- }
    { Let the logfile know what condition is being returned }
    { ----------------------------------------------------- }

    ac_object.current_routine = "ac_object_action_load_criteria "
    internal_log_message ( ac_object, ac_object.current_routine:ret_val, C_MSG_LOW )

    RETURN ( ret_val )

ENDROUTINE { ac_object_action_load_criteria }

{******************************************************************************}

ROUTINE ac_object_action_write_criteria( ac_object )

    DECLARE status, text_array, i

    ret_val = TRUE

    IF NOT ( ac_object.review_mode ) THEN

        FILE WRITE ac_object.ace_report      , msg.31 : ac_object.ach_commit_view : " " : ac_object.ach_commit_criteria, status
        FILE WRITE ac_object.ace_short_report, msg.31 : ac_object.ach_commit_view : " " : ac_object.ach_commit_criteria, status

        { ---------------------------------------------------------------------- }
        { Special for interactive RMB operation                                  }
        { ---------------------------------------------------------------------- }

        IF ( ac_object.rmb_object <> EMPTY ) THEN

            FILE WRITE ac_object.ace_report, msg.35 : ac_object.ac_criteria_modified_on, status
            FILE WRITE ac_object.ace_report, msg.36 : ac_object.ac_criteria_modified_by, status
            FILE WRITE ac_object.ace_report, msg.44 : ac_object.ac_criteria_description, status

            FILE WRITE ac_object.ace_short_report, msg.35 : ac_object.ac_criteria_modified_on, status
            FILE WRITE ac_object.ace_short_report, msg.36 : ac_object.ac_criteria_modified_by, status
            FILE WRITE ac_object.ace_short_report, msg.44 : ac_object.ac_criteria_description, status

        ENDIF

        ARRAY text_array

        ac_object.current_routine = "ac_object_action_write_criteria "
        i                         = EMPTY

        IF ( criteria_lib_to_text ( ac_object.ac_dbase_select_array,
                                    text_array                     ,
                                    i                              ,
                                    ac_object.ach_commit_view      ,
                                    FALSE                          ) ) THEN

            i = 1
            WHILE ( text_array[i] <> EMPTY ) DO

                internal_log_message ( ac_object, ac_object.current_routine:text_array[i], C_MSG_LOW )

                FILE WRITE ac_object.ace_report      , "     " : text_array[i], status
                FILE WRITE ac_object.ace_short_report, "     " : text_array[i], status

                i = i + 1

            ENDWHILE

            FILE WRITE ac_object.ace_report      , msg.52, status
            FILE WRITE ac_object.ace_short_report, msg.52, status

        ELSE

            ret_val             = FALSE
            ac_object.error_msg = msg.22
            internal_log_message ( ac_object, ac_object.current_routine:ac_object.error_msg, C_MSG_FULL )

        ENDIF

    ENDIF   { write criteria in review mode one way, all other modes from array }

    RETURN ( ret_val )

ENDROUTINE  { ac_object_action_write_criteria }

{******************************************************************************}

ROUTINE ac_object_action_check_conditions (  ac_object  )

    ac_object.current_routine = "ac_object_action_check_conditions "
    tmp                       = EMPTY
    ret_val                   = TRUE

    IF ( ac_object.commit_mode = C_TABLESET_EXPORT ) AND ( ac_object.do_archive_csv ) THEN

        { --------------------------------------------- }
        { Data export - record already moved ?          }
        { --------------------------------------------- }

        IF     ( ac_object.ach_base_table = "MLP_HEADER"         ) THEN

            tmp = SELECT AUTO_COMMIT_EXPORTED.DESTINATION_CPU
                           WHERE MLP_ID                = LEFTSTRING ( ac_object.base_table_identity, ac_object.G_LEN_MLP )
                           AND   MLP_VERSION           = PACKED_DECIMAL ( RIGHTSTRING ( ac_object.base_table_identity, 10 ) )
                           AND   DESTINATION_FULL_LIST = ac_object.cpu_destination


        ELSEIF ( ac_object.ach_base_table = "TEST_SCHED_HEADER"  ) THEN

            tmp = SELECT AUTO_COMMIT_EXPORTED.DESTINATION_CPU
                           WHERE TEST_SCHEDULE         = ac_object.base_table_identity
                               AND   DESTINATION_FULL_LIST = ac_object.cpu_destination


        ELSEIF ( ac_object.ach_base_table = "PDS_PROTO"          ) THEN

            tmp = SELECT AUTO_COMMIT_EXPORTED.DESTINATION_CPU
                           WHERE PDS_PROTO             = LEFTSTRING ( ac_object.base_table_identity, ac_object.G_LEN_PDS )
                           AND   PDS_VERSION           = PACKED_DECIMAL ( RIGHTSTRING ( ac_object.base_table_identity, 10 ) )
                           AND   DESTINATION_FULL_LIST = ac_object.cpu_destination


        ELSEIF ( ac_object.ach_base_table = "VERSIONED_ANALYSIS" ) THEN

            tmp = SELECT AUTO_COMMIT_EXPORTED.DESTINATION_CPU
                           WHERE ANALYSIS              = LEFTSTRING ( ac_object.base_table_identity, ac_object.G_LEN_ANAL )
                           AND   ANALYSIS_VERSION      = PACKED_DECIMAL ( RIGHTSTRING ( ac_object.base_table_identity, 10 ) )
                               AND   DESTINATION_FULL_LIST = ac_object.cpu_destination

        ENDIF   { each table has own lookup }

        { -------------------------------------------------------------------- }
        { If CPU has been delivered, then disallow this record                 }
        { -------------------------------------------------------------------- }

        IF ( tmp <> EMPTY ) THEN

            tmp = msg_127

        ENDIF

    ELSEIF ( ac_object.commit_mode = C_COMMIT_MODE_DECONSIGN )
    OR     ( ac_object.commit_mode = C_TABLESET_ARCHIVE      )
    OR     ( ac_object.commit_mode = C_TABLESET_DELETE       )
    OR     ( ac_object.commit_mode = C_TABLESET_EXPORT       )
    OR     ( ac_object.commit_mode = C_TABLESET_COMMIT_MOVE  ) THEN

        { do nothing conditions already checked }

    ELSEIF ( ac_object.ach_base_table = "LOT_DETAILS" ) THEN

        tmp = SELECT JOB_HEADER.JOB_NAME
                        WHERE lot_id = ac_object.base_table_identity
                        AND ( ( status <> "A" ) AND ( status <> "R" ) AND ( status <> "X" ) )

        IF ( tmp <> EMPTY ) THEN
            tmp = msg_84 : tmp
        ENDIF

    ELSEIF ( ac_object.ach_base_table = "JOB_HEADER" ) THEN

        { ------------------------------------------------------------- }
        { The Job must be of a certain status, else it cannot be done   }
        { ------------------------------------------------------------- }

        tmp = SELECT JOB_HEADER.STATUS
                        WHERE JOB_NAME = ac_object.base_table_identity

        IF ( INDEX ( C_JOB_STATUS, tmp ) > 0 ) THEN
            tmp = EMPTY
        ELSE
            tmp = msg_85 : ac_object.base_table_identity : tmp
        ENDIF

        { ------------------------------------------------------------- }
        { IF this is empty, then check all job's samples                }
        { ------------------------------------------------------------- }

        IF ( tmp = EMPTY ) THEN

            tmp = SELECT SAMPLE.id_numeric
                                 WHERE job_name = ac_object.base_table_identity
                                 AND ( ( status <> "A" ) AND ( status <> "R" ) AND ( status <> "X" ) )

            IF ( tmp <> EMPTY ) THEN
                tmp = msg_86 : ac_object.base_table_identity : tmp
            ENDIF

        ENDIF

        { ------------------------------------------------------------- }
        { Special caveat for PDS study jobs cannot go until PDS is gone }
        { ------------------------------------------------------------- }

        IF ( tmp = EMPTY ) AND NOT ( ac_object.pds_mode ) AND ( VALID_TABLE ( C_PDS_STUDY ) ) THEN

            tmp = SELECT JOB_HEADER.ORIGINAL_JOB
                                 WHERE ORIGINAL_JOB = ac_object.base_table_identity

            IF ( tmp = EMPTY ) THEN

                tmp = SELECT 'C_PDS_STUDY'.IDENTITY
                                          WHERE IDENTITY = ac_object.base_table_identity

                IF ( tmp <> EMPTY ) THEN
                    tmp = msg_87 : ac_object.base_table_identity
                ENDIF

            ELSE
                tmp = msg_88 : ac_object.base_table_identity
            ENDIF

        ENDIF

    ELSEIF ( ac_object.ach_base_table = "PDS_STUDY" ) THEN

        { ------------------------------------------------------------- }
        { Special caveat for PDS study status (constant)                }
        { ------------------------------------------------------------- }

        ac_object.pds_study_job = EMPTY
        ac_object.pds_orig_job  = EMPTY

        tmp = SELECT 'C_PDS_STUDY'.STATUS
                        WHERE IDENTITY = ac_object.base_table_identity

        IF ( tmp <> EMPTY ) AND ( INDEX ( C_PDS_STATUS, tmp ) > 0 ) THEN
            tmp = EMPTY
        ELSE
            tmp = msg_89 : ac_object.base_table_identity : tmp
        ENDIF

        { ------------------------------------------------------------- }
        { Study status is ok, what about study's OWNER job ?            }
        { ------------------------------------------------------------- }

        IF ( tmp = EMPTY ) AND ( VALID_FIELD ( C_PDS_STUDY, "ORIGINAL_JOB" ) ) THEN

            tmp = SELECT JOB_HEADER.STATUS
                                 WHERE JOB_NAME = ( SELECT 'C_PDS_STUDY'.ORIGINAL_JOB
                                                    WHERE IDENTITY = ac_object.base_table_identity )

                     { --------------------------------------------------------- }
            tmp = EMPTY   { Remove this line if original job is needed for pds commit }
                     { --------------------------------------------------------- }

            IF ( tmp = EMPTY ) THEN

                { There might not be an original job }

            ELSEIF ( INDEX ( C_JOB_STATUS, tmp ) > 0 ) THEN

                ac_object.pds_orig_job = SELECT JOB_HEADER.JOB_NAME
                tmp = EMPTY

            ELSE

                tmp = msg_92 : ac_object.base_table_identity : tmp

            ENDIF

        ENDIF

        { ------------------------------------------------------------- }
        { Study status is ok and owner job, but what about study job?   }
        { ------------------------------------------------------------- }

        IF tmp = EMPTY THEN

            tmp = SELECT JOB_HEADER.STATUS
                  WHERE JOB_NAME = ac_object.base_table_identity

            IF ( tmp = EMPTY ) THEN

                { There might not be a study job }

            ELSEIF ( INDEX ( C_JOB_STATUS, tmp ) > 0 ) THEN

                ac_object.pds_study_job = SELECT JOB_HEADER.JOB_NAME
                tmp                     = EMPTY  { all is ok, go ahead and process }

            ELSE

                tmp = msg_92 : ac_object.base_table_identity { job/study status is wrong }

            ENDIF

        ENDIF

    ELSEIF ( ac_object.ach_base_table = "MLP_HEADER" ) THEN

        ac_object.call_trigger ( "check_conditions_custom_table", tmp, ret_val )

    ELSEIF ( ac_object.ach_base_table = "VERSIONED_ANALYSIS" ) THEN

        ac_object.call_trigger ( "check_conditions_custom_table", tmp, ret_val )

    ELSEIF ( ac_object.ach_base_table = "BATCH_HEADER" ) THEN

        { ----------------------------------------------------------------- }
        { If batch is not of certain status it cannot be done               }
        { ----------------------------------------------------------------- }

        tmp = SELECT BATCH_HEADER.STATUS
                        WHERE IDENTITY = ac_object.base_table_identity

        IF ( tmp <> EMPTY ) AND ( INDEX ( C_BATCH_STATUSES, STRIP ( tmp ) ) = 0 )  THEN
            tmp = EMPTY
        ELSE
            tmp = msg_103 : tmp
        ENDIF

    ELSEIF ( ac_object.ach_base_table = "WORKSHEET" ) THEN

        { ----------------------------------------------------------------- }
        { If Analysis worksheet's tests must all have been moved            }
        { ----------------------------------------------------------------- }

        tmp = SELECT WORKSHEET.STATUS
                        WHERE IDENTITY = ac_object.base_table_identity

        IF ( tmp <> EMPTY ) AND ( INDEX ( C_WORKSHEET_STATUS, STRIP ( tmp ) ) > 0 )  THEN
            tmp = EMPTY
        ELSE
            tmp = msg_104 : tmp
        ENDIF

    ELSEIF ( ac_object.ach_base_table = "CERTIFICATE" ) THEN

        { ----------------------------------------------------------------- }
        { If COA is not of certain status it cannot be done                 }
        { ----------------------------------------------------------------- }

        tmp = SELECT 'C_CERTIFICATE_TABLE'.STATUS
                        WHERE IDENTITY = ac_object.base_table_identity

        IF ( tmp <> EMPTY ) AND ( INDEX ( C_COA_STATUSES, STRIP ( tmp ) ) > 0 )  THEN
            tmp = EMPTY
        ELSE
            tmp = msg_105 : tmp
        ENDIF

    ELSEIF ( ac_object.ach_base_table = "STANDARD_VERSIONS" ) THEN

        { ----------------------------------------------------------------- }
        { If standard version is not "consumed" it cannot be done           }
        { ----------------------------------------------------------------- }

        tmp = SELECT STANDARD_VERSIONS.STANDARD_STATUS
                        WHERE IDENTITY = LEFTSTRING ( ac_object.base_table_identity, ac_object.G_LEN_STD )
                        AND   VERSION  = PACKED_DECIMAL ( RIGHTSTRING ( ac_object.base_table_identity, 10 ) )

        IF ( tmp <> EMPTY ) AND ( INDEX ( C_STANDARD_STATUSES, STRIP ( tmp ) ) > 0 ) THEN
            tmp = EMPTY
        ELSE
            tmp = msg_106 : tmp
        ENDIF

    ELSEIF ( ac_object.ach_base_table = "SAMPLE" ) THEN

        { ----------------------------------------------------------------- }
        { Samples have to be certain status values                          }
        { ----------------------------------------------------------------- }

        tmp = SELECT SAMPLE.STATUS
                        WHERE ID_NUMERIC = ac_object.base_table_identity

        IF ( tmp <> EMPTY ) AND ( INDEX ( C_SAMPLE_STATUSES, STRIP ( tmp ) ) > 0 ) THEN
            tmp = EMPTY
        ELSE
            tmp = msg_74 : tmp
        ENDIF

    ELSEIF ( ac_object.ach_base_table = C_PDS_PROTO_TABLE ) THEN

        { ----------------------------------------------------------------- }
        { PDS Proto - type must match constant                              }
        { ----------------------------------------------------------------- }

        tmp = SELECT 'C_PDS_PROTO_TABLE'.TYPE
                        WHERE IDENTITY = ac_object.base_table_identity

        IF ( tmp <> EMPTY) AND ( INDEX ( C_PROTO_TYPES, STRIP(tmp) ) > 0 ) THEN
            tmp = EMPTY
        ELSE
            tmp = msg_89 : ac_object.base_table_identity : tmp
        ENDIF

    ELSEIF ( ac_object.ach_base_table = "TEST_SCHED_HEADER" ) THEN

        ac_object.call_trigger ( "check_conditions_custom_table", tmp, ret_val )

    ELSEIF ( ac_object.ach_base_table = "LABELPRINT" ) THEN
        { nothing, passes }
    ELSEIF ( NOT ac_object.call_trigger ( "check_conditions_custom_table", tmp, ret_val ) ) THEN

        tmp = ac_object.current_routine : ac_object.base_table_identity
        internal_log_message ( ac_object, tmp : ac_object.continue, C_MSG_LOW )

    ELSE

        tmp = internal_translate_message ( "LIT_AUTO_COMMIT_PROGRAM_NOT_COMPLETED" )
        {fm(tmp)}

    ENDIF

    { --------------------------------------------------------------- }
    { Performed select condition/routine if not empty, cannot archive }
    { --------------------------------------------------------------- }

    IF ( tmp <> EMPTY ) THEN

        ac_object.processed_a_record = FALSE
        ac_object.check_value        = tmp
        ret_val                      = FALSE

        internal_log_message ( ac_object, ac_object.current_routine : tmp, C_MSG_HIGH )

    ELSEIF ( ac_object.call_trigger ( "check_condition_veto", tmp, ret_val ) ) THEN

        ac_object.processed_a_record = TRUE
        tmp                          = ac_object.current_routine : ac_object.base_table_identity

        internal_log_message ( ac_object, tmp : ac_object.continue, C_MSG_LOW )

        { ----------------------------------------------------------------------------------------------------- }
        { If current number of recs is exceeded then quiesce on this rec - read each time to allow terminate bg }
        { ----------------------------------------------------------------------------------------------------- }

        IF ( ac_object.count_base >= ac_object.max_count ) THEN

            ac_object.continue = FALSE

        ENDIF

        { --------------------------------------------------------------- }
        { If system shutdown flag is set then also quiesce                }
        { --------------------------------------------------------------- }

        IF ( ac_object.continue ) THEN

            ac_object.continue = NOT SELECT CONFIG_HEADER.VALUE WHERE IDENTITY = "SHUTDOWN_ENABLED"

        ENDIF

    ENDIF   { tmp check condition empty }

    { ----------------------------------------------------- }
    { Let the logfile know what condition is being returned }
    { ----------------------------------------------------- }

    internal_log_message ( ac_object, ac_object.current_routine : ret_val, C_MSG_LOW )

    RETURN ( ret_val )

ENDROUTINE   { ac_object_action_check_conditions }

{******************************************************************************}

ROUTINE ac_object_action_validate_ach ( ac_object )

    DECLARE i

    ac_object.current_routine = "ac_object_action_validate_ach "
    ret_val                   = TRUE

    { ------------------------------------------------------------------ }
    { View must exist, base_table on the view and field_identity in view }
    { ------------------------------------------------------------------ }

    IF ( VALID_TABLE ( ac_object.ach_commit_view ) ) THEN

        IF ( ac_object.do_archive_csv ) AND NOT ( ac_object.JSTR_enabled ) AND ( GLOBAL ( "MODE" ) = "INTERACTIVE" ) THEN

            IF ( NOT ac_object.select_destination() ) THEN

                ret_val             = FALSE
                ac_object.error_msg = "USER_EXITED_DESTINATION"
                internal_log_message ( ac_object, ac_object.error_msg, C_MSG_FULL )

            ENDIF

        ELSE

            { ------------------------------------------------------------------ }
            { Source table is required to have 3 fields to point to execution    }
            { ------------------------------------------------------------------ }

            IF NOT ( VALID_FIELD ( ac_object.ach_base_table, C_CONSIGN_ID       ) )
            OR NOT ( VALID_FIELD ( ac_object.ach_base_table, C_CONSIGN_SEQUENCE ) )
            OR NOT ( VALID_FIELD ( ac_object.ach_base_table, C_CONSIGN_DATE     ) ) THEN

                IF ( INDEX ( ac_object.ach_base_table, "LABEL" ) = 0 ) THEN    { LIT 12-Dec-2010 START }
                ret_val             = FALSE
                ac_object.error_msg = ac_object.ach_base_table : msg.09
                tmp                 = ac_object.current_routine : ac_object.ach_base_table : msg.09

                internal_log_message ( ac_object, tmp, C_MSG_FULL )

                ENDIF                                                          { LIT 12-Dec-2010 END }
            ENDIF

        ENDIF

        { ------------------------------------------------------------------ }
        { Validate that all required tables are defined in database          }
        { ------------------------------------------------------------------ }

        IF ( ret_val ) THEN

            i = 1

            WHILE ( ac_object.required_array[i,1] <> EMPTY ) AND ( ret_val ) DO

                IF NOT VALID_TABLE ( ac_object.required_array[i,1] ) THEN

                    ret_val             = FALSE
                    ac_object.error_msg = msg.32 : ac_object.required_array[i,1]
                    tmp                 = ac_object.current_routine : ac_object.error_msg

                    internal_log_message ( ac_object, tmp, C_MSG_FULL )

                ENDIF

                i = i + 1

            ENDWHILE

        ENDIF

    ELSE

        ret_val             = FALSE
        ac_object.error_msg = msg.06
        tmp                 = ac_object.current_routine : msg.06

        internal_log_message ( ac_object, tmp, C_MSG_FULL )

    ENDIF  { valid_table for the commit view... }

    { ------------------------------------------------ }
    { show log file what became of all these checks    }
    { ------------------------------------------------ }

    internal_log_message ( ac_object, ac_object.current_routine : ret_val, C_MSG_LOW )

    RETURN ( ret_val )

ENDROUTINE  { ac_object_action_validate_ach }

{******************************************************************************}

ROUTINE ac_object_action_get_auto_commit_list ( ac_object )

    DECLARE an_array

    ac_object.current_routine = "ac_object_action_get_auto_commit_list "
    ret_val                   = TRUE

    { -------------------------------------------------------------- }
    { The base table is done, then any dependant tables              }
    { -------------------------------------------------------------- }

    tmp = ac_object.make_destination ( ac_object.ach_base_table )

    internal_log_message ( ac_object, ac_object.current_routine : tmp, C_MSG_LOW )

    { -------------------------------------------------------------- }
    { Get all the user config tables and dependancies                }
    { -------------------------------------------------------------- }

    IF ( VALID_TABLE ( tmp ) ) THEN

        ARRAY an_array
        ARRAY ac_object.user_tables

        ret_val = ac_object.default_auto_commit_list()

    ELSE

        ret_val             = FALSE
        ac_object.error_msg = msg.41 : tmp : " " : ac_object.ach_base_table

        internal_log_message ( ac_object, ac_object.current_routine : ret_val, C_MSG_FULL )

    ENDIF   { base table is not a valid committed table name }

    { ----------------------------------------------------- }
    { Let the logfile know what condition is being returned }
    { ----------------------------------------------------- }

    ac_object.current_routine = "ac_object_action_get_auto_commit_list "
    internal_log_message ( ac_object, ac_object.current_routine : ret_val, C_MSG_LOW )

    RETURN ( ret_val )

ENDROUTINE  { ac_object_action_get_auto_commit_list }

{******************************************************************************}

ROUTINE ac_object_action_default_auto_commit_list ( ac_object )

    DECLARE an_array  ,
                 an_array2 ,
                 tmp1, tmp2

    ac_object.current_routine = "ac_object_action_default_auto_commit_list "
    ret_val                   = TRUE
         tmp1                      = ""

    WriteToLog("ac_object.ach_base_table: '":ac_object.ach_base_table:"'")
    IF ( INDEX ( ac_object.ach_base_table, "JOB_HEADER" ) > 0 ) THEN

        ac_object.user_tables[1,1] = ac_object.ach_base_table
        ac_object.user_tables[1,2] = ac_object.ach_field_identity
        ac_object.user_tables[1,3] = ac_object.ach_field_identity
        ac_object.user_tables[1,4] = ac_object.make_destination( ac_object.ach_base_table)

        ARRAY an_array
        ARRAY an_array2
        an_array [1] = "JOB_NAME"
        an_array2[1] = "ID_NUMERIC"

        ac_object.user_tables[2,1] = STRIP ( ac_object.ach_commit_source_prefix ) : "SAMPLE"
        ac_object.user_tables[2,2] = an_array
        ac_object.user_tables[2,3] = an_array2
        ac_object.user_tables[2,4] = STRIP ( ac_object.ach_commit_destination_prefix ) : "SAMPLE"

        ARRAY an_array
        ARRAY an_array2
        an_array [1] = "SAMPLE"
        an_array2[1] = "TEST_NUMBER"

        ac_object.user_tables[3,1] = STRIP ( ac_object.ach_commit_source_prefix ) : "TEST"
        ac_object.user_tables[3,2] = an_array
        ac_object.user_tables[3,3] = an_array2
        ac_object.user_tables[3,4] = STRIP(  ac_object.ach_commit_destination_prefix ) : "TEST"

        ARRAY an_array
        ARRAY an_array2
        an_array [1] = "TEST_NUMBER"
        an_array2[1] = "TEST_NUMBER"
        an_array2[2] = "NAME"

        ac_object.user_tables[4,1] = STRIP ( ac_object.ach_commit_source_prefix ) : "RESULT"
        ac_object.user_tables[4,2] = an_array
        ac_object.user_tables[4,3] = an_array2
        ac_object.user_tables[4,4] = STRIP (  ac_object.ach_commit_destination_prefix ) : "RESULT"

        { ------------------------------------------------------------------------------ }
        { If list results tables are defined on source and destination then do it also   }
        { ------------------------------------------------------------------------------ }

        tmp1 = STRIP ( ac_object.ach_commit_source_prefix       ) : "LIST_RESULT"
        tmp2 = STRIP (  ac_object.ach_commit_destination_prefix ) : "LIST_RESULT"

        IF ( VALID_TABLE ( tmp1 ) ) AND ( VALID_TABLE ( tmp2 ) ) THEN

            ARRAY an_array
            ARRAY an_array2
            an_array [1] = "TEST_NUMBER"
            an_array2[1] = "TEST_NUMBER"
            an_array2[2] = "NAME"

            ac_object.list_result_enabled = TRUE

            ac_object.user_tables[5,1] = tmp1
            ac_object.user_tables[5,2] = an_array
            ac_object.user_tables[5,3] = an_array2
            ac_object.user_tables[5,4] = tmp2

        ENDIF

    ELSEIF ( INDEX ( ac_object.ach_base_table, "SAMPLE" ) > 0 ) THEN

        ac_object.user_tables[1,1] = ac_object.ach_base_table
        ac_object.user_tables[1,2] = ac_object.ach_field_identity
        ac_object.user_tables[1,3] = ac_object.ach_field_identity
        ac_object.user_tables[1,4] = ac_object.make_destination( ac_object.ach_base_table)

        ARRAY an_array
        ARRAY an_array2
        an_array [1] = "SAMPLE"
        an_array2[1] = "TEST_NUMBER"

        ac_object.user_tables[2,1] = STRIP ( ac_object.ach_commit_source_prefix ) : "TEST"
        ac_object.user_tables[2,2] = an_array
        ac_object.user_tables[2,3] = an_array2
        ac_object.user_tables[2,4] = STRIP(  ac_object.ach_commit_destination_prefix ) : "TEST"

        ARRAY an_array
        ARRAY an_array2
        an_array [1] = "TEST_NUMBER"
        an_array2[1] = "TEST_NUMBER"
        an_array2[2] = "NAME"

        ac_object.user_tables[3,1] = STRIP ( ac_object.ach_commit_source_prefix ) : "RESULT"
        ac_object.user_tables[3,2] = an_array
        ac_object.user_tables[3,3] = an_array2
        ac_object.user_tables[3,4] = STRIP (  ac_object.ach_commit_destination_prefix ) : "RESULT"

        { ------------------------------------------------------------------------------ }
        { If list results tables are defined on source and destination then do it also   }
        { ------------------------------------------------------------------------------ }

        tmp1 = STRIP ( ac_object.ach_commit_source_prefix       ) : "LIST_RESULT"
        tmp2 = STRIP (  ac_object.ach_commit_destination_prefix ) : "LIST_RESULT"

        IF ( VALID_TABLE ( tmp1 ) ) AND ( VALID_TABLE ( tmp2 ) ) THEN

            ARRAY an_array
            ARRAY an_array2
            an_array [1] = "TEST_NUMBER"
            an_array2[1] = "TEST_NUMBER"
            an_array2[2] = "NAME"

            ac_object.list_result_enabled = TRUE

            ac_object.user_tables[4,1] = tmp1
            ac_object.user_tables[4,2] = an_array
            ac_object.user_tables[4,3] = an_array2
            ac_object.user_tables[4,4] = tmp2

        ENDIF

    ELSEIF ( INDEX ( ac_object.ach_base_table, "PDS_STUDY" ) > 0 ) THEN

        ac_object.do_decrement_mode = FALSE   { *** gets each table as if not in heirarchy *** }

        ac_object.user_tables[1,1] = ac_object.ach_base_table
        ac_object.user_tables[1,2] = ac_object.ach_field_identity
        ac_object.user_tables[1,3] = ac_object.ach_field_identity
        ac_object.user_tables[1,4] = ac_object.make_destination( ac_object.ach_base_table)

        ARRAY an_array
        ARRAY an_array2

        an_array [1] = "HEADER"
        an_array [2] = "MATRIX_TYPE"

        GET_TABLE_DETAILS PDS_AXIS_POINT, "KEY0_FIELD", an_array2

        ac_object.user_tables[2,1] = STRIP ( ac_object.ach_commit_source_prefix ) : "PDS_AXIS_POINT"
        ac_object.user_tables[2,2] = an_array
        ac_object.user_tables[2,3] = an_array2
        ac_object.user_tables[2,4] = STRIP (  ac_object.ach_commit_destination_prefix ) : "PDS_AXIS_POINT"

        ARRAY an_array
        ARRAY an_array2

        an_array [1] = "HEADER"
        an_array [2] = "MATRIX_TYPE"

        GET_TABLE_DETAILS CONDITION_ENTRY, "KEY0_FIELD", an_array2

        ac_object.user_tables[3,1] = STRIP ( ac_object.ach_commit_source_prefix ) : "CONDITION_ENTRY"
        ac_object.user_tables[3,2] = an_array
        ac_object.user_tables[3,3] = an_array2
        ac_object.user_tables[3,4] = STRIP (  ac_object.ach_commit_destination_prefix ) : "CONDITION_ENTRY"

        ARRAY an_array
        ARRAY an_array2

        an_array [1] = "HEADER"
        an_array [2] = "MATRIX_TYPE"

        GET_TABLE_DETAILS LAYER_ENTRY, "KEY0_FIELD", an_array2

        ac_object.user_tables[4,1] = STRIP ( ac_object.ach_commit_source_prefix ) : "LAYER_ENTRY"
        ac_object.user_tables[4,2] = an_array
        ac_object.user_tables[4,3] = an_array2
        ac_object.user_tables[4,4] = STRIP (  ac_object.ach_commit_destination_prefix ) : "LAYER_ENTRY"

        ARRAY an_array
        ARRAY an_array2

        an_array [1] = "HEADER"
        an_array [2] = "MATRIX_TYPE"

        GET_TABLE_DETAILS PDS_BASETIME, "KEY0_FIELD", an_array2

        ac_object.user_tables[5,1] = STRIP ( ac_object.ach_commit_source_prefix ) : "PDS_BASETIME"
        ac_object.user_tables[5,2] = an_array
        ac_object.user_tables[5,3] = an_array2
        ac_object.user_tables[5,4] = STRIP (  ac_object.ach_commit_destination_prefix ) : "PDS_BASETIME"

        ARRAY an_array
        ARRAY an_array2

        an_array [1] = "HEADER"
        GET_TABLE_DETAILS PDS_STUDY_PULL, "KEY0_FIELD", an_array2

        ac_object.user_tables[6,1] = STRIP ( ac_object.ach_commit_source_prefix ) : "PDS_STUDY_PULL"
        ac_object.user_tables[6,2] = an_array
        ac_object.user_tables[6,3] = an_array2
        ac_object.user_tables[6,4] = STRIP (  ac_object.ach_commit_destination_prefix ) : "PDS_STUDY_PULL"


    ELSEIF ( INDEX ( ac_object.ach_base_table, "PDS_PROTO" ) > 0 ) THEN

        ac_object.do_decrement_mode = FALSE   { *** gets each table as if not in heirarchy *** }

        ac_object.user_tables[1,1] = ac_object.ach_base_table
        ac_object.user_tables[1,2] = ac_object.ach_field_identity
        ac_object.user_tables[1,3] = ac_object.ach_field_identity
        ac_object.user_tables[1,4] = ac_object.make_destination( ac_object.ach_base_table)

        ARRAY an_array
        ARRAY an_array2

        an_array [1] = "HEADER"
        an_array [2] = "PROTOCOL_VERSION"
        an_array [3] = "MATRIX_TYPE"

        GET_TABLE_DETAILS PDS_AXIS_POINT, "KEY0_FIELD", an_array2

        ac_object.user_tables[2,1] = STRIP ( ac_object.ach_commit_source_prefix ) : "PDS_AXIS_POINT"
        ac_object.user_tables[2,2] = an_array
        ac_object.user_tables[2,3] = an_array2
        ac_object.user_tables[2,4] = STRIP (  ac_object.ach_commit_destination_prefix ) : "PDS_AXIS_POINT"

        ARRAY an_array
        ARRAY an_array2

        an_array [1] = "HEADER"
        an_array [2] = "PROTOCOL_VERSION"
        an_array [3] = "MATRIX_TYPE"

        GET_TABLE_DETAILS CONDITION_ENTRY, "KEY0_FIELD", an_array2

        ac_object.user_tables[3,1] = STRIP ( ac_object.ach_commit_source_prefix ) : "CONDITION_ENTRY"
        ac_object.user_tables[3,2] = an_array
        ac_object.user_tables[3,3] = an_array2
        ac_object.user_tables[3,4] = STRIP (  ac_object.ach_commit_destination_prefix ) : "CONDITION_ENTRY"

        ARRAY an_array
        ARRAY an_array2

        an_array [1] = "HEADER"
        an_array [2] = "PROTOCOL_VERSION"
        an_array [3] = "MATRIX_TYPE"

        GET_TABLE_DETAILS LAYER_ENTRY, "KEY0_FIELD", an_array2

        ac_object.user_tables[4,1] = STRIP ( ac_object.ach_commit_source_prefix ) : "LAYER_ENTRY"
        ac_object.user_tables[4,2] = an_array
        ac_object.user_tables[4,3] = an_array2
        ac_object.user_tables[4,4] = STRIP (  ac_object.ach_commit_destination_prefix ) : "LAYER_ENTRY"

        ARRAY an_array
        ARRAY an_array2

        an_array [1] = "HEADER"
        an_array [2] = "PROTOCOL_VERSION"
        an_array [3] = "MATRIX_TYPE"

        GET_TABLE_DETAILS PDS_BASETIME, "KEY0_FIELD", an_array2

        ac_object.user_tables[5,1] = STRIP ( ac_object.ach_commit_source_prefix ) : "PDS_BASETIME"
        ac_object.user_tables[5,2] = an_array
        ac_object.user_tables[5,3] = an_array2
        ac_object.user_tables[5,4] = STRIP (  ac_object.ach_commit_destination_prefix ) : "PDS_BASETIME"

        ARRAY an_array
        ARRAY an_array2

        an_array [1] = "HEADER"
        an_array [2] = "PROTOCOL_VERSION"

        GET_TABLE_DETAILS PDS_PROTO_PULL, "KEY0_FIELD", an_array2

        ac_object.user_tables[6,1] = STRIP ( ac_object.ach_commit_source_prefix ) : "PDS_PROTO_PULL"
        ac_object.user_tables[6,2] = an_array
        ac_object.user_tables[6,3] = an_array2
        ac_object.user_tables[6,4] = STRIP (  ac_object.ach_commit_destination_prefix ) : "PDS_PROTO_PULL"

    ELSEIF ( INDEX ( ac_object.ach_base_table, "BATCH_HEADER" ) > 0 ) THEN

        ac_object.user_tables[1,1] = ac_object.ach_base_table
        ac_object.user_tables[1,2] = ac_object.ach_field_identity
        ac_object.user_tables[1,3] = ac_object.ach_field_identity
        ac_object.user_tables[1,4] = ac_object.make_destination( ac_object.ach_base_table)

        ARRAY an_array
        ARRAY an_array2
        an_array [1] = "IDENTITY"

        GET_TABLE_DETAILS BATCH_ENTRY, "KEY0_FIELD", an_array2

        ac_object.user_tables[2,1] = STRIP ( ac_object.ach_commit_source_prefix ) : "BATCH_ENTRY"
        ac_object.user_tables[2,2] = an_array
        ac_object.user_tables[2,3] = an_array2
        ac_object.user_tables[2,4] = STRIP ( ac_object.ach_commit_destination_prefix ) : "BATCH_ENTRY"

    ELSEIF ( INDEX ( ac_object.ach_base_table, "TEST_SCHED_HEADER" ) > 0 ) THEN

        ac_object.user_tables[1,1] = ac_object.ach_base_table
        ac_object.user_tables[1,2] = ac_object.ach_field_identity
        ac_object.user_tables[1,3] = ac_object.ach_field_identity
        ac_object.user_tables[1,4] = ac_object.make_destination( ac_object.ach_base_table)

        ARRAY an_array
        ARRAY an_array2
        an_array [1] = "IDENTITY"

        GET_TABLE_DETAILS TEST_SCHED_ENTRY, "KEY0_FIELD", an_array2

        ac_object.user_tables[2,1] = STRIP ( ac_object.ach_commit_source_prefix ) : "TEST_SCHED_ENTRY"
        ac_object.user_tables[2,2] = an_array
        ac_object.user_tables[2,3] = an_array2
        ac_object.user_tables[2,4] = STRIP ( ac_object.ach_commit_destination_prefix ) : "TEST_SCHED_ENTRY"

    ELSEIF ( INDEX ( ac_object.ach_base_table, "MLP_HEADER" ) > 0 ) THEN

        ac_object.user_tables[1,1] = ac_object.ach_base_table
        ac_object.user_tables[1,2] = ac_object.ach_field_identity
        ac_object.user_tables[1,3] = ac_object.ach_field_identity
        ac_object.user_tables[1,4] = ac_object.make_destination( ac_object.ach_base_table)

        IF ( ac_object.ach_commit_destination_type <> C_REMOVE_FLAG ) THEN

            ARRAY an_array
            ARRAY an_array2
            an_array [1] = "PRODUCT_ID"
            an_array [2] = "PRODUCT_VERSION"

            GET_TABLE_DETAILS MLP_COMPONENTS, "KEY0_FIELD", an_array2

            ac_object.user_tables[2,1] = STRIP ( ac_object.ach_commit_source_prefix ) : "MLP_COMPONENTS"
            ac_object.user_tables[2,2] = an_array
            ac_object.user_tables[2,3] = an_array2
            ac_object.user_tables[2,4] = STRIP ( ac_object.ach_commit_destination_prefix ) : "MLP_COMPONENTS"

            ARRAY an_array
            ARRAY an_array2
            an_array [1] = "PRODUCT_ID"
            an_array [2] = "PRODUCT_VERSION"

            GET_TABLE_DETAILS MLP_ANALYSIS, "KEY0_FIELD", an_array2

            ac_object.user_tables[3,1] = STRIP ( ac_object.ach_commit_source_prefix ) : "MLP_ANALYSIS"
            ac_object.user_tables[3,2] = an_array
            ac_object.user_tables[3,3] = an_array2
            ac_object.user_tables[3,4] = STRIP ( ac_object.ach_commit_destination_prefix ) : "MLP_ANALYSIS"

            ARRAY an_array
            ARRAY an_array2
            an_array [1] = "PRODUCT_ID"
            an_array [2] = "PRODUCT_VERSION"



            GET_TABLE_DETAILS MLP_VALUES, "KEY0_FIELD", an_array2

            ac_object.user_tables[4,1] = STRIP ( ac_object.ach_commit_source_prefix ) : "MLP_VALUES"
            ac_object.user_tables[4,2] = an_array
            ac_object.user_tables[4,3] = an_array2
            ac_object.user_tables[4,4] = STRIP ( ac_object.ach_commit_destination_prefix ) : "MLP_VALUES"

            ARRAY an_array
            ARRAY an_array2
            an_array [1] = "IDENTITY"
            an_array [2] = "IDENTITY_VERSION"

            GET_TABLE_DETAILS MLP_SCHEDULE, "KEY0_FIELD", an_array2

            ac_object.user_tables[5,1] = STRIP ( ac_object.ach_commit_source_prefix ) : "MLP_SCHEDULE"
            ac_object.user_tables[5,2] = an_array
            ac_object.user_tables[5,3] = an_array2
            ac_object.user_tables[5,4] = STRIP ( ac_object.ach_commit_destination_prefix ) : "MLP_SCHEDULE"

            { --------------------------------------------------------------------- }
            { Custom and EFM tables                                                 }
            { --------------------------------------------------------------------- }

            tmp1 = "PROD_SCHED"

            IF ( VALID_TABLE ( tmp1 ) ) THEN

                ARRAY an_array
                ARRAY an_array2
                an_array [1] = "PRODUCT_NAME"
                an_array [2] = "PRODUCT_VERSION"

                GET_TABLE_DETAILS 'tmp1', "KEY0_FIELD", an_array2

                ac_object.user_tables[6,1] = STRIP ( ac_object.ach_commit_source_prefix ) : tmp1
                ac_object.user_tables[6,2] = an_array
                ac_object.user_tables[6,3] = an_array2
                ac_object.user_tables[6,4] = STRIP ( ac_object.ach_commit_destination_prefix ) : tmp1

            ENDIF

            tmp1 = "MLP_HEADER_LANGUAGE"

            IF ( VALID_TABLE ( tmp1 ) ) THEN

                ARRAY an_array
                ARRAY an_array2
                an_array [1] = "MLP_HEADER"
                an_array [2] = "MLP_VERSION"

                GET_TABLE_DETAILS 'tmp1', "KEY0_FIELD", an_array2

                ac_object.user_tables[6,1] = STRIP ( ac_object.ach_commit_source_prefix ) : tmp1
                ac_object.user_tables[6,2] = an_array
                ac_object.user_tables[6,3] = an_array2
                ac_object.user_tables[6,4] = STRIP ( ac_object.ach_commit_destination_prefix ) : tmp1

            ENDIF

            tmp1 = "PARM_SETUP_LINK_FIELDS"

            IF ( VALID_TABLE ( tmp1 ) ) THEN

                ARRAY an_array
                ARRAY an_array2
                an_array [1] = "IDENTITY"

                GET_TABLE_DETAILS 'tmp1', "KEY0_FIELD", an_array2

                ac_object.user_tables[7,1] = STRIP ( ac_object.ach_commit_source_prefix ) : tmp1
                ac_object.user_tables[7,2] = an_array
                ac_object.user_tables[7,3] = an_array2
                ac_object.user_tables[7,4] = STRIP ( ac_object.ach_commit_destination_prefix ) : tmp1

            ENDIF

            tmp1 = "PARM_SETUP_VALUES"

            IF ( VALID_TABLE ( tmp1 ) ) THEN

                ARRAY an_array
                ARRAY an_array2
                an_array [1] = "IDENTITY"

                GET_TABLE_DETAILS 'tmp1', "KEY0_FIELD", an_array2

                ac_object.user_tables[8,1] = STRIP ( ac_object.ach_commit_source_prefix ) : tmp1
                ac_object.user_tables[8,2] = an_array
                ac_object.user_tables[8,3] = an_array2
                ac_object.user_tables[8,4] = STRIP ( ac_object.ach_commit_destination_prefix ) : tmp1

            ENDIF

            tmp1 = "PARM_SETUP"

        IF ( VALID_TABLE ( tmp1 ) ) THEN

        ARRAY an_array
            ARRAY an_array2
                an_array [1] = "IDENTITY"
                an_array [2] = "IDENTITY_VERSION"

                GET_TABLE_DETAILS 'tmp1', "KEY0_FIELD", an_array2

                ac_object.user_tables[9,1] = STRIP ( ac_object.ach_commit_source_prefix ) : tmp1
                ac_object.user_tables[9,2] = an_array
                ac_object.user_tables[9,3] = an_array2
                ac_object.user_tables[9,4] = STRIP ( ac_object.ach_commit_destination_prefix ) : tmp1

            ENDIF

            tmp1 = "MX_MATERIAL_CLASS"

            IF ( VALID_TABLE ( tmp1 ) ) THEN

                ARRAY an_array
                ARRAY an_array2
                an_array [1] = "SPECIFICATION"

                GET_TABLE_DETAILS 'tmp1', "KEY0_FIELD", an_array2

                ac_object.user_tables[9,1] = STRIP ( ac_object.ach_commit_source_prefix ) : tmp1
                ac_object.user_tables[9,2] = an_array
                ac_object.user_tables[9,3] = an_array2
                ac_object.user_tables[9,4] = STRIP ( ac_object.ach_commit_destination_prefix ) : tmp1

            ENDIF

        ENDIF   { removeflag is only on the base table, otherwise all the tables are deleted }

    ELSEIF ( INDEX ( ac_object.ach_base_table, "VERSIONED_ANALYSIS" ) > 0 ) THEN

        ac_object.user_tables[1,1] = ac_object.ach_base_table
        ac_object.user_tables[1,2] = ac_object.ach_field_identity
        ac_object.user_tables[1,3] = ac_object.ach_field_identity
        ac_object.user_tables[1,4] = ac_object.make_destination( ac_object.ach_base_table)

        IF ( ac_object.ach_commit_destination_type <> C_REMOVE_FLAG ) THEN

            ARRAY an_array
            ARRAY an_array2
            an_array [1] = "ANALYSIS"
            an_array [2] = "ANALYSIS_VERSION"

            GET_TABLE_DETAILS VERSIONED_COMPONENT, "KEY0_FIELD", an_array2

            ac_object.user_tables[2,1] = STRIP ( ac_object.ach_commit_source_prefix ) : "VERSIONED_COMPONENT"
            ac_object.user_tables[2,2] = an_array
            ac_object.user_tables[2,3] = an_array2
            ac_object.user_tables[2,4] = STRIP ( ac_object.ach_commit_destination_prefix ) : "VERSIONED_COMPONENT"

        ENDIF  { base table remove only does one table, otherwise all the child tables }

        tmp1 = "PARM_SETUP_LINK_FIELDS"

        IF ( VALID_TABLE ( tmp1 ) ) THEN

           ARRAY an_array
           ARRAY an_array2
           an_array [1] = "IDENTITY"

           GET_TABLE_DETAILS 'tmp1', "KEY0_FIELD", an_array2

           ac_object.user_tables[3,1] = STRIP ( ac_object.ach_commit_source_prefix ) : tmp1
           ac_object.user_tables[3,2] = an_array
           ac_object.user_tables[3,3] = an_array2
           ac_object.user_tables[3,4] = STRIP ( ac_object.ach_commit_destination_prefix ) : tmp1

        ENDIF

            tmp1 = "PARM_SETUP_VALUES"

        IF ( VALID_TABLE ( tmp1 ) ) THEN

           ARRAY an_array
           ARRAY an_array2
           an_array [1] = "IDENTITY"

           GET_TABLE_DETAILS 'tmp1', "KEY0_FIELD", an_array2

           ac_object.user_tables[4,1] = STRIP ( ac_object.ach_commit_source_prefix ) : tmp1
           ac_object.user_tables[4,2] = an_array
           ac_object.user_tables[4,3] = an_array2
           ac_object.user_tables[4,4] = STRIP ( ac_object.ach_commit_destination_prefix ) : tmp1

        ENDIF

        tmp1 = "PARM_SETUP"

        IF ( VALID_TABLE ( tmp1 ) ) THEN

            ARRAY an_array
                ARRAY an_array2
                an_array [1] = "IDENTITY"
                an_array [2] = "IDENTITY_VERSION"

                GET_TABLE_DETAILS 'tmp1', "KEY0_FIELD", an_array2

                ac_object.user_tables[5,1] = STRIP ( ac_object.ach_commit_source_prefix ) : tmp1
                ac_object.user_tables[5,2] = an_array
                ac_object.user_tables[5,3] = an_array2
                ac_object.user_tables[5,4] = STRIP ( ac_object.ach_commit_destination_prefix ) : tmp1

        ENDIF

        tmp1 = "VERSIONED_ANALYSIS_STOCK_USE"

        IF ( VALID_TABLE ( tmp1 ) ) THEN

            ARRAY an_array
                ARRAY an_array2
                an_array [1] = "ANALYSIS"
                an_array [2] = "ANALYSIS_VERSION"

                GET_TABLE_DETAILS 'tmp1', "KEY0_FIELD", an_array2

                ac_object.user_tables[6,1] = STRIP ( ac_object.ach_commit_source_prefix ) : tmp1
                ac_object.user_tables[6,2] = an_array
                ac_object.user_tables[6,3] = an_array2
                ac_object.user_tables[6,4] = STRIP ( ac_object.ach_commit_destination_prefix ) : tmp1

        ENDIF

        tmp1 = "VERSIONED_C_L_HEADER"

        IF ( VALID_TABLE ( tmp1 ) ) THEN

            ARRAY an_array
                ARRAY an_array2
                an_array [1] = "ANALYSIS"
                an_array [2] = "ANALYSIS_VERSION"

                GET_TABLE_DETAILS 'tmp1', "KEY0_FIELD", an_array2

                ac_object.user_tables[7,1] = STRIP ( ac_object.ach_commit_source_prefix ) : tmp1
                ac_object.user_tables[7,2] = an_array
                ac_object.user_tables[7,3] = an_array2
                ac_object.user_tables[7,4] = STRIP ( ac_object.ach_commit_destination_prefix ) : tmp1

        ENDIF

        tmp1 = "VERSIONED_C_L_ENTRY"

        IF ( VALID_TABLE ( tmp1 ) ) THEN

            ARRAY an_array
                ARRAY an_array2
                an_array [1] = "ANALYSIS"
                an_array [2] = "ANALYSIS_VERSION"

                GET_TABLE_DETAILS 'tmp1', "KEY0_FIELD", an_array2

                ac_object.user_tables[8,1] = STRIP ( ac_object.ach_commit_source_prefix ) : tmp1
                ac_object.user_tables[8,2] = an_array
                ac_object.user_tables[8,3] = an_array2
                ac_object.user_tables[8,4] = STRIP ( ac_object.ach_commit_destination_prefix ) : tmp1

        ENDIF

    ELSEIF ( INDEX ( ac_object.ach_base_table, "STANDARD_VERSIONS" ) > 0 ) THEN

        ac_object.user_tables[1,1] = ac_object.ach_base_table
        ac_object.user_tables[1,2] = ac_object.ach_field_identity
        ac_object.user_tables[1,3] = ac_object.ach_field_identity
        ac_object.user_tables[1,4] = ac_object.make_destination( ac_object.ach_base_table)

        ARRAY an_array
        ARRAY an_array2
        an_array [1] = "IDENTITY"
        an_array [2] = "VERSION"

        GET_TABLE_DETAILS STANDARD_CONCENTRATION, "KEY0_FIELD", an_array2

        ac_object.user_tables[2,1] = STRIP ( ac_object.ach_commit_source_prefix ) : "STANDARD_CONCENTRATION"
        ac_object.user_tables[2,2] = an_array
        ac_object.user_tables[2,3] = an_array2
        ac_object.user_tables[2,4] = STRIP ( ac_object.ach_commit_destination_prefix ) : "STANDARD_CONCENTRATION"

    ELSEIF ( INDEX ( ac_object.ach_base_table, "WORKSHEET" ) > 0 ) THEN

        ac_object.user_tables[1,1] = ac_object.ach_base_table
        ac_object.user_tables[1,2] = ac_object.ach_field_identity
        ac_object.user_tables[1,3] = ac_object.ach_field_identity
        ac_object.user_tables[1,4] = ac_object.make_destination( ac_object.ach_base_table)

    ELSEIF ( INDEX ( ac_object.ach_base_table, "LOT_DETAILS" ) > 0 ) THEN

        ac_object.user_tables[1,1] = ac_object.ach_base_table
        ac_object.user_tables[1,2] = ac_object.ach_field_identity
        ac_object.user_tables[1,3] = ac_object.ach_field_identity
        ac_object.user_tables[1,4] = ac_object.make_destination( ac_object.ach_base_table)

        ARRAY an_array
        ARRAY an_array2
        an_array [1] = "FROM_LOT"
        an_array2[1] = "FROM_LOT"

        ac_object.user_tables[2,1] = STRIP ( ac_object.ach_commit_source_prefix ) : "LOT_RELATION"
        ac_object.user_tables[2,2] = an_array
        ac_object.user_tables[2,3] = an_array2
        ac_object.user_tables[2,4] = STRIP ( ac_object.ach_commit_destination_prefix ) : "LOT_RELATION"

    ELSEIF ( INDEX ( ac_object.ach_base_table, C_CERTIFICATE_TABLE ) > 0 ) THEN

        ac_object.user_tables[1,1] = ac_object.ach_base_table
        ac_object.user_tables[1,2] = ac_object.ach_field_identity
        ac_object.user_tables[1,3] = ac_object.ach_field_identity
        ac_object.user_tables[1,4] = ac_object.make_destination( ac_object.ach_base_table)

        ARRAY an_array
        ARRAY an_array2
        an_array [1] = "CERTIFICATE"

        GET_TABLE_DETAILS 'C_CERTIFICATE_TEXT', "KEY0_FIELD", an_array2

        ac_object.user_tables[2,1] = STRIP ( ac_object.ach_commit_source_prefix ) : "CERTIFICATE_TEXT"
        ac_object.user_tables[2,2] = an_array
        ac_object.user_tables[2,3] = an_array2
        ac_object.user_tables[2,4] = STRIP ( ac_object.ach_commit_destination_prefix ) : "CERTIFICATE_TEXT"

        ARRAY an_array
        ARRAY an_array2
        an_array [1] = "CERTIFICATE"

        GET_TABLE_DETAILS 'C_CERTIFICATE_RESULTS', "KEY0_FIELD", an_array2

        ac_object.user_tables[3,1] = STRIP ( ac_object.ach_commit_source_prefix ) : "CERTIFICATE_RESULTS"
        ac_object.user_tables[3,2] = an_array
        ac_object.user_tables[3,3] = an_array2
        ac_object.user_tables[3,4] = STRIP ( ac_object.ach_commit_destination_prefix ) : "CERTIFICATE_RESULTS"

        ARRAY an_array
        ARRAY an_array2
        an_array [1] = "CERTIFICATE"

        GET_TABLE_DETAILS 'C_CERTIFICATE_COMMENTS', "KEY0_FIELD", an_array2

        ac_object.user_tables[4,1] = STRIP ( ac_object.ach_commit_source_prefix ) : "CERTIFICATE_COMMENTS"
        ac_object.user_tables[4,2] = an_array
        ac_object.user_tables[4,3] = an_array2
        ac_object.user_tables[4,4] = STRIP ( ac_object.ach_commit_destination_prefix ) : "CERTIFICATE_COMMENTS"

    ELSEIF ( ac_object.call_trigger ( "custom_auto_commit_list", tmp1, ret_val ) ) THEN

        internal_log_message ( ac_object, ac_object.current_routine : tmp1, C_MSG_FULL )

    ELSE

        ret_val             = FALSE
        ac_object.error_msg = msg.20
        internal_log_message ( ac_object, ac_object.current_routine : ac_object.error_msg, C_MSG_FULL )

    ENDIF

    { ----------------------------------------------------- }
    { If all is ok to here, then validate (it has trigger)  }
    { ----------------------------------------------------- }

    IF ( ret_val ) THEN

        ret_val = ac_object.validate_default_ac_list()

    ENDIF

    { ----------------------------------------------------- }
    { Let the logfile know what condition is being returned }
    { ----------------------------------------------------- }

    ac_object.current_routine = "ac_object_action_default_auto_commit_list "
    internal_log_message ( ac_object, ac_object.current_routine : ret_val, C_MSG_LOW )

    RETURN ( ret_val )

ENDROUTINE  { ac_object_action_default_auto_commit_list }

{******************************************************************************}

ROUTINE ac_object_action_validate_default_ac_list ( ac_object )

    DECLARE cnt

    ret_val = TRUE
    cnt     = 1

    IF ( ac_object.call_trigger ( "before_validate_ac_list", cnt, ret_val ) ) THEN

        ac_object.no_user_tables  = SIZE_OF_ARRAY ( ac_object.user_tables )
        cnt                       = 1

        WHILE ( cnt <= ac_object.no_user_tables ) AND ( ret_val ) DO

            IF ( VALID_TABLE ( ac_object.user_tables[cnt,4] ) ) THEN

                cnt = cnt + 1

            ELSE

                ret_val                   = FALSE
                ac_object.error_msg       = msg.10 : ac_object.user_tables[cnt,4]
                ac_object.current_routine = "ac_object_action_validate_default_ac_list "

                internal_log_message ( ac_object, ac_object.current_routine : ac_object.error_msg, C_MSG_FULL )

            ENDIF

        ENDWHILE

    ELSE

        ret_val = FALSE

    ENDIF  { trigger to adjust commit list had an error }

    { ----------------------------------------------------- }
    { Let the logfile know what condition is being returned }
    { ----------------------------------------------------- }

    ac_object.current_routine = "ac_object_action_validate_default_ac_list "
    internal_log_message ( ac_object, ac_object.current_routine : ret_val, C_MSG_LOW )

    RETURN ( ret_val )

ENDROUTINE  { ac_object_action_validate_default_ac_list }

{******************************************************************************}

ROUTINE ac_object_action_make_destination ( ac_object, VALUE a_table )

    DECLARE a_len, prefix_slen, a_ret

    IF a_table = "ARCHIVE_AUDIT_TRANS" THEN
        a_table = "ARCHIVE_AUDIT_TRANSACTION"
    ENDIF

    a_table     = STRIP ( a_table )
    a_len       = STRINGLENGTH ( a_table )
    prefix_slen = STRINGLENGTH ( ac_object.ach_commit_source_prefix  )
    a_ret       = ac_object.ach_commit_destination_prefix : STRIP ( RIGHTSTRING ( a_table, a_len - prefix_slen ) )

    IF a_ret = "ARCHIVE_AUDIT_TRANSACTION" THEN
        a_ret = "ARCHIVE_AUDIT_TRANS"
    ENDIF

    RETURN ( a_ret )

ENDROUTINE     { ac_object_action_make_destination }

{******************************************************************************}

ROUTINE ac_object_action_get_system_tables ( ac_object )

    DECLARE an_array, i, i2

    ac_object.current_routine = "ac_object_action_get_system_tables "

    { -------------------------------------------------------------- }
    { Get all the user config tables and dependancies                }
    { -------------------------------------------------------------- }

    ARRAY an_array
    ARRAY ac_object.system_tables

    { -------------------------------------------------------------- }
    { Validate all required tables                                   }
    { -------------------------------------------------------------- }

    an_array = ac_object.required_array
    ret_val  = TRUE
    i        = 0
    i2       = 1

    WHILE ( an_array[i2,1] <> EMPTY ) AND ( ret_val ) DO

        tmp = ac_object.make_destination( an_array[i2,1] )

        IF ( VALID_TABLE ( tmp ) ) THEN

            i = i + 1
            ac_object.system_tables[i,1] = an_array[i2,1]
            ac_object.system_tables[i,2] = internal_set_system_field ( an_array[i2,1] )
            ac_object.system_tables[i,3] = tmp

            internal_log_message ( ac_object, ac_object.current_routine : i : tmp, C_MSG_LOW )

        ELSE

            ret_val             = FALSE
            ac_object.error_msg = msg.11 : tmp : " " :an_array[i2,1]

            internal_log_message ( ac_object, ac_object.current_routine : ac_object.error_msg, C_MSG_FULL )

        ENDIF

        i2 = i2 + 1

    ENDWHILE

    { ----------------------------------------------------- }
    { Let the logfile know what condition is being returned }
    { ----------------------------------------------------- }

    internal_log_message ( ac_object, ac_object.current_routine : ret_val, C_MSG_LOW )

    RETURN ( ret_val )

ENDROUTINE  { ac_object_action_get_system_tables }

{******************************************************************************}

ROUTINE ac_object_action_set_source_tableset ( ac_object )

    DECLARE current_table_set

    ac_object.current_routine = "ac_object_action_set_source_tableset "
    current_table_set         = GLOBAL ( GLBL_SETCOM_TABLE_SET_GLOBAL )
    ret_val                   = TRUE

    { ---------------------------------------------------------- }
    { If menu is currently in commit view nothing can run        }
    { ---------------------------------------------------------- }

    IF ( GLOBAL  ( GLBL_COMMIT_VIEW_MODE ) ) THEN

        ret_val             = FALSE
        ac_object.error_msg = msg.43
        internal_log_message ( ac_object, ac_object.current_routine : ac_object.error_msg, C_MSG_FULL )

    ELSEIF ( ac_object.ach_commit_destination <> current_table_set ) THEN


        SET GLOBAL GLBL_SETCOM_TABLE_SET_GLOBAL TO ac_object.ach_commit_destination

    ENDIF

    { ----------------------------------------------------- }
    { Let the logfile know what condition is being returned }
    { ----------------------------------------------------- }

    internal_log_message ( ac_object, ac_object.current_routine:ac_object.ach_commit_destination, C_MSG_LOW )

    RETURN ( ret_val )

ENDROUTINE  { ac_object_action_set_source_tableset }

{******************************************************************************}

ROUTINE ac_object_action_close_logfile ( ac_object, VALUE retval )

    DECLARE status

    ac_object.current_routine = "ac_object_action_close_logfile "

    { -------------------------------------------------------------- }
    { Calculate how long it took to do this whole process            }
    { -------------------------------------------------------------- }

    tmp = NOW - ac_object.ac_start_time

    IF ( BLANK ( tmp ) ) OR ( tmp = "ERROR" ) THEN

        tmp = INTERVAL ( "0000 00:00:00.01" )

    ENDIF

    internal_log_message ( ac_object, ac_object.current_routine : "(" : msg.45:tmp: ")  " : NOW, C_MSG_HIGH )

    ac_object.ace_execute_interval = INTERVAL ( tmp )

    IF ( ac_object.ace_execute_interval = "ERROR" ) THEN

        ac_object.ace_execute_interval = INTERVAL ( "0000 00:11:04.56" )

    ENDIF

    { ------------------------------------------------------------------------------------------ }
    { Update execution table with everything we did so far...                                    }
    { ------------------------------------------------------------------------------------------ }

    retval = ac_object.update_execution( retval )

    { ------------------------------------------------------------------------------------------ }
    { Let user have a trigger to update anything customized                                      }
    { ------------------------------------------------------------------------------------------ }

    ac_object.call_trigger ( "before_update_auto_commit_execution", "CLOSE", retval )

    UPDATE AUTO_COMMIT_EXECUTION, status
    COMMIT

    IF status <> EMPTY THEN

        ac_object.current_routine = "ac_object_action_close_logfile "
        retval                    = FALSE

        internal_log_message ( ac_object, ac_object.current_routine:msg.21:" ":status, C_MSG_HIGH )

    ENDIF

    { ------------------------------------------------------------------------------------------ }
    { No matter what we have some type of report to output                                       }
    { ------------------------------------------------------------------------------------------ }

    IF ( ac_object.do_archive_csv ) THEN

        ac_object.update_destination()

    ELSEIF( retval )

        ac_object.write_reports( retval )

    ENDIF

    ac_object.call_trigger ( "before_close_files",  "CLOSE", retval )

    FILE CLOSE ac_object.ace_short_report, tmp
    FILE CLOSE ac_object.ace_report      , tmp
    FILE CLOSE ac_object.ace_logfile     , tmp


    RETURN ( retval )

ENDROUTINE  { ac_object_action_close_logfile }

{******************************************************************************}

ROUTINE ac_object_action_update_execution ( ac_object,
                                            retval   )

    DECLARE status

    ac_object.current_routine = "ac_object_action_update_execution "

    { -------------------------------------------------------------- }
    { Update the execution table with new values                     }
    { -------------------------------------------------------------- }

    IF NOT ( TRANSACTION_IS_WRITE() ) THEN

        START WRITE TRANSACTION C_ACE_LOGFILE_TRANSACTION

    ENDIF

    status = SELECT AUTO_COMMIT_EXECUTION.IDENTITY FOR UPDATE
                 WHERE IDENTITY       = ac_object.ach_identity
                 AND   ORDER_NUMBER   = ac_object.ace_order_number

    IF ( status <> LOCKED ) THEN

        IF ( ac_object.pds_mode ) THEN
            ASSIGN AUTO_COMMIT_EXECUTION.BASE_COUNT   = ac_object.count_pds_job
        ELSE
            ASSIGN AUTO_COMMIT_EXECUTION.BASE_COUNT   = ac_object.count_base
        ENDIF

        ASSIGN AUTO_COMMIT_EXECUTION.COUNT_SAMPLE         = ac_object.count_sample
        ASSIGN AUTO_COMMIT_EXECUTION.COUNT_TEST           = ac_object.count_test
        ASSIGN AUTO_COMMIT_EXECUTION.COUNT_RESULT         = ac_object.count_result
        ASSIGN AUTO_COMMIT_EXECUTION.COUNT_AUDIT_DATA     = ac_object.count_audit_data
        ASSIGN AUTO_COMMIT_EXECUTION.COUNT_AUDIT_EVENT    = ac_object.count_audit_event
        ASSIGN AUTO_COMMIT_EXECUTION.COUNT_AUDIT_TRANS    = ac_object.count_audit_trans
        ASSIGN AUTO_COMMIT_EXECUTION.COUNT_ESIG_DATA      = ac_object.count_esig_data
        ASSIGN AUTO_COMMIT_EXECUTION.COUNT_ESIG_EVENT     = ac_object.count_esig_event
        ASSIGN AUTO_COMMIT_EXECUTION.COUNT_INC_HEADER     = ac_object.count_inc_header
        ASSIGN AUTO_COMMIT_EXECUTION.COUNT_INC_RESULT     = ac_object.count_inc_result
        ASSIGN AUTO_COMMIT_EXECUTION.COUNT_INSPECTOR      = ac_object.count_inspector
        ASSIGN AUTO_COMMIT_EXECUTION.EXECUTE_INTERVAL     = ac_object.ace_execute_interval
        ASSIGN AUTO_COMMIT_EXECUTION.A_MESSAGE            = ac_object.error_msg

        { ---------------------------------------------------------------------------- }
        { Any optional fields defined then also save this data                         }
        { ---------------------------------------------------------------------------- }

        IF ( ac_object.list_result_enabled ) AND ( VALID_FIELD ( "AUTO_COMMIT_EXECUTION", C_COUNT_LIST_RESULT ) ) THEN

            ASSIGN AUTO_COMMIT_EXECUTION.'C_COUNT_LIST_RESULT' = ac_object.count_list_result

        ENDIF

        IF ( ac_object.worksheets_enabled ) AND ( VALID_FIELD ( "AUTO_COMMIT_EXECUTION", C_COUNT_WORKSHEET ) ) THEN

            ASSIGN AUTO_COMMIT_EXECUTION.'C_COUNT_WORKSHEET' = ac_object.count_worksheet

        ENDIF

        { ---------------------------------------------------------------------------- }
        { Label engine uses optional tables/fields                                     }
        { ---------------------------------------------------------------------------- }

        IF ( ac_object.labels_enabled ) THEN

            IF ( VALID_FIELD ( "AUTO_COMMIT_EXECUTION", C_COUNT_LABEL ) ) THEN

                ASSIGN AUTO_COMMIT_EXECUTION.'C_COUNT_LABEL' = ac_object.count_labelprint

            ENDIF


            IF ( VALID_FIELD ( "AUTO_COMMIT_EXECUTION", C_COUNT_LABEL_LINES ) ) THEN

                ASSIGN AUTO_COMMIT_EXECUTION.'C_COUNT_LABEL_LINES' = ac_object.count_labelprint_lines

            ENDIF

        ENDIF

        { ---------------------------------------------------------------------------- }
        { Disposition engine uses optional tables/fields                               }
        { ---------------------------------------------------------------------------- }

        IF ( ac_object.disposition_enabled ) THEN

            IF ( VALID_FIELD ( "AUTO_COMMIT_EXECUTION", C_COUNT_DISP_HEADER ) ) THEN

                ASSIGN AUTO_COMMIT_EXECUTION.'C_COUNT_DISP_HEADER' = ac_object.count_disp_header

            ENDIF


            IF ( VALID_FIELD ( "AUTO_COMMIT_EXECUTION", C_COUNT_DISP_COMMENT ) ) THEN

                ASSIGN AUTO_COMMIT_EXECUTION.'C_COUNT_DISP_COMMENT' = ac_object.count_disp_comment

            ENDIF

        ENDIF

        { ---------------------------------------------------------------------------- }
        { PDS tables/fields are part of kit, but may never be used at a site           }
        { ---------------------------------------------------------------------------- }

        ASSIGN AUTO_COMMIT_EXECUTION.COUNT_PDS_STUDY      = ac_object.count_pds_study
        ASSIGN AUTO_COMMIT_EXECUTION.COUNT_PDS_AXIS_POINT = ac_object.count_pds_axis_point
        ASSIGN AUTO_COMMIT_EXECUTION.COUNT_PDS_STUDY_PULL = ac_object.count_pds_study_pull
        ASSIGN AUTO_COMMIT_EXECUTION.COUNT_PDS_BASETIME   = ac_object.count_pds_basetime
        ASSIGN AUTO_COMMIT_EXECUTION.COUNT_PDS_LAYER      = ac_object.count_pds_layer
        ASSIGN AUTO_COMMIT_EXECUTION.COUNT_PDS_CONDITION  = ac_object.count_pds_condition

        { ---------------------------------------------------------------------------- }
        { COA tables - BASE TABLE                                                      }
        { ---------------------------------------------------------------------------- }

        IF ( ac_object.certificates_enabled ) THEN

            IF ( VALID_FIELD ( "AUTO_COMMIT_EXECUTION", C_COUNT_CERTIFICATE ) ) THEN

                ASSIGN AUTO_COMMIT_EXECUTION.'C_COUNT_CERTIFICATE' = ac_object.count_certificate

            ENDIF

            IF ( VALID_FIELD ( "AUTO_COMMIT_EXECUTION", C_COUNT_COA_COMMENT ) ) THEN

                ASSIGN AUTO_COMMIT_EXECUTION.'C_COUNT_COA_COMMENT' = ac_object.count_coa_comment

            ENDIF

            IF ( VALID_FIELD ( "AUTO_COMMIT_EXECUTION", C_COUNT_COA_RESULT ) ) THEN

                ASSIGN AUTO_COMMIT_EXECUTION.'C_COUNT_COA_RESULT' = ac_object.count_coa_result

            ENDIF

            IF ( VALID_FIELD ( "AUTO_COMMIT_EXECUTION", C_COUNT_COA_TEXT ) ) THEN

                ASSIGN AUTO_COMMIT_EXECUTION.'C_COUNT_COA_TEXT' = ac_object.count_coa_text

            ENDIF

        ENDIF

        { ---------------------------------------------------------------------------- }
        { MLP Mode is optional tables/fields  BASE TABLE                               }
        { ---------------------------------------------------------------------------- }

        IF ( ac_object.mlp_enabled ) THEN

            IF ( VALID_FIELD ( "AUTO_COMMIT_EXECUTION", C_COUNT_MLP ) ) THEN
                ASSIGN AUTO_COMMIT_EXECUTION.'C_COUNT_MLP' = ac_object.count_MLP_header
            ENDIF

            IF ( VALID_FIELD ( "AUTO_COMMIT_EXECUTION", C_COUNT_MLP_SCHEDULE ) ) THEN
                ASSIGN AUTO_COMMIT_EXECUTION.'C_COUNT_MLP_SCHEDULE' = ac_object.count_MLP_Schedule
            ENDIF

            IF ( VALID_FIELD ( "AUTO_COMMIT_EXECUTION", C_COUNT_MLP_ANALYSIS ) ) THEN
                ASSIGN AUTO_COMMIT_EXECUTION.'C_COUNT_MLP_ANALYSIS' = ac_object.count_MLP_Analysis
            ENDIF

            IF ( VALID_FIELD ( "AUTO_COMMIT_EXECUTION", C_COUNT_MLP_COMPONENTS ) ) THEN
                ASSIGN AUTO_COMMIT_EXECUTION.'C_COUNT_MLP_COMPONENTS' = ac_object.count_MLP_Components
            ENDIF

            IF ( VALID_FIELD ( "AUTO_COMMIT_EXECUTION", C_COUNT_MLP_VALUES ) ) THEN
                ASSIGN AUTO_COMMIT_EXECUTION.'C_COUNT_MLP_VALUES' = ac_object.count_MLP_Values
            ENDIF

        ENDIF

        { ---------------------------------------------------------------------------- }
        { Analyses and lower tables are optional (arcom) tables/fields BASE TABLE      }
        { ---------------------------------------------------------------------------- }

        IF ( ac_object.analysis_enabled ) THEN

            IF ( VALID_FIELD ( "AUTO_COMMIT_EXECUTION", C_COUNT_ANALYSIS ) ) THEN
                ASSIGN AUTO_COMMIT_EXECUTION.'C_COUNT_ANALYSIS' = ac_object.count_analysis
            ENDIF

            IF ( VALID_FIELD ( "AUTO_COMMIT_EXECUTION", C_COUNT_COMPONENTS ) ) THEN
                ASSIGN AUTO_COMMIT_EXECUTION.'C_COUNT_COMPONENTS' = ac_object.count_components
            ENDIF

            IF ( VALID_FIELD ( "AUTO_COMMIT_EXECUTION", C_COUNT_CL_HEADER ) ) THEN
                ASSIGN AUTO_COMMIT_EXECUTION.'C_COUNT_CL_HEADER' = ac_object.count_cl_header
            ENDIF

            IF ( VALID_FIELD ( "AUTO_COMMIT_EXECUTION", C_COUNT_CL_ENTRY ) ) THEN
                ASSIGN AUTO_COMMIT_EXECUTION.'C_COUNT_CL_ENTRY' = ac_object.count_cl_entry
            ENDIF

        ENDIF

        { ---------------------------------------------------------------------------- }
        { Standard Versions/concentration aree optional tables/fields BASE TABLE       }
        { ---------------------------------------------------------------------------- }

        IF ( ac_object.standard_enabled ) THEN

            IF ( VALID_FIELD ( "AUTO_COMMIT_EXECUTION", C_COUNT_STANDARDS ) ) THEN
                ASSIGN AUTO_COMMIT_EXECUTION.'C_COUNT_STANDARDS' = ac_object.count_standard_versions
            ENDIF

            IF ( VALID_FIELD ( "AUTO_COMMIT_EXECUTION", C_COUNT_STANDARD_CONC ) ) THEN
                ASSIGN AUTO_COMMIT_EXECUTION.'C_COUNT_STANDARD_CONC' = ac_object.count_std_conc
            ENDIF

        ENDIF

        { ---------------------------------------------------------------------------- }
        { BATCHES and lower tables are optional (arcom) tables/fields   BASE TABLE     }
        { ---------------------------------------------------------------------------- }

        IF ( ac_object.batches_enabled ) THEN

            IF ( VALID_FIELD ( "AUTO_COMMIT_EXECUTION", C_COUNT_BATCH ) ) THEN
                ASSIGN AUTO_COMMIT_EXECUTION.'C_COUNT_BATCH'  = ac_object.count_batch
            ENDIF

            IF ( VALID_FIELD ( "AUTO_COMMIT_EXECUTION", C_COUNT_BATCH_ENTRY ) ) THEN
                ASSIGN AUTO_COMMIT_EXECUTION.'C_COUNT_BATCH_ENTRY' = ac_object.count_batch_entry
            ENDIF

        ENDIF

        { ---------------------------------------------------------------------------- }
        { Lot Details optional tables/fields BASE TABLE                                }
        { ---------------------------------------------------------------------------- }

        IF ( ac_object.lot_enabled ) THEN

            IF ( VALID_FIELD ( "AUTO_COMMIT_EXECUTION", C_COUNT_LOT_DETAILS ) ) THEN
                ASSIGN AUTO_COMMIT_EXECUTION.'C_COUNT_LOT_DETAILS' = ac_object.count_lot_details
            ENDIF

            IF ( VALID_FIELD ( "AUTO_COMMIT_EXECUTION", C_COUNT_LOT_RELATION ) ) THEN
                ASSIGN AUTO_COMMIT_EXECUTION.'C_COUNT_LOT_RELATION' = ac_object.count_lot_relation
            ENDIF

        ENDIF

    ELSE

        retval = FALSE
        internal_log_message ( ac_object, ac_object.current_routine:msg.21:" ":status, C_MSG_HIGH )

    ENDIF  { update entry  }

    RETURN ( retval )

ENDROUTINE  { ac_object_action_update_execution }

{******************************************************************************}

ROUTINE ac_object_action_select_destination ( ac_object )

    DECLARE form, a_prompt, b_prompt, a_len, a_msg

    IF VARIABLE_IS_ASSIGNED ( ac_object.cpu_destination ) THEN

        ret_val = TRUE

    ELSE

        ac_object.cpu_destination = EMPTY

        CREATE OBJECT "STD_FORM", form
            form.header = internal_translate_message ( "LIT_AUTO_COMMIT_SELECT_DESTINATION" )
            form.height = 2
            form.width  = 56
            form.column = 20
            form.row    = 10

        a_msg = internal_translate_message ( "LIT_AUTO_COMMIT_DESTINATION_CPU" )
        a_len = STRINGLENGTH ( STRIP ( a_msg ) ) + 3

        PROMPT OBJECT a_prompt ON LINE 1 FROM a_len to form.width - 2
            FORMAT identity
            WITH (VALUE = GLOBAL("AUTO_COMMIT_DEFAULT_DEST"))

            a_prompt.browse_routine = "internal_multi_browse_CPU"
            a_prompt.vgl_library    = "LIT_AUTO_COMMIT"

        PROMPT OBJECT b_prompt ON LINE 2 FROM a_len to form.width - 2
            a_prompt.browse_routine = "internal_multi_browse_CPU"
            a_prompt.vgl_library    = "LIT_AUTO_COMMIT"

        form.add_prompt( a_prompt )
        form.add_display ( a_msg, 1, 1, PROMPT_RENDITION_RAISED )

        form.add_prompt( b_prompt )
        form.add_display ( "Start with", 1, 2, PROMPT_RENDITION_RAISED )

        form.start_prompt()
        form.wait_prompt()
        form.end_prompt()

        IF ( form.get_lastkey() = "EXIT" ) OR ( BLANK ( a_prompt.value ) ) THEN

            ret_val = FALSE

        ELSE

            ac_object.cpu_destination = TO_UPPER(a_prompt.value)
            ret_val                   = TRUE
            start_letter              = TO_UPPER(b_prompt.value)

        ENDIF

    ENDIF  { cpu_destination already set for PDS }

    RETURN ( ret_val )

ENDROUTINE  {  ac_object_action_select_destination }

{******************************************************************************}

ROUTINE ac_object_action_update_destination ( ac_object )

    DECLARE status     ,
                 an_id      ,
                 dest_array ,
                 a_cnt

    ret_val = TRUE

    ac_object.current_routine = "ac_object_action_update_destination "

    IF NOT ( TRANSACTION_IS_WRITE() ) THEN

        START WRITE TRANSACTION C_ACE_LOGFILE_TRANSACTION

    ENDIF

    { ----------------------------------------------------------------------- }
    { Can have multiple CPU destinations, save for each one                   }
    { ----------------------------------------------------------------------- }

    IF ( ac_object.cpu_destination <> EMPTY ) THEN

        ARRAY dest_array

        internal_make_array_from_csv ( ac_object.cpu_destination, dest_array )

        a_cnt = 1

        WHILE ( dest_array[a_cnt] <> EMPTY ) DO

            { -------------------------------------------------------------- }
            { Update the execution table with new values                     }
            { -------------------------------------------------------------- }

            status = SELECT AUTO_COMMIT_DESTINATION.IDENTITY FOR UPDATE
                               WHERE IDENTITY           = ac_object.ach_identity
                               AND   ORDER_NUMBER       = ac_object.ace_order_number
                               AND   DESTINATION_SYSTEM = dest_array[a_cnt]

            IF ( status = EMPTY ) THEN

                an_id = ac_object.ace_full_id : dest_array[a_cnt]

                RESERVE ENTRY AUTO_COMMIT_DESTINATION, an_id, status

                IF status = EMPTY THEN

                    ASSIGN AUTO_COMMIT_DESTINATION.DATE_SUBMITTED = NOW
                    ASSIGN AUTO_COMMIT_DESTINATION.SUBMITTED_BY   = OPERATOR
                    ASSIGN AUTO_COMMIT_DESTINATION.ZIP_FILE_ID    = STRIP ( ac_object.ace_zip_file_id )

                    UPDATE AUTO_COMMIT_DESTINATION, status
                    ret_val = ( status = EMPTY )

                    IF status <> EMPTY THEN

                        ac_object.error_msg = ac_object.current_routine : msg.24 : an_id : status
                        internal_log_message ( ac_object, ac_object.error_msg, C_MSG_FULL )

                    ENDIF

                    internal_log_message ( ac_object, ac_object.current_routine:an_id, C_MSG_LOW )

                ELSE

                    ret_val = FALSE

                ENDIF

            ENDIF  { update entry  }

            a_cnt = a_cnt + 1

        ENDWHILE   { something in destination to save }

    ENDIF  { cpu_destination is not empty }

    { ------------------------------------------- }
    { Save all for whatever added                 }
    { ------------------------------------------- }

    IF ( ret_val ) THEN

        COMMIT

    ELSE

        ROLLBACK
        internal_log_message ( ac_object, ac_object.current_routine:msg_129, C_MSG_FULL )

    ENDIF   { no destinations to save }

    { ----------------------------------------------------- }
    { Let the logfile know what condition is being returned }
    { ----------------------------------------------------- }

    internal_log_message ( ac_object, ac_object.current_routine : ret_val, C_MSG_LOW )

    RETURN ( ret_val )

ENDROUTINE  { ac_object_action_update_destination }

{******************************************************************************}

ROUTINE ac_object_action_write_Reports ( ac_object, VALUE retval )

    DECLARE status

    { -------------------------------------------------------------- }
    { Write all the stuff to all files based upon operating mode     }
    { -------------------------------------------------------------- }

    FILE WRITE ac_object.ace_report,  msg.52                                           , status
    FILE WRITE ac_object.ace_report,  msg.45 : "(" :ac_object.ace_execute_interval: ")", status
    FILE WRITE ac_object.ace_report,  msg.53 : NOW                                     , status
    FILE WRITE ac_object.ace_report,  msg.54 : OPERATOR                                , status
    FILE WRITE ac_object.ace_report,  msg.52                                           , status

    FILE WRITE ac_object.ace_short_report,  msg.52                                           , status
    FILE WRITE ac_object.ace_short_report,  msg.45 : "(" :ac_object.ace_execute_interval: ")", status
    FILE WRITE ac_object.ace_short_report,  msg.53 : NOW                                     , status
    FILE WRITE ac_object.ace_short_report,  msg.54 : OPERATOR                                , status
    FILE WRITE ac_object.ace_short_report,  msg.52                                           , status

    { -------------------------------------------------------------------------------------------------- }
    { The mode / base table determines what data is written to output files                              }
    { -------------------------------------------------------------------------------------------------- }

    IF ( ac_object.pds_mode ) THEN

        FILE WRITE ac_object.ace_report,  msg_83 : ac_object.count_pds_study     , status
        FILE WRITE ac_object.ace_report,  msg_78 : ac_object.count_pds_study_pull, status
        FILE WRITE ac_object.ace_report,  msg_79 : ac_object.count_pds_axis_point, status
        FILE WRITE ac_object.ace_report,  msg_80 : ac_object.count_pds_basetime  , status
        FILE WRITE ac_object.ace_report,  msg_81 : ac_object.count_pds_layer     , status
        FILE WRITE ac_object.ace_report,  msg_82 : ac_object.count_pds_condition , status

        FILE WRITE ac_object.ace_short_report,  msg_83 : ac_object.count_pds_study     , status
        FILE WRITE ac_object.ace_short_report,  msg_78 : ac_object.count_pds_study_pull, status
        FILE WRITE ac_object.ace_short_report,  msg_79 : ac_object.count_pds_axis_point, status
        FILE WRITE ac_object.ace_short_report,  msg_80 : ac_object.count_pds_basetime  , status
        FILE WRITE ac_object.ace_short_report,  msg_81 : ac_object.count_pds_layer     , status
        FILE WRITE ac_object.ace_short_report,  msg_82 : ac_object.count_pds_condition , status

    ELSEIF ( ac_object.batches_enabled ) THEN

        FILE WRITE ac_object.ace_report,  msg_107  : ac_object.count_batch_header, status
        FILE WRITE ac_object.ace_report,  msg_108  : ac_object.count_batch_entry , status

        FILE WRITE ac_object.ace_short_report,  msg_107 : ac_object.count_batch_header, status
        FILE WRITE ac_object.ace_short_report,  msg_108 : ac_object.count_batch_entry , status

    ELSEIF ( ac_object.certificates_enabled ) THEN

        FILE WRITE ac_object.ace_report,  msg_97  : ac_object.count_certificate, status
        FILE WRITE ac_object.ace_report,  msg_98  : ac_object.count_coa_comment, status
        FILE WRITE ac_object.ace_report,  msg_99  : ac_object.count_coa_result , status
        FILE WRITE ac_object.ace_report,  msg_100 : ac_object.count_coa_text   , status

        FILE WRITE ac_object.ace_short_report,  msg_97  : ac_object.count_certificate, status
        FILE WRITE ac_object.ace_short_report,  msg_98  : ac_object.count_coa_comment, status
        FILE WRITE ac_object.ace_short_report,  msg_99  : ac_object.count_coa_result , status
        FILE WRITE ac_object.ace_short_report,  msg_100 : ac_object.count_coa_text   , status

    ELSEIF ( ac_object.mlp_enabled ) THEN

        FILE WRITE ac_object.ace_report,  msg_110 : ac_object.count_mlp_header    , status
        FILE WRITE ac_object.ace_report,  msg_111 : ac_object.count_mlp_schedule  , status
        FILE WRITE ac_object.ace_report,  msg_112 : ac_object.count_mlp_analysis  , status
        FILE WRITE ac_object.ace_report,  msg_113 : ac_object.count_mlp_components, status
        FILE WRITE ac_object.ace_report,  msg_115 : ac_object.count_mlp_values    , status

        FILE WRITE ac_object.ace_short_report,  msg_110 : ac_object.count_mlp_header    , status
        FILE WRITE ac_object.ace_short_report,  msg_111 : ac_object.count_mlp_schedule  , status
        FILE WRITE ac_object.ace_short_report,  msg_112 : ac_object.count_mlp_analysis  , status
        FILE WRITE ac_object.ace_short_report,  msg_113 : ac_object.count_mlp_components, status
        FILE WRITE ac_object.ace_short_report,  msg_115 : ac_object.count_mlp_values    , status

    ELSEIF ( ac_object.analysis_enabled ) THEN

        FILE WRITE ac_object.ace_report,  msg_116 : ac_object.count_versioned_analysis   , status
        FILE WRITE ac_object.ace_report,  msg_117 : ac_object.count_versioned_component  , status
        FILE WRITE ac_object.ace_report,  msg_118 : ac_object.count_v_cl_header          , status
        FILE WRITE ac_object.ace_report,  msg_119 : ac_object.count_v_cl_entry           , status

        FILE WRITE ac_object.ace_short_report,  msg_116 : ac_object.count_versioned_analysis   , status
        FILE WRITE ac_object.ace_short_report,  msg_117 : ac_object.count_versioned_component  , status
        FILE WRITE ac_object.ace_short_report,  msg_118 : ac_object.count_v_cl_header          , status
        FILE WRITE ac_object.ace_short_report,  msg_119 : ac_object.count_v_cl_entry           , status

    ELSEIF ( ac_object.standard_enabled ) THEN

        FILE WRITE ac_object.ace_report,  msg_120 : ac_object.count_standard_versions, status
        FILE WRITE ac_object.ace_report,  msg_121 : ac_object.count_std_conc         , status

        FILE WRITE ac_object.ace_short_report,  msg_120 : ac_object.count_standard_versions, status
        FILE WRITE ac_object.ace_short_report,  msg_121 : ac_object.count_std_conc         , status

    ELSEIF ( ac_object.lot_enabled ) THEN

        FILE WRITE ac_object.ace_report,  msg_109 : ac_object.count_lot_details , status
        FILE WRITE ac_object.ace_report,  msg_122 : ac_object.count_lot_relation, status

        FILE WRITE ac_object.ace_short_report,  msg_109 : ac_object.count_lot_details , status
        FILE WRITE ac_object.ace_short_report,  msg_122 : ac_object.count_lot_relation, status

    ELSEIF ( ac_object.worksheets_enabled ) THEN

        FILE WRITE ac_object.ace_report,  msg_96 : ac_object.count_worksheet, status

        FILE WRITE ac_object.ace_short_report,  msg_96 : ac_object.count_worksheet, status

    ELSEIF ( ac_object.test_schedule_enabled ) THEN

        tmp = PAD ( STRIP ( msg_60 ) :" ": STRIP ( ac_object.ach_base_table ), ".", 33 ) :" ": ac_object.count_base

        FILE WRITE ac_object.ace_report, tmp                                   , status
        FILE WRITE ac_object.ace_report,  msg_125 : ac_object.count_tsched_entry, status

        FILE WRITE ac_object.ace_report, tmp                                         , status
        FILE WRITE ac_object.ace_short_report,  msg_125 : ac_object.count_tsched_entry, status

    ENDIF

    { ---------------------------------------------------------------------------- }
    { Multiple ways these counts are enabled...                                    }
    { ---------------------------------------------------------------------------- }

    IF ( ac_object.jstr_enabled ) THEN

        tmp = PAD ( STRIP ( msg_60 ) :" ": STRIP ( ac_object.ach_base_table ), ".", 33 ) :" ": ac_object.count_base

        FILE WRITE ac_object.ace_report, tmp, status

        IF ( INDEX ( ac_object.ach_base_table, "SAMPLE" ) > 0 ) THEN
            { count is the base count do not repeat }
        ELSE
            FILE WRITE ac_object.ace_report,  msg_75 : ac_object.count_sample  , status
        ENDIF

        FILE WRITE ac_object.ace_report,  msg_76 : ac_object.count_test    , status
        FILE WRITE ac_object.ace_report,  msg_77 : ac_object.count_result  , status

        { ----------------  do same for short report  ---------------------- }

        FILE WRITE ac_object.ace_short_report, tmp, status

        IF ( INDEX ( ac_object.ach_base_table, "SAMPLE" ) > 0 ) THEN
            { count is the base count do not repeat }
        ELSE
            FILE WRITE ac_object.ace_short_report,  msg_75 : ac_object.count_sample , status
        ENDIF

        FILE WRITE ac_object.ace_short_report,  msg_76 : ac_object.count_test   , status
        FILE WRITE ac_object.ace_short_report,  msg_77 : ac_object.count_result , status

        { ------------------   list results only if found in database ------ }

        IF ( ac_object.list_result_enabled ) THEN

            FILE WRITE ac_object.ace_report      ,  msg_93 : ac_object.count_list_result, status
            FILE WRITE ac_object.ace_short_report,  msg_93 : ac_object.count_list_result, status

        ENDIF

    ENDIF   { specific to each type of arcom done }

    { ------------------------------------------------------------------------ }
    { Next set of tables are optional special tables                           }
    { ------------------------------------------------------------------------ }


    IF ( ac_object.disposition_enabled ) THEN

        FILE WRITE ac_object.ace_report,  msg_66 : ac_object.count_disp_header , status
        FILE WRITE ac_object.ace_report,  msg_68 : ac_object.count_disp_comment, status

        FILE WRITE ac_object.ace_short_report,  msg_66 : ac_object.count_disp_header , status
        FILE WRITE ac_object.ace_short_report,  msg_68 : ac_object.count_disp_comment, status

    ENDIF

    { ------------------------------------------------------------------ }
    { LABEL Engine is an optional IFM and common to many modes           }
    { ------------------------------------------------------------------ }

    IF ( ac_object.labels_enabled ) THEN

        FILE WRITE ac_object.ace_report,  msg_94 : ac_object.count_labelprint      , status
        FILE WRITE ac_object.ace_report,  msg_95 : ac_object.count_labelprint_lines, status

        FILE WRITE ac_object.ace_short_report,  msg_94 : ac_object.count_labelprint      , status
        FILE WRITE ac_object.ace_short_report,  msg_95 : ac_object.count_labelprint_lines, status

    ENDIF


    { -------------------------------------------------------------------------------------------------- }
    { The next portion is common to all types of archival (system tables)                                }
    { -------------------------------------------------------------------------------------------------- }

    FILE WRITE ac_object.ace_report,  msg_61 : ac_object.count_audit_data  , status
    FILE WRITE ac_object.ace_report,  msg_62 : ac_object.count_audit_event , status
    FILE WRITE ac_object.ace_report,  msg_63 : ac_object.count_audit_trans , status
    FILE WRITE ac_object.ace_report,  msg_64 : ac_object.count_esig_data   , status
    FILE WRITE ac_object.ace_report,  msg_65 : ac_object.count_esig_event  , status
    FILE WRITE ac_object.ace_report,  msg_69 : ac_object.count_inc_header  , status
    FILE WRITE ac_object.ace_report,  msg_70 : ac_object.count_inc_result  , status

    FILE WRITE ac_object.ace_short_report,  msg_61 : ac_object.count_audit_data  , status
    FILE WRITE ac_object.ace_short_report,  msg_62 : ac_object.count_audit_event , status
    FILE WRITE ac_object.ace_short_report,  msg_63 : ac_object.count_audit_trans , status
    FILE WRITE ac_object.ace_short_report,  msg_64 : ac_object.count_esig_data   , status
    FILE WRITE ac_object.ace_short_report,  msg_65 : ac_object.count_esig_event  , status
    FILE WRITE ac_object.ace_short_report,  msg_69 : ac_object.count_inc_header  , status
    FILE WRITE ac_object.ace_short_report,  msg_70 : ac_object.count_inc_result  , status

    { ------------------------------------------------------------------ }
    { Final messages written to report/logfile                           }
    { ------------------------------------------------------------------ }

    FILE WRITE ac_object.ace_report      ,  msg.52, status
    FILE WRITE ac_object.ace_short_report,  msg.52, status

    RETURN ( retval )

ENDROUTINE  { ac_object_action_write_reports }

{******************************************************************************}

ROUTINE ac_object_action_create_logfile ( ac_object )

    DECLARE status

    ac_object.current_routine = "ac_object_action_create_logfile "
    ret_val                   = TRUE

    IF NOT ( TRANSACTION_IS_WRITE() ) THEN

        START WRITE TRANSACTION C_ACE_LOGFILE_TRANSACTION

    ENDIF

    { -------------------------------------------------------------- }
    { Extend/create the new logfile                                  }
    { -------------------------------------------------------------- }

    FILE EXTEND ac_object.ace_logfile, status

    tmp = ac_object.current_routine:ac_object.ach_identity:ac_object.ace_order_number:" ":NOW

    internal_log_message ( ac_object, tmp, C_MSG_HIGH )

    { -------------------------------------------------------------- }
    { Extend/create the new report (formatted pretty)                }
    { -------------------------------------------------------------- }

    FILE EXTEND ac_object.ace_report, status

    IF ( ac_object.ace_show_short_report ) THEN

        FILE EXTEND ac_object.ace_short_report, status

    ENDIF

    tmp = STRIP(ac_object.ach_identity):"-":STRIP(ac_object.ace_order_number)

    FILE WRITE ac_object.ace_report, msg.18 : tmp                      , status
    FILE WRITE ac_object.ace_report, msg.40 : NOW                      , status
    FILE WRITE ac_object.ace_report, msg.37 : ac_object.ach_description, status
    {Changed by CONSULT-02 according to mail from DKTBG 2012-02-20 12:49
    FILE WRITE ac_object.ace_report, msg.38 : ac_object.ach_modified_on, status
    FILE WRITE ac_object.ace_report, msg.39 : ac_object.ach_modified_by, status
    }
    FILE WRITE ac_object.ace_report, msg.38 : NOW                      , status
    FILE WRITE ac_object.ace_report, msg.39 : OPERATOR                 , status
    FILE WRITE ac_object.ace_report, msg.52                            , status


    IF ac_object.ace_show_short_report THEN

        FILE WRITE ac_object.ace_short_report, msg.18 : tmp                      , status
        FILE WRITE ac_object.ace_short_report, msg.40 : NOW                      , status
        FILE WRITE ac_object.ace_short_report, msg.37 : ac_object.ach_description, status
        {Changed by CONSULT-02 according to mail from DKTBG 2012-02-20 12:49
        FILE WRITE ac_object.ace_report, msg.38 : ac_object.ach_modified_on, status
        FILE WRITE ac_object.ace_report, msg.39 : ac_object.ach_modified_by, status
        }
        FILE WRITE ac_object.ace_report, msg.38 : NOW                      , status
        FILE WRITE ac_object.ace_report, msg.39 : OPERATOR                 , status
        FILE WRITE ac_object.ace_short_report, msg.52                            , status

    ENDIF

    IF ( ac_object.report_only ) THEN

        FILE WRITE ac_object.ace_report, msg_71, status
        FILE WRITE ac_object.ace_report, msg.52, status

        IF ac_object.ace_show_short_report THEN
            FILE WRITE ac_object.ace_short_report, msg_71, status
            FILE WRITE ac_object.ace_short_report, msg.52, status
        ENDIF

        FILE WRITE ac_object.ace_logfile, msg.52, status
        FILE WRITE ac_object.ace_logfile, msg_71, status
        FILE WRITE ac_object.ace_logfile, msg.52, status

    ENDIF

    { -------------------------------------------------------------- }
    { Update the execution table with new values                     }
    { -------------------------------------------------------------- }

    status = SELECT AUTO_COMMIT_EXECUTION.IDENTITY FOR UPDATE
                 WHERE IDENTITY       = ac_object.ach_identity
                 AND   ORDER_NUMBER   = ac_object.ace_order_number

    IF ( status = EMPTY ) THEN

        RESERVE ENTRY AUTO_COMMIT_EXECUTION, ac_object.ace_full_id, status

        IF status = EMPTY THEN

            ASSIGN AUTO_COMMIT_EXECUTION.ARCHIVE_REPORT  = ac_object.ace_report
            ASSIGN AUTO_COMMIT_EXECUTION.ARCHIVE_LOGFILE = ac_object.ace_logfile
            ASSIGN AUTO_COMMIT_EXECUTION.OPERATOR        = OPERATOR
            ASSIGN AUTO_COMMIT_EXECUTION.A_MESSAGE       = ac_object.error_msg
            ASSIGN AUTO_COMMIT_EXECUTION.REPORT_ONLY     = ac_object.report_only

            IF ( GLOBAL ( "MODE" ) = "INTERACTIVE" ) THEN
                ASSIGN AUTO_COMMIT_EXECUTION.LAST_EXECUTE_FOREGROUND = NOW
            ELSE
                ASSIGN AUTO_COMMIT_EXECUTION.LAST_EXECUTE_BACKGROUND = NOW
            ENDIF

        ENDIF

    ELSEIF ( status <> LOCKED ) THEN

        ASSIGN AUTO_COMMIT_EXECUTION.ARCHIVE_REPORT  = ac_object.ace_report
        ASSIGN AUTO_COMMIT_EXECUTION.ARCHIVE_LOGFILE = ac_object.ace_logfile
        ASSIGN AUTO_COMMIT_EXECUTION.OPERATOR        = OPERATOR
        ASSIGN AUTO_COMMIT_EXECUTION.A_MESSAGE       = ac_object.error_msg
        ASSIGN AUTO_COMMIT_EXECUTION.REPORT_ONLY     = ac_object.report_only

        IF ( GLOBAL ( "MODE" ) = "INTERACTIVE" ) THEN
            ASSIGN AUTO_COMMIT_EXECUTION.LAST_EXECUTE_FOREGROUND = NOW
        ELSE
            ASSIGN AUTO_COMMIT_EXECUTION.LAST_EXECUTE_BACKGROUND = NOW
        ENDIF

    ENDIF  { update entry  }

    { ------------------------------------------------------------------------------------------ }
    { Save all now - will have another update with count - tell's us if a crash or invalid setup }
    { ------------------------------------------------------------------------------------------ }

    ac_object.call_trigger ( "before_update_auto_commit_execution", "OPEN" ,  ret_val )

    UPDATE AUTO_COMMIT_EXECUTION, status
    COMMIT

    IF status <> EMPTY THEN

        ac_object.error_msg = msg.24
        internal_log_message ( ac_object, ac_object.current_routine:msg.24:" ":status, C_MSG_FULL )

    ENDIF

    ret_val = STATUS = EMPTY

    { ----------------------------------------------------- }
    { Let the logfile know what condition is being returned }
    { ----------------------------------------------------- }

    internal_log_message ( ac_object, ac_object.current_routine : ret_val, C_MSG_LOW )

    IF ( ret_val ) THEN

        ac_object.create_rpt_files( 1 )

    ENDIF

    RETURN ( ret_val )

ENDROUTINE  { ac_object_action_create_logfile }

{******************************************************************************}

ROUTINE ac_object_action_create_rpt_files ( ac_object, VALUE cycle )

    DECLARE status

    IF ( cycle > 1 ) THEN

        ac_object.ace_report       = ac_object.ace_report : STRIP ( cycle )
        ac_object.ace_short_report = ac_object.ace_report : STRIP ( cycle )

    ENDIF

    { -------------------------------------------------------------- }
    { Extend/create the new report (formatted pretty)                }
    { -------------------------------------------------------------- }

    FILE EXTEND ac_object.ace_report      , status
    FILE EXTEND ac_object.ace_short_report, status

    tmp = STRIP(ac_object.ach_identity):"-":STRIP(ac_object.ace_order_number)

    FILE WRITE ac_object.ace_report, msg.18 : tmp                      , status
    FILE WRITE ac_object.ace_report, msg.40 : NOW                      , status
    FILE WRITE ac_object.ace_report, msg.37 : ac_object.ach_description, status
    FILE WRITE ac_object.ace_report, msg.38 : ac_object.ach_modified_on, status
    FILE WRITE ac_object.ace_report, msg.39 : ac_object.ach_modified_by, status
    FILE WRITE ac_object.ace_report, msg.52                            , status

    FILE WRITE ac_object.ace_short_report, msg.18 : tmp                      , status
    FILE WRITE ac_object.ace_short_report, msg.40 : NOW                      , status
    FILE WRITE ac_object.ace_short_report, msg.37 : ac_object.ach_description, status
    FILE WRITE ac_object.ace_short_report, msg.38 : ac_object.ach_modified_on, status
    FILE WRITE ac_object.ace_short_report, msg.39 : ac_object.ach_modified_by, status
    FILE WRITE ac_object.ace_short_report, msg.52                            , status

    IF ( ac_object.report_only ) THEN

        FILE WRITE ac_object.ace_report, msg_71, status
        FILE WRITE ac_object.ace_report, msg.52, status

        FILE WRITE ac_object.ace_short_report, msg_71, status
        FILE WRITE ac_object.ace_short_report, msg.52, status

        FILE WRITE ac_object.ace_logfile, msg.52, status
        FILE WRITE ac_object.ace_logfile, msg_71, status
        FILE WRITE ac_object.ace_logfile, msg.52, status

    ENDIF

ENDROUTINE  { ac_object_action_create_rpt_files }

{******************************************************************************}

ROUTINE ac_object_action_call_trigger (      ac_object ,
                                       VALUE a_mode    ,
                                       VALUE var1      ,
                                       VALUE var2      )


    ac_object.current_routine = "ac_object_action_call_trigger "
    retval                    = TRUE

    IF ( ac_object.user_library <> EMPTY ) THEN

        IF ( VGL_VALIDATE_ROUTINE ( ac_object.user_library, a_mode ) ) THEN

            internal_log_message ( ac_object, a_mode:" - ":var1:" - ":var2:" - ":msg.13, C_MSG_HIGH )

            CALL_ROUTINE a_mode IN LIBRARY ac_object.user_library
            USING ac_object, var1, var2 RETURNING retval

            IF ( retval = EMPTY ) OR ( VARIABLE_GET_TYPE ( retval ) <> "Boolean" ) THEN

                retval = TRUE
                internal_log_message ( ac_object, ac_object.current_routine:a_mode:msg.14:retval, C_MSG_HIGH )

            ENDIF

        ENDIF  { does the routine in library exist }

    ENDIF   { the base library is not setup }

    { ----------------------------------------------------- }
    { Let the logfile know what condition is being returned }
    { ----------------------------------------------------- }

    ac_object.current_routine = "ac_object_action_call_trigger "   { user could have wrote to this var }
    internal_log_message ( ac_object, ac_object.current_routine : "  *  *  *  *  *  " : a_mode : var1 : var2 : ret_val, C_MSG_LOW )

    RETURN ( var2 )       { **** MUST return this variable *** }

ENDROUTINE   { ac_object_action_call_Trigger }

{******************************************************************************}

ROUTINE ac_object_action_toggle_pds_objects (       ac_object ,
                          VALUE var_mode  )

    { --------------------------------------------------------------------------------------- }
    { Set and reset JOB and PDS object to allow switching between studies and their JSTR data }
    { --------------------------------------------------------------------------------------- }

    ac_object.current_routine = "ac_object_action_toggle_pds_objects "
    ret_val                   = TRUE

    IF var_mode = "JOB_HEADER" THEN

        ac_object.do_decrement_mode  = TRUE
        ac_object.start_processing   = FALSE
        ac_object.rmb_object         = ac_object
        ac_object.pds_mode           = FALSE

        ac_object.ach_base_table     = ac_object.ach_commit_source_prefix : "JOB_HEADER"
        ac_object.ach_commit_view    = ac_object.ach_commit_source_prefix : "JOB_HEADER"

        ac_object.a_table            = ac_object.ach_base_table
        ac_object.cycle_count        = 1

        ARRAY ac_object.a_identity
        ARRAY ac_object.a_field
        ARRAY ac_object.a_select_field
        ARRAY ac_object.ach_field_identity

        ac_object.a_identity_full       = ac_object.base_table_identity
        ac_object.a_identity[1]         = ac_object.base_table_identity
        ac_object.a_field[1]            = "JOB_NAME"
        ac_object.a_select_field[1]     = "JOB_NAME"
        ac_object.ach_field_identity[1] = "JOB_NAME"
        ac_object.ac_id_field_1         = "JOB_NAME"

        { ----------------------------------------------------------- }
        { Init all arrays to the new (job) table                      }
        { ----------------------------------------------------------- }

        ARRAY ac_object.user_tables

        ret_val = ac_object.default_auto_commit_list ()

    ELSEIF ( var_mode = "PDS_STUDY" ) THEN

        ac_object.do_decrement_mode  = FALSE
        ac_object.start_processing   = FALSE
        ac_object.pds_mode           = TRUE

        ac_object.ach_base_table     = ac_object.ach_commit_source_prefix : "PDS_STUDY"
        ac_object.ach_commit_view    = ac_object.save_pds_view

        ac_object.a_table            = "PDS_STUDY"
        ac_object.cycle_count        = 1

        ARRAY ac_object.a_identity
        ARRAY ac_object.a_field
        ARRAY ac_object.a_select_field
        ARRAY ac_object.ach_field_identity

        ac_object.a_identity_full       = EMPTY
        ac_object.a_identity[1]         = EMPTY
        ac_object.a_field[1]            = "IDENTITY"
        ac_object.a_select_field[1]     = "IDENTITY"

        ac_object.ach_field_identity[1] = "IDENTITY"

        ac_object.ac_id_field_1         = ac_object.ach_field_identity[1]

        { ----------------------------------------------------------- }
        { Init all arrays to the new (pds_study) table                }
        { ----------------------------------------------------------- }

        ARRAY ac_object.user_tables

        ret_val = ac_object.default_auto_commit_list ()

    ENDIF

    ac_object.current_routine = "ac_object_action_toggle_pds_objects "
    internal_log_message ( ac_object, ac_object.current_routine : ret_val, C_MSG_LOW )

    RETURN ( ret_val )

ENDROUTINE   { ac_object_action_toggle_pds_objects }

{******************************************************************************}

ROUTINE ac_object_action_select_table ( ac_object )

{DECLARE mlp_id, mlp_ver, entry_code, ec_array
 ARRAY ec_array}

    ac_object.current_routine = "ac_object_action_select_table "
    ret_val                   = TRUE

    { --------------------------------------------------------------- }
    { Select the key table and its key fields                         }
    { --------------------------------------------------------------- }
    IF (ac_object.a_table = "PARM_SETUP_LINK_FIELDS") OR (ac_object.a_table = "PARM_SETUP_VALUES") THEN

    {ac_object.a_identity[1] =   SELECT PARAMETERS_VIEW.primary_key
                    WHERE primary_key = strip (ac_object.a_identity[1] )
                    AND secondary_key = strip(ac_object.a_identity[2] )}
    ac_object.a_identity[1] =   SELECT parm_setup . identity
                                 WHERE identity = strip (ac_object.a_identity[1] )
                                   AND identity_version = strip(ac_object.a_identity[2] )

    ENDIF

    IF ( ac_object.a_field = EMPTY ) OR ( SIZE_OF_ARRAY ( ac_object.a_field ) > C_MAX_IDENTITIES ) THEN

        ret_val                     = FALSE
        ac_object.a_current_select  = "ERROR MAX IDENTITIES or invalid field select setup"
        ac_object.error_msg         = msg.19 : ac_object.a_current_select

        internal_log_message ( ac_object, ac_object.current_routine:ac_object.a_table:msg.19, C_MSG_FULL )

    ELSEIF ( ac_object.a_field[6] <> EMPTY ) THEN

        ac_object.a_current_select = SELECT 'ac_object.a_table'.'ac_object.a_select_field[1]' FOR UPDATE
                                             WHERE 'ac_object.a_field[1]' = ac_object.a_identity[1]
                                             AND   'ac_object.a_field[2]' = ac_object.a_identity[2]
                                             AND   'ac_object.a_field[3]' = ac_object.a_identity[3]
                                             AND   'ac_object.a_field[4]' = ac_object.a_identity[4]
                                             AND   'ac_object.a_field[5]' = ac_object.a_identity[5]
                                             AND   'ac_object.a_field[6]' = ac_object.a_identity[6]
                                             ORDER ON 'ac_object.a_field[1]'

    ELSEIF ( ac_object.a_field[5] <> EMPTY ) THEN

        ac_object.a_current_select = SELECT 'ac_object.a_table'.'ac_object.a_select_field[1]' FOR UPDATE
                                             WHERE 'ac_object.a_field[1]' = ac_object.a_identity[1]
                                             AND   'ac_object.a_field[2]' = ac_object.a_identity[2]
                                             AND   'ac_object.a_field[3]' = ac_object.a_identity[3]
                                             AND   'ac_object.a_field[4]' = ac_object.a_identity[4]
                                             AND   'ac_object.a_field[5]' = ac_object.a_identity[5]
                                             ORDER ON 'ac_object.a_field[1]','ac_object.a_field[2]'

    ELSEIF ( ac_object.a_field[4] <> EMPTY ) THEN

        ac_object.a_current_select = SELECT 'ac_object.a_table'.'ac_object.a_select_field[1]' FOR UPDATE
                                             WHERE 'ac_object.a_field[1]' = ac_object.a_identity[1]
                                             AND   'ac_object.a_field[2]' = ac_object.a_identity[2]
                                             AND   'ac_object.a_field[3]' = ac_object.a_identity[3]
                                             AND   'ac_object.a_field[4]' = ac_object.a_identity[4]
                                             ORDER ON 'ac_object.a_field[1]','ac_object.a_field[2]'

    ELSEIF ( ac_object.a_field[3] <> EMPTY ) THEN

        IF ( INDEX ( ac_object.ach_base_table, "PDS_" ) > 0 ) AND ( ac_object.a_identity[3] = EMPTY ) THEN

            IF ( INDEX ( ac_object.ach_base_table, "PROTO" ) > 0 ) THEN

                ac_object.a_identity[3] = "P"

            ELSE

                ac_object.a_identity[3] = "S"

            ENDIF

        ENDIF  { very special case for matrix type on PDS issues }

        ac_object.a_current_select = SELECT 'ac_object.a_table'.'ac_object.a_select_field[1]' FOR UPDATE
                                             WHERE 'ac_object.a_field[1]' = ac_object.a_identity[1]
                                             AND   'ac_object.a_field[2]' = ac_object.a_identity[2]
                                             AND   'ac_object.a_field[3]' = ac_object.a_identity[3]
                                             ORDER ON 'ac_object.a_field[1]','ac_object.a_field[2]'

    ELSEIF ( ac_object.a_field[2] <> EMPTY ) THEN

        IF ( INDEX ( ac_object.ach_base_table, "PDS_" ) > 0 ) AND ( ac_object.a_identity[2] = EMPTY ) THEN

            IF ( INDEX ( ac_object.ach_base_table, "PROTO" ) > 0 ) THEN

                ac_object.a_identity[2] = "P"

            ELSE

                ac_object.a_identity[2] = "S"

            ENDIF

        ENDIF  { very special case for matrix type on PDS STUDY ONLY issues }

        ac_object.a_current_select = SELECT 'ac_object.a_table'.'ac_object.a_select_field[1]' FOR UPDATE
                                             WHERE 'ac_object.a_field[1]' = ac_object.a_identity[1]
                                             AND   'ac_object.a_field[2]' = ac_object.a_identity[2]
                                             ORDER ON 'ac_object.a_field[1]','ac_object.a_field[2]'

    ELSE

        ac_object.a_current_select = SELECT 'ac_object.a_table'.'ac_object.a_select_field[1]' FOR UPDATE
                                             WHERE 'ac_object.a_field[1]' = ac_object.a_identity[1]
                                             ORDER ON 'ac_object.a_field[1]'

    ENDIF



    { --------------------------------------------------------------- }
    { If we found something, then it has to be committed/desconsigned }
    { --------------------------------------------------------------- }

    IF ( ac_object.a_current_select <> EMPTY ) THEN

        window_set_status(ac_object.a_table:" ":ac_object.a_current_select)

        {UPDATE product_id and product_version for MLP_VALUES where entrycode = mlp_components.entrycode }
        {IF ac_object.a_table = "MLP_COMPONENTS" THEN

            MLP_ID  = ac_object.a_current_select
            MLP_VER = SELECT max_active_mlp_ver . max_version WHERE identity = MLP_ID

            entry_code = SELECT DISTINCT mlp_components.entry_code WHERE product_id = mlp_id AND product_version = mlp_ver
            WHILE entry_code <> EMPTY DO
                ec_array[SIZE_OF_ARRAY(ec_array)+1,1] = entry_code
                ec_array[SIZE_OF_ARRAY(ec_array)  ,2] = mlp_id
                ec_array[SIZE_OF_ARRAY(ec_array)  ,3] = mlp_ver
            NEXT mlp_components
                entry_code = SELECT mlp_components.entry_code
            ENDWHILE

            ec = 1
            WHILE ec <= SIZE_OF_ARRAY(ec_array) DO
                IF ((SELECT mlp_values.product_id WHERE entry_code = ec_array[ec,1]) = EMPTY) THEN
                ENDIF
                IF(STRIP(ec_array[ec,2]) <> SELECT mlp_values.product_id      WHERE entry_code = ec_array[ec,1])
                OR(      ec_array[ec,3]  <> SELECT mlp_values.product_version WHERE entry_code = ec_array[ec,1]) THEN
                    SQL("UPDATE MLP_VALUES SET product_id = '":STRIP(ec_array[ec,2]):"', product_version = '":ec_array[ec,3]:"' WHERE entry_code = '":ec_array[ec,1]:"'")
                ENDIF
                ec = ec + 1
            ENDWHILE
        ENDIF}


        internal_log_message ( ac_object, ac_object.current_routine:ac_object.a_table:ac_object.a_current_select, C_MSG_LOW )

        ret_val = ac_object.commit_table()

        { -------------------------------------------------------------------------------- }
        { The commit table does the next and could come back empty, so go back up the tree }
        { -------------------------------------------------------------------------------- }

        IF ( ret_val ) AND ( ac_object.a_current_select = EMPTY ) THEN

            ARRAY ac_object.a_identity

            ac_object.current_routine  = "ac_object_action_select_table "
            ac_object.a_identity_full  = EMPTY
            ac_object.start_processing = FALSE

            internal_log_message ( ac_object, ac_object.current_routine:ac_object.a_table: "EMPTY", C_MSG_LOW )

            IF ( ac_object.do_decrement_mode ) THEN

                ret_val = ac_object.decrement_current_set()

            ELSEIF ( ac_object.cycle_count < SIZE_OF_ARRAY ( ac_object.user_tables ) ) THEN

                ret_val = ac_object.get_next_entity()   { pds/static mode...      }

            ENDIF                                            { mode does not decrement }

        ENDIF  { retval ok and current select EMPTY }

    ELSE

        internal_log_message ( ac_object, ac_object.current_routine:ac_object.a_table: "EMPTY", C_MSG_LOW )

        ARRAY ac_object.a_identity

        ac_object.a_identity_full = EMPTY
        ret_val                   = ac_object.save_current_set()

        { ----------------------------------------------------------------- }
        { PDS (non-decrement mode) goes on to the next table to get records }
        { ----------------------------------------------------------------- }

        IF  ( ret_val                                                         )
        AND ( NOT ( ac_object.do_decrement_mode )                             )
        AND ( ac_object.cycle_count < SIZE_OF_ARRAY ( ac_object.user_tables ) ) THEN

            ret_val = ac_object.get_next_entity()         { pds/static mode.... }

        ELSEIF ( ac_object.do_decrement_mode ) THEN

            ret_val = ac_object.decrement_current_set()   { PDS when job has cancelled samples or static }

        ENDIF

    ENDIF

    { ----------------------------------------------------- }
    { Let the logfile know what condition is being returned }
    { ----------------------------------------------------- }

    ac_object.current_routine = "ac_object_action_select_table "
    internal_log_message ( ac_object, ac_object.current_routine : ret_val, C_MSG_LOW )

    RETURN ( ret_val )

ENDROUTINE  { ac_object_action_select_table }

{******************************************************************************}

ROUTINE ac_object_action_commit_table ( ac_object )

    DECLARE i

    { --------------------------------------------------------------- }
    { Must be able to do all records and all dependent tables         }
    { --------------------------------------------------------------- }

    ac_object.current_routine = "ac_object_action_commit_table "
    ret_val                   = TRUE

    WHILE ( ( ac_object.a_current_select <> EMPTY ) AND ( ret_val ) ) DO

        IF ( ac_object.a_current_select = LOCKED ) THEN

            ret_val             = FALSE
            ac_object.error_msg = msg.01

            internal_log_message ( ac_object, ac_object.current_routine:ac_object.error_msg, C_MSG_FULL )

        ELSE

            { -------------------------------------------------------- }
            { Get data from current database pointer for save action   }
            { -------------------------------------------------------- }

            ac_object.a_identity_full = ""
            i = 1

            WHILE ( i <= 6 ) DO

                IF ( ac_object.a_select_field[i] <> EMPTY ) THEN

                    ac_object.a_identity[i]   = SELECT 'ac_object.a_table'.'ac_object.a_select_field[i]'
                    ac_object.a_identity_full = ac_object.a_identity_full : ac_object.a_identity[i]

                    tmp = ac_object.current_routine:ac_object.a_table:ac_object.a_identity[i]
                    internal_log_message ( ac_object, tmp , C_MSG_LOW )

                ELSE

                    ac_object.a_identity[i] = EMPTY

                ENDIF

                i = i + 1

            ENDWHILE

            { -------------------------------------------- }
            { Save what was just selected                  }
            { -------------------------------------------- }

            ret_val = ac_object.save_current_set()

            { ----------------------------- }
            { Select the next one           }
            { ----------------------------- }


            NEXT 'ac_object.a_table'
            ac_object.a_current_select = SELECT 'ac_object.a_table'.'ac_object.a_field[1]'

        ENDIF   { locked }

    ENDWHILE   { while not empty and ret_val ok }

    { ----------------------------------------------------- }
    { Let the logfile know what condition is being returned }
    { ----------------------------------------------------- }

    ac_object.current_routine = "ac_object_action_commit_table "
    internal_log_message ( ac_object, ac_object.current_routine : ret_val, C_MSG_LOW )

    RETURN ( ret_val )

ENDROUTINE  { ac_object_action_commit_table }

{******************************************************************************}

ROUTINE ac_object_action_save_current_set ( ac_object )

    ac_object.current_routine                  = "ac_object_action_save_current_set "
    ret_val                                    = TRUE
    ac_object.save_count                       = ac_object.save_count + 1
    ac_object.save_set[ac_object.save_count,1] = ac_object.a_table
    tmp                                        = ac_object.make_destination ( ac_object.a_table )

    IF ( VALID_TABLE ( tmp ) ) THEN

        ac_object.save_set[ac_object.save_count,2] = tmp                         { destination table        }
        ac_object.save_set[ac_object.save_count,3] = ac_object.a_identity_full   { cat of all a_identity    }
        ac_object.save_set[ac_object.save_count,4] = ac_object.a_field           { where a_field_1=         }
        ac_object.save_set[ac_object.save_count,5] = ac_object.a_select_field    { select table.a_select... }
        ac_object.save_set[ac_object.save_count,6] = ac_object.a_identity        { x = select table.a_sel...}
        ac_object.a_destination                    = tmp

        { -------------------------------------------------------------------------- }
        { Save the current master pointer into user_tables (dynamic data)            }
        { -------------------------------------------------------------------------- }

        ac_object.user_tables[ac_object.cycle_count,5] = ac_object.a_identity_full
        ac_object.user_tables[ac_object.cycle_count,6] = ac_object.a_identity
        ac_object.user_tables[ac_object.cycle_count,7] = tmp : ac_object.a_identity_full  { used by decrement }

        { -------------------------------------------------------------------------- }
        { save_set[7...] on are arrays of system table records found for each entity }
        { -------------------------------------------------------------------------- }

        tmp = tmp : ac_object.save_count : ac_object.a_table : ac_object.a_identity_full

        internal_log_message ( ac_object, ac_object.current_routine:tmp, C_MSG_LOW )

        IF ( ac_object.do_decrement_mode ) THEN

            { ----------------------------------------------------- }
            { If we are not at the last table on this rec go to it  }
            { ----------------------------------------------------- }

            IF ( ac_object.cycle_count < ac_object.no_user_tables ) THEN

                IF ( ac_object.a_identity_full <> EMPTY ) THEN
                    ret_val = ac_object.get_next_entity()
                ENDIF

            ENDIF

            { ----------------------------------------------------- }
            { Either we forced to end of cycle or naturally at end  }
            { ----------------------------------------------------- }

            IF ( ret_val ) AND ( ac_object.cycle_count >= ac_object.no_user_tables ) THEN

                ac_object.start_processing = TRUE
                ret_val                    = ac_object.system_consign()
                ac_object.start_processing = FALSE

            ENDIF

        ELSE

            ret_val = ac_object.system_consign()

        ENDIF   { pds_mode is not decrement can have empty tables and no hierarchy }

    ELSE

        { ----------------------------------------------------- }
        { May want this to fail....                             }
        { ----------------------------------------------------- }

        ret_val                   = FALSE
        ac_object.current_routine = "ac_object_action_save_current_set "
        ac_object.error_msg       = msg.27 : ac_object.a_table

        internal_log_message ( ac_object, ac_object.current_routine:ac_object.error_msg, C_MSG_FULL )

    ENDIF

    { ----------------------------------------------------- }
    { Let the logfile know what condition is being returned }
    { ----------------------------------------------------- }

    ac_object.current_routine = "ac_object_action_save_current_set "
    internal_log_message ( ac_object, ac_object.current_routine : ret_val, C_MSG_LOW )

    RETURN ( ret_val )

ENDROUTINE   { ac_object_action_save_current_set }

{******************************************************************************}

ROUTINE ac_object_action_decrement_current_set ( ac_object )

    ac_object.current_routine = "ac_object_action_decrement_current_set "

    IF ( ac_object.cycle_count > 1 ) THEN

        ac_object.cycle_count     = ac_object.cycle_count - 1
        ac_object.a_table         = ac_object.user_tables[ac_object.cycle_count,1]   { come from static  }
        ac_object.a_field         = ac_object.user_tables[ac_object.cycle_count,2]   { ...               }
        ac_object.a_select_field  = ac_object.user_tables[ac_object.cycle_count,3]   { ...               }
        ac_object.a_destination   = ac_object.user_tables[ac_object.cycle_count,4]   { end of static     }
        ac_object.a_identity_full = ac_object.user_tables[ac_object.cycle_count,5]   { key0 cat fields   }
        ac_object.a_identity      = ac_object.user_tables[ac_object.cycle_count,6]   { key0 array fields }

        tmp = ac_object.save_count : ac_object.a_table : ac_object.a_identity_full : ac_object.cycle_count

        internal_log_message ( ac_object, ac_object.current_routine:tmp, C_MSG_LOW )

        IF ( ac_object.a_identity_full <> EMPTY ) AND ( ret_val ) THEN

            ac_object.start_processing = FALSE
            ret_val                    = ac_object.system_consign()

        ENDIF

    ELSE

        ret_val = TRUE
        internal_log_message ( ac_object, ac_object.current_routine : ac_object.cycle_count, C_MSG_LOW )

    ENDIF


    RETURN ( ret_val )

ENDROUTINE   { ac_object_action_decrement_current_set }

{******************************************************************************}

ROUTINE ac_object_action_get_next_entity ( ac_object )

    ac_object.current_routine = "ac_object_action_get_next_entity "
    ret_val                   = TRUE

    internal_log_message ( ac_object, ac_object.current_routine : ac_object.a_table, C_MSG_LOW )

    { --------------------------------------------------------------- }
    { The cycle_count goes up and down for each record in a set       }
    { --------------------------------------------------------------- }

    ac_object.cycle_count     = ac_object.cycle_count + 1
    ac_object.a_table         = ac_object.user_tables[ac_object.cycle_count,1]
    ac_object.a_field         = ac_object.user_tables[ac_object.cycle_count,2]
    ac_object.a_select_field  = ac_object.user_tables[ac_object.cycle_count,3]

    { --------------------------------------------------------------- }
    { PDS Study is special - gets all records from 2 fields off base  }
    { --------------------------------------------------------------- }

    IF ( INDEX ( ac_object.ach_base_table, "PDS_STUDY" ) > 0 )  THEN

        ac_object.a_identity[1] = ac_object.pds_identity

    ELSEIF ( NOT ac_object.do_DECREMENT_MODE ) THEN

        ac_object.set_key0_fields()

    ENDIF

    ret_val = ac_object.select_table()

    { ----------------------------------------------------- }
    { Let the logfile know what condition is being returned }
    { ----------------------------------------------------- }

    ac_object.current_routine = "ac_object_action_get_next_entity "
    internal_log_message ( ac_object, ac_object.current_routine : ret_val, C_MSG_LOW )

    RETURN ( ret_val )

ENDROUTINE  { ac_object_action_get_next_entity }

{******************************************************************************}

ROUTINE ac_object_action_table_special_save (       ac_object ,
                                              VALUE a_table   )

    DECLARE a_id, a_type, a_ndex, a_cnt, a_crit

    ac_object.current_routine = "ac_object_action_table_special_save "

    { ------------------------------------------------------------------------------------------------------- }
    { While reading data for the PDS we have to keep the static data that is referenced to export as well     }
    { ------------------------------------------------------------------------------------------------------- }

    IF ( a_table = "PDS_PROTO" ) THEN

        ac_object.pds_product         = SELECT 'C_PDS_PROTO_TABLE'.PRODUCT
        ac_object.pds_product_version = SELECT 'C_PDS_PROTO_TABLE'.PRODUCT_VERSION
        ac_object.pds_config          = SELECT 'C_PDS_PROTO_TABLE'.DEFAULT_CONFIG

        internal_log_message ( ac_object, ac_object.current_routine : ac_object.pds_product : ac_object.pds_config, C_MSG_LOW )

    ELSEIF ( a_table = "PDS_PROTO_PULL" ) THEN

        a_id = SELECT 'C_PDS_PROTO_PULL_TABLE'.TEST_SCHEDULE

        IF  ( a_id <> EMPTY      )
        AND ( NOT BLANK ( a_id ) )
        AND   NOT ( internal_array_slice ( ac_object.array_test_schedules, a_id, a_ndex ) ) THEN

            a_cnt                                 = SIZE_OF_ARRAY ( ac_object.array_test_schedules ) + 1
            ac_object.array_test_schedules[a_cnt] = a_id

            internal_log_message ( ac_object, ac_object.current_routine : ac_object.a_table : a_cnt : a_id, C_MSG_LOW )

        ENDIF

        a_id = SELECT 'C_PDS_PROTO_PULL_TABLE'.LAYER_FACTOR

        IF  ( a_id <> EMPTY      )
        AND ( NOT BLANK ( a_id ) )
        AND   NOT  ( internal_array_slice ( ac_object.pds_array_l_factor, a_id, a_ndex ) ) THEN

            a_cnt                               = SIZE_OF_ARRAY ( ac_object.pds_array_l_factor ) + 1
            ac_object.pds_array_l_factor[a_cnt] = a_id

            internal_log_message ( ac_object, ac_object.current_routine : ac_object.a_table : a_cnt : a_id, C_MSG_LOW )

        ENDIF

        a_id = SELECT 'C_PDS_PROTO_PULL_TABLE'.TIME_FACTOR

        IF  ( a_id <> EMPTY      )
        AND ( NOT BLANK ( a_id ) )
        AND   NOT  ( internal_array_slice ( ac_object.pds_array_t_factor, a_id, a_ndex ) ) THEN

            a_cnt                               = SIZE_OF_ARRAY ( ac_object.pds_array_t_factor ) + 1
            ac_object.pds_array_t_factor[a_cnt] = a_id

            internal_log_message ( ac_object, ac_object.current_routine : ac_object.a_table : a_cnt : a_id, C_MSG_LOW )

        ENDIF

        a_id = SELECT 'C_PDS_PROTO_PULL_TABLE'.C_FACTOR

        IF  ( a_id <> EMPTY      )
        AND ( NOT BLANK ( a_id ) )
        AND   NOT  ( internal_array_slice ( ac_object.pds_array_c_factor, a_id, a_ndex ) ) THEN

            a_cnt                               = SIZE_OF_ARRAY ( ac_object.pds_array_c_factor ) + 1
            ac_object.pds_array_c_factor[a_cnt] = a_id

            internal_log_message ( ac_object, ac_object.current_routine : ac_object.a_table : a_cnt : a_id, C_MSG_LOW )

        ENDIF

    ELSEIF ( a_table = "TEST_SCHED_ENTRY" ) THEN

        a_id   = SELECT TEST_SCHED_ENTRY.ANALYSIS_ID
        a_type = SELECT TEST_SCHED_ENTRY.IS_ANALYSIS

 {       IF  ( a_id <> EMPTY      )
        AND ( NOT BLANK ( a_id ) )
        AND ( a_type             )
        AND   NOT  ( internal_array_slice ( ac_object.array_analysis, a_id, a_ndex ) ) THEN

            a_cnt                           = SIZE_OF_ARRAY ( ac_object.array_analysis ) + 1
            ac_object.array_analysis[a_cnt] = a_id

            internal_log_message ( ac_object, ac_object.current_routine : ac_object.a_table : a_cnt : a_id, C_MSG_LOW )

        ENDIF}


    ELSEIF ( a_table = "MLP_COMPONENTS" ) THEN

        a_id   = SELECT MLP_COMPONENTS.ANALYSIS_ID

 {       IF  ( a_id <> EMPTY      )
        AND ( NOT BLANK ( a_id ) )
        AND   NOT  ( internal_array_slice ( ac_object.array_analysis, a_id, a_ndex ) ) THEN

            a_cnt                           = SIZE_OF_ARRAY ( ac_object.array_analysis ) + 1
            ac_object.array_analysis[a_cnt] = a_id

            internal_log_message ( ac_object, ac_object.current_routine : ac_object.a_table : a_cnt : a_id, C_MSG_LOW )

        ENDIF}

    ELSEIF ( a_table = "MLP_VALUES" ) THEN

        a_id = SELECT MLP_VALUES.TEXT_PHRASE

        IF  ( a_id <> EMPTY      )
        AND ( NOT BLANK ( a_id ) )
        AND   NOT  ( internal_array_slice ( ac_object.array_limit_phrase, a_id, a_ndex ) ) THEN

            { ---------------------------------------------------------------------- }
            { Limit phrase/entries are records only...                               }
            { ---------------------------------------------------------------------- }

            a_cnt                               = SIZE_OF_ARRAY ( ac_object.array_limit_phrase ) + 1
            ac_object.array_limit_phrase[a_cnt] = a_id

            internal_log_message ( ac_object, ac_object.current_routine : ac_object.a_table : a_cnt : a_id, C_MSG_LOW )

        ENDIF

        a_id = SELECT MLP_VALUES.CALCULATION

        IF  ( a_id <> EMPTY      )
        AND ( NOT BLANK ( a_id ) )
        AND   NOT ( internal_array_slice ( ac_object.array_limit_calc, a_id, a_ndex ) ) THEN

            { ---------------------------------------------------------------------- }
            { Limit calcs are records and files as well...                           }
            { ---------------------------------------------------------------------- }

            a_cnt                             = SIZE_OF_ARRAY ( ac_object.array_limit_calc ) + 1
            ac_object.array_limit_calc[a_cnt] = a_id

            internal_log_message ( ac_object, ac_object.current_routine : ac_object.a_table : a_cnt : a_id, C_MSG_LOW )

        ENDIF

        a_id = SELECT MLP_VALUES.LEVEL_ID

        IF  ( a_id <> EMPTY      )
        AND ( NOT BLANK ( a_id ) )
        AND   NOT ( internal_array_slice ( ac_object.array_mlp_levels, a_id, a_ndex ) ) THEN

            { ---------------------------------------------------------------------- }
            { LEVEL id is static data that needs to tag along                        }
            { ---------------------------------------------------------------------- }

            a_cnt                             = SIZE_OF_ARRAY ( ac_object.array_mlp_levels ) + 1
            ac_object.array_mlp_levels[a_cnt] = a_id

            internal_log_message ( ac_object, ac_object.current_routine : ac_object.a_table : a_cnt : a_id, C_MSG_LOW )

        ENDIF



{ELSEIF ( a_table = "parm_setup_link_fields" ) THEN
flash_message (a_table,true)
        a_id = SELECT parameters_view.identity

            IF  ( a_id <> EMPTY      )
            AND ( NOT BLANK ( a_id ) )
            AND   NOT ( internal_array_slice ( ac_object.array_param_link, a_id, a_ndex ) ) THEN}

                { ---------------------------------------------------------------------- }
                { LEVEL id is static data that needs to tag along                        }
                { ---------------------------------------------------------------------- }

                {a_cnt                             = SIZE_OF_ARRAY ( ac_object.array_param_link ) + 1
                ac_object.array_mlp_levels[a_cnt] = a_id

                internal_log_message ( ac_object, ac_object.current_routine : ac_object.a_table : a_cnt : a_id, C_MSG_LOW )

        ENDIF}

    ELSEIF ( a_table = "VERSIONED_COMPONENT" ) THEN

        a_id   = SELECT VERSIONED_COMPONENT.CALCULATION
        a_type = SELECT VERSIONED_COMPONENT.RESULT_TYPE
        a_crit = SELECT VERSIONED_COMPONENT.ENTITY_CRITERIA

        IF ( a_type = "K" ) THEN

            { ---------------------------------------------------------------------- }
            { Calculations are records but also files to get...                      }
            { ---------------------------------------------------------------------- }

            IF  ( a_id <> EMPTY      )
            AND ( NOT BLANK ( a_id ) )
            AND   NOT  ( internal_array_slice ( ac_object.array_limit_calc, a_id, a_ndex ) ) THEN

                a_cnt                             = SIZE_OF_ARRAY ( ac_object.array_limit_calc ) + 1
                ac_object.array_limit_calc[a_cnt] = a_id

                internal_log_message ( ac_object, ac_object.current_routine : ac_object.a_table : a_cnt : a_id, C_MSG_LOW )

            ENDIF

        ELSEIF ( a_type = "O" ) THEN

            { ---------------------------------------------------------------------- }
            { Phrases from analyses - and get phrase entries...                      }
            { ---------------------------------------------------------------------- }

            IF  ( a_id <> EMPTY      )
            AND ( NOT BLANK ( a_id ) )
            AND   NOT  ( internal_array_slice ( ac_object.array_text_phrase, a_id, a_ndex ) ) THEN

                a_cnt                              = SIZE_OF_ARRAY ( ac_object.array_text_phrase ) + 1
                ac_object.array_text_phrase[a_cnt] = a_id

                internal_log_message ( ac_object, ac_object.current_routine : ac_object.a_table : a_cnt : a_id, C_MSG_LOW )

            ENDIF


        ELSEIF ( a_type = "L" ) THEN

            { ---------------------------------------------------------------------- }
            { List results are also special records and files to get...              }
            { ---------------------------------------------------------------------- }

            IF  ( a_id <> EMPTY      )
            AND ( NOT BLANK ( a_id ) )
            AND   NOT  ( internal_array_slice ( ac_object.array_list_result, a_id, a_ndex ) ) THEN

                a_cnt                              = SIZE_OF_ARRAY ( ac_object.array_list_result ) + 1
                ac_object.array_list_result[a_cnt] = a_id

                internal_log_message ( ac_object, ac_object.current_routine : ac_object.a_table : a_cnt : a_id, C_MSG_LOW )

            ENDIF

        ELSEIF ( a_type = "E" ) THEN

            { ---------------------------------------------------------------------- }
            { Phrases from analyses - and get phrase entries...                      }
            { ---------------------------------------------------------------------- }

            IF  ( a_id <> EMPTY      )
            AND ( NOT BLANK ( a_id ) )
            AND   NOT  ( internal_array_slice ( ac_object.array_criteria_saved, a_id, a_ndex ) ) THEN

                a_cnt                                = SIZE_OF_ARRAY ( ac_object.array_criteria_saved ) + 1
                ac_object.array_criteria_saved[a_cnt] = a_crit

                internal_log_message ( ac_object, ac_object.current_routine : ac_object.a_table : a_cnt : a_id, C_MSG_LOW )

            ENDIF


        ENDIF

    ENDIF   { if.else for all special tables }

ENDROUTINE  {   ac_object_action_table_special_save }

{******************************************************************************}

ROUTINE ac_object_action_system_consign ( ac_object )

    DECLARE status, a_dest

    ac_object.current_routine = "ac_object_action_system_consign "
    a_dest                    = ac_object.ach_commit_destination

    { -------------------------------------------------------------- }
    { Set the value for the archive_logfile/report on table if there }
    { -------------------------------------------------------------- }

    IF ( ac_object.a_table = ac_object.ach_base_table ) THEN

        ret_val = ac_object.set_master_fields()

    ENDIF

    { --------------------------------------------------------------- }
    { Some tables reference other records and these are saved later   }
    { --------------------------------------------------------------- }


    ac_object.table_special_save( ac_object.a_table )


    { -------------------------------------------------------------- }
    { Set all values on the dependant (system) tables                }
    { -------------------------------------------------------------- }

    IF NOT ( ac_object.do_archive_csv ) THEN

        ret_val = ret_val AND ( ac_object.commit_system_tables() )

    ENDIF


    { -------------------------------------------------------------- }
    { If error return and do not continue, else report or consign    }
    { -------------------------------------------------------------- }

    IF ( NOT ret_val ) THEN

        ac_object.current_routine = "ac_object_action_system_consign "
        ac_object.error_msg       = msg.28
        ret_val                   = FALSE

        internal_log_message ( ac_object, ac_object.current_routine:ac_object.a_table:ac_object.error_msg, C_MSG_FULL )

    ELSEIF ( ac_object.a_identity_full <> EMPTY ) THEN

        IF     ( INDEX ( ac_object.a_table, "JOB_HEADER" ) > 0 ) THEN

            ac_object.count_pds_job = ac_object.count_pds_job + 1

        ELSEIF ( INDEX ( ac_object.a_table, "SAMPLE" ) > 0 ) THEN

            ac_object.count_sample = ac_object.count_sample + 1

        ELSEIF ( INDEX ( ac_object.a_table, "TEST_SCHED_ENTRY" ) > 0 ) THEN

            ac_object.count_tsched_entry = ac_object.count_tsched_entry + 1

        ELSEIF ( INDEX ( ac_object.a_table, "TEST" ) > 0 ) THEN

            ac_object.count_test = ac_object.count_test + 1

        ELSEIF ( INDEX ( ac_object.a_table, "RESULT" ) > 0 ) THEN

            ac_object.count_result = ac_object.count_result + 1

        ELSEIF ( INDEX ( ac_object.a_table, "LIST_RESULT" ) > 0 ) THEN

            ac_object.count_list_result = ac_object.count_list_result + 1

        ELSEIF ( INDEX ( ac_object.a_table, "WORKSHEET" ) > 0 ) THEN

            ac_object.count_worksheet = ac_object.count_worksheet + 1

        ELSEIF ( INDEX ( ac_object.a_table, "STUDY_PULL" ) > 0 ) THEN

            ac_object.count_pds_study_pull = ac_object.count_pds_study_pull + 1

        ELSEIF ( INDEX ( ac_object.a_table, "PROTO_PULL" ) > 0 ) THEN

            ac_object.count_pds_study_pull = ac_object.count_pds_study_pull + 1

        ELSEIF ( INDEX ( ac_object.a_table, "AXIS_POINT" ) > 0 ) THEN

            ac_object.count_pds_axis_point = ac_object.count_pds_axis_point + 1

        ELSEIF ( INDEX ( ac_object.a_table, "CONDITION" ) > 0 ) THEN

            ac_object.count_pds_condition = ac_object.count_pds_condition + 1

        ELSEIF ( INDEX ( ac_object.a_table, "LAYER" ) > 0 ) THEN

            ac_object.count_pds_layer = ac_object.count_pds_layer + 1

        ELSEIF ( INDEX ( ac_object.a_table, "BASETIME" ) > 0 ) THEN

            ac_object.count_pds_basetime = ac_object.count_pds_basetime + 1

        ELSEIF ( INDEX ( ac_object.a_table, "BATCH_HEADER" ) > 0 ) THEN

            ac_object.count_batch_header = ac_object.count_batch_header + 1

        ELSEIF ( INDEX ( ac_object.a_table, "BATCH_ENTRY" ) > 0 ) THEN

            ac_object.count_batch_entry = ac_object.count_batch_entry + 1

        ELSEIF ( INDEX ( ac_object.a_table, "CERTIFICATE" ) > 0 ) THEN

            ac_object.count_certificate = ac_object.count_certificate + 1

        ELSEIF ( INDEX ( ac_object.a_table, "CERTIFICATE_COMMENTS" ) > 0 ) THEN

            ac_object.count_coa_comment = ac_object.count_coa_comment + 1

        ELSEIF ( INDEX ( ac_object.a_table, "CERTIFICATE_RESULTS" ) > 0 ) THEN

            ac_object.count_coa_result = ac_object.count_coa_result + 1

        ELSEIF ( INDEX ( ac_object.a_table, "CERTIFICATE_TEXT" ) > 0 ) THEN

            ac_object.count_coa_text = ac_object.count_coa_text + 1

        ELSEIF ( INDEX ( ac_object.a_table, "LOT_DETAILS" ) > 0 ) THEN

            ac_object.count_lot_details = ac_object.count_lot_details + 1

        ELSEIF ( INDEX ( ac_object.a_table, "LOT_RELATION" ) > 0 ) THEN

            ac_object.count_lot_relation = ac_object.count_lot_relation + 1

        ELSEIF ( INDEX ( ac_object.a_table, "MLP_HEADER" ) > 0 ) THEN

            ac_object.count_mlp_header = ac_object.count_mlp_header + 1

        ELSEIF ( INDEX ( ac_object.a_table, "MLP_ANALYSIS" ) > 0 ) THEN

            ac_object.count_mlp_analysis = ac_object.count_mlp_analysis + 1

        ELSEIF ( INDEX ( ac_object.a_table, "MLP_SCHEDULE" ) > 0 ) THEN

            ac_object.count_mlp_schedule = ac_object.count_mlp_schedule + 1

        ELSEIF ( INDEX ( ac_object.a_table, "MLP_COMPONENTS" ) > 0 ) THEN

            ac_object.count_mlp_components = ac_object.count_mlp_components + 1

        ELSEIF ( INDEX ( ac_object.a_table, "MLP_VALUES" ) > 0 ) THEN

            ac_object.count_mlp_values = ac_object.count_mlp_values + 1

        ELSEIF ( INDEX ( ac_object.a_table, "VERSIONED_ANALYSIS" ) > 0 ) THEN

            ac_object.count_versioned_analysis = ac_object.count_versioned_analysis + 1

        ELSEIF ( INDEX ( ac_object.a_table, "VERSIONED_COMPONENT" ) > 0 ) THEN

            ac_object.count_versioned_component = ac_object.count_versioned_component + 1

        ELSEIF ( INDEX ( ac_object.a_table, "VERSIONED_C_L_HEADER" ) > 0 ) THEN

            ac_object.count_v_cl_header = ac_object.count_v_cl_header + 1

        ELSEIF ( INDEX ( ac_object.a_table, "VERSIONED_C_L_ENTRY" ) > 0 ) THEN

            ac_object.count_v_cl_entry = ac_object.count_v_cl_entry + 1

        ELSEIF ( INDEX ( ac_object.a_table, "STANDARD_VERSIONS" ) > 0 ) THEN

            ac_object.count_standard_versions = ac_object.count_standard_versions + 1

        ELSEIF ( INDEX ( ac_object.a_table, "STANDARD_CONCENTRATION" ) > 0 ) THEN

            ac_object.count_std_conc = ac_object.count_std_conc + 1

        ELSE

            { ---------------------------------------------------- }
            { Trigger updates the counts                           }
            { ---------------------------------------------------- }

        ENDIF

        { --------------------------------------------------------- }
        { If not a report then do the duty...                       }
        { --------------------------------------------------------- }

        IF NOT ( ac_object.report_only ) AND ( ret_val ) THEN

            { --------------------------------------------------------- }
            { set fields/movement on the actual table we are working on }
            { --------------------------------------------------------- }

            IF     ( ac_object.do_REMOVEFLAG ) THEN

                ASSIGN 'ac_object.a_table'.REMOVEFLAG = TRUE
                UPDATE 'ac_object.a_table', status

            ELSEIF ( ac_object.do_DELETE ) THEN

                ac_object.delete_archive ( ac_object.a_table, status )

            ELSEIF ( ac_object.do_archive_csv ) THEN

                ac_object.delete_archive ( ac_object.a_table, status )

            ELSEIF ( ac_object.do_consign ) THEN

                CONSIGN 'ac_object.a_table' TO a_dest, status

            ELSE

                DECONSIGN 'ac_object.a_table', status

            ENDIF

            ret_val = status = EMPTY

            IF NOT ret_val THEN

                ac_object.error_msg       = msg.25 : status
                ac_object.current_routine = "ac_object_action_system_consign "

                internal_log_message ( ac_object, ac_object.current_routine :ac_object.error_msg, C_MSG_FULL )

            ENDIF

        ENDIF

        ac_object.current_routine = "ac_object_action_system_consign "

        internal_log_message ( ac_object, ac_object.current_routine :ac_object.a_table: tmp, C_MSG_LOW )

        { ------------------------------------------------------- }
        { Each record is written to report TABLE Key0             }
        { ------------------------------------------------------- }

        IF ( ac_object.a_identity_full <> EMPTY ) THEN

            tmp  = PAD ( ac_object.a_table, " ", C_MAX_TABLE_LENGTH + 5 ) : ac_object.a_identity_full

            FILE WRITE ac_object.ace_report, tmp, status

            internal_log_message ( ac_object, ac_object.current_routine:tmp, C_MSG_LOW )

        ENDIF  { current rec is empty so do not report it }

    ENDIF

    { ----------------------------------------------------- }
    { Let the logfile know what condition is being returned }
    { ----------------------------------------------------- }

    ac_object.current_routine = "ac_object_action_system_consign "
    internal_log_message ( ac_object, ac_object.current_routine : ret_val, C_MSG_LOW )

    RETURN ( ret_val )

ENDROUTINE  { ac_object_action_system_consign }

{******************************************************************************}

ROUTINE ac_object_action_set_master_fields ( ac_object )

    ac_object.current_routine = "ac_object_action_set_master_fields "
    ret_val                   = TRUE

    IF ( NOT ac_object.report_only ) AND ( NOT ac_object.do_archive_csv ) THEN

        IF ( VALID_FIELD ( ac_object.a_table, C_CONSIGN_ID ) ) AND
           ( VALID_FIELD ( ac_object.a_table, C_CONSIGN_SEQUENCE ) ) AND
           ( VALID_FIELD ( ac_object.a_table, C_CONSIGN_DATE ) ) THEN

        ASSIGN 'ac_object.a_table'.'C_CONSIGN_ID'       = ac_object.ach_identity
        ASSIGN 'ac_object.a_table'.'C_CONSIGN_SEQUENCE' = ac_object.ace_order_number
        ASSIGN 'ac_object.a_table'.'C_CONSIGN_DATE'     = ac_object.ac_start_time

        UPDATE 'ac_object.a_table', tmp

        IF tmp <> EMPTY THEN

            ret_val             = FALSE
            ac_object.error_msg = ac_object.a_table:msg.29:tmp

            internal_log_message ( ac_object, ac_object.current_routine:ac_object.a_table:ac_object.error_msg, C_MSG_FULL )

        ENDIF

        FILE WRITE ac_object.ace_report, msg.52, tmp     { - - - - separator line written }

        ENDIF
    ENDIF

    RETURN ( ret_val )

ENDROUTINE   { ac_object_action_set_master_fields }

{******************************************************************************}

ROUTINE ac_object_action_set_table_no_prefix ( ac_object )

    DECLARE prefix_len, table_len

    prefix_len                  = STRINGLENGTH ( ac_object.ach_commit_source_prefix       )
    table_len                   = STRINGLENGTH ( ac_object.a_table                        )
    ac_object.a_table_no_prefix = RIGHTSTRING ( ac_object.a_table, table_len - prefix_len )

ENDROUTINE  { ac_object_action_set_table_no_prefix }

{******************************************************************************}

ROUTINE ac_object_action_delete_archive ( ac_object, VALUE a_table, status )

    { ------------------------------------------------------------- }
    { If data is saved to CSV do this before deletion               }
    { ------------------------------------------------------------- }

    status = EMPTY

    IF ( ac_object.del_archive_save_csv ) OR ( ac_object.do_archive_csv ) THEN

        ac_object.archive_csv_data ( a_table )

    ENDIF

    { ------------------------------------------------------------- }
    { Can have arc only (pds_proto) and not delete....              }
    { ------------------------------------------------------------- }

    IF ( ac_object.do_DELETE ) THEN

        DELETE 'a_table', status

    ENDIF

    RETURN ( status )

ENDROUTINE  { ac_object_action_delete_archive }

{******************************************************************************}

ROUTINE ac_object_action_archive_csv_data (      ac_object,
                                           VALUE a_table  )


    DECLARE ndex        ,
                 a_array     ,
                 a_key0_array,
                 field_array ,
                 a_cnt       ,
                 a_line

    { -------------------------------------------------------- }
    { Set all the arrays for the csv file to write             }
    { -------------------------------------------------------- }

    ac_object.archive_csv_set_fields ( a_table, ndex )

    { -------------------------------------------------------- }
    { Only the current record already selected is saved        }
    { -------------------------------------------------------- }

    ARRAY a_array
    ARRAY a_key0_array
    ARRAY field_array

    field_array = ac_object.ace_csv_field_names[ndex,2]      { field names for "ndex" table }
    a_cnt       = 1

    WHILE ( field_array[a_cnt] <> EMPTY ) DO

        a_array[a_cnt] = SELECT 'a_table'.'field_array[a_cnt]'
        a_cnt          = a_cnt + 1

    ENDWHILE

    { ------------------------------------------------------- }
    { Save the current full id in case we get files attached  }
    { ------------------------------------------------------- }

    GET_TABLE_DETAILS 'a_table', "KEY0_FIELD", a_key0_array

    ac_object.a_identity_full = ""
    a_cnt                     = 1

    WHILE ( a_key0_array[a_cnt] <> EMPTY ) DO

        a_key0_array[a_cnt]       = SELECT 'a_table'.'a_key0_array[a_cnt]'
        ac_object.a_identity_full = ac_object.a_identity_full : a_key0_array[a_cnt]
        a_cnt                     = a_cnt + 1

    ENDWHILE

    { -------------------------------------------------------- }
    { Convert array into a csv line & append to data array     }
    { -------------------------------------------------------- }

    ac_object.archive_csv_write_array ( a_array, TRUE, a_line )


    { -------------------------------------------------------- }
    { Append line to the array of every rec saved by table     }
    { -------------------------------------------------------- }

    IF NOT ( internal_array_2_slice ( ac_object.ace_archive_set, a_table, ndex, 1 ) ) THEN

        ARRAY a_array
    ELSE
        a_array = ac_object.ace_archive_set[ndex,2]
    ENDIF

    { -------------------------------------------------------- }
    { Save all of these for output at the end of all data      }
    { -------------------------------------------------------- }

    a_cnt                             = SIZE_OF_ARRAY ( a_array ) + 1
    a_array[a_cnt]                    = a_line
    ac_object.ace_archive_set[ndex,1] = a_table
    ac_object.ace_archive_set[ndex,2] = a_array
    ac_object.ace_archive_set[ndex,3] = a_key0_array
    ac_object.ace_archive_set[ndex,4] = ac_object.a_identity_full

    RETURN ( TRUE )

ENDROUTINE   { ac_object_action_archive_csv_data }

{******************************************************************************}

ROUTINE ac_object_action_archive_csv_set_fields (       ac_object ,
                                                  VALUE a_table   ,
                                                        ndex      )


    DECLARE full_array   ,
                 dest_count   ,
                 max_count    ,
                 a_size       ,
                 cnt          ,
                 field_array  ,
                 size_array

    IF NOT ( internal_array_2_slice ( ac_object.ace_csv_field_names, a_table, ndex, 1 ) ) THEN

        ac_object.archive_csv_set_filename( a_table, ndex )

        { --------------------------------------------------------------------- }
        { Get field names for this table                                        }
        { --------------------------------------------------------------------- }

        ARRAY full_array  ARRAYSIZE ( 0 , 2 )
        ARRAY field_array
        ARRAY size_array

        GET_UNORDERED_FIELD_NAMES ( a_table , full_array )

        cnt        = 0
        dest_count = 0
        max_count  = SIZE_OF_ARRAY ( full_array )

        WHILE ( cnt < max_count ) DO

            cnt = cnt + 1

            IF NOT ( full_array [ cnt, 2 ] ) THEN

                GET_FIELD_DETAILS 'a_table'.'full_array[cnt,1]', "FIELD_SIZE", a_size

                dest_count                 = dest_count + 1
                field_array [ dest_count ] = full_array [ cnt,1 ]
                size_array  [ dest_count ] = a_size

            ENDIF

        ENDWHILE

        ac_object.archive_csv_write_array ( field_array, FALSE, dest_count)
        ac_object.archive_csv_write_array ( size_array , FALSE, max_count )

        ac_object.ace_csv_field_names[ndex,1] = a_table             { each table "type" (result, test etc          }
        ac_object.ace_csv_field_names[ndex,2] = field_array         { array of table's names for each table csv'ed }
        ac_object.ace_csv_field_names[ndex,3] = dest_count          { string of catenated field names for csv      }
        ac_object.ace_csv_field_names[ndex,4] = max_count           { string of catenated field sizes for csv      }

    ENDIF   { fields are already set, just adding data in that case }

ENDROUTINE    { ac_object_action_archive_csv_set_fields }

{******************************************************************************}

ROUTINE ac_object_action_archive_csv_set_filename (       ac_object ,
                                                    VALUE a_table   ,
                                                    VALUE ndex      )


    DECLARE a_semi,
                 a_dir

    a_dir  = LOGICAL ( "SMP$ARCHIVEFILES" )
    a_semi = INDEX ( a_dir, ";" )

    IF ( a_semi > 0 ) THEN

        a_dir = LEFTSTRING ( a_dir, a_semi - 1 )

    ENDIF

    ac_object.ace_csv_file_id [ ndex ] = a_dir : "\" : STRIP ( ac_object.ace_file_id ) :"\": STRIP ( a_table ) : ".csv"

ENDROUTINE  {  ac_object_action_archive_csv_set_filename }

{******************************************************************************}

ROUTINE ac_object_action_archive_csv_write_array (       ac_object      ,
                                                    array_to_write ,
                                              VALUE delimit        ,
                                                         line_to_write  )


    DECLARE count         ,
                 max_arr_elem

    line_to_write = ""
    max_arr_elem  = SIZE_OF_ARRAY ( array_to_write )
    count         = 0

    WHILE ( count < max_arr_elem ) DO

        IF ( count > 0 ) THEN
            line_to_write = line_to_write : ","
        ENDIF

        count = count + 1

        IF ( array_to_write [ count ] = NULL ) THEN

            line_to_write = line_to_write : C_NULL_VALUE

        ELSE

            IF ( delimit ) THEN
                line_to_write = line_to_write : C_DELIMIT_CHAR
            ENDIF

            IF ( variable_get_type ( array_to_write[ count ] ) = "Text" ) AND
               ( LEFTSTRING ( array_to_write[ count ], 1 ) = " " )        THEN

                array_to_write [ count ] = LEFTSTRING ( array_to_write [ count ], LENGTH ( array_to_write [ count ] ) )

            ELSE

                array_to_write[ count ]  = STRIP( array_to_write[ count ] )

            ENDIF

            line_to_write = line_to_write : ac_object.archive_csv_double_quote ( STRING ( array_to_write [ count ] ) )

            IF ( delimit ) THEN

                line_to_write = line_to_write : C_DELIMIT_CHAR

            ENDIF

        ENDIF

    ENDWHILE

ENDROUTINE   { ac_object_action_archive_csv_write_array }

{******************************************************************************}

ROUTINE ac_object_action_archive_csv_double_quote (       ac_object,
                                                    VALUE st_val   )


    DECLARE copy     ,
                 part     ,
                 result   ,
                 delim_idx

    copy      = st_val
    result    = ""
    delim_idx = INDEX ( copy, C_DELIMIT_CHAR )

    WHILE ( delim_idx > 0 ) DO

        part      = LEFTSTRING ( copy, delim_idx )
        result    = result : part : C_DELIMIT_CHAR
        copy      = copy # part
        delim_idx = INDEX ( copy, C_DELIMIT_CHAR )

    ENDWHILE

    result = result : copy

    RETURN ( result )

ENDROUTINE   { ac_object_action_archive_csv_double_quote }

{******************************************************************************}

ROUTINE ac_object_action_archive_csv_all_files ( ac_object )

    DECLARE a_count,
                 a_table,
                 status

    status  = EMPTY
    a_count = 1
    a_table = ac_object.ace_csv_field_names[a_count,1]

    WHILE ( ac_object.ace_csv_file_id[a_count] <> EMPTY ) AND ( status = EMPTY ) DO

        ac_object.archive_csv_1_file ( a_table, status, a_count )

        a_count = a_count + 1
        a_table = ac_object.ace_csv_field_names[a_count,1]

    ENDWHILE

    { ----------------------------------------------------------- }
    { All the files are written - issue error if write was bad    }
    { ----------------------------------------------------------- }

    IF ( status <> EMPTY ) THEN

        ret_val                   = FALSE
        ac_object.current_routine = "ac_object_action_archive_csv_all_files"
        ac_object.error_msg       = msg_128 :" ": status

        internal_log_message ( ac_object, ac_object.current_routine:ac_object.error_msg, C_MSG_FULL )

    ENDIF

    RETURN  ( ret_val )

ENDROUTINE   {  ac_object_action_archive_csv_all_files }

{******************************************************************************}

ROUTINE ac_object_action_archive_csv_1_file (       ac_object,
                                              VALUE a_table  ,
                                                    status   ,
                                                    count    )

    DECLARE org_format   ,
                 num_recs     ,
                 a_array      ,
                 a_cnt

    ARRAY a_array

    a_array    = ac_object.ace_archive_set[count,2]
    num_recs   = SIZE_OF_ARRAY ( a_array )
    org_format = GLOBAL ( "FORMAT_TEXT" )

    SET FORMAT      C_REAL_FORMAT
    SET DATE FORMAT C_DATE_FORMAT

    IF ( NOT FILE EXISTS ( ac_object.ace_csv_file_id[count] ) ) THEN

        FILE CREATE ac_object.ace_csv_file_id[count]         , status
        FILE WRITE  ac_object.ace_csv_file_id[count], a_table, status

        IF ( status = EMPTY ) THEN

            FILE WRITE ac_object.ace_csv_file_id[count], ac_object.ace_csv_field_names[count,3], status

            IF ( status = EMPTY ) THEN

                FILE WRITE ac_object.ace_csv_file_id[count], ac_object.ace_csv_field_names[count,4], status
                FILE WRITE ac_object.ace_csv_file_id[count], num_recs                              , status

            ENDIF

        ENDIF

    ELSE

        FILE EXTEND ac_object.ace_csv_file_id[count], status

    ENDIF

    { -------------------------------------------------------- }
    { Now only the data set by caller criteria is output       }
    { -------------------------------------------------------- }

    IF ( status = EMPTY ) THEN

        a_cnt = 1

        WHILE ( a_array[a_cnt] <> EMPTY ) AND ( status = EMPTY ) DO

            FILE WRITE ac_object.ace_csv_file_id[count], a_array[a_cnt], status

            a_cnt = a_cnt + 1

        ENDWHILE

        IF ( status = EMPTY ) THEN

            FILE CLOSE ac_object.ace_csv_file_id[count], status

        ENDIF

    ENDIF  { error on file extend }

    RESTORE DATE FORMAT

    SET FORMAT org_format

    RETURN ( status = EMPTY )

ENDROUTINE   { ac_object_action_archive_csv_1_file }

{******************************************************************************}

ROUTINE ac_object_action_archive_csv_zip_files ( ac_object )

    DECLARE regfile  ,
                 logfile  ,
                 a_key    ,
                 a_exe_dir,
                 a_log_dir,
                 a_arc_dir,
                 a_zip_id ,
                 a_semi   ,
                 a_spawn  ,
                 status

    retval    = FALSE
    a_exe_dir = LOGICAL ( "SMP$PROGRAMS" )
    a_semi    = INDEX ( a_exe_dir, ";" )

    IF ( a_semi > 0 ) THEN

        a_exe_dir = LEFTSTRING ( a_exe_dir, a_semi - 1 )

    ENDIF

    a_log_dir = LOGICAL ( "SMP$TEXTREPORTS" )
    a_semi    = INDEX ( a_log_dir, ";" )

    IF ( a_semi > 0 ) THEN

        a_log_dir = LEFTSTRING ( a_log_dir, a_semi - 1 )

    ENDIF

    a_arc_dir = LOGICAL ( "SMP$ARCHIVEFILES" )
    a_semi    = INDEX ( a_arc_dir, ";" )

    IF ( a_semi > 0 ) THEN

        a_arc_dir = LEFTSTRING ( a_arc_dir, a_semi - 1 )

    ENDIF

    a_zip_id = a_exe_dir :"\": C_7ZA_EXE

    IF ( FILE EXISTS ( a_zip_id ) ) THEN

        regfile   = STRIP ( ac_object.ace_file_id )
        logfile   = STRIP ( regfile )
        regfile   = a_log_dir : "\" : regfile : "_zip.BAT"

        FILE DELETE regfile, status
        FILE CREATE regfile, status
        FILE EXTEND regfile, status

        IF status = EMPTY THEN

{**************************************************************************************************************
            fm( "a_zip_id              ":a_zip_id               :ASCII(10):
                "a_arc_dir             ":a_arc_dir              :ASCII(10):
                "ac_object.ace_file_id ":ac_object.ace_file_id  )

            a_key = ASCII(34) : a_zip_id                 : ASCII(34) : C_7ZIP_SELF_EXTRACT_CMD:
                    ASCII(34) : self.install_set_zip_id  : ASCII(34) : " "                    :
                    ASCII(34) : self.install_set_kit_dir : "\*"      : ASCII(34) 
***************************************************************************************************************}
            a_key = ASCII(34) : a_zip_id                                                                       : ASCII(34) : C_7ZIP_ZIP_CREATE_CMD :
                    ASCII(34) : a_arc_dir : "\" : ac_object.ace_file_id : "\" : ac_object.ace_file_id : ".arc" : ASCII(34) : " "                   :
                    ASCII(34) : a_arc_dir : "\" : ac_object.ace_file_id : "\*" : ASCII(34)

            FILE WRITE regfile, a_key , status
            FILE WRITE regfile, "exit", status

{BLOCK Created by DKTBG to modify exported csv files}
            DECLARE file_array, f, filepath, set_field, set_value
            IF status = EMPTY THEN
                filepath = a_arc_dir : "\" : ac_object.ace_file_id : "\*.csv"
                FILE FIND filepath, file_array, status

                f = 1
                WHILE f <= SIZE_OF_ARRAY(file_array) DO
                filepath = file_array[f]
                    IF INDEX(TOUPPER(file_array[f]), "MLP_HEADER.CSV") > 0 THEN
                        set_field = "APPROVAL_STATUS"
                        set_value = GLOBAL("AUTO_COMMIT_EXPORT_STATUS")
                        fix_exported_files (filepath, set_field, set_value)
                    ELSEIF INDEX(TOUPPER(file_array[f]), "VERSIONED_ANALYSIS.CSV") > 0 THEN
                        set_field = "APPROVAL_STATUS"
                        set_value = GLOBAL("AUTO_COMMIT_EXPORT_STATUS")
                        fix_exported_files (filepath, set_field, set_value)
                    ELSEIF INDEX(TOUPPER(file_array[f]), "MLP_SCHEDULE.CSV") > 0 THEN
                        set_field = "MLP_VERSION"
                        set_value = "0"
                        fix_exported_files (filepath, set_field, set_value)
                    ENDIF
                    f = f + 1
                ENDWHILE
{BLOCK End}
                FILE CLOSE regfile, status

                IF status = EMPTY THEN

                    a_spawn = ASCII(34): regfile :ASCII(34) : " >> " : ASCII(34): STRIP (a_log_dir:"\":log_file):"_zip.log" :ASCII(34) : " 2>&1"

                    SPAWN "cmd /E:ON /D /A /C " : a_spawn, status QUIETLY

                    retval = ( status = EMPTY )

                ENDIF  { file close }

            ENDIF  { file write }

        ENDIF  { file extend }

    ELSE

        retval = TRUE

    ENDIF   { file to zip with must exist }

    RETURN ( retval )

ENDROUTINE   { ac_object_action_archive_csv_zip_files }

{******************************************************************************}

ROUTINE ac_object_action_archive_csv_update_export ( ac_object )

    RETURN {Avoid listing items as exported}

    DECLARE status, a_cnt, a_cnt2, a_key0, the_key, a_len, dest_array

    {
        ac_object.ace_archive_set[ndex,1] = a_table
        ac_object.ace_archive_set[ndex,2] = a_array
        ac_object.ace_archive_set[ndex,3] = a_key0_array
        ac_object.ace_archive_set[ndex,4] = a_identity_full
    }

    GET_FIELD_DETAILS AUTO_COMMIT_EXPORTED.DESTINATION_CPU, "FIELD_SIZE", a_len

    { --------------------------------------------------------------------- }
    { For each CPU record is sent to save this so it cannot be sent twice   }
    { --------------------------------------------------------------------- }

    IF ( ac_object.cpu_destination <> EMPTY ) THEN

        ARRAY dest_array

        internal_make_array_from_csv ( ac_object.cpu_destination, dest_array )

        a_cnt2 = 1

        WHILE ( dest_array[a_cnt2] <> EMPTY ) DO

            a_cnt  = 1
            a_key0 = ac_object.ace_full_id : PAD ( dest_array[a_cnt2], " ", a_len )

            { --------------------------------------------------------------------- }
            { For all records sent to this CPU save each one                        }
            { --------------------------------------------------------------------- }

            WHILE ( ac_object.array_base_identities[a_cnt] <> EMPTY ) DO

                the_key                  = a_key0 : PACKED_DECIMAL ( a_cnt )
                ac_object.ach_base_table = STRIP ( ac_object.ach_base_table )

                START WRITE TRANSACTION "AUTO_COMMIT_EXPORTED":ac_object.ace_full_id

                RESERVE ENTRY AUTO_COMMIT_EXPORTED, the_key, status

                IF ( status = EMPTY ) THEN

                    IF     ( ac_object.ach_base_table = "MLP_HEADER"        ) THEN
                        ASSIGN AUTO_COMMIT_EXPORTED.MLP_ID      = LEFTSTRING  ( ac_object.array_base_identities[a_cnt], ac_object.G_LEN_MLP )
                        ASSIGN AUTO_COMMIT_EXPORTED.MLP_VERSION = RIGHTSTRING ( ac_object.array_base_identities[a_cnt], 10 )

                    ELSEIF ( ac_object.ach_base_table = "TEST_SCHED_HEADER" ) THEN

                        ASSIGN AUTO_COMMIT_EXPORTED.TEST_SCHEDULE = ac_object.array_base_identities[a_cnt]

                    ELSEIF ( ac_object.ach_base_table = "PDS_PROTO" ) THEN

                        ASSIGN AUTO_COMMIT_EXPORTED.PDS_PROTO   = LEFTSTRING  ( ac_object.array_base_identities[a_cnt], ac_object.G_LEN_PDS )
                        ASSIGN AUTO_COMMIT_EXPORTED.PDS_VERSION = RIGHTSTRING ( ac_object.array_base_identities[a_cnt], 10 )

                    ELSEIF ( ac_object.ach_base_table = "VERSIONED_ANALYSIS" ) THEN

                        ASSIGN AUTO_COMMIT_EXPORTED.ANALYSIS         = LEFTSTRING  ( ac_object.array_base_identities[a_cnt], ac_object.G_LEN_ANAL )
                        ASSIGN AUTO_COMMIT_EXPORTED.ANALYSIS_VERSION = RIGHTSTRING ( ac_object.array_base_identities[a_cnt], 10 )

                    ELSE

                        { some other table not supported.... }

                    ENDIF

                    { --------------------------------------------------------------- }
                    { Makes reporting and followup easier to do....                   }
                    { --------------------------------------------------------------- }

                    ASSIGN AUTO_COMMIT_EXPORTED.TABLE_ID              = ac_object.ach_base_table
                    ASSIGN AUTO_COMMIT_EXPORTED.IDENTITY_FULL         = ac_object.array_base_identities[a_cnt]
                    ASSIGN AUTO_COMMIT_EXPORTED.DATE_EXPORTED         = NOW
                    ASSIGN AUTO_COMMIT_EXPORTED.EXPORTED_BY           = OPERATOR
                    ASSIGN AUTO_COMMIT_EXPORTED.DESTINATION_FULL_LIST = ac_object.cpu_destination

                    UPDATE AUTO_COMMIT_EXPORTED, status
                    COMMIT

                ELSE

                    ROLLBACK

                ENDIF   { reserve status }

                a_cnt = a_cnt + 1

            ENDWHILE

            a_cnt2 = a_cnt2 + 1

        ENDWHILE   { dest_array is an array from cpu_destination }

    ENDIF   { destination is set }

ENDROUTINE  {  ac_object_action_archive_csv_update_export}

{******************************************************************************}

ROUTINE ac_object_action_commit_system_tables ( ac_object )

    DECLARE i        ,
                a_dest   ,
                a_full_id

    ac_object.current_routine = "ac_object_action_commit_system_tables "
    ret_val                   = TRUE
    a_dest                    =  ac_object.a_destination
    a_full_id                 =  ac_object.a_identity_full

    { ----------------------------------------------------- }
    { Set table without prefix so system can find old data  }
    { ----------------------------------------------------- }

    ac_object.set_table_no_prefix()

    internal_log_message ( ac_object, ac_object.current_routine:" ":ac_object.a_table_no_prefix:a_dest:a_full_id, C_MSG_LOW )

    { ----------------------------------------------------- }
    { We do all the system table for the current table      }
    { ----------------------------------------------------- }

    i = 1

    WHILE ( ac_object.system_tables[i,1] <> EMPTY ) AND ( ret_val ) AND ( a_full_id <> EMPTY ) DO

        internal_log_message ( ac_object, ac_object.current_routine:ac_object.a_table:ac_object.system_tables[i,1], C_MSG_LOW )

        { ----------------------------------------------------------------- }
        { Each type of system table has a special way of commit             }
        { ----------------------------------------------------------------- }

        IF  ( INDEX ( ac_object.system_tables[i,1], "AUDIT_DATA"        ) > 0 )
        OR  ( INDEX ( ac_object.system_tables[i,1], "AUDIT_EVENT"       ) > 0 )
        OR  ( INDEX ( ac_object.system_tables[i,1], "AUDIT_TRANSACTION" ) > 0 ) THEN

            IF  ( INDEX ( ac_object.system_tables[i,1], "AUDIT_DATA" ) > 0 ) THEN

                ret_val = ac_object.consign_audits( TRUE )

            ENDIF

        ELSEIF ( INDEX ( ac_object.system_tables[i,1], "INCIDENTS"             ) > 0 )
        OR     ( INDEX ( ac_object.system_tables[i,1], "INC_CHECKLIST_RESULTS" ) > 0 ) THEN

            IF ( INDEX ( ac_object.system_tables[i,1], "INCIDENTS" ) > 0 ) THEN

                ret_val = ac_object.consign_incidents()

            ENDIF

        ELSEIF ( INDEX ( ac_object.system_tables[i,1], "ESIG_DATA"  ) > 0 )
        OR     ( INDEX ( ac_object.system_tables[i,1], "ESIG_EVENT" ) > 0 ) THEN

            IF ( INDEX ( ac_object.system_tables[i,1], "ESIG_DATA" ) > 0 ) THEN

                ret_val = ac_object.consign_esigs( TRUE )

            ENDIF

        ELSEIF ( INDEX ( ac_object.system_tables[i,1], "INSPECTORS" ) > 0 ) THEN

            ret_val = ac_object.consign_inspectors()

        ELSEIF ( INDEX ( ac_object.system_tables[i,1], "WORKSHEET" ) > 0 ) THEN

            IF ( INDEX ( ac_object.a_table, "SAMPLE" ) > 0 ) THEN

                ac_object.worksheets_enabled = TRUE
                ret_val                      = ac_object.consign_worksheets()

            ELSE

                ARRAY ac_object.save_set[ac_object.save_count,11]

            ENDIF

        ELSEIF ( INDEX ( ac_object.system_tables[i,1], "LABELPRINT" ) > 0 ) THEN

            IF ( INDEX ( ac_object.a_table, "TEST"              ) > 0 )
                           OR ( INDEX ( ac_object.a_table, "SAMPLE"            ) > 0 )
                           OR ( INDEX ( ac_object.a_table, "STANDARD_VERSIONS" ) > 0 )
                           OR ( INDEX ( ac_object.a_table, "LABELPRINT"        ) > 0 ) THEN     { LIT 12-Dec-2010 START/END  }

                ac_object.labels_enabled = TRUE
                ret_val                  = ac_object.consign_labels()

            ELSE

                ARRAY ac_object.save_set[ac_object.save_count,12]

            ENDIF


        ELSEIF ( INDEX ( ac_object.system_tables[i,1], "DISPOSITION_HEADER" ) > 0 )
        OR     ( INDEX ( ac_object.system_tables[i,1], "DISP_COMMENTS"      ) > 0 ) THEN

            IF  ( INDEX ( ac_object.system_tables[i,1], "DISPOSITION_HEADER" ) > 0 )
            AND ( INDEX ( ac_object.a_table           , "JOB_HEADER"         ) > 0 ) THEN

                ac_object.disposition_enabled = TRUE
                ret_val                       = ac_object.consign_disposition()

            ENDIF

        ELSEIF ( ac_object.call_trigger ( "system_table_commit_custom_table",  a_full_id, retval ) ) THEN


            ARRAY ac_object.save_set[ac_object.save_count,13]

            internal_log_message ( ac_object, "** USER_TRIGGER **":ac_object.current_routine :ac_object.a_table:ac_object.system_tables[i,1], C_MSG_LOW )

        ELSE

            ac_object.error_msg = msg.15
            internal_log_message ( ac_object, "*****":ac_object.current_routine :ac_object.a_table:ac_object.system_tables[i,1]:ac_object.error_msg, C_MSG_LOW )

        ENDIF

        i = i + 1

    ENDWHILE   { all system tables are cross checked }

    { ----------------------------------------------------- }
    { Let the logfile know what condition is being returned }
    { ----------------------------------------------------- }

    ac_object.current_routine = "ac_object_action_commit_system_tables "
    internal_log_message ( ac_object, ac_object.current_routine : ac_object.a_table: ret_val, C_MSG_LOW )


    RETURN ( ret_val )

ENDROUTINE  { ac_object_action_commit_system_tables }

{******************************************************************************}

ROUTINE ac_object_action_consign_audits (       ac_object   ,
                                          VALUE normal_mode )

    DECLARE a_e_table   ,
                a_t_table   ,
                a_d_table   ,
                event_id    ,
                data_id     ,
                trans_id    ,
                a_trans     ,
                a_dest      ,
                status      ,
        an_array    ,
                i, i2

    ac_object.current_routine = "ac_object_action_consign_audits "
    ret_val                   = TRUE
    i                         = 0
    a_dest                    = ac_object.ach_commit_destination

    ARRAY an_array

    { -------------------------------------------------- }
    { Prefix blank on active set on all others           }
    { -------------------------------------------------- }

    a_e_table = STRIP ( ac_object.ach_commit_source_prefix ) : "AUDIT_EVENT"
    a_d_table = STRIP ( ac_object.ach_commit_source_prefix ) : "AUDIT_DATA"
    a_t_table = STRIP ( ac_object.ach_commit_source_prefix ) : "AUDIT_TRANSACTION"

    IF ac_object.ach_commit_source_prefix = "ARCHIVE_" THEN
        a_t_table = STRIP ( ac_object.ach_commit_source_prefix ) : "AUDIT_TRANS"
    ENDIF

    { ----------------------------------------------------------------------------------------------- }
    { Select all audit and child audit tables                                                         }
    { ----------------------------------------------------------------------------------------------- }

    IF normal_mode THEN

        event_id = SELECT 'a_e_table'.event FOR UPDATE
                   WHERE (   record_key0 = ac_object.a_identity_full )
                             AND   ( ( table_name  = ac_object.a_table_no_prefix ) OR ( table_name = a_e_table ) )
                             ORDER ON event

        internal_log_message ( ac_object, ac_object.current_routine:ac_object.a_table:ac_object.a_identity_full:event_id, C_MSG_LOW )

    ELSE

        event_id = SELECT 'a_e_table'.event FOR UPDATE
                   WHERE ( record_key0 = ac_object.a_special_id    )
                             AND   ( table_name  = ac_object.a_special_table )
                             ORDER ON event

        internal_log_message ( ac_object, "** AUDIT **":ac_object.current_routine:ac_object.a_table:ac_object.a_special_id:event_id, C_MSG_LOW )

    ENDIF


    WHILE ( ( event_id <> EMPTY ) AND ( ret_val ) ) DO

        IF ( event_id = LOCKED ) THEN

            ac_object.error_msg = msg.26 : a_e_table : ac_object.a_table_no_prefix : ac_object.a_identity_full
            ret_val             = FALSE
            internal_log_message ( ac_object, ac_object.current_routine:ac_object.error_msg, C_MSG_FULL )

        ELSE

            i2  = 1
            i   = i + 1

            ac_object.count_audit_event = ac_object.count_audit_event + 1

            tmp = "  ":a_e_table:" ": STRIP ( event_id ) :" ":
                              STRIP ( SELECT 'a_e_table'.table_name   ) :" ":
                              STRIP ( SELECT 'a_e_table'.record_key0  ) :" ":
                              STRIP ( SELECT 'a_e_table'.event_action ) :" ":
                              STRIP ( SELECT 'a_e_table'.event_reason )


            FILE WRITE ac_object.ace_report, tmp, status


            an_array[i,i2] = tmp
            a_trans        = SELECT 'a_e_table'.transaction  { used later to get transactions }

            internal_log_message ( ac_object, ac_object.current_routine:tmp, C_MSG_LOW )

            { -------------------------------------------------- }
            { move the audit_data (multiple values) for event    }
            { -------------------------------------------------- }

            data_id = SELECT 'a_d_table'.data FOR UPDATE WHERE event = event_id
                                  ORDER ON data

            WHILE ( ( data_id <> EMPTY ) AND ( ret_val ) ) DO

                IF ( data_id = LOCKED ) THEN

                    ac_object.error_msg = msg.26 : a_d_table : event_id
                    ret_val             = FALSE
                    internal_log_message ( ac_object, ac_object.current_routine:ac_object.error_msg, C_MSG_FULL )

                ELSE

                    i2  = i2 + 1

                    ac_object.count_audit_data = ac_object.count_audit_data + 1

                    tmp = "   ":a_d_table:" ":STRIP ( data_id ):" ":
                                      STRIP ( SELECT 'a_d_table'.data_reason  ) :" ":
                                      STRIP ( SELECT 'a_d_table'.field        ) :" ":
                                      STRIP ( SELECT 'a_d_table'.value_before ) :" ":
                                      STRIP ( SELECT 'a_d_table'.value_after  )

                    an_array[i,i2] = tmp

                    FILE WRITE ac_object.ace_report, tmp, status

                    internal_log_message ( ac_object, ac_object.current_routine:tmp, C_MSG_LOW )

                    IF NOT ( ac_object.report_only ) THEN

                        IF ( ac_object.do_DELETE ) THEN

                            ac_object.delete_archive ( a_d_table, status )

                        ELSEIF ( ac_object.do_archive_csv ) THEN

                            ac_object.delete_archive ( a_d_table, status )

                        ELSEIF ( ac_object.do_consign ) THEN

                            CONSIGN 'a_d_table' TO a_dest, status

                        ELSEIF ( ac_object.do_REMOVEFLAG ) THEN

                            { don't do anything just yet... }

                            status = EMPTY

                        ELSE

                            DECONSIGN 'a_d_table', status

                        ENDIF

                        IF status <> EMPTY THEN

                            ret_val             = FALSE
                            ac_object.error_msg = msg.25:tmp:status
                            internal_log_message ( ac_object, ac_object.current_routine:ac_object.error_msg, C_MSG_FULL )

                        ENDIF

                    ENDIF

                ENDIF

                NEXT 'a_d_table'
                data_id = SELECT 'a_d_table'.data

            ENDWHILE

            { -------------------------------------------------- }
            { move the audit_transaction table 1-1 table         }
            { -------------------------------------------------- }

            trans_id = SELECT 'a_t_table'.transaction FOR UPDATE WHERE transaction = a_trans

            IF ( ( trans_id <> EMPTY ) AND ( ret_val ) ) THEN

                IF ( trans_id = LOCKED ) THEN

                    ac_object.error_msg = msg.26 : a_t_table : a_trans
                    ret_val             = FALSE
                    internal_log_message ( ac_object, ac_object.current_routine:ac_object.error_msg, C_MSG_FULL )

                ELSEIF ( ac_object.audit_trans_last_1 ( trans_id ) ) THEN

                    i2  = i2 + 1

                    ac_object.count_audit_trans = ac_object.count_audit_trans + 1

                    tmp = "  ":a_t_table:" ": STRIP(a_trans):" ":
                                      STRIP ( SELECT 'a_t_table'.system_pid       ) :" ":
                                      STRIP ( SELECT 'a_t_table'.user_id          ) :" ":
                                      STRIP ( SELECT 'a_t_table'.transaction_name ) :" ":
                                      STRIP ( SELECT 'a_t_table'.transaction_date ) :" ":
                                      STRIP ( SELECT 'a_t_table'.session_id       )

                    an_array[i,i2] = tmp

                    FILE WRITE ac_object.ace_report, tmp, status

                    internal_log_message ( ac_object, ac_object.current_routine:tmp, C_MSG_LOW )

                    IF NOT ( ac_object.report_only ) THEN

                        IF ( ac_object.do_DELETE ) THEN

                            ac_object.delete_archive ( a_t_table, status )

                        ELSEIF ( ac_object.do_archive_csv ) THEN

                            ac_object.delete_archive ( a_t_table, status )

                        ELSEIF ( ac_object.do_consign ) THEN

                            CONSIGN 'a_t_table' TO a_dest, status

                        ELSEIF ( ac_object.do_REMOVEFLAG ) THEN

                            { don't do anything just yet... }

                            status = EMPTY

                        ELSE

                            DECONSIGN 'a_t_table', status

                        ENDIF

                        IF status <> EMPTY THEN

                            ret_val             = FALSE
                            ac_object.error_msg = msg.25:a_t_table:tmp:status
                            internal_log_message ( ac_object, ac_object.current_routine:ac_object.error_msg, C_MSG_FULL )

                        ENDIF

                    ENDIF

                ELSE

                    i2  = i2 + 1
                    tmp = " * REFERENCED * ":a_t_table:" ":  STRIP ( a_trans  ) :" ":
                                      STRIP ( SELECT 'a_t_table'.system_pid       ) :" ":
                                      STRIP ( SELECT 'a_t_table'.user_id          ) :" ":
                                      STRIP ( SELECT 'a_t_table'.transaction_name ) :" ":
                                      STRIP ( SELECT 'a_t_table'.transaction_date ) :" ":
                                      STRIP ( SELECT 'a_t_table'.session_id       )

                    FILE WRITE ac_object.ace_report, tmp, status
                    internal_log_message ( ac_object, ac_object.current_routine:tmp, C_MSG_FULL )

                ENDIF   { not locked but is referenced }

            ENDIF  { trans_id not empty and status is empty }

            { ------------------------------------------ }
            { Consign audit event                        }
            { ------------------------------------------ }
            ac_object.count_audit_event = ac_object.count_audit_event + 1

            IF NOT ( ac_object.report_only ) AND ( ret_val ) THEN

                IF ( ac_object.do_DELETE ) THEN

                    ac_object.delete_archive ( a_e_table, status )

                ELSEIF ( ac_object.do_archive_csv ) THEN

                    ac_object.delete_archive ( a_e_table, status )

                ELSEIF ( ac_object.do_consign ) THEN

                    CONSIGN 'a_e_table' TO a_dest, status

                ELSEIF ( ac_object.do_REMOVEFLAG ) THEN

                    { don't do anything just yet... }

                    status = EMPTY

                ELSE

                    DECONSIGN 'a_e_table', status

                ENDIF

                IF status <> EMPTY THEN

                    ret_val             = FALSE
                    ac_object.error_msg = msg.25:a_e_table:status
                    internal_log_message ( ac_object, ac_object.current_routine:ac_object.error_msg, C_MSG_FULL )

                ENDIF


            ENDIF

            NEXT 'a_e_table'
            event_id = SELECT 'a_e_table'.event

        ENDIF  { record locked }

    ENDWHILE   { event_id not empty and status empty }

    { --------------------------- }
    { Save data for the report    }
    { --------------------------- }

    ac_object.save_set[ac_object.save_count,7] = an_array

    { ----------------------------------------------------- }
    { Let the logfile know what condition is being returned }
    { ----------------------------------------------------- }

    ac_object.current_routine = "ac_object_action_consign_audits "
    internal_log_message ( ac_object, ac_object.current_routine:ac_object.a_table, C_MSG_LOW )

    RETURN ( ret_val )

ENDROUTINE   {  ac_object_action_consign_audits }

{******************************************************************************}

ROUTINE ac_object_action_consign_esigs (       ac_object   ,
                                         VALUE normal_mode )

    DECLARE esig_data_table  ,
                esig_event_table ,
                event_id         ,
                a_event          ,
                a_dest           ,
                status           ,
        an_array         ,
                i, i2

    ac_object.current_routine = "ac_object_action_consign_esigs "
    ret_val                   = TRUE
    i                         = 0
    a_dest                    = ac_object.ach_commit_destination

    ARRAY an_array

    { -------------------------------------------------- }
    { Prefix blank on active others are not              }
    { -------------------------------------------------- }

    esig_data_table  = STRIP ( ac_object.ach_commit_source_prefix ) : "ESIG_DATA"
    esig_event_table = STRIP ( ac_object.ach_commit_source_prefix ) : "ESIG_EVENT"

    { -------------------------------------------------- }
    { Select all esig and esig child (1-1) records       }
    { -------------------------------------------------- }

    IF normal_mode THEN

        event_id = SELECT 'esig_data_table'.esig_event_id FOR UPDATE
                       WHERE (  record_key0 = ac_object.a_identity_full )
                       AND   ( ( table_name = ac_object.a_table_no_prefix )
                       OR      ( table_name = esig_data_table             ) )
                           ORDER ON esig_data_id, esig_event_id

        internal_log_message ( ac_object, ac_object.current_routine:ac_object.a_table:ac_object.a_identity_full:event_id, C_MSG_LOW )

    ELSE

        event_id = SELECT 'esig_data_table'.esig_event_id FOR UPDATE
                       WHERE ( record_key0 = ac_object.a_special_id   )
                       AND   ( table_name = ac_object.a_special_table )
                           ORDER ON esig_data_id, esig_event_id

        internal_log_message ( ac_object, ac_object.current_routine:ac_object.a_special_table:ac_object.a_special_id:event_id, C_MSG_LOW )

    ENDIF

    { -------------------------------------------------- }

    WHILE ( ( event_id <> EMPTY ) AND ( ret_val ) ) DO

        IF ( event_id = LOCKED ) THEN

            ac_object.error_msg = msg.26:esig_data_table:ac_object.a_table:ac_object.a_identity_full
            ret_val             = FALSE
            internal_log_message ( ac_object, ac_object.current_routine:ac_object.error_msg, C_MSG_FULL )

        ELSE

            i2  = 1
            i   = i + 1

            ac_object.count_esig_data = ac_object.count_esig_data + 1

            tmp = "  ":esig_data_table:" ":STRIP ( event_id ):" ":
                              STRIP ( SELECT 'esig_data_table'.table_name    ) :" ":
                              STRIP ( SELECT 'esig_data_table'.record_key0   )

            an_array[i,i2] = tmp

            FILE WRITE ac_object.ace_report, tmp, status

            internal_log_message ( ac_object, ac_object.current_routine:tmp, C_MSG_LOW )

            { -------------------------------------------------- }
            { move the esig_event table 1-1 table                }
            { -------------------------------------------------- }

            a_event = SELECT 'esig_event_table'.esig_event_id FOR UPDATE WHERE esig_event_id = event_id
                                  ORDER ON esig_event_id

            IF ( ( a_event <> EMPTY ) AND ( ret_val ) ) THEN

                IF ( a_event = LOCKED ) THEN

                    ac_object.error_msg = msg.26 : esig_event_table : event_id
                    ret_val             = FALSE
                    internal_log_message ( ac_object, ac_object.current_routine:ac_object.error_msg, C_MSG_FULL )

                ELSEIF ( ac_object.esig_event_last_1 ( event_id ) ) THEN

                    i2  = i2 + 1

                    ac_object.count_esig_event = ac_object.count_esig_event + 1

                    tmp = "  ":esig_event_table:" ":STRIP ( a_event ) :" ":
                                      STRIP ( SELECT 'esig_event_table'.operator          ) :" ":
                                      STRIP ( SELECT 'esig_event_table'.fullname          ) :" ":
                                      STRIP ( SELECT 'esig_event_table'.server_date       ) :" ":
                                      STRIP ( SELECT 'esig_event_table'.menu_number       ) :" ":
                                      STRIP ( SELECT 'esig_event_table'.esig_reason       ) :" ":
                                      STRIP ( SELECT 'esig_event_table'.signature_comment )

                    an_array[i,i2] = tmp

                    FILE WRITE ac_object.ace_report, tmp, status

                    internal_log_message ( ac_object, ac_object.current_routine:tmp, C_MSG_LOW )

                    IF NOT ( ac_object.report_only ) THEN

                        IF ( ac_object.do_DELETE ) THEN

                            ac_object.delete_archive ( esig_event_table, status )

                        ELSEIF ( ac_object.do_archive_csv ) THEN

                            ac_object.delete_archive ( esig_event_table, status )

                        ELSEIF ( ac_object.do_consign ) THEN

                            CONSIGN 'esig_event_table' TO a_dest, status

                        ELSEIF ( ac_object.do_REMOVEFLAG ) THEN

                            { don't do anything just yet... }

                            status = EMPTY

                        ELSE

                            DECONSIGN 'esig_event_table', status

                        ENDIF

                        IF status <> EMPTY THEN

                            ret_val             = FALSE
                            ac_object.error_msg = msg.25:tmp:status
                            internal_log_message ( ac_object, ac_object.current_routine:ac_object.error_msg, C_MSG_FULL )

                        ENDIF
                    ENDIF

                ELSE

                    i2  = i2 + 1
                    tmp = " * REFERENCED *  ":esig_event_table:" ":  STRIP ( a_event         ) :" ":
                                      STRIP ( SELECT 'esig_event_table'.operator          ) :" ":
                                      STRIP ( SELECT 'esig_event_table'.fullname          ) :" ":
                                      STRIP ( SELECT 'esig_event_table'.server_date       ) :" ":
                                      STRIP ( SELECT 'esig_event_table'.menu_number       ) :" ":
                                      STRIP ( SELECT 'esig_event_table'.esig_reason       ) :" ":
                                      STRIP ( SELECT 'esig_event_table'.signature_comment )

                    FILE WRITE ac_object.ace_report, tmp, status
                    internal_log_message ( ac_object, ac_object.current_routine:tmp, C_MSG_FULL )

                ENDIF   { not locked but it is not the last reference either }

            ENDIF  { a_event not empty and status is empty }

            { ----------------------------------------- }
            { commit or decommit based upon mode        }
            { ----------------------------------------- }

            ac_object.count_esig_data = ac_object.count_esig_data + 1
            IF NOT ( ac_object.report_only ) AND ( ret_val ) THEN

                IF ( ac_object.do_DELETE ) THEN

                    ac_object.delete_archive ( esig_data_table, status )

                ELSEIF ( ac_object.do_archive_csv ) THEN

                    ac_object.delete_archive ( esig_data_table, status )

                ELSEIF ( ac_object.do_consign ) THEN

                    CONSIGN 'esig_data_table' TO a_dest, status

                ELSEIF ( ac_object.do_REMOVEFLAG ) THEN

                    { don't do anything just yet... }

                    status = EMPTY

                ELSE

                    DECONSIGN 'esig_data_table', status

                ENDIF

                IF status <> EMPTY THEN

                    ret_val             = FALSE
                    ac_object.error_msg = msg.25:esig_data_table:status
                    internal_log_message ( ac_object, ac_object.current_routine:ac_object.error_msg, C_MSG_FULL )

                ENDIF

            ENDIF

            NEXT 'esig_data_table'
            event_id = SELECT 'esig_data_table'.esig_event_id

        ENDIF  { record locked }

    ENDWHILE   { event_id not empty and status empty }

    { -------------------------------------- }
    { Save what we got for reporting.......  }
    { -------------------------------------- }

    ac_object.save_set[ac_object.save_count,8] = an_array

    { ----------------------------------------------------- }
    { Let the logfile know what condition is being returned }
    { ----------------------------------------------------- }

    ac_object.current_routine = "ac_object_action_consign_esigs "
    internal_log_message ( ac_object, ac_object.current_routine:ac_object.a_table, C_MSG_LOW )

    RETURN ( ret_val )

ENDROUTINE   {  ac_object_action_consign_esigs }

{******************************************************************************}

ROUTINE ac_object_action_esig_event_last_1 (       ac_object  ,
                                             VALUE esig_event )


    DECLARE a_go    ,
                a_rec

    a_go = TRUE

    {-------------------------------------------------------------------------------- }
    { If this is delete mode, then only one record can match esig_data to esig_event  }
    {-------------------------------------------------------------------------------- }

    IF NOT ( ac_object.report_only ) AND ( ac_object.do_DELETE ) THEN

        ac_object.current_routine = "action_esig_event_last_1 "

        a_rec = SELECT COUNT 'C_ESIG_DATA_ALL_VIEW' WHERE ESIG_EVENT_ID = esig_event
        a_go  = ( a_rec = 0 )

        IF a_go THEN

            {-------------------------------------------------------------------------------- }
            { If it is still a_go then make sure only 1 record in the archive set by table    }
            {-------------------------------------------------------------------------------- }

            a_rec = SELECT COUNT 'C_ESIG_DATA_ALL_VIEW_2' WHERE ESIG_EVENT_ID = esig_event
            a_go  = ( a_rec = 1 )

        ENDIF

        {-------------------------------------------------------------------------------- }
        { show some kinda message to the logfile for which mode happened                  }
        {-------------------------------------------------------------------------------- }

        IF a_go THEN

            internal_log_message ( ac_object, ac_object.current_routine:"EVENT_OK ---> ":esig_event, C_MSG_HIGH )
        ELSE

            internal_log_message ( ac_object, ac_object.current_routine:"** SKIP EVENT ** ":esig_event, C_MSG_FULL )

        ENDIF

    ENDIF  { not report and is delete, so check if can finally get rid of event }

    RETURN ( a_go )

ENDROUTINE   { ac_object_action_esig_event_last_1 }

{******************************************************************************}

ROUTINE ac_object_action_audit_trans_last_1 (       ac_object   ,
                                              VALUE audit_trans )

    DECLARE a_go    ,
                a_rec

    a_go = TRUE

    {-------------------------------------------------------------------------------- }
    { If this is delete mode, then only one record can match audit trans data         }
    {-------------------------------------------------------------------------------- }

    IF NOT ( ac_object.report_only ) AND ( ac_object.do_DELETE ) THEN

        ac_object.current_routine = "action_audit_trans_last_1 "

        a_rec = SELECT COUNT 'C_AUDIT_TRANS_ALL_VIEW' WHERE TRANSACTION = audit_trans
        a_go  = ( a_rec = 0 )

        IF a_go THEN

            { ------------------------------------------------- }
            { If none there, make absolutely sure only 1 here...}
            { ------------------------------------------------- }

            a_rec = SELECT COUNT 'C_AUDIT_TRANS_ALL_VIEW_2' WHERE TRANSACTION = audit_trans
            a_go  = ( a_rec = 0 )

        ENDIF


        { ------------------------------------------------- }
        { Show message to logfile for all cases...          }
        { ------------------------------------------------- }

        IF a_go THEN

            internal_log_message ( ac_object, ac_object.current_routine:"TRANSACTION_OK ---> ":audit_trans, C_MSG_HIGH )
        ELSE

            internal_log_message ( ac_object, ac_object.current_routine:"** SKIP TRANSACTION ":audit_trans, C_MSG_FULL )

        ENDIF

    ENDIF  { not report and is delete, so check if can finally get rid of event }

    RETURN ( a_go )

ENDROUTINE   { ac_object_action_audit_trans_last_1 }

{******************************************************************************}

ROUTINE ac_object_action_consign_incidents ( ac_object )

    DECLARE inc_table     ,
                inc_res_table ,
                inc_id        ,
                a_inc_res     ,
                a_inc_act     ,
                a_dest        ,
                status        ,
                an_array      ,
                i, i2

    ac_object.current_routine = "ac_object_action_consign_incidents "
    ret_val                   = TRUE
    i                         = 0
    a_dest                    = ac_object.ach_commit_destination

    ARRAY an_array

    { -------------------------------------------------- }
    { Prefix blank on active others are not              }
    { -------------------------------------------------- }

    inc_table     = STRIP ( ac_object.ach_commit_source_prefix ) : "INCIDENTS"
    inc_res_table = STRIP ( ac_object.ach_commit_source_prefix ) : "INC_CHECKLIST_RESULTS"

    internal_log_message ( ac_object, ac_object.current_routine:ac_object.a_table:ac_object.a_identity_full, C_MSG_LOW )

    { -------------------------------------------------- }
    { Select all incidents/check_results (1-many)        }
    { -------------------------------------------------- }

    inc_id = SELECT 'inc_table'.incident_id FOR UPDATE
                 WHERE ( subject_field = ac_object.a_identity_full )
                 AND   ( ( subject_table = ac_object.a_table_no_prefix ) OR ( subject_table = inc_table  ) )
                 ORDER ON incident_id

    { -------------------------------------------------- }
    { Go thru all and get each and its children          }
    { -------------------------------------------------- }

    WHILE ( ( inc_id <> EMPTY ) AND ( ret_val ) ) DO

        IF ( inc_id = LOCKED ) THEN

            ac_object.error_msg = msg.26:inc_table:ac_object.a_table:ac_object.a_identity_full
            ret_val             = FALSE
            internal_log_message ( ac_object, ac_object.current_routine:ac_object.error_msg, C_MSG_FULL )

        ELSE

            i2  = 1
            i   = i + 1

            ac_object.count_inc_header = ac_object.count_inc_header + 1

            tmp = "  ":inc_table:" ":STRIP ( inc_id ):" ":
                              STRIP ( SELECT 'inc_table'.description    ) :" ":
                              STRIP ( SELECT 'inc_table'.incident_date  ) :" ":
                              STRIP ( SELECT 'inc_table'.reported_by    ) :" ":
                              STRIP ( SELECT 'inc_table'.subject_table  ) :" ":
                              STRIP ( SELECT 'inc_table'.subject_field  ) :" ":
                              STRIP ( SELECT 'inc_table'.location_id    ) :" ":
                              STRIP ( SELECT 'inc_table'.remark         )

            an_array[i,i2] = tmp

            FILE WRITE ac_object.ace_report, tmp, status

            internal_log_message ( ac_object, ac_object.current_routine:tmp, C_MSG_LOW )

            { -------------------------------------------------- }
            { move the inc_checklist_results table 1-many table  }
            { -------------------------------------------------- }

            a_inc_res = SELECT 'inc_res_table'.incident_id FOR UPDATE WHERE incident_id = inc_id
                                    ORDER ON action_number

            WHILE ( ( a_inc_res <> EMPTY ) AND ( ret_val ) ) DO

                IF ( a_inc_res = LOCKED ) THEN

                    ac_object.error_msg = msg.26 : inc_res_table : inc_id
                    ret_val             = FALSE
                    internal_log_message ( ac_object, ac_object.current_routine:ac_object.error_msg, C_MSG_FULL )

                ELSE

                    i2  = i2 + 1

                    ac_object.count_inc_result = ac_object.count_inc_result + 1

                    tmp = "  ":inc_res_table:" ":STRIP ( a_inc_res ):" ":
                                      STRIP ( SELECT 'inc_res_table'.action_number   ) :" ":
                                      STRIP ( SELECT 'inc_res_table'.checklist_id    ) :" ":
                                      STRIP ( SELECT 'inc_res_table'.action_type     ) :" ":
                                      STRIP ( SELECT 'inc_res_table'.action_taken    ) :" ":
                                      STRIP ( SELECT 'inc_res_table'.action_result   ) :" ":
                                      STRIP ( SELECT 'inc_res_table'.completion_date ) :" ":
                                      STRIP ( SELECT 'inc_res_table'.completed_by    )

                    an_array[i,i2] = tmp


                    FILE WRITE ac_object.ace_report, tmp, status

                    internal_log_message ( ac_object, ac_object.current_routine:tmp, C_MSG_LOW )

                    IF NOT ( ac_object.report_only ) THEN

                        IF ( ac_object.do_DELETE ) THEN

                            ac_object.delete_archive ( inc_res_table, status )

                        ELSEIF ( ac_object.do_archive_csv ) THEN

                            ac_object.delete_archive ( inc_res_table, status )

                        ELSEIF ( ac_object.do_consign ) THEN

                            CONSIGN 'inc_res_table' TO a_dest, status

                        ELSEIF ( ac_object.do_REMOVEFLAG ) THEN

                            { don't do anything just yet... }

                            status = EMPTY

                        ELSE

                            DECONSIGN 'inc_res_table', status

                        ENDIF

                        IF status <> EMPTY THEN

                            ret_val             = FALSE
                            ac_object.error_msg = msg.25:inc_res_table:status
                            internal_log_message ( ac_object, ac_object.current_routine:ac_object.error_msg, C_MSG_FULL )

                        ELSE

                            a_inc_act = PACKED_DECIMAL ( SELECT 'inc_res_table'.action_number )
                            ac_object.a_special_id    = a_inc_res : a_inc_act
                            ac_object.a_special_table = "INC_CHECKLIST_RESULTS"

                            ret_val = ac_object.consign_audits ( FALSE )

                            IF ret_val THEN

                                ret_val = ac_object.consign_esigs ( FALSE )

                            ENDIF

                        ENDIF

                    ENDIF
                ENDIF

                NEXT 'inc_res_table'
                a_inc_res = SELECT 'inc_res_table'.incident_id

            ENDWHILE  { a_event not empty and status is empty }

            { -------------------------------------- }
            { Commmit decommit current rec...        }
            { -------------------------------------- }

            ac_object.count_inc_header = ac_object.count_inc_header + 1
            IF NOT ( ac_object.report_only ) AND ( ret_val ) THEN

                IF ( ac_object.do_DELETE ) THEN

                    ac_object.delete_archive ( inc_table, status )

                ELSEIF ( ac_object.do_archive_csv ) THEN

                    ac_object.delete_archive ( inc_table, status )

                ELSEIF ( ac_object.do_consign ) THEN

                    CONSIGN 'inc_table' TO a_dest, status

                ELSEIF ( ac_object.do_REMOVEFLAG ) THEN

                    { don't do anything just yet... }

                    status = EMPTY

                ELSE

                    DECONSIGN 'inc_table', status

                ENDIF

                IF status <> EMPTY THEN

                    ret_val             = FALSE
                    ac_object.error_msg = msg.25:inc_table:status
                    internal_log_message ( ac_object, ac_object.current_routine:ac_object.error_msg, C_MSG_FULL )

                ELSE

                    ac_object.a_special_id    = inc_id
                    ac_object.a_special_table = "INCIDENTS"

                    ret_val = ac_object.consign_audits ( FALSE )

                    IF ret_val THEN

                        ret_val = ac_object.consign_esigs ( FALSE )

                    ENDIF

                ENDIF

            ENDIF

            NEXT 'inc_table'
            inc_id = SELECT 'inc_table'.incident_id

        ENDIF  { record locked }

    ENDWHILE   { event_id not empty and status empty }

    { -------------------------------------------------- }
    { Save what we did for reporting.....                }
    { -------------------------------------------------- }

    ac_object.save_set[ac_object.save_count,9] = an_array

    { ----------------------------------------------------- }
    { Let the logfile know what condition is being returned }
    { ----------------------------------------------------- }

    ac_object.current_routine = "ac_object_action_consign_incidents "
    internal_log_message ( ac_object, ac_object.current_routine:ac_object.a_table, C_MSG_LOW )

    RETURN ( ret_val )

ENDROUTINE   {  ac_object_action_consign_incidents }

{******************************************************************************}

ROUTINE ac_object_action_consign_inspectors ( ac_object )

    DECLARE inc_table     ,
                 inc_id        ,
                 a_dest        ,
                 status        ,
                 an_array      ,
                 i, i2

    ac_object.current_routine = "ac_object_action_consign_inspectors "
    ret_val                   = TRUE
    i                         = 0
    a_dest                    = ac_object.ach_commit_destination

    ARRAY an_array

    { -------------------------------------------------- }
    { Prefix blank on active others are not              }
    { -------------------------------------------------- }

    inc_table = STRIP ( ac_object.ach_commit_source_prefix ) : "INSPECTORS"

    internal_log_message ( ac_object, ac_object.current_routine:ac_object.a_table:ac_object.a_identity_full, C_MSG_LOW )

    { -------------------------------------------------- }
    { Select all incidents/check_results (1-many)        }
    { -------------------------------------------------- }

    inc_id = SELECT 'inc_table'.order_num FOR UPDATE
             WHERE ( record_key0 = ac_object.a_identity_full   )
             AND   ( ( table_name  = ac_object.a_table_no_prefix ) OR ( table_name = inc_table ) )

    { -------------------------------------------------- }
    { Go thru all and get each and its children          }
    { -------------------------------------------------- }

    WHILE ( ( inc_id <> EMPTY ) AND ( ret_val ) ) DO

        IF ( inc_id = LOCKED ) THEN

            ac_object.error_msg = msg.25 : inc_table:ac_object.a_table:ac_object.a_identity_full
            ret_val             = FALSE
            internal_log_message ( ac_object, ac_object.current_routine:ac_object.error_msg, C_MSG_FULL )

        ELSE

            i2  = 1
            i   = i + 1

            ac_object.count_inspector = ac_object.count_inspector + 1

            tmp = "  ":inc_table:" ": STRIP ( inc_id ):" ":
                              STRIP ( SELECT 'inc_table'.table_name           ) :" ":
                              STRIP ( SELECT 'inc_table'.record_key0          ) :" ":
                              STRIP ( SELECT 'inc_table'.version              ) :" ":
                              STRIP ( SELECT 'inc_table'.inspection_user_type ) :" ":
                              STRIP ( SELECT 'inc_table'.personnel_id         ) :" ":
                              STRIP ( SELECT 'inc_table'.role_id              ) :" ":
                              STRIP ( SELECT 'inc_table'.inspection_identity  ) :" ":
                              STRIP ( SELECT 'inc_table'.status               ) :" ":
                              STRIP ( SELECT 'inc_table'.inspection_text      ) :" ":
                              STRIP ( SELECT 'inc_table'.modified_on          ) :" ":
                              STRIP ( SELECT 'inc_table'.modified_by          )

            an_array[i,i2]            = tmp

            FILE WRITE ac_object.ace_report, tmp, status

            internal_log_message ( ac_object, ac_object.current_routine:tmp, C_MSG_LOW )

            IF NOT ( ac_object.report_only ) THEN

                IF ( ac_object.do_delete ) THEN

                    ac_object.delete_archive ( inc_table, status )

                ELSEIF ( ac_object.do_archive_csv ) THEN

                    ac_object.delete_archive ( inc_table, status )

                ELSEIF ( ac_object.do_consign ) THEN

                    CONSIGN 'inc_table' TO a_dest, status

                ELSEIF ( ac_object.do_REMOVEFLAG ) THEN

                    { don't do anything just yet... }

                    status = EMPTY

                ELSE

                    DECONSIGN 'inc_table', status

                ENDIF

                IF status <> EMPTY THEN

                    ret_val             = FALSE
                    ac_object.error_msg = msg.26:inc_table:status
                    internal_log_message ( ac_object, ac_object.current_routine:ac_object.error_msg, C_MSG_FULL )

                ENDIF

            ENDIF

        ENDIF  { record locked }

        NEXT 'inc_table'
        inc_id = SELECT 'inc_table'.order_num

    ENDWHILE   { event_id not empty and status empty }

    { -------------------------------------- }
    { Save data for reporting                }
    { -------------------------------------- }

    ac_object.save_set[ac_object.save_count,10] = an_array

    { ----------------------------------------------------- }
    { Let the logfile know what condition is being returned }
    { ----------------------------------------------------- }

    ac_object.current_routine = "ac_object_action_consign_inspectors "
    internal_log_message ( ac_object, ac_object.current_routine:ac_object.a_table, C_MSG_LOW )

    RETURN ( ret_val )

ENDROUTINE   {  ac_object_action_consign_inspectors }

{******************************************************************************}

ROUTINE ac_object_action_consign_disposition ( ac_object )

    DECLARE disp_table ,
                 dcom_table ,
                 disp_id    ,
                 disp_vers  ,
                 a_dest     ,
                 status     ,
                 an_array   ,
                 i, i2

    ac_object.current_routine = "ac_object_action_consign_disposition "
    ret_val                   = TRUE
    i                         = 0
    status                    = EMPTY
    a_dest                    = ac_object.ach_commit_destination

    ARRAY an_array

    { -------------------------------------------------- }
    { Prefix blank on active others are not              }
    { -------------------------------------------------- }

    disp_table = STRIP ( ac_object.ach_commit_source_prefix ) : "DISPOSITION_HEADER"
    dcom_table = STRIP ( ac_object.ach_commit_source_prefix ) : "DISP_COMMENTS"

    internal_log_message ( ac_object, ac_object.current_routine:ac_object.a_table:ac_object.a_identity_full, C_MSG_LOW )

    { -------------------------------------------------- }
    { Select disposition_header/results (1-many)         }
    { -------------------------------------------------- }

    disp_id = SELECT 'disp_table'.disposition_batch FOR UPDATE
              WHERE ( disposition_batch  = ac_object.a_identity_full )
                  ORDER ON disposition_version

    { -------------------------------------------------- }
    { Go thru all and get each and its children          }
    { -------------------------------------------------- }

    WHILE ( ( disp_id <> EMPTY ) AND ( ret_val ) ) DO

        IF ( disp_id = LOCKED ) THEN

            ac_object.error_msg = msg.02:disp_table:ac_object.a_table
            ret_val             = FALSE
            internal_log_message ( ac_object, ac_object.current_routine:ac_object.error_msg, C_MSG_FULL )

        ELSE

            disp_vers = PACKED_DECIMAL ( SELECT 'disp_table'.disposition_version )

            i2  = 1
            i   = i + 1

            ac_object.count_disp_header = ac_object.count_disp_header + 1

            tmp = "  ":disp_table:" ":STRIP ( disp_id ):" ":STRIP ( disp_vers )

            an_array[i,i2] = tmp


            FILE WRITE ac_object.ace_report, tmp, status

            internal_log_message ( ac_object, ac_object.current_routine:tmp, C_MSG_LOW )

            { --------------------------------- }
            { Lower tables are optional         }
            { --------------------------------- }

            IF ( VALID_TABLE ( dcom_table ) ) THEN

                ret_val = ret_val AND ( ac_object.consign_disp_comments ( disp_id, disp_vers, dcom_table, i, i2, an_array, a_dest ) )

            ENDIF

            ac_object.current_routine = "ac_object_action_consign_disposition "

            { --------------------------------- }
            { Save master tables data           }
            { --------------------------------- }

            IF NOT ( ac_object.report_only ) AND ( ret_val ) THEN

                IF ( ac_object.do_DELETE ) THEN

                    ac_object.delete_archive ( disp_table, status )

                ELSEIF ( ac_object.do_archive_csv ) THEN

                    ac_object.delete_archive ( disp_table, status )

                ELSEIF ( ac_object.do_consign ) THEN

                    CONSIGN 'disp_table' TO a_dest, status

                ELSEIF ( ac_object.do_REMOVEFLAG ) THEN

                    { don't do anything just yet... }

                    status = EMPTY

                ELSE

                    DECONSIGN 'disp_table', status

                ENDIF

                IF status <> EMPTY THEN

                    ret_val             = FALSE
                    ac_object.error_msg = msg.25:disp_table:status
                    internal_log_message ( ac_object, ac_object.current_routine:ac_object.error_msg, C_MSG_FULL )

                ELSE

                    ac_object.a_special_id    = disp_id : disp_vers
                    ac_object.a_special_table = "DISPOSITION_HEADER"

                    ret_val = ac_object.consign_audits ( FALSE )

                    IF ret_val THEN

                        ret_val = ac_object.consign_esigs ( FALSE )

                    ENDIF

                ENDIF

            ENDIF

            NEXT 'disp_table'
            disp_id = SELECT 'disp_table'.disposition_batch

        ENDIF  { record locked }

    ENDWHILE   { id not empty and status empty }

    { --------------------------------- }
    { Save data for reporting....       }
    { --------------------------------- }

    ac_object.save_set[ac_object.save_count,14] = an_array

    { ----------------------------------------------------- }
    { Let the logfile know what condition is being returned }
    { ----------------------------------------------------- }

    ac_object.current_routine = "ac_object_action_consign_disposition "
    internal_log_message ( ac_object, ac_object.current_routine:ac_object.a_table, C_MSG_LOW )

    RETURN ( ret_val )

ENDROUTINE   {  ac_object_action_consign_disposition }

{******************************************************************************}

ROUTINE ac_object_action_consign_disp_comments (      ac_object  ,
                                                VALUE disp_id    ,
                                                VALUE disp_vers  ,
                                                VALUE dcom_table ,
                                                      i          ,
                                                      i2         ,
                                                      an_array   ,
                                                      a_dest     )

    DECLARE a_res, status

    ac_object.current_routine = "ac_object_action_consign_disp_comments "
    ret_val                   = TRUE

    a_res = SELECT 'dcom_table'.comment_no FOR UPDATE
                 WHERE job_name            = disp_id
                 AND   disposition_version = disp_vers
                 ORDER ON comment_no

    { ------------------------------------ }
    { Get each and move it                 }
    { ------------------------------------ }

    WHILE ( ( a_res <> EMPTY ) AND ( ret_val ) ) DO

        IF ( a_res = LOCKED ) THEN

            ac_object.error_msg  = msg.02: dcom_table : disp_id
            ret_val              = FALSE
            internal_log_message ( ac_object, ac_object.current_routine:ac_object.error_msg, C_MSG_FULL )

        ELSE

            i2  = i2 + 1

            ac_object.count_disp_comment = ac_object.count_disp_comment + 1

            tmp = "  ":dcom_table:" ":STRIP ( a_res ):" ":
                                STRIP ( SELECT 'dcom_table'.comment_context  ) :" ":
                                STRIP ( SELECT 'dcom_table'.comment_text     )

            an_array[i,i2] = tmp


            FILE WRITE ac_object.ace_report, tmp, status


            internal_log_message ( ac_object, ac_object.current_routine:tmp, C_MSG_LOW )

            IF NOT ( ac_object.report_only ) THEN

                IF ( ac_object.do_DELETE ) THEN

                    ac_object.delete_archive ( dcom_table, status )

                ELSEIF ( ac_object.do_archive_csv ) THEN

                    ac_object.delete_archive ( dcom_table, status )

                ELSEIF ( ac_object.do_consign ) THEN

                    CONSIGN 'dcom_table' TO a_dest, status

                ELSEIF ( ac_object.do_REMOVEFLAG ) THEN

                    { don't do anything just yet... }

                    status = EMPTY

                ELSE

                    DECONSIGN 'dcom_table', status

                ENDIF

                IF status <> EMPTY THEN

                    ac_object.error_msg = dcom_table:status
                    ret_val             = FALSE
                    internal_log_message ( ac_object, ac_object.current_routine:ac_object.error_msg, C_MSG_FULL )

                ELSE


                    ac_object.a_special_id    = disp_id : disp_vers : a_res
                    ac_object.a_special_table = "DISP_COMMENTS"

                    ret_val = ac_object.consign_audits ( FALSE )

                    IF ret_val THEN

                        ac_object.consign_esigs ( FALSE )

                    ENDIF

                ENDIF

            ENDIF

        ENDIF { locked }

        NEXT 'dcom_table'
        a_res = SELECT 'dcom_table'.comment_no

    ENDWHILE  { a_event not empty and status is empty }

    { ----------------------------------------------------- }
    { Let the logfile know what condition is being returned }
    { ----------------------------------------------------- }

    ac_object.current_routine = "ac_object_action_consign_disp_comments "
    internal_log_message ( ac_object, ac_object.current_routine:ac_object.a_table:ret_val, C_MSG_LOW )

    RETURN ( ret_val )

ENDROUTINE   {  ac_object_action_consign_disp_comments }

{******************************************************************************}
{                                                                              }
{                                                                              }
{                                                                              }
{                                                                              }
{ These actions are done whenever the calling value has been archived          }
{                                                                              }
{                                                                              }
{                                                                              }
{                                                                              }
{                                                                              }
{******************************************************************************}


ROUTINE ac_object_action_consign_worksheets ( ac_object )

    DECLARE a_table     ,
                 a_id        ,
                 a_dest      ,
                 status      ,
                 an_array    ,
                 i, i2       ,
                 a_type

    ARRAY an_array
    ARRAY ac_object.save_set[ac_object.save_count,11]    { used for reporting... }

    ac_object.current_routine = "ac_object_action_consign_worksheets "
    ret_val                   = TRUE
    i                         = 0
    a_dest                    = ac_object.ach_commit_destination
    a_table                   = STRIP ( ac_object.ach_commit_source_prefix ) : "WORKSHEET"

    { -------------------------------------------------- }
    { Depends on which table is being archived....       }
    { -------------------------------------------------- }


    IF ( INDEX ( ac_object.a_table, "SAMPLE" ) > 0 ) THEN

        a_type = "SMPWKS    "

    ELSEIF ( INDEX ( ac_object.a_table, "TEST" ) > 0 ) THEN

        a_type = "TESTWKS   "

    ELSE
        a_type = "UDWKS     "

    ENDIF

    { -------------------------------------------------- }
    { Prefix blank on active others are not              }
    { -------------------------------------------------- }

    internal_log_message ( ac_object, ac_object.current_routine:ac_object.a_table:ac_object.a_identity_full, C_MSG_LOW )

    { -------------------------------------------------- }
    { Select all worksheets by type passed in....        }
    { -------------------------------------------------- }

    a_id = SELECT 'a_table'.identity FOR UPDATE
                WHERE ( WORKSHEET_TYPE = a_type   )
                AND   ( IDENTITY       = ac_object.a_identity_full )

    { -------------------------------------------------- }
    { Go thru all and get each and its children          }
    { -------------------------------------------------- }

    WHILE ( ( a_id <> EMPTY ) AND ( ret_val ) ) DO

        IF ( a_id = LOCKED ) THEN

            ac_object.error_msg = msg.25 : a_table : ac_object.a_table : ac_object.a_identity_full
            ret_val             = FALSE
            internal_log_message ( ac_object, ac_object.current_routine:ac_object.error_msg, C_MSG_FULL )

        ELSE

            i2  = 1
            i   = i + 1

            ac_object.count_worksheet = ac_object.count_worksheet + 1

            tmp = "  ":a_table:" ":STRIP ( a_id ):" ":
                              STRIP ( SELECT 'a_table'.worksheet_type     ) :" ":
                              STRIP ( SELECT 'a_table'.assigned_operator  ) :" ":
                              STRIP ( SELECT 'a_table'.generator_operator ) :" ":
                              STRIP ( SELECT 'a_table'.status             ) :" ":
                              STRIP ( SELECT 'a_table'.link_number        ) :" ":
                              STRIP ( SELECT 'a_table'.date_generated     )

            an_array[i,i2]            = tmp


            FILE WRITE ac_object.ace_report, tmp, status


            internal_log_message ( ac_object, ac_object.current_routine:tmp, C_MSG_LOW )

            IF NOT ( ac_object.report_only ) THEN

                IF ( ac_object.do_delete ) THEN

                    ac_object.delete_archive ( a_table, status )

                ELSEIF ( ac_object.do_archive_csv ) THEN

                    ac_object.delete_archive ( a_table, status )

                ELSEIF ( ac_object.do_consign ) THEN

                    CONSIGN 'a_table' TO a_dest, status

                ELSEIF ( ac_object.do_REMOVEFLAG ) THEN

                    { don't do anything just yet... }

                    status = EMPTY

                ELSE

                    DECONSIGN 'a_table', status

                ENDIF

                IF status <> EMPTY THEN

                    ret_val             = FALSE
                    ac_object.error_msg = msg.26:a_table:status
                    internal_log_message ( ac_object, ac_object.current_routine:ac_object.error_msg, C_MSG_FULL )

                ELSE

                    ac_object.a_special_id    = a_id
                    ac_object.a_special_table = "WORKSHEET"    { or should this be a_table ? }

                    ret_val = ac_object.consign_audits ( FALSE )

                    IF ret_val THEN

                        ret_val = ac_object.consign_esigs ( FALSE )

                    ENDIF

                ENDIF  { status empty on consign/delete }

            ENDIF

        ENDIF  { record locked }

        NEXT 'a_table'
        a_id = SELECT 'a_table'.identity

    ENDWHILE   { event_id not empty and status empty }

    { ----------------------------------------------------- }
    { Let the logfile know what condition is being returned }
    { ----------------------------------------------------- }

    ac_object.save_set[ac_object.save_count,11] = an_array
    ac_object.current_routine                   = "ac_object_action_consign_worksheets "

    internal_log_message ( ac_object, ac_object.current_routine:ac_object.a_table, C_MSG_LOW )

    RETURN ( ret_val )

ENDROUTINE   {  ac_object_action_consign_worksheets }

{******************************************************************************}

ROUTINE ac_object_action_consign_labels ( ac_object )

    DECLARE a_dest   ,
                 a_table  ,
                 a_table2 ,
                 i, i2    ,
                 an_array ,
                 a_id     ,
                 a_id2    ,
                 tmp      ,
                 status

    ARRAY an_array
    ARRAY ac_object.save_set[ac_object.save_count,12]    { used to report the data }

    ret_val                   = TRUE
    i                         = 0
    a_dest                    = ac_object.ach_commit_destination
    a_table                   = STRIP ( ac_object.ach_commit_source_prefix ) : "LABELPRINT"
    a_table2                  = STRIP ( ac_object.ach_commit_source_prefix ) : "LABELPRINT_LINES"
    ac_object.current_routine = "ac_object_action_consign_labels "

    { -------------------------------------------------- }
    { Prefix blank on active others are not              }
    { -------------------------------------------------- }

    internal_log_message ( ac_object, ac_object.current_routine:ac_object.a_table:ac_object.a_identity_full, C_MSG_LOW )

    { -------------------------------------------------- }
    { Select all incidents/check_results (1-many)        }
    { -------------------------------------------------- }

    a_id = SELECT 'a_table'.key1 FOR UPDATE
                WHERE ( KEY1        = STRIP ( ac_object.a_identity_full ) )
                AND   ( LABEL_TABLE = ac_object.a_table )

    { -------------------------------------------------- }
    { Go thru all and get each and its children          }
    { -------------------------------------------------- }

    WHILE ( ( a_id <> EMPTY ) AND ( ret_val ) ) DO

        IF ( a_id = LOCKED ) THEN

            ac_object.error_msg = msg.26:a_table:ac_object.a_table:ac_object.a_identity_full
            ret_val             = FALSE
            internal_log_message ( ac_object, ac_object.current_routine:ac_object.error_msg, C_MSG_FULL )

        ELSE

            i2  = 1
            i   = i + 1

            ac_object.count_labelprint = ac_object.count_labelprint + 1

            tmp = "  ":a_table:" ":STRIP ( a_id ):" ":
                              STRIP ( SELECT 'a_table'.key2           ) :" ":
                              STRIP ( SELECT 'a_table'.key3           ) :" ":
                              STRIP ( SELECT 'a_table'.label_id       ) :" ":
                              STRIP ( SELECT 'a_table'.label_status   ) :" ":
                              STRIP ( SELECT 'a_table'.version        ) :" ":
                              STRIP ( SELECT 'a_table'.label_no       ) :" ":
                              STRIP ( SELECT 'a_table'.label_type     )

            an_array[i,i2] = tmp

            FILE WRITE ac_object.ace_report, tmp, status

            internal_log_message ( ac_object, ac_object.current_routine:tmp, C_MSG_LOW )

            { -------------------------------------------------- }
            { move the inc_checklist_results table 1-many table  }
            { -------------------------------------------------- }

            a_id2 = SELECT 'a_table2'.key1 FOR UPDATE WHERE KEY1 = a_id

            WHILE ( ( a_id2 <> EMPTY ) AND ( ret_val ) ) DO

                IF ( a_id2 = LOCKED ) THEN

                    ac_object.error_msg = msg.26 : a_table2 : a_id
                    ret_val             = FALSE
                    internal_log_message ( ac_object, ac_object.current_routine:ac_object.error_msg, C_MSG_FULL )

                ELSE

                    i2  = i2 + 1

                    ac_object.count_labelprint_lines = ac_object.count_labelprint_lines + 1

                    tmp = "  ":a_table2:" ":STRIP ( a_id2 ):" ":
                                      STRIP ( SELECT 'a_table2'.key2          ) :" ":
                                      STRIP ( SELECT 'a_table2'.key3          ) :" ":
                                      STRIP ( SELECT 'a_table2'.label_id      ) :" ":
                                      STRIP ( SELECT 'a_table2'.label_status  ) :" ":
                                      STRIP ( SELECT 'a_table2'.version       ) :" ":
                                      STRIP ( SELECT 'a_table2'.label_no      ) :" ":
                                      STRIP ( SELECT 'a_table2'.label_count   )

                    an_array[i,i2] = tmp


                    FILE WRITE ac_object.ace_report, tmp, status


                    internal_log_message ( ac_object, ac_object.current_routine:tmp, C_MSG_LOW )

                    IF NOT ( ac_object.report_only ) THEN

                        IF ( ac_object.do_DELETE ) THEN

                            ac_object.delete_archive ( a_table2, status )

                        ELSEIF ( ac_object.do_archive_csv ) THEN

                            ac_object.delete_archive ( a_table2, status )

                        ELSEIF ( ac_object.do_consign ) THEN

                            CONSIGN 'a_table2' TO a_dest, status

                        ELSEIF ( ac_object.do_REMOVEFLAG ) THEN

                            { don't do anything just yet... }

                            status = EMPTY

                        ELSE

                            DECONSIGN 'a_table2', status

                        ENDIF

                        IF status <> EMPTY THEN

                            ret_val             = FALSE
                            ac_object.error_msg = msg.25:a_table2:status
                            internal_log_message ( ac_object, ac_object.current_routine:ac_object.error_msg, C_MSG_FULL )

                        ELSE

                            ac_object.a_special_id    = a_id2
                            ac_object.a_special_table = "LABELPRINT_LINES"

                            ret_val = ac_object.consign_audits ( FALSE )

                            IF ret_val THEN

                                ret_val = ac_object.consign_esigs ( FALSE )

                            ENDIF

                        ENDIF

                    ENDIF
                ENDIF

                NEXT 'a_table2'
                a_id2 = SELECT 'a_table2'.key1

            ENDWHILE  { a_id2 not empty and status is empty }

            { -------------------------------------- }
            { Commmit decommit current rec...        }
            { -------------------------------------- }

            IF NOT ( ac_object.report_only ) AND ( ret_val ) THEN

                IF ( ac_object.do_DELETE ) THEN

                    ac_object.delete_archive ( a_table, status )

                ELSEIF ( ac_object.do_archive_csv ) THEN

                    ac_object.delete_archive ( a_table, status )

                ELSEIF ( ac_object.do_consign ) THEN

                    CONSIGN 'a_table' TO a_dest, status

                ELSEIF ( ac_object.do_REMOVEFLAG ) THEN

                    { don't do anything just yet... }

                    status = EMPTY

                ELSE

                    DECONSIGN 'a_table', status

                ENDIF

                IF status <> EMPTY THEN

                    ret_val             = FALSE
                    ac_object.error_msg = msg.25:a_table:status
                    internal_log_message ( ac_object, ac_object.current_routine:ac_object.error_msg, C_MSG_FULL )

                ELSE

                    ac_object.a_special_id    = a_id
                    ac_object.a_special_table = "LABELPRINT"

                    ret_val = ac_object.consign_audits ( FALSE )

                    IF ret_val THEN

                        ret_val = ac_object.consign_esigs ( FALSE )

                    ENDIF

                ENDIF

            ENDIF

            NEXT 'a_table'
            a_id = SELECT 'a_table'.key1

        ENDIF  { record locked }

    ENDWHILE   { a_id not empty and status empty }

    { ----------------------------------------------------- }
    { Let the logfile know what condition is being returned }
    { ----------------------------------------------------- }

    ac_object.save_set[ac_object.save_count,12] = an_array
    ac_object.current_routine                   = "ac_object_action_consign_labels "

    internal_log_message ( ac_object, ac_object.current_routine:ac_object.a_table, C_MSG_LOW )

    RETURN ( ret_val )

ENDROUTINE   {  ac_object_action_consign_labels }

{******************************************************************************}
{                                                                              }
{                                                                              }
{                                                                              }
{                                                                              }
{  Actions called from the main processing routine based upon the mode         }
{                                                                              }
{                                                                              }
{                                                                              }
{                                                                              }
{                                                                              }
{******************************************************************************}

ROUTINE ac_object_action_commit ( ac_object )

    RETURN ( ac_object.a_mode ( "ac_object_action_commit" ) )

ENDROUTINE  { ac_object_action_commit }

{******************************************************************************}

ROUTINE ac_object_action_commit_move ( ac_object )

    RETURN ( ac_object.a_mode ( "ac_object_action_commit_move" ) )

ENDROUTINE  { ac_object_action_commit_move }

{******************************************************************************}

ROUTINE ac_object_action_deconsign ( ac_object )

    RETURN ( ac_object.a_mode ( "ac_object_action_deconsign" ) )

ENDROUTINE  { ac_object_action_deconsign }

{******************************************************************************}

ROUTINE ac_object_action_archive ( ac_object )

    RETURN ( ac_object.a_mode ( "ac_object_action_archive" ) )  { same as commit_move... }

ENDROUTINE  { ac_object_action_archive }

{******************************************************************************}

ROUTINE ac_object_action_delete ( ac_object )

    RETURN ( ac_object.a_mode ( "ac_object_action_delete" ) )

ENDROUTINE  { ac_object_action_delete }

{******************************************************************************}

ROUTINE ac_object_action_remove ( ac_object )

    RETURN ( ac_object.a_mode ( "ac_object_action_remove" ) )

ENDROUTINE  { ac_object_action_remove }

{******************************************************************************}

ROUTINE ac_object_action_export ( ac_object )

    RETURN ( ac_object.a_mode ( "ac_object_action_export" ) )

ENDROUTINE  { ac_object_action_export }

{******************************************************************************}

ROUTINE ac_object_action_a_mode ( ac_object, VALUE a_routine )

    { --------------------------------------------------------------- }
    { Start at the top table and it calls any lower entities          }
    { --------------------------------------------------------------- }

    ac_object.a_field        = ac_object.ach_field_identity
    ac_object.a_select_field = ac_object.ach_field_identity
    ac_object.a_table        = ac_object.ach_base_table
    ac_object.cycle_count    = 1
    ret_val                  = FALSE
    tmp                      = a_routine : ac_object.a_table : ac_object.base_table_identity

    internal_log_message ( ac_object, tmp, C_MSG_LOW )

    { ----------------------------------------------------- }
    { If all lower user/system tables ok, then consign      }
    { ----------------------------------------------------- }

    ret_val = ac_object.select_table()

    { ----------------------------------------------------- }
    { Let the logfile know what condition is being returned }
    { ----------------------------------------------------- }

    internal_log_message ( ac_object, a_routine : ret_val, C_MSG_LOW )

    RETURN ( ret_val )

ENDROUTINE  { ac_object_action_a_mode }

{******************************************************************************}

ROUTINE ac_object_action_report_only ( ac_object )

    DECLARE status, i, part

    { --------------------------------------------------------------- }
    { Go through all that was chosen and output report                }
    { --------------------------------------------------------------- }

    ac_object.current_routine = "ac_object_action_report_only "

    { -------------------------------------------------------- }
    { The current table and the full cat'ed identity           }
    { -------------------------------------------------------- }

    IF ( ac_object.a_identity_full <> EMPTY ) THEN

        tmp  = PAD ( ac_object.a_table, " ", C_MAX_TABLE_LENGTH + 5 ) : ac_object.a_identity_full

        FILE WRITE ac_object.ace_report, tmp, status

        internal_log_message ( ac_object, ac_object.current_routine:tmp, C_MSG_LOW )

        { -------------------------------------------------------- }
        { The rest of the save_array are all arrays of details     }
        { -------------------------------------------------------- }

        IF ( ac_object.ach_report_details ) THEN

            i = 7

            WHILE ( i <= C_MAX_SAVE_SET ) DO

                part = ac_object.save_set[ac_object.save_count,i]

                { -------------------------------------------------------- }
                { If there are no audits, esigs, etc then array is 0       }
                { -------------------------------------------------------- }

                IF ( ( part <> EMPTY ) AND ( SIZE_OF_ARRAY ( part ) > 0 ) ) THEN
                    ac_object.report_details ( part, i )
                ENDIF

                i = i + 1

            ENDWHILE

        ENDIF  { report details is auto_commit_header.report_details }

    ENDIF  { current rec is empty so do not report it }

    RETURN ( TRUE )

ENDROUTINE  { ac_object_action_commit_report_only }

{******************************************************************************}

ROUTINE ac_object_action_report_details ( ac_object, part, VALUE part_i )

    DECLARE i, i2, status

    ac_object.current_routine = "ac_object_action_report_details "

    i = 1

    { ----------------------------- }
    { Arrays that are 2 dimensional }
    { ----------------------------- }

    IF ( part_i = 7 ) OR ( part_i = 8 ) OR ( part_i = 9 ) OR ( part_i = 11 ) OR ( part_i = 12 ) THEN

        WHILE ( part[i,1] <> EMPTY ) DO

            i2 = 1

            WHILE ( part[i,i2] <> EMPTY ) DO

                FILE WRITE ac_object.ace_report, part[i,i2], status
                internal_log_message ( ac_object, ac_object.current_routine:part[i,i2], C_MSG_LOW )
                i2 = i2 + 1

            ENDWHILE

            i = i + 1

        ENDWHILE

    ELSE

        WHILE ( part[i] <> EMPTY ) DO

            FILE WRITE ac_object.ace_report, part[i], status
            internal_log_message ( ac_object, ac_object.current_routine:part[i], C_MSG_LOW )
            i = i + 1

        ENDWHILE

    ENDIF


ENDROUTINE  { ac_object_action_report_details }

{*******************************************************************************
*
*
*
*
*              V I E W    O B J E C T   D A T A B A S E    R O U T I N E S
*
*
*
*
*******************************************************************************}

ROUTINE internal_define_view_object_database

    DEFINE CLASS "VIEW_OBJECT_DATABASE" INHERIT "STD_COLLECTION"
        PROPERTIES
            "table"      ,
            "ac_object"  ,
            "max_count"

        ACTIONS
            "initialise" ,
            "select"

    END CLASS

ENDROUTINE { define_view_object_database }

{******************************************************************************}

ROUTINE view_object_database_action_initialise (       self     ,
                                                 VALUE tab_name )

    self.table = tab_name

ENDROUTINE { view_object_database_action_initialise }

{******************************************************************************}

ROUTINE view_object_database_action_select ( self         ,
                                             select_array )

    DECLARE context     ,
            context_2   ,
                key0_array  ,
                next_record ,
                new_record  ,
                old_record  ,
        count

    PUSH_FILE_DESCRIPTOR ( self.table, context )

    GET_TABLE_DETAILS 'self.table', "KEY0_FIELD", key0_array

    start_letter = start_letter : "%"

    Array_select_add (select_array    ,
                         ARRAY_SELECT_LIKE ,
                         "identity"     ,
                         start_letter      )



    array_select ( self.table, FALSE, select_array )

    next_record = SELECT 'self.table'.'key0_array[1]'

    IF next_record <> EMPTY THEN

        count = 1

    ENDIF

    WHILE next_record <> EMPTY DO

        CREATE OBJECT "STD_OBJECT_RECORD", new_record

        new_record.table = self.table

        object_add_table ( new_record, self.table )
        OBJECT_SET_CURRENT_TABLE  ( new_record, self.table )

        self.add ( new_record )

        old_record = next_record

        NEXT 'self.table'
        next_record = SELECT 'self.table'.'key0_array[1]'

        IF ( next_record <> EMPTY ) AND ( VALID_FIELD ( self.table, ac_object.ac_id_field_1 ) ) THEN

            { ---------------------------------------------------------------------------------------- }
            { Increment count by the base table select and not the view (self.table) for accuracy      }
            { ---------------------------------------------------------------------------------------- }

            PUSH_FILE_DESCRIPTOR ( self.table, context_2 )

            IF ( SELECT 'ac_object.ach_base_table'.'ac_object.ac_id_field_1'
                  WHERE 'ac_object.ac_id_field_1' = SELECT 'self.table'.'ac_object.ac_id_field_1'
                                                     WHERE 'key0_array[1]' = old_record           ) <>
               ( SELECT 'ac_object.ach_base_table'.'ac_object.ac_id_field_1'
                  WHERE 'ac_object.ac_id_field_1' = SELECT 'self.table'.'ac_object.ac_id_field_1'
                                                     WHERE 'key0_array[1]' = next_record          ) THEN
                count = count + 1

            ENDIF

            POP_FILE_DESCRIPTOR ( context_2 )
        ELSE
            count = count + 1
        ENDIF

        IF ( count > self.max_count ) THEN

            next_record = EMPTY

        ENDIF

    ENDWHILE

    POP_FILE_DESCRIPTOR ( context )

ENDROUTINE { view_object_database_action_select }

{*******************************************************************************
*
*
*
*
*                      L T E   P A G E   1    R O U T I N E S
*
*
*
*
*******************************************************************************}

ROUTINE prompt_auto_commit_header_base_table ( VALUE column     ,
                                               VALUE row        ,
                                               VALUE cell_width ,
                                                     screen     ,
                                               VALUE is_display )

    DECLARE cur_val      ,
                prev_val     ,
                an_array     ,
                a1_array     ,
                a_base_table ,
                a_base_child ,
                smp_vers     ,
                max_vers     ,
                i

    prev_val = SELECT auto_commit_header.base_table
    cur_val  = prev_val

    IF is_display THEN

        DISPLAY prev_val ON LINE row FROM column TO column + cell_width - 1 IN WINDOW screen

    ELSE

        ARRAY an_array

        smp_vers = PAD ( SUBSTITUTE ( smp_version_number(), " ", "" ), " ", 10 )

        ARRAY_SELECT_ADD ( an_array, ARRAY_SELECT_EQ, "SMP_VERSION" , smp_vers )

        max_vers = PACKED_DECIMAL ( ARRAY_SELECT_MAX ( "SMP_TABLESETS", "VERSION_NUMBER", an_array ) )

        { -------------------------------------------------------- }
        { Get all base table names that can be done                }
        { -------------------------------------------------------- }

        ARRAY a1_array

        i = 0
        a_base_table = SELECT SMP_TABLE_ARCOM.SYSTEM_TABLE
                                 WHERE SMP_VERSION    = smp_vers
                                 AND   VERSION_NUMBER = max_vers
                                 AND   BASE_TABLE     = TRUE
                                 AND   EXPORT_TABLE   = FALSE


        WHILE ( a_base_table <> EMPTY ) DO

            IF ( VALID_TABLE ( a_base_table ) ) THEN

                REPEAT

                    GET_TABLE_DETAILS 'a_base_table', "CHILD", a_base_child

                    i             = i + 1
                    a1_array[i,1] = a_base_table
                    a1_array[i,2] = a_base_table
                    a_base_table  = a_base_child

                UNTIL BLANK ( a_base_child )

            ENDIF  { table is set as base but not in structure (PDS not installed, COA not installed etc }

            NEXT SMP_TABLE_ARCOM

            a_base_table = SELECT SMP_TABLE_ARCOM.SYSTEM_TABLE

        ENDWHILE

        { -------------------------------------------------------- }
        { Get the input from user and save data                    }
        { -------------------------------------------------------- }

        PROMPT FOR cur_val ON LINE row FROM column TO column + cell_width - 1 IN WINDOW screen CHOOSE OUTOF a1_array
        WITH ( value = prev_val )

        IF ( lastkey <> "EXIT" ) THEN

            IF ( cur_val <> prev_val ) THEN

                ASSIGN auto_commit_header.base_table         = cur_val
                ASSIGN auto_commit_header.commit_view        = ""
                ASSIGN auto_commit_header.commit_source      = ""
                ASSIGN auto_commit_header.commit_destination = ""

            ENDIF

        ENDIF

    ENDIF  { is_display }

ENDROUTINE { prompt_auto_commit_header_base_table }

{******************************************************************************}

ROUTINE prompt_auto_commit_header_commit_source ( VALUE column     ,
                                                  VALUE row        ,
                                                  VALUE cell_width ,
                                                        screen     ,
                                                  VALUE is_display )

    DECLARE cur_val      ,
                 prev_val     ,
                 a_table

    a_table      = SELECT auto_commit_header.base_table
    prev_val     = SELECT auto_commit_header.commit_source
    cur_val      = prev_val

    IF ( is_display ) THEN

        DISPLAY prev_val ON LINE row FROM column TO column + cell_width - 1 IN WINDOW screen

    ELSEIF  ( a_table = EMPTY ) OR ( BLANK ( a_table ) )  THEN              { ** LIT001 ** Start/End }

        cur_val = "          "

        DISPLAY cur_val ON LINE row FROM column TO column + cell_width - 1 IN WINDOW screen

        PROMPT FOR cur_val ON LINE row FROM column TO column + cell_width - 1 IN WINDOW screen WITH ( display_only = TRUE )

        ASSIGN auto_commit_header.commit_source      = ""
        ASSIGN auto_commit_header.commit_destination = ""
        ASSIGN auto_commit_header.commit_view        = ""

    ELSE

        { ------------------------------------------------------------- }
        { Base table's tableset id is the source - display only         }
        { ------------------------------------------------------------- }

        GET_TABLE_DETAILS 'a_table', "TABLESET", cur_val

        IF ( BLANK ( cur_val ) ) THEN
            cur_val = "ACTIVE"
        ENDIF


        PROMPT FOR cur_val ON LINE row FROM column TO column + cell_width - 1 IN WINDOW screen WITH ( display_only = TRUE )

        IF lastkey <> "EXIT" THEN

            IF ( cur_val <> prev_val ) THEN

                ASSIGN auto_commit_header.commit_source      = cur_val
                ASSIGN auto_commit_header.commit_destination = ""

            ENDIF

        ENDIF

    ENDIF  { is_display }

ENDROUTINE { prompt_auto_commit_header_commit_source }

{******************************************************************************}

ROUTINE prompt_auto_commit_header_commit_destination ( VALUE column     ,
                                                       VALUE row        ,
                                                       VALUE cell_width ,
                                                             screen     ,
                                                       VALUE is_display )

    DECLARE cur_val       ,
                prev_val       ,
                an_array       ,
                a2_array       ,
                a_source       ,
                smp_vers       ,
                max_vers       ,
                source_mode    ,
                a_base_table   ,
                a_save_base    ,
                a_base_child   ,
                a_tableset     ,
                a_removeflag   ,
                i


    a_source       = SELECT auto_commit_header.commit_source
    prev_val       = SELECT auto_commit_header.commit_destination
    a_base_table   = SELECT auto_commit_header.base_table
    a_save_base    = a_base_table
    cur_val        = prev_val

    IF ( is_display ) THEN

        DISPLAY prev_val ON LINE row FROM column TO column + cell_width - 1 IN WINDOW screen

    ELSEIF  ( a_base_table = EMPTY ) OR ( BLANK ( a_base_table ) )
    OR      ( a_source     = EMPTY ) OR ( BLANK ( a_source     ) ) THEN     { ** LIT001 start/end ** }

        cur_val = "          "

        DISPLAY cur_val ON LINE row FROM column TO column + cell_width - 1 IN WINDOW screen

        PROMPT FOR cur_val ON LINE row FROM column TO column + cell_width - 1 IN WINDOW screen WITH ( display_only = TRUE )

        ASSIGN auto_commit_header.commit_destination = ""

    ELSE

        { ------------------------------------------------------------- }
        { Get all child tableset names of this base table               }
        { ------------------------------------------------------------- }

        GET_TABLE_DETAILS 'a_base_table', "REMOVE_FIELD", a_removeflag

        ARRAY an_array
                  i = 0

        REPEAT

            GET_TABLE_DETAILS 'a_base_table', "CHILD", a_base_child
            GET_TABLE_DETAILS 'a_base_table', "TABLESET", a_tableset

            IF NOT BLANK ( a_tableset ) THEN

                IF ( a_tableset <> a_source ) THEN

                    i             = i + 1
                    an_array[i,1] = a_tableset
                    an_array[i,2] = a_tableset

                ENDIF

            ENDIF

            a_base_table = a_base_child

        UNTIL BLANK ( a_base_child )

        { ------------------------------------------------------------- }
        { Find the source table_Set_mode, it defines destinations       }
        { ------------------------------------------------------------- }

        IF ( a_source <> EMPTY ) AND ( NOT BLANK ( a_source ) ) THEN

            smp_vers = PAD ( SUBSTITUTE ( smp_version_number(), " ", "" ), " ", 10 )

            ARRAY a2_array

            ARRAY_SELECT_ADD ( a2_array, ARRAY_SELECT_EQ, "SMP_VERSION" , smp_vers )
            ARRAY_SELECT_ADD ( a2_array, ARRAY_SELECT_EQ, "TABLE_SET_ID", a_source )

            max_vers = PACKED_DECIMAL ( ARRAY_SELECT_MAX ( "SMP_TABLESETS", "VERSION_NUMBER", a2_array ) )

            source_mode = SELECT SMP_TABLESETS.TABLE_SET_MODE
                                    WHERE SMP_VERSION   = smp_vers
                                    AND VERSION_NUMBER  = max_vers
                                    AND TABLE_SET_ID    = a_source

            { -------------------------------------------------------------- }
            { Got source's mode, now build destination options               }
            { -------------------------------------------------------------- }

            IF source_mode = C_TABLESET_ACTIVE THEN         { actives depend on base table }

                IF ( INDEX ( a_save_base, "PDS_STUDY" ) > 0 ) THEN

                    ARRAY an_array
                    an_array[1,1] = "ARCHIVE_TABLE_SET"
                    an_array[1,2] = "ARCHIVE_TABLE_SET"

                ELSEIF ( a_removeflag <> EMPTY ) THEN

                    ARRAY an_array
                    an_array[1,1] = C_REMOVE_FLAG
                    an_array[1,2] = C_REMOVE_FLAG
                    an_array[2,1] = C_DELETE_FLAG
                    an_array[2,2] = C_DELETE_FLAG

                ENDIF

            ELSEIF source_mode = C_TABLESET_COMMIT THEN     { commit->another commit, archive, active or retain }

                IF ( INDEX ( a_save_base, "PDS_STUDY" ) > 0 ) THEN

                    ARRAY an_array
                    an_array[1,1] = ""
                    an_array[1,2] = ""

                ELSEIF ( a_removeflag <> EMPTY ) THEN

                    ARRAY an_array
                    an_array[1,1] = "ACTIVE"
                    an_array[1,2] = "ACTIVE"
                    an_array[2,1] = C_DELETE_FLAG
                    an_array[2,2] = C_DELETE_FLAG

                ELSE

                    i             = SIZE_OF_ARRAY ( an_array ) + 1
                    an_array[i,1] = "ACTIVE"
                    an_array[i,2] = "ACTIVE"

                ENDIF

            ELSEIF source_mode = C_TABLESET_ARCHIVE THEN    { archives depend on base table }

                IF ( a_removeflag <> EMPTY ) THEN

                    ARRAY an_array
                    an_array[1,1] = "ACTIVE"
                    an_array[1,2] = "ACTIVE"
                    an_array[2,1] = C_DELETE_FLAG
                    an_array[2,2] = C_DELETE_FLAG

                ELSE

                    i             = SIZE_OF_ARRAY ( an_array ) + 1
                    an_array[i,1] = C_DELETE_FLAG
                    an_array[i,2] = C_DELETE_FLAG

                    i             = i + 1
                    an_array[i,1] = "ACTIVE"
                    an_array[i,2] = "ACTIVE"

                    i             = i + 1
                    an_array[i,1] = "DEFAULT_TABLE_SET"
                    an_array[i,2] = "DEFAULT_TABLE_SET"

                ENDIF

            ELSE                                            { retain can only move to active }

                IF ( INDEX ( a_save_base, "PDS_STUDY" ) > 0 ) THEN

                    ARRAY an_array
                    an_array[1,1] = ""
                    an_array[1,2] = ""

                ELSEIF ( INDEX ( a_save_base, "JOB_HEADER" ) > 0 ) THEN


                    ARRAY an_array
                    an_array[1,1] = "ACTIVE"
                    an_array[1,2] = "ACTIVE"

                    an_array[2,1] = "DEFAULT_TABLE_SET"
                    an_array[2,2] = "DEFAULT_TABLE_SET"

                ENDIF

            ENDIF

        ELSE

            cur_val = internal_translate_message ( "LIT_AUTO_COMMIT_HEADER_REQUIRED_FIELD" )

            fm(cur_val)

        ENDIF   { a_source empty or BLANK }

        { ----------------------------------------------------------- }
        { Finally, we get to ask with these choices...                }
        { ----------------------------------------------------------- }

        PROMPT FOR cur_val ON LINE row FROM column TO column + cell_width - 1 IN WINDOW screen CHOOSE OUTOF an_array
        WITH ( value = prev_val )

        IF lastkey <> "EXIT" THEN

            IF ( cur_val <> prev_val ) THEN

                ASSIGN auto_commit_header.commit_destination = cur_val

            ENDIF

        ENDIF

    ENDIF  { is_display }

ENDROUTINE { prompt_auto_commit_header_commit_destination }

{*********************************************************************************}

ROUTINE prompt_AUTO_COMMIT_HEADER_commit_view ( VALUE column     ,
                                                VALUE row        ,
                                                VALUE cell_width ,
                                                      screen     ,
                                                VALUE is_display )

    DECLARE cur_val    ,
                prev_val   ,
                base_table ,
                view_array ,
                a_view     ,
        i2

    base_table = STRIP ( SELECT auto_commit_header.base_table )
    prev_val   = SELECT auto_commit_header.commit_view
    cur_val    = prev_val

    IF ( is_display ) THEN

        DISPLAY prev_val ON LINE row FROM column TO column + cell_width - 1 IN WINDOW screen

    ELSE

        ARRAY view_array

        i2     = 0
        a_view = SELECT 'C_SMP_TABLE'.SYSTEM_TABLE WHERE VIEW_ON_TABLES LIKE "%":base_table:"%"

        IF ( NOT BLANK ( base_table ) ) THEN

            WHILE ( a_view <> EMPTY ) DO

                i2               = i2 + 1
                view_array[i2,1] = a_view
                view_array[i2,2] = a_view

                NEXT 'C_SMP_TABLE'
                a_view = SELECT 'C_SMP_TABLE'.SYSTEM_TABLE

            ENDWHILE

        ENDIF  { BASE TABLE CANNOT BE BLANK }

        { -------------------------------------- }
        { Allow blank to remove assignment       }
        { -------------------------------------- }

        i2               = i2 + 1
        view_array[i2,1] = ""
        view_array[i2,2] = ""

        PROMPT FOR cur_val ON LINE row FROM column TO column + cell_width - 1 IN WINDOW screen CHOOSE OUTOF view_array
        WITH ( value = prev_val )

        IF lastkey <> "EXIT" THEN

            IF ( cur_val <> prev_val ) THEN

                ASSIGN auto_commit_header.commit_view = cur_val

            ENDIF

        ENDIF

    ENDIF  { is_display }

ENDROUTINE { prompt_auto_commit_header_commit_view }

{*******************************************************************************
*
*
*                      L T E   P A G E   2    R O U T I N E S
*
*
*******************************************************************************}

ROUTINE internal_display_file ( self )

    IF FILE EXISTS ( self.user_info ) THEN
        WriteToLog("FILE SEND ":self.user_info:", DISPLAY/")
        FILE SEND self.user_info, "DISPLAY/"
    ELSE
        fm("AUTO_COMMIT_FILE_NOT_FOUND" : self.user_info)
    ENDIF

    RETURN ( TRUE )

ENDROUTINE  { internal_display_file }

{******************************************************************************}

ROUTINE internal_set_system_field ( a_table )

    DECLARE a_field

    a_field = ""

    { ------------------------------------------------------- }
    { default system tables on all systems                    }
    { ------------------------------------------------------- }

    IF     ( a_table = "AUDIT_DATA"            ) THEN

        a_field = a_table

    ELSEIF ( a_table = "AUDIT_EVENT"           ) THEN

        a_field = a_table

    ELSEIF ( a_table = "AUDIT_TRANSACTION"     ) THEN

        a_field = a_table

    ELSEIF ( a_table = "ESIG_DATA"             ) THEN

        a_field = a_table

    ELSEIF ( a_table = "ESIG_EVENT"            ) THEN

        a_field = a_table

    ELSEIF ( a_table = "INCIDENTS"             ) THEN

        a_field = a_table

    ELSEIF ( a_table = "INC_CHECKLIST_RESULTS" ) THEN

        a_field = a_table

    ELSEIF ( a_table = "INSPECTORS"            ) THEN

        a_field = a_table

    ELSEIF ( a_table = "WORKSHEET"             ) THEN

        a_field = a_table

    ELSEIF ( a_table = "LABELPRINT"            ) THEN

        a_field = a_table

    ELSEIF ( a_table = "LABELPRINT_LINES"      ) THEN

        a_field = a_table

    ENDIF

    RETURN ( a_field )

ENDROUTINE    { internal_set_system_field }

{******************************************************************************}

ROUTINE internal_array_slice (       test_array  ,
                               VALUE nested_id   ,
                                     index_found )


    DECLARE count,
                retval

    retval      = FALSE
    count       = 0
    index_found = 0

    IF ( SIZE_OF_ARRAY ( test_array ) > 0 ) THEN

        WHILE ( count < SIZE_OF_ARRAY ( test_array ) ) DO

            count = count + 1

            IF ( test_array[count] = nested_id ) THEN

                retval      = TRUE
                index_found = count
                count       = SIZE_OF_ARRAY ( test_array )  { get outta while }

            ENDIF

        ENDWHILE

    ENDIF

    RETURN ( retval )

ENDROUTINE   { internal_array_slice }

{******************************************************************************}

ROUTINE internal_array_2_slice (       test_array    ,
                                 VALUE nested_id     ,
                                       index_found   ,
                                 VALUE array_element )


    DECLARE count,
                retval

    retval      = FALSE
    count       = 0
    index_found = 0

    IF ( SIZE_OF_ARRAY ( test_array ) > 0 ) THEN

        WHILE ( count < SIZE_OF_ARRAY ( test_array ) ) DO

            count = count + 1

            IF ( test_array[count,array_element] = nested_id ) THEN

                retval      = TRUE
                index_found = count
                count       = SIZE_OF_ARRAY ( test_array )  { get outta while }

            ENDIF

        ENDWHILE

    ENDIF

    IF NOT retval THEN
        index_found = SIZE_OF_ARRAY ( test_array ) + 1
    ENDIF

    RETURN ( retval )

ENDROUTINE   { internal_array_2_slice }

{*******************************************************************************
*
*                            I N T E R F A C E
*                             R O U T I N E S
*
* The following routines are provided as call back points for LTE processing
*
*******************************************************************************}

ROUTINE validation_routine

    DECLARE a_field, a_table, labtable

    ret_val = TRUE
    a_table = "AUTO_COMMIT_HEADER"

    labtablib_get_labtable ( labtable )

    IF labtable.name_of_table = a_table THEN

        a_field = SELECT AUTO_COMMIT_HEADER.BASE_TABLE

        IF ( a_field = EMPTY ) OR ( BLANK ( a_field ) ) THEN

            ret_val = FALSE
            tmp     = internal_translate_message ("LIT_LABTABLE_ENTRY_REQUIRED")
            fm(tmp:" ":STRIP(a_table):" BASE_TABLE")

        ENDIF

        IF ( ret_val ) THEN

            a_field = SELECT AUTO_COMMIT_HEADER.COMMIT_VIEW

            IF ( a_field = EMPTY ) OR ( BLANK ( a_field ) ) THEN

                ret_val = FALSE
                tmp     = internal_translate_message ("LIT_LABTABLE_ENTRY_REQUIRED")
                fm(tmp:" ":STRIP(a_table):" COMMIT_VIEW")

            ENDIF

        ENDIF

        IF ( ret_val ) THEN

            a_field = SELECT AUTO_COMMIT_HEADER.COMMIT_SOURCE

            IF ( a_field = EMPTY ) OR ( BLANK ( a_field ) ) THEN

                ret_val = FALSE
                tmp     = internal_translate_message ("LIT_LABTABLE_ENTRY_REQUIRED")
                fm(tmp:" ":STRIP(a_table):" COMMIT_SOURCE")

            ENDIF

        ENDIF

        IF ( ret_val ) THEN

            a_field = SELECT AUTO_COMMIT_HEADER.COMMIT_DESTINATION

            IF ( a_field = EMPTY ) OR ( BLANK ( a_field ) ) THEN

                ret_val = FALSE
                tmp     = internal_translate_message ("LIT_LABTABLE_ENTRY_REQUIRED")
                fm(tmp:" ":STRIP(a_table):" COMMIT_DESTINATION")

            ENDIF

        ENDIF


    ENDIF

    RETURN ( ret_val )

ENDROUTINE  { validation_routine - called by labtablib }

{******************************************************************************}

ROUTINE prompt_object_routine (       prompt_object ,
                                VALUE key0_count    ,
                                VALUE operation     )

    DECLARE labtable

    labtablib_get_labtable ( labtable )

    { -------------------------------------------------------------------- }
    { Disable RMB editing on any record at all - only table loaded         }
    { -------------------------------------------------------------------- }

    IF ( labtable.name_of_table = "AUTO_COMMIT_HEADER" ) THEN

        array_select_add ( prompt_object.mandatory_array, ARRAY_SELECT_NE, "COMMIT_DESTINATION", "EXPORT" )
        array_select_add ( prompt_object.mandatory_array, ARRAY_SELECT_NE, "COMMIT_DESTINATION", "REMOVE" )

    ENDIF  { prompts on special tables }

    array_select_add ( prompt_object.select_array, ARRAY_SELECT_EQ, "ENABLE_RMB", FALSE )

ENDROUTINE    { prompt_object_routine = called by labtablib }

{******************************************************************************}

ROUTINE update_routine ( labtable )

    retval = TRUE

    IF ( INDEX ( labtable.identity, "RMB" ) > 0 ) THEN

        ASSIGN AUTO_COMMIT_HEADER.ENABLE_RMB        = TRUE
        ASSIGN AUTO_COMMIT_HEADER.MANUAL_BACKGROUND = TRUE

    ELSEIF ( INDEX ( labtable.identity, "WDT" ) > 0 ) THEN

        ASSIGN AUTO_COMMIT_HEADER.ENABLE_RMB        = FALSE
        ASSIGN AUTO_COMMIT_HEADER.MANUAL_BACKGROUND = FALSE

    ELSE

        ASSIGN AUTO_COMMIT_HEADER.ENABLE_RMB        = FALSE
        ASSIGN AUTO_COMMIT_HEADER.MANUAL_BACKGROUND = TRUE

    ENDIF

        RETURN ( retval )

ENDROUTINE  {  update_routine = called by labtablib }

{******************************************************************************}

ROUTINE read_data_routine (       labtable  ,
                            VALUE operation )

ENDROUTINE   { read_data_routine = called by labtablib }

{******************************************************************************}

ROUTINE validate_new_id_routine ( VALUE new_id )

    RETURN ( TRUE )

ENDROUTINE    { validate_new_id_routine = called by labtablib }

{******************************************************************************}

ROUTINE remove_restore_routine ( labtable )

        RETURN ( TRUE )

ENDROUTINE   { remove_restore_routine = called by labtablib }

{******************************************************************************}

ROUTINE internal_translate_message ( VALUE message )

    DECLARE val        ,
                 msg_pointer,
                 stlen      ,
                 save_text  ,
                 a_amper    ,
                 do_pointer

    { -------------------------------------------------------------------------- }
    { May not have the global yet - so just get the setting directly             }
    { -------------------------------------------------------------------------- }

    do_pointer  = GLOBAL ( C_MESSAGE_POINTERS )
    save_text   = GLOBAL ( "FORMAT_TEXT" )
    message     = STRIP ( message )
    a_amper     = INDEX ( message, "&&" )
    stlen       = STRINGLENGTH ( message )

    { --------------------------------------------------------------------------------------- }
    { Messages can be displayed as pointers, or can be MESSAGE_PRN_###, or a specific message }
    { --------------------------------------------------------------------------------------- }

    IF NOT do_pointer THEN

        SET FORMAT "9999"

        { ------------------------------------------------------------------------------ }
        { Message is like GET_USER_MESSAGE ( an_id, 2 )                                  }
        { ------------------------------------------------------------------------------ }

        IF ( a_amper > 1 ) THEN

            msg_pointer = STRIP ( RIGHTSTRING ( message, stlen - ( a_amper + 1 ) ) )
            message     = STRIP ( LEFTSTRING ( message, a_amper - 1 ) )

            IF ( NUMTEXT ( msg_pointer ) ) THEN

                msg_pointer = NUMERIC ( msg_pointer )

            ELSE

                msg_pointer = 1

            ENDIF

        ELSE

            msg_pointer = 1

        ENDIF

        { --------------------------------------------------------- }
        { If message is MESSAGE_PRN do one way, else the other way  }
        { --------------------------------------------------------- }

        IF ( INDEX ( message, "MESSAGE_PRN" ) > 0 ) THEN

            message = ROUND ( message # "MESSAGE_PRN_" )

            val = GET MESSAGE ( message, msg_pointer )

        ELSE

            val = GET_USER_MESSAGE ( message, msg_pointer )


        ENDIF

        { --------------------------------------------------------- }
        { Any mistake then return the message pointer...            }
        { --------------------------------------------------------- }

        IF val = ERROR THEN

            val = STRIP ( message )

        ENDIF

        SET FORMAT save_text

    ELSE

        val = STRIP ( message )

    ENDIF   { when do_pointer do not do anything... allows you to run application with message id's }

    RETURN ( val )

ENDROUTINE    { internal_translate_message }

{*******************************************************************************}

ROUTINE internal_log_message (       ac_object  ,
                               VALUE tmpString  ,
                               VALUE msg_Level  )

    DECLARE msg, status

    msg = NOW:" | ":msg_level:" | ":tmpString

    IF ( msg_Level >= ac_object.debug_level ) THEN

        FILE WRITE ac_object.ace_logfile, msg, status

    ENDIF

    IF ( msg_Level >= C_MSG_MED ) THEN

        window_set_status ( msg )

    ENDIF

ENDROUTINE { internal_log_message }

{******************************************************************************}

ROUTINE internal_create_directory ( VALUE a_dir )

    DECLARE fso

    retval = TRUE

    IF NOT FILE EXISTS ( a_dir ) THEN

        CREATE OBJECT CLASS_STD_OLE_AUTOMATION_SERVER,fso
            fso.create("Scripting.FileSystemObject")

        retval = fso.CreateFolder ( a_dir )

        IF ( retval <> EMPTY ) THEN

            retval = TRUE

        ELSE

            retval = FALSE

        ENDIF

    ENDIF

    RETURN ( retval )

ENDROUTINE   { internal_create_directory }

{*******************************************************************************}

ROUTINE internal_initialize_messages ( msg )

    DEFINE CLASS CLASS_MESSAGES
    PROPERTIES
            "01"   ,
            "02"   ,
            "03"   ,
            "04"   ,
            "05"   ,
            "06"   ,
            "07"   ,
            "08"   ,
            "09"   ,
            "10"   ,
            "11"   ,
            "12"   ,
            "13"   ,
            "14"   ,
            "15"   ,
            "16"   ,
            "17"   ,
            "18"   ,
            "19"   ,
            "20"   ,
            "21"   ,
            "22"   ,
            "23"   ,
            "24"   ,
            "25"   ,
            "26"   ,
            "27"   ,
            "28"   ,
            "29"   ,
            "30"   ,
            "31"   ,
            "32"   ,
            "33"   ,
            "34"   ,
            "35"   ,
            "36"   ,
            "37"   ,
            "38"   ,
            "39"   ,
            "40"   ,
            "41"   ,
            "42"   ,
            "43"   ,
            "44"   ,
            "45"   ,
            "46"   ,
            "47"   ,
            "48"   ,
            "49"   ,
            "50"   ,
            "51"   ,
            "52"   ,
            "53"   ,
            "54"   ,
            "55"   ,
            "56"   ,
            "57"   ,
            "58"   ,
            "59"   ,
            "60"   ,
            "61"   ,
            "62"   ,
            "63"   ,
            "64"   ,
            "65"   ,
            "66"   ,
            "67"   ,
            "68"   ,
            "69"   ,
            "70"   ,
            "71"   ,
            "72"   ,
            "73"   ,
            "74"   ,
            "75"   ,
            "76"   ,
            "77"   ,
            "78"   ,
            "79"   ,
            "80"   ,
            "81"   ,
            "82"   ,
            "83"   ,
            "84"   ,
            "85"   ,
            "86"   ,
            "87"   ,
            "88"   ,
            "89"   ,
            "90"   ,
            "91"   ,
            "92"   ,
            "93"   ,
            "94"   ,
            "95"   ,
            "96"   ,
            "97"   ,
            "98"   ,
            "99"   ,
            "100"  ,
            "101"  ,
            "102"  ,
            "103"  ,
            "104"  ,
            "105"  ,
            "106"  ,
            "107"  ,
            "108"  ,
            "109"  ,
            "110"  ,
            "111"  ,
            "112"  ,
            "113"  ,
            "114"  ,
            "115"  ,
            "116"  ,
            "117"  ,
            "118"  ,
            "119"  ,
            "120"  ,
            "121"  ,
            "122"  ,
            "123"  ,
            "124"  ,
            "125"  ,
            "126"  ,
            "127"  ,
            "128"  ,
            "129"  ,
            "130"
    END CLASS

    CREATE OBJECT CLASS_MESSAGES, msg

    msg.01  = internal_translate_message ( "LIT_AUTO_COMMIT_01" )
    msg.02  = internal_translate_message ( "LIT_AUTO_COMMIT_02" )
    msg.03  = internal_translate_message ( "LIT_AUTO_COMMIT_03" )
    msg.04  = internal_translate_message ( "LIT_AUTO_COMMIT_04" )
    msg.05  = internal_translate_message ( "LIT_AUTO_COMMIT_05" )
    msg.06  = internal_translate_message ( "LIT_AUTO_COMMIT_06" )
    msg.07  = internal_translate_message ( "LIT_AUTO_COMMIT_07" )
    msg.08  = internal_translate_message ( "LIT_AUTO_COMMIT_08" )
    msg.09  = internal_translate_message ( "LIT_AUTO_COMMIT_09" )
    msg.10  = internal_translate_message ( "LIT_AUTO_COMMIT_10" )
    msg.11  = internal_translate_message ( "LIT_AUTO_COMMIT_11" )
    msg.12  = internal_translate_message ( "LIT_AUTO_COMMIT_12" )
    msg.13  = internal_translate_message ( "LIT_AUTO_COMMIT_13" )
    msg.14  = internal_translate_message ( "LIT_AUTO_COMMIT_14" )
    msg.15  = internal_translate_message ( "LIT_AUTO_COMMIT_15" )
    msg.16  = internal_translate_message ( "LIT_AUTO_COMMIT_16" )
    msg.17  = internal_translate_message ( "LIT_AUTO_COMMIT_17" )
    msg.18  = internal_translate_message ( "LIT_AUTO_COMMIT_18" )
    msg.19  = internal_translate_message ( "LIT_AUTO_COMMIT_19" )
    msg.20  = internal_translate_message ( "LIT_AUTO_COMMIT_20" )
    msg.21  = internal_translate_message ( "LIT_AUTO_COMMIT_21" )
    msg.22  = internal_translate_message ( "LIT_AUTO_COMMIT_22" )
    msg.23  = internal_translate_message ( "LIT_AUTO_COMMIT_23" )
    msg.24  = internal_translate_message ( "LIT_AUTO_COMMIT_24" )
    msg.25  = internal_translate_message ( "LIT_AUTO_COMMIT_25" )
    msg.26  = internal_translate_message ( "LIT_AUTO_COMMIT_26" )
    msg.27  = internal_translate_message ( "LIT_AUTO_COMMIT_27" )
    msg.28  = internal_translate_message ( "LIT_AUTO_COMMIT_28" )
    msg.29  = internal_translate_message ( "LIT_AUTO_COMMIT_29" )
    msg.30  = internal_translate_message ( "LIT_AUTO_COMMIT_30" )
    msg.31  = internal_translate_message ( "LIT_AUTO_COMMIT_31" )
    msg.32  = internal_translate_message ( "LIT_AUTO_COMMIT_32" )
    msg.33  = internal_translate_message ( "LIT_AUTO_COMMIT_33" )
    msg.34  = internal_translate_message ( "LIT_AUTO_COMMIT_34" )
    msg.35  = internal_translate_message ( "LIT_AUTO_COMMIT_35" )
    msg.36  = internal_translate_message ( "LIT_AUTO_COMMIT_36" )
    msg.37  = internal_translate_message ( "LIT_AUTO_COMMIT_37" )
    msg.38  = internal_translate_message ( "LIT_AUTO_COMMIT_38" )
    msg.39  = internal_translate_message ( "LIT_AUTO_COMMIT_39" )
    msg.40  = internal_translate_message ( "LIT_AUTO_COMMIT_40" )
    msg.41  = internal_translate_message ( "LIT_AUTO_COMMIT_41" )
    msg.42  = internal_translate_message ( "LIT_AUTO_COMMIT_42" )
    msg.43  = internal_translate_message ( "LIT_AUTO_COMMIT_43" )
    msg.44  = internal_translate_message ( "LIT_AUTO_COMMIT_44" )
    msg.45  = internal_translate_message ( "LIT_AUTO_COMMIT_45" )
    msg.46  = internal_translate_message ( "LIT_AUTO_COMMIT_46" )
    msg.47  = internal_translate_message ( "LIT_AUTO_COMMIT_47" )
    msg.48  = internal_translate_message ( "LIT_AUTO_COMMIT_48" )
    msg.49  = internal_translate_message ( "LIT_AUTO_COMMIT_49" )
    msg.50  = internal_translate_message ( "LIT_AUTO_COMMIT_50" )
    msg.51  = internal_translate_message ( "LIT_AUTO_COMMIT_51" )
    msg.52  = internal_translate_message ( "LIT_AUTO_COMMIT_52" )
    msg.53  = internal_translate_message ( "LIT_AUTO_COMMIT_53" )
    msg.54  = internal_translate_message ( "LIT_AUTO_COMMIT_54" )
    msg.55  = internal_translate_message ( "LIT_AUTO_COMMIT_55" )
    msg.56  = internal_translate_message ( "LIT_AUTO_COMMIT_56" )
{BLOCK edited by CONSULT-02 to avoid errors.}
    msg_57  = internal_translate_message ( "LIT_AUTO_COMMIT_57" )
    {msg_58  = internal_translate_message ( "LIT_AUTO_COMMIT_58" )
     msg_59  = internal_translate_message ( "LIT_AUTO_COMMIT_59" )}
    msg_60  = internal_translate_message ( "LIT_AUTO_COMMIT_60" )
    msg_61  = internal_translate_message ( "LIT_AUTO_COMMIT_61" )
    msg_62  = internal_translate_message ( "LIT_AUTO_COMMIT_62" )
    msg_63  = internal_translate_message ( "LIT_AUTO_COMMIT_63" )
    msg_64  = internal_translate_message ( "LIT_AUTO_COMMIT_64" )
    msg_65  = internal_translate_message ( "LIT_AUTO_COMMIT_65" )
    msg_66  = internal_translate_message ( "LIT_AUTO_COMMIT_66" )
    {msg_67  = internal_translate_message ( "LIT_AUTO_COMMIT_67" )}
    msg_68  = internal_translate_message ( "LIT_AUTO_COMMIT_68" )
    msg_69  = internal_translate_message ( "LIT_AUTO_COMMIT_69" )
    msg_70  = internal_translate_message ( "LIT_AUTO_COMMIT_70" )
    msg_71  = internal_translate_message ( "LIT_AUTO_COMMIT_71" )
    msg_72  = internal_translate_message ( "LIT_AUTO_COMMIT_72" )
    msg_73  = internal_translate_message ( "LIT_AUTO_COMMIT_73" )
    msg_74  = internal_translate_message ( "LIT_AUTO_COMMIT_74" )
    msg_75  = internal_translate_message ( "LIT_AUTO_COMMIT_75" )
    msg_76  = internal_translate_message ( "LIT_AUTO_COMMIT_76" )
    msg_77  = internal_translate_message ( "LIT_AUTO_COMMIT_77" )
    msg_78  = internal_translate_message ( "LIT_AUTO_COMMIT_78" )
    msg_79  = internal_translate_message ( "LIT_AUTO_COMMIT_79" )
    msg_80  = internal_translate_message ( "LIT_AUTO_COMMIT_80" )
    msg_81  = internal_translate_message ( "LIT_AUTO_COMMIT_81" )
    msg_82  = internal_translate_message ( "LIT_AUTO_COMMIT_82" )
    msg_83  = internal_translate_message ( "LIT_AUTO_COMMIT_83" )
    msg_84  = internal_translate_message ( "LIT_AUTO_COMMIT_84" )
    msg_85  = internal_translate_message ( "LIT_AUTO_COMMIT_85" )
    msg_86  = internal_translate_message ( "LIT_AUTO_COMMIT_86" )
    msg_87  = internal_translate_message ( "LIT_AUTO_COMMIT_87" )
    msg_88  = internal_translate_message ( "LIT_AUTO_COMMIT_88" )
    msg_89  = internal_translate_message ( "LIT_AUTO_COMMIT_89" )
    {msg_90  = internal_translate_message ( "LIT_AUTO_COMMIT_90" )}
    msg_91  = internal_translate_message ( "LIT_AUTO_COMMIT_91" )
    msg_92  = internal_translate_message ( "LIT_AUTO_COMMIT_92" )
    msg_93  = internal_translate_message ( "LIT_AUTO_COMMIT_93" )
    msg_94  = internal_translate_message ( "LIT_AUTO_COMMIT_94" )
    msg_95  = internal_translate_message ( "LIT_AUTO_COMMIT_95" )
    msg_96  = internal_translate_message ( "LIT_AUTO_COMMIT_96" )
    msg_97  = internal_translate_message ( "LIT_AUTO_COMMIT_97" )
    msg_98  = internal_translate_message ( "LIT_AUTO_COMMIT_98" )
    msg_99  = internal_translate_message ( "LIT_AUTO_COMMIT_99" )
    msg_100 = internal_translate_message ( "LIT_AUTO_COMMIT_100" )
    {msg_101 = internal_translate_message ( "LIT_AUTO_COMMIT_101" )
     msg_102 = internal_translate_message ( "LIT_AUTO_COMMIT_102" )}
    msg_103 = internal_translate_message ( "LIT_AUTO_COMMIT_103" )
    msg_104 = internal_translate_message ( "LIT_AUTO_COMMIT_104" )
    msg_105 = internal_translate_message ( "LIT_AUTO_COMMIT_105" )
    msg_106 = internal_translate_message ( "LIT_AUTO_COMMIT_106" )
    msg_107 = internal_translate_message ( "LIT_AUTO_COMMIT_107" )
    msg_108 = internal_translate_message ( "LIT_AUTO_COMMIT_108" )
    msg_109 = internal_translate_message ( "LIT_AUTO_COMMIT_109" )
    msg_110 = internal_translate_message ( "LIT_AUTO_COMMIT_110" )
    msg_111 = internal_translate_message ( "LIT_AUTO_COMMIT_111" )
    msg_112 = internal_translate_message ( "LIT_AUTO_COMMIT_112" )
    msg_113 = internal_translate_message ( "LIT_AUTO_COMMIT_113" )
    {msg_114 = internal_translate_message ( "LIT_AUTO_COMMIT_114" )}
    msg_115 = internal_translate_message ( "LIT_AUTO_COMMIT_115" )
    msg_116 = internal_translate_message ( "LIT_AUTO_COMMIT_116" )
    msg_117 = internal_translate_message ( "LIT_AUTO_COMMIT_117" )
    msg_118 = internal_translate_message ( "LIT_AUTO_COMMIT_118" )
    msg_119 = internal_translate_message ( "LIT_AUTO_COMMIT_119" )
    msg_120 = internal_translate_message ( "LIT_AUTO_COMMIT_120" )
    msg_121 = internal_translate_message ( "LIT_AUTO_COMMIT_121" )
    msg_122 = internal_translate_message ( "LIT_AUTO_COMMIT_122" )
    {msg_123 = internal_translate_message ( "LIT_AUTO_COMMIT_123" )}
    msg_124 = internal_translate_message ( "LIT_AUTO_COMMIT_124" )
    msg_125 = internal_translate_message ( "LIT_AUTO_COMMIT_125" )
    msg_126 = internal_translate_message ( "LIT_AUTO_COMMIT_126" )
    msg_127 = internal_translate_message ( "LIT_AUTO_COMMIT_127" )
    msg_128 = internal_translate_message ( "LIT_AUTO_COMMIT_128" )
    msg_129 = internal_translate_message ( "LIT_AUTO_COMMIT_129" )
    msg_130 = internal_translate_message ( "LIT_AUTO_COMMIT_130" )
{END BLOCK edited by CONSULT-02}

ENDROUTINE  { internal_initialize_messages }

{******************************************************************************}

ROUTINE internal_input_ach_identity ( VALUE a_view        ,
                                      VALUE a_msg_1      ,
                                      VALUE a_msg_2      ,
                                            select_array ,
                                            return_id    )

    ret_val = vgl_prompt_in_window_criteria ( a_view       ,
                                              a_msg_1      ,
                                              a_msg_2      ,
                                              ""           ,
                                              select_array ,
                                              return_id    )

    RETURN ( ret_val )

ENDROUTINE   { internal_input_ach_identity  }

{********************************************************************************}
{                                                                                }
{                                                                                }
{                                                                                }
{     THE OLD FASHIONED WAY TO DO LTE'S FOR THOSE FOLKS NOT USING INTERFACE      }
{                                                                                }
{                                                                                }
{                                                                                }
{********************************************************************************}

ROUTINE internal_lte_table_setup ( VALUE a_table_name ,
                                   VALUE option       ,
                                   VALUE operation    )

    name_of_table           = a_table_name
    directory               = EMPTY
    extn                    = EMPTY
    help_context            = EMPTY
    default_value           = EMPTY
    footer_mess             = EMPTY
    display_footer_mess     = EMPTY
    input_mess              = internal_translate_message ( "LIT_AUTO_COMMIT_HEADER" )
    header_mess             = internal_translate_message ( "LIT_AUTO_COMMIT_HEADER" )
    displayed_name_of_table = internal_translate_message ( "LIT_AUTO_COMMIT_HEADER" )


    ARRAY labtable_messages       ARRAY_SIZE ( 0 )
        labtable_messages [ IDENTITY_MESSAGE ]    = get message ( 2545 , 1 ) { "Identity" }
        labtable_messages [ MOD_ON_MESSAGE   ]    = get message ( 2546 , 1 ) { "Modified On" }
        labtable_messages [ MOD_BY_MESSAGE   ]    = get message ( 2547 , 1 ) { "Modified By" }
        labtable_messages [ READ_MESSAGE     ]    = get message ( 2566 , 1 ) { "Labtable Read Transaction" }
        labtable_messages [ WRITE_MESSAGE    ]    = get message ( 2567 , 1 ) { "Labtable Write Transaction" }


    ARRAY prompt_details ARRAY_SIZE ( 0, 6 )

        prompt_details [ 1, MESSAGE_POSITION    ] = internal_translate_message ( "LIT_AUTO_COMMIT_HEADER_GROUP_ID" )
        prompt_details [ 1, FIELD_NAME_POSITION ] = "GROUP_ID"

        prompt_details [ 2, MESSAGE_POSITION    ] = internal_translate_message ( "LIT_AUTO_COMMIT_HEADER_DESCRIPTION" )
        prompt_details [ 2, FIELD_NAME_POSITION ] = "DESCRIPTION"

        prompt_details [ 3, MESSAGE_POSITION    ] = internal_translate_message ( "LIT_AUTO_COMMIT_HEADER_BASE_TABLE" )
        prompt_details [ 3, FIELD_NAME_POSITION ] = "BASE_TABLE"
        prompt_details [ 3, TYPE_POSITION       ] = "ROUTINE"
        prompt_details [ 3, LIBRARY_POSITION    ] = GLOBAL( "current_library" )
        prompt_details [ 3, ROUTINE_POSITION    ] = "PROMPTAUTOCOMMITHEADERBASETABLE"

        prompt_details [ 4, MESSAGE_POSITION    ] = internal_translate_message ( "LIT_AUTO_COMMIT_HEADER_COMMIT_VIEW" )
        prompt_details [ 4, FIELD_NAME_POSITION ] = "COMMIT_VIEW"
        prompt_details [ 4, TYPE_POSITION       ] = "ROUTINE"
        prompt_details [ 4, LIBRARY_POSITION    ] = GLOBAL( "current_library" )
        prompt_details [ 4, ROUTINE_POSITION    ] = "PROMPTAUTOCOMMITHEADERCOMMITVIEW"

        prompt_details [ 5, MESSAGE_POSITION    ] = internal_translate_message ( "LIT_AUTO_COMMIT_HEADER_COMMIT_SOURCE" )
        prompt_details [ 5, FIELD_NAME_POSITION ] = "COMMIT_SOURCE"
        prompt_details [ 5, TYPE_POSITION       ] = "ROUTINE"
        prompt_details [ 5, LIBRARY_POSITION    ] = GLOBAL( "current_library" )
        prompt_details [ 5, ROUTINE_POSITION    ] = "PROMPTAUTOCOMMITHEADERCOMMITSOURCE"

        prompt_details [ 6, MESSAGE_POSITION    ] = internal_translate_message ( "LIT_AUTO_COMMIT_HEADER_COMMIT_DESTINATION" )
        prompt_details [ 6, FIELD_NAME_POSITION ] = "COMMIT_DESTINATION"
        prompt_details [ 6, TYPE_POSITION       ] = "ROUTINE"
        prompt_details [ 6, LIBRARY_POSITION    ] = GLOBAL( "current_library" )
        prompt_details [ 6, ROUTINE_POSITION    ] = "PROMPTAUTOCOMMITHEADERCOMMITDESTINATION"

        prompt_details [ 7, MESSAGE_POSITION    ] = internal_translate_message ( "LIT_AUTO_COMMIT_HEADER_MAN_BACK" )
        prompt_details [ 7, FIELD_NAME_POSITION ] = "MANUAL_BACKGROUND"

        prompt_details [ 8, MESSAGE_POSITION    ] = internal_translate_message ( "LIT_AUTO_COMMIT_HEADER_ENABLED" )
        prompt_details [ 8, FIELD_NAME_POSITION ] = "ENABLED"

    ARRAY fields_to_output
        fields_to_output [ 1 ]  = 1
        fields_to_output [ 2 ]  = 2
        fields_to_output [ 3 ]  = 3
        fields_to_output [ 4 ]  = 4
        fields_to_output [ 5 ]  = 5
        fields_to_output [ 6 ]  = 6
        fields_to_output [ 7 ]  = 7
        fields_to_output [ 8 ]  = 8

    ARRAY special_actions_report  ARRAY_SIZE ( 0, 4 )
        special_actions_report [ 1 , CHARACTER_POSITION ] = "*"
        special_actions_report [ 1 , TITLE_POSITION     ] = GET MESSAGE ( 784 , 1 )

        special_actions_report [ 2 , CHARACTER_POSITION ] = "1"
        special_actions_report [ 2 , TITLE_POSITION     ] = internal_translate_message ( "LIT_AUTO_COMMIT_HEADER_COMMIT_CRITERIA" )
        special_actions_report [ 2 , LIBRARY_POSITION   ] = "LIT_AUTO_COMMIT"
        special_actions_report [ 2 , ROUTINE_POSITION   ] = "auto_commit_criteria"


ENDROUTINE   { table_setup LTE }

{********************************************************************************}

ROUTINE do_the_work  ( VALUE operation, VALUE option )

    DECLARE a_table

    a_table = SELECT MASTER_MENU.TABLE_NAME WHERE PROCEDURE_NUM = option

    internal_lte_table_setup ( a_table, option, operation )

    smp_lte_perform_option  ( name_of_table              ,
                              displayed_name_of_table    ,
                              prompt_details             ,
                              labtable_messages          ,
                              default_value              ,
                              input_mess                 ,
                              header_mess                ,
                              footer_mess                ,
                              display_footer_mess        ,
                              directory                  ,
                              extn                       ,
                              help_context               ,
                              global ("current_library") ,
                              fields_to_output           ,
                              special_actions_report     ,
                              operation                  )

ENDROUTINE { do_the_work LTE }
{********************************************************************************}
ROUTINE add_option ( option )
    do_the_work ( "add_ident", option )
ENDROUTINE
{********************************************************************************}
ROUTINE copy_option ( option )
    do_the_work ( "copy_ident", option )
ENDROUTINE
{********************************************************************************}
ROUTINE modify_option ( option )
    do_the_work ( "modify_ident", option )
ENDROUTINE
{********************************************************************************}
ROUTINE display_option ( option )
    do_the_work ( "display_ident", option )
ENDROUTINE
{********************************************************************************}
ROUTINE remove_option ( option )
    do_the_work ( "remove_ident", option )
ENDROUTINE
{********************************************************************************}
ROUTINE restore_option ( option )
    do_the_work ( "restore_ident", option )
ENDROUTINE
{********************************************************************************}
ROUTINE list_option ( option )
    do_the_work ( "list_idents", option )
ENDROUTINE
{********************************************************************************}
ROUTINE print_option ( option )
    do_the_work ( "print_ident", option )
ENDROUTINE
{********************************************************************************}
ROUTINE smp_lte_initialise
ENDROUTINE

{********************************************************************************}

ROUTINE auto_commit_criteria ( VALUE id        ,
                                     copy_id   ,
                               VALUE operation )

    DECLARE a_view

    ret_val = FALSE
    a_view  = PAD ( SELECT AUTO_COMMIT_HEADER.COMMIT_VIEW, " ", 20 )

    IF NOT BLANK ( a_view ) THEN

        IF NOT ( VALID_TABLE ( a_view ) ) THEN

            fm("LIT_LAB_AUTO_COMMIT_INVALID_VIEW")

        ELSE

            id     = C_CRITERIA_PREFIX : id
            id     = PAD ( SUBSTITUTE ( id, " ", "" ) , " ", 20 )
            id     = a_view : id

            { ------------------------------------------------------------------ }
            { We got something, now print or edit it                             }
            { ------------------------------------------------------------------ }

            CALL_ROUTINE "labtable_input" IN LIBRARY "$CRITERIA_EDIT" USING id, copy_id, operation RETURNING ret_val

        ENDIF { not a valid view }

    ENDIF  { view is blank }

    RETURN ( ret_val )

ENDROUTINE   { auto_commit_criteria }

{********************************************************************************}

ROUTINE auto_commit_criteria_test ( VALUE id        ,
                                          copy_id   ,
                                    VALUE operation )


    DECLARE a_TRUE  ,
                a_FALSE ,
                a_EMPTY ,
                a_file

    a_TRUE  = TRUE
    a_FALSE = FALSE
    a_EMPTY = EMPTY

    IF ( operation = "MODIFY" ) THEN

        PUSH_FILE_DESCRIPTOR ( "AUTO_COMMIT_HEADER", a_file )

        CALL_ROUTINE "interactive_commit" USING id, a_TRUE, a_EMPTY, a_FALSE, a_FALSE IN LIBRARY "LIT_AUTO_COMMIT"
        NEW CONTEXT

        POP_FILE_DESCRIPTOR ( a_file )

        id = SELECT AUTO_COMMIT_HEADER.IDENTITY FOR UPDATE WHERE IDENTITY = id

    ELSEIF ( operation = "READ_FOR_MODIFY" ) THEN

        internal_initialize_messages(msg)

    ENDIF

    RETURN ( TRUE )

ENDROUTINE   { auto_commit_criteria_test }

{********************************************************************************}
{                                                                                }
{                                                                                }
{                                                                                }
{                                                                                }
{             R O U T I N E S    F O R    R M B    E X P L O R E R               }
{                                                                                }
{                                                                                }
{                                                                                }
{                                                                                }
{********************************************************************************}

ROUTINE RMB_auto_commit_execution_details( explorer_rmb, record_object, collection )

    DECLARE the_id

    retval = TRUE

    collection.set_first()

    WHILE ( collection.current <> EMPTY ) & ( retval ) DO

        IF ( collection.table = "AUDIT_TRANSACTION" ) THEN
            the_id = SELECT AUDIT_TRANSACTION.TRANSACTION_NAME   IN OBJECT collection.current
        ELSEIF ( collection.table = "AUTO_COMMIT_EXECUTION" ) THEN
            the_id = SELECT AUTO_COMMIT_EXECUTION.ARCHIVE_REPORT IN OBJECT collection.current
        ELSE
            the_id = EMPTY
        ENDIF

        IF the_id <> EMPTY THEN

            IF FILE EXISTS ( the_id ) THEN
                WriteToLog("FILE SEND ":the_id:", DISPLAY/")
                FILE SEND the_id, "DISPLAY/"
            ELSE
                fm("LIT_AUTO_COMMIT_FILE_NOT_FOUND" : the_id)
            ENDIF

        ENDIF

        collection.set_next()

    ENDWHILE

    RETURN ( retval )

ENDROUTINE    { RMB_auto_commit_execution_details... }

{********************************************************************************}

ROUTINE RMB_auto_commit_execution_delete( explorer_rmb, record_object, collection )

    DECLARE the_id

    retval = TRUE

    collection.set_first()

    WHILE ( collection.current <> EMPTY ) & ( retval ) DO

        IF ( collection.table = "AUDIT_TRANSACTION" ) THEN
            the_id = SELECT AUDIT_TRANSACTION.TRANSACTION_NAME   IN OBJECT collection.current FOR UPDATE
        ELSEIF ( collection.table = "AUTO_COMMIT_EXECUTION" ) THEN
            the_id = SELECT AUTO_COMMIT_EXECUTION.ARCHIVE_REPORT IN OBJECT collection.current FOR UPDATE
        ELSE
            the_id = EMPTY
        ENDIF

        IF the_id <> EMPTY THEN

            collection.current.deleted = TRUE

        ENDIF

        collection.set_next()

    ENDWHILE

    RETURN ( retval )

ENDROUTINE    { RMB_auto_commit_execution_delete }

{********************************************************************************}

ROUTINE RMB_active_commit ( explorer_rmb, record_object, collection )

    ret_val = internal_entity_rmb ( explorer_rmb, record_object, collection, C_ACTIVE_TABLESET, C_COMMIT_TABLESET )

ENDROUTINE    { RMB_active_commit }

{********************************************************************************}

ROUTINE RMB_active_archive( explorer_rmb, record_object, collection )

    ret_val = internal_entity_rmb ( explorer_rmb, record_object, collection, C_ACTIVE_TABLESET, C_ARCHIVE_TABLESET )

ENDROUTINE    { RMB_active_archive }

{********************************************************************************}

ROUTINE RMB_active_retain ( explorer_rmb, record_object, collection )

    ret_val = internal_entity_rmb ( explorer_rmb, record_object, collection, C_ACTIVE_TABLESET, C_RETAIN_TABLESET )

ENDROUTINE    { RMB_active_retain }

{********************************************************************************}

ROUTINE RMB_active_delete ( explorer_rmb, record_object, collection )

    ret_val = internal_entity_rmb ( explorer_rmb, record_object, collection, C_ACTIVE_TABLESET, C_DELETE_TABLESET )

ENDROUTINE    { RMB_active_delete }

{********************************************************************************}

ROUTINE RMB_commit_archive ( explorer_rmb, record_object, collection )

    ret_val = internal_entity_rmb ( explorer_rmb, record_object, collection, C_COMMIT_TABLESET, C_ARCHIVE_TABLESET )

ENDROUTINE    { RMB_commit_archive }

{********************************************************************************}

ROUTINE RMB_commit_active ( explorer_rmb, record_object, collection )

    ret_val = internal_entity_rmb ( explorer_rmb, record_object, collection, C_COMMIT_TABLESET, C_ACTIVE_TABLESET )

ENDROUTINE    { RMB_commit_active }

{********************************************************************************}

ROUTINE RMB_commit_retain ( explorer_rmb, record_object, collection )

    ret_val = internal_entity_rmb ( explorer_rmb, record_object, collection, C_COMMIT_TABLESET, C_RETAIN_TABLESET )

ENDROUTINE    { RMB_commit_retain }

{********************************************************************************}

ROUTINE RMB_archive_delete ( explorer_rmb, record_object, collection )

    ret_val = internal_entity_rmb ( explorer_rmb, record_object, collection, C_ARCHIVE_TABLESET, C_DELETE_TABLESET )

ENDROUTINE    { RMB_archive_delete }

{********************************************************************************}

ROUTINE RMB_archive_active ( explorer_rmb, record_object, collection )

    ret_val = internal_entity_rmb ( explorer_rmb, record_object, collection, C_ARCHIVE_TABLESET, C_ACTIVE_TABLESET )

ENDROUTINE    { RMB_archive_active }

{********************************************************************************}

ROUTINE RMB_archive_commit ( explorer_rmb, record_object, collection )

    ret_val = internal_entity_rmb ( explorer_rmb, record_object, collection, C_ARCHIVE_TABLESET, C_COMMIT_TABLESET )

ENDROUTINE    { RMB_archive_commit }

{********************************************************************************}

ROUTINE RMB_archive_retain ( explorer_rmb, record_object, collection )

    ret_val = internal_entity_rmb ( explorer_rmb, record_object, collection, C_ARCHIVE_TABLESET, C_RETAIN_TABLESET )

ENDROUTINE    { RMB_archive_retain }

{********************************************************************************}

ROUTINE RMB_retain_active ( explorer_rmb, record_object, collection )

    ret_val = internal_entity_rmb ( explorer_rmb, record_object, collection, C_RETAIN_TABLESET, C_ACTIVE_TABLESET )

ENDROUTINE    { RMB_retain_active }

{********************************************************************************}

ROUTINE RMB_retain_commit ( explorer_rmb, record_object, collection )

    ret_val = internal_entity_rmb ( explorer_rmb, record_object, collection, C_RETAIN_TABLESET, C_COMMIT_TABLESET )

ENDROUTINE    { RMB_retain_commit }

{********************************************************************************}

ROUTINE RMB_active_export ( explorer_rmb, record_object, collection )

    ret_val = internal_entity_rmb ( explorer_rmb, record_object, collection, C_ACTIVE_TABLESET, C_TABLESET_EXPORT )

ENDROUTINE    { RMB_active_export }

{********************************************************************************}

ROUTINE internal_entity_rmb (       explorer_rmb  ,
                                    record_object ,
                                    collection    ,
                              VALUE a_source      ,
                              VALUE a_destination )

    DECLARE a_rec         ,
                a_table       ,
                key0_fields   ,
        a_mastermenu  ,
        a_basetable   ,
        a_array       ,
        ach_array     ,
                i

    retval       = TRUE
    a_table      = collection.table
    a_mastermenu = SELECT EXPLORER_RMB.MENUPROC IN OBJECT record_object
    a_basetable  = strip (SELECT MASTER_MENU.TABLE_NAME WHERE PROCEDURE_NUM = a_mastermenu)

{fm(a_table, true)
fm(a_mastermenu, true)
fm(a_basetable, true)}
    { V102 Start - removed cabinet folder which are not used }
    { V102 End   - code removed                              }

    { ----------------------------------------------------------------- }
    { We have to have the key0 fields from the base table to archive    }
    { ----------------------------------------------------------------- }

    GET_TABLE_DETAILS 'a_basetable', "KEY0_FIELD", key0_fields


{fm(SELECT 'a_basetable'.'key0_fields[1]',true) }

    { ----------------------------------------------------------------- }
    { The criteria in this case comes from the selected values in RMB   }
    { ----------------------------------------------------------------- }

    ARRAY a_array
    ARRAY_SELECT_ADD ( a_array, ARRAY_SELECT_PUSH, EMPTY, EMPTY )

    collection.set_first()

    WHILE ( collection.current <> EMPTY ) & ( retval ) DO

        { ----------------------------------------------------------------- }
        { Get all key0_fields from the view for this record                 }
        { ----------------------------------------------------------------- }

        i = 1
        WHILE ( key0_fields[i] <> EMPTY ) DO

            IF ( VALID_FIELD ( a_table, key0_fields[i] ) ) THEN

                a_rec = SELECT 'a_table'.'key0_fields[i]' IN OBJECT collection.current

                ARRAY_SELECT_ADD ( a_array, ARRAY_SELECT_EQ, key0_fields[i], a_rec )

            ELSE

                fm("LIT_AUTO_COMMIT_VIEW_INVALID_RMB_SETUP")

                ret_val = FALSE

            ENDIF

            i = i + 1

        ENDWHILE

        collection.set_next()

        IF ( collection.current <> EMPTY ) THEN

            ARRAY_SELECT_ADD ( a_array, ARRAY_SELECT_POP , EMPTY, EMPTY )
            ARRAY_SELECT_ADD ( a_array, ARRAY_SELECT_OR  , EMPTY, EMPTY )
            ARRAY_SELECT_ADD ( a_array, ARRAY_SELECT_PUSH, EMPTY, EMPTY )

        ELSE

            ARRAY_SELECT_ADD ( a_array, ARRAY_SELECT_POP , EMPTY, EMPTY )

        ENDIF

    ENDWHILE

    { ----------------------------------------------------------------- }
    { Figure out the "actual" table that wants to be moved and get ach  }
    { ----------------------------------------------------------------- }


    IF ( ret_val ) THEN

        ARRAY ach_array

        i     = 1
        a_rec = SELECT AUTO_COMMIT_HEADER.IDENTITY
                    WHERE BASE_TABLE         = a_basetable
                    AND   ENABLE_RMB         = TRUE
                    AND   ENABLED            = TRUE
                    AND   COMMIT_SOURCE      = a_source
                    AND   COMMIT_DESTINATION = a_destination
                    AND   REMOVEFLAG         = FALSE

        WHILE ( a_rec <> EMPTY ) DO

            ach_array[i,1] = a_rec
            ach_array[i,2] = ""                         { SELECT AUTO_COMMIT_VIEW.VERSION_NUMBER not doing vers any more }
            ach_array[i,3] = a_rec : ach_array[i,2]
            ach_array[i,4] = FALSE                      { RMB's are never report only.... }

            NEXT AUTO_COMMIT_HEADER

            a_rec = SELECT AUTO_COMMIT_HEADER.IDENTITY
            i     = i + 1

        ENDWHILE


        { ----------------------------------------------------------------- }
        { If only one option, then do this one - otherwise user must choose }
        { ----------------------------------------------------------------- }

        IF     ( SIZE_OF_ARRAY ( ach_array ) = 0 ) OR ( SIZE_OF_ARRAY ( a_array ) <= 2 ) THEN

            fm("LIT_AUTO_COMMIT_VIEW_NO_RECORDS_FOUND")

        ELSEIF ( SIZE_OF_ARRAY ( ach_array ) = 1 ) THEN

            internal_initialize_messages(msg)
            interactive_commit ( ach_array[1,3], ach_array[1,4], a_array, TRUE, FALSE )

        ELSE

            fm("LIT_AUTO_COMMIT_VIEW_MULTIPLE_FOUND")

        ENDIF

    ENDIF  { initial RMB was screwy... }

    RETURN ( retval )

ENDROUTINE   { internal_entity_rmb }

{******************************************************************************}

ROUTINE internal_multi_browse_CPU ( self )

    DECLARE chooser

    CREATE OBJECT LIST_CHOOSER_CLASS, chooser
        chooser.table  = "DESTINATION_CPU"
        chooser.field  = "IDENTITY"
        chooser.header = GET_USER_MESSAGE ( "EXPLORER_RMB_CHOOSE", 1 )
        chooser.create_form()
        chooser.form.row = chooser.form.row + 3
        chooser.form.start_prompt()
        chooser.load_db()
        chooser.load_data()
        chooser.read_csv ( self.text )
        chooser.form.wait_prompt()
        chooser.form.end_prompt()

    self.set_text ( chooser.build_csv() )

ENDROUTINE { internal_multi_browse_CPU }

{******************************************************************************}

ROUTINE internal_make_array_from_csv ( VALUE csv, a_array )

    DECLARE pos, a_cnt, val

    ARRAY a_array

    a_cnt = 0

    WHILE LENGTH ( csv ) > 0 DO

        pos   = INDEX ( csv, "," )
        a_cnt = a_cnt + 1

        IF ( pos > 1 ) THEN

            a_array[a_cnt] = STRIP ( LEFTSTRING ( csv, pos - 1 ) )
            val            = STRIP ( LEFTSTRING ( csv, pos     ) )

        ELSE
            a_array[a_cnt] = csv
            val            = csv

        ENDIF

        csv = csv # val

    ENDWHILE

ENDROUTINE   { internal_make_array_from_csv }

ROUTINE SQL(VALUE SQL_string)
{*************************************************************************
* Purpose      : Execute oracle SQL string
* Parameters   : SQL string
* Return Value : None
**************************************************************************}
        WriteToLog(SQL_String)
        execute_sql(SQL_string)
        execute_sql("commit")
ENDROUTINE

ROUTINE WriteToLog(VALUE Msg)
{*************************************************************************
* Purpose      : Writes to predefined log,
*                using WriteLog in $lib_utils
* Parameters   : Msg - what to write in log
* Return Value : N/A
**************************************************************************}

    WriteLog(Msg, global("current_library"))

ENDROUTINE

ROUTINE fix_exported_files (filepath, set_field, set_value)
{*************************************************************************
* Purpose      : Modify exported csv files
*                to match custom setup.
* Parameters   : filepath:  File to modify
*                set_field: Field to modify
*                set_value: New value in field
* Return Value : N/A
**************************************************************************}
DECLARE check_ok, line_var, read_array, row_index, nq, endchar, i, numofnq, chk, chk2, firstpart, lastpart

ARRAY read_array ARRAY_SIZE(0,2)

    row_index = 1
    FILE OPEN filepath, check_ok
    WHILE (check_ok = EMPTY) DO
        FILE READ filepath, line_var ,check_ok
        read_array [row_index, 1] = row_index
        read_array [row_index, 2] = line_var
        row_index = row_index + 1
    ENDWHILE

    FILE CLOSE filepath, check_ok
    row_index = 1
    nq = 0

    WHILE row_index <= size_of_array(read_array) DO
        IF read_array[row_index, 1] = 2 THEN
            endchar = INDEX(read_array[row_index, 2], set_field )
            i = 1
            WHILE i <> endchar DO
                IF SUBSTRING( read_array[row_index, 2], i, 1) = "," THEN
                    nq = nq + 1
                ENDIF
                i = i + 1
            ENDWHILE
            numofnq = nq
        ELSEIF read_array[row_index, 1] >= 5 THEN
            i   = 1
            nq  = 0
            chk = ASCII(34) : ","
            chk2 = "     ,"
            WHILE i <= LENGTH(read_array[row_index, 2]) DO
                IF SUBSTRING( read_array[row_index, 2], i, LENGTH(chk)) = chk THEN
                    nq = nq + 1
                ENDIF
                IF SUBSTRING( read_array[row_index, 2], i, LENGTH(chk2)) = chk2 THEN
                    nq = nq + 1
                ENDIF
                IF nq = numofnq THEN
                    firstpart = SUBSTRING(read_array[row_index, 2], 1, i + 2)
                    lastpart  = SUBSTRING(read_array[row_index, 2], i + 4, LENGTH(read_array[row_index, 2]))
                    read_array[row_index, 2] = firstpart : set_value : lastpart
                    i = LENGTH(read_array[row_index, 2])
                ENDIF
                i = i + 1
            ENDWHILE
        ENDIF
        row_index = row_index + 1
    ENDWHILE

    FILE DELETE filepath, check_ok
    FILE CREATE filepath, check_ok
    FILE EXTEND filepath, check_ok

    row_index = 1
    WHILE row_index < size_of_array(read_array) DO
        FILE WRITE filepath, STRIP(read_array[row_index, 2]), check_ok
        row_index = row_index + 1
    ENDWHILE

    FILE CLOSE filepath, check_ok

ENDROUTINE
