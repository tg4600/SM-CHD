{******************************************************************************
*
* Module Name   : $BATCH_ENTRY.RPF
*
* Purpose       : Contains the class supporting the batch entry table
*
* Document Ref. :
*
* Specification : SE/T/VGSM320-WORK-BATCH
*
* Portability   : Not Checked
*
* Re-entrant    :
*
*******************************************************************************}

ENABLE WINDOWS
SET NOTPROTECTED
SET NAME "DEFER/"
SET COMPILE_OPTION DECLARE

JOIN STANDARD_LIBRARY STD_ARRAY
JOIN STANDARD_LIBRARY STD_ARRAY_SELECT
JOIN STANDARD_LIBRARY STD_CLASS
JOIN STANDARD_LIBRARY STD_DATABASE
JOIN STANDARD_LIBRARY STD_LOGIN
JOIN STANDARD_LIBRARY STD_GENERAL
JOIN STANDARD_LIBRARY STD_MESSAGE

JOIN LIBRARY $LIB_UTILS
JOIN LIBRARY $LIB_COMP
JOIN LIBRARY $LIB_COMM
JOIN LIBRARY $LIB_RE_COLLECTION
JOIN LIBRARY $BATCH_UTILS
JOIN LIBRARY $BATCH_USER

JOIN LIBRARY $SAMP_JOB
JOIN LIBRARY $PROMPT_TEST_SAMPLES

JOIN LIBRARY $LIB_RE_LIST
JOIN LIBRARY $COMP_LIST
JOIN LIBRARY $MLPS_CONST
JOIN LIBRARY $SAMP_USER


{* CONSTANTS ******************************************************************}


CONSTANT STD_BATCH_RESULT_COLLECTION = "STD_BATCH_RESULT_COLLECTION"

{* VARIABLES ******************************************************************}

DECLARE batch_entry_result_collection     ,
	batch_entry_component_collection  ,
	batch_entry_result_list           ,
	batch_entry_result_list_name

{******************************************************************************}

GLOBAL

ROUTINE batch_entry_initialise

{
*	Initialise all the batch entry modules
*
*******************************************************************************}

	IF NOT global ( "LIBRARY_INITIALISED" ) THEN

		samp_job_initialise ()
		batch_entry_define_class ()
		prompt_test_samples_initialise ()
		lib_re_list_initialise ()
		comp_list_assign_initialise ()
		lib_re_collection_initialise ()

		CREATE OBJECT "STD_COLLECTION" , batch_entry_result_collection
		batch_entry_result_collection . add_index ( "TEST_NUMBER" )

		lib_re_collection_create_component ( batch_entry_component_collection )

		batch_entry_result_list      = EMPTY
		batch_entry_result_list_name = EMPTY

		SET GLOBAL "LIBRARY_INITIALISED" TO TRUE

	ENDIF

ENDROUTINE

{******************************************************************************}

GLOBAL

ROUTINE batch_entry_reset

{
*	Reset the batch queues
*
*******************************************************************************}

	CREATE OBJECT "STD_COLLECTION" , batch_entry_result_collection
	batch_entry_result_collection . add_index ( "TEST_NUMBER" )

ENDROUTINE

{******************************************************************************}

ROUTINE batch_entry_define_class

{
*	Define the classes for the batch entry table
*
*******************************************************************************}

	DEFINE CLASS STD_BATCH_ENTRY_BASE

		PROPERTIES "REPEAT_SECTION"          ,
			   "TEST_NUMBER"             ,
			   "STANDARD_VERSION"        ,
			   "TEMPLATE"                ,
			   "REVIEW"                  ,
			   "CHILDREN"                ,
			   "PARENT_TEST"             ,
			   "WILL_UPDATE"             ,

			   "USER_INFO"

		ACTIONS    "CREATE_ROW"              ,
			   "SET_PARENT_POINTER"      ,
			   "SET_FIELDS"              ,
			   "SET_ORDER"               ,
			   "GET_ORDER"               ,
			   "UPDATE"                  ,
			   "READ"                    ,
			   "EXISTS"                  ,
			   "DELETE"                  ,
			   "TYPE_RESULT_LIST"        ,
			   "VALIDATE"                ,

			   "SET_CHILD_POINTER"       ,
			   "SET_CHILD_TESTS"         ,
			   "SET_PARENT_TEST"         ,
			   "FIND_PARENT"             ,
			   "FIND_REAL_PARENT"        ,

			   "FIND_VERSION"            ,
			   "GET_SAMPLE_DETAILS"      ,
			   "LOGIN_SAMPLE"            ,
			   "CREATE_SAMPLE"           ,
			   "MODIFY_SAMPLE"           ,
			   "ENTRY_RESULT_LIST"       ,
			   "UPDATE_RESULTS"          ,
			   "RELEASE_RESULTS"         ,
			   "TAKE_OFF_BATCH"          ,

                           "REVIEW"                  ,
			   "REVIEW_FULL"             ,
			   "REVIEW_UPDATE"           ,


			   "BASE_PROMPT_SAMPLETEST"  ,
			   "BASE_DISPLAY_SAMPLETEST" ,

			   "BASE_PROMPT_STANDARD"    ,

			   "BASE_PROMPT_PARENT"      ,
			   "BASE_NOPARENT"           ,

			   "BASE_DISPLAY_FIELD"      ,

			   "PROMPT_IDENTITY"         ,

			   "SELECT_TEST_UPDATE"      ,
			   "GET_TYPE"                ,
			   "DATABASE_NAME"           ,
			   "GET_SAMPLE"              ,
			   "GET_TEST"                ,
			   "SET_TEST"                ,
			   "GET_RESULTS"             ,
			   "GET_REVIEW"              ,
			   "GET_PARENT"              ,
			   "CLEAR_SLOT"              ,

			   "GET_CLASS_NAME"          ,
			   "SET_TEMPLATE"            ,
			   "GET_TEMPLATE"            ,
			   "WANT_PARENT"             ,
			   "SET_REPEAT"              ,
			   "GET_REPEAT"              ,
			   "SHOULD_CREATE_SECTION"   ,
			   "SHOULD_CREATE"           ,
			   "IS_SAMPLE"    	     ,
			   "SET_WILL_UPDATE"         ,
			   "GET_WILL_UPDATE"         ,

			   "GET_SAMP_TEST_FIELD"     ,
			   "IS_SAME_AS"	             ,
			   "IS_COMPLETE"             ,
			   "TEST_IS_COMPLETE"        ,
			   "TEST_IS_INSPECTED"       ,
			   "UPDATE_SAMPLE_STATUS"    ,
			   "INSPECT_TEST"            ,
			   "INSPECT"                 ,
			   "AUTHORISE_TEST"          ,
			   "AUTHORISE_RESULTS"       ,
			   "AUTHORISE"               ,
			   "REACTIVATE"              ,
			   "CANCEL"                  ,
			   "COMMIT"                  ,
			   "SHOULD_COMMIT"

		TABLES BATCH_ENTRY    ,
		       SAMP_TEST_VIEW

		INITIALISATION

	END CLASS

	DEFINE CLASS STD_BATCH_ENTRY_SAMPLE

		INHERIT    STD_BATCH_ENTRY_BASE

		ACTIONS    "GET_TYPE"               ,
			   "DATABASE_NAME"          ,
			   "SHOULD_CREATE_SECTION"  ,
			   "ENTRY_RESULT_LIST"      ,
			   "IS_SAMPLE"              ,
			   "PROMPT_IDENTITY" 	    ,
			   "CANCEL"                 ,
			   "REVIEW"                 ,
			   "REVIEW_UPDATE"

	END CLASS

	DEFINE CLASS STD_BATCH_ENTRY_WASH

		INHERIT    STD_BATCH_ENTRY_BASE

		ACTIONS    "GET_TYPE"               ,
			   "DATABASE_NAME"          ,
			   "SHOULD_CREATE"          ,
			   "SHOULD_CREATE_SECTION"  ,
			   "ENTRY_RESULT_LIST"      ,
			   "PROMPT_IDENTITY"        ,
			   "CREATE_SAMPLE"          ,
			   "MODIFY_SAMPLE"	        ,
		       "REVIEW"                 ,
			   "IS_COMPLETE"	        ,
			   "SHOULD_COMMIT"

	END CLASS


	DEFINE CLASS STD_BATCH_ENTRY_STANDARD

		INHERIT    STD_BATCH_ENTRY_BASE

		ACTIONS    "GET_TYPE"               ,
			   "DATABASE_NAME"          ,
			   "SHOULD_CREATE_SECTION"  ,
			   "CREATE_SAMPLE"          ,
			   "PROMPT_IDENTITY"	    ,
			   "STANDARD_RESULT_LIST"   ,
			   "ENTRY_RESULT_LIST"	    ,
			   "DELETE"

	END CLASS

	DEFINE CLASS STD_BATCH_ENTRY_MS

		INHERIT    STD_BATCH_ENTRY_STANDARD

		ACTIONS    "GET_TYPE"               ,
			   "DATABASE_NAME"          ,
                           "WANT_PARENT"            ,
			   "ENTRY_RESULT_LIST"	    ,
			   "PROMPT_IDENTITY"

	END CLASS

	DEFINE CLASS STD_BATCH_ENTRY_MSD

		INHERIT    STD_BATCH_ENTRY_STANDARD

		ACTIONS    "GET_TYPE"            ,
			   "DATABASE_NAME"       ,
                           "WANT_PARENT"         ,
			   "ENTRY_RESULT_LIST"	 ,
			   "SET_MS_PARENT"       ,
			   "PROMPT_IDENTITY"

	END CLASS

	DEFINE CLASS STD_BATCH_ENTRY_CONTROL

		INHERIT    STD_BATCH_ENTRY_STANDARD

		ACTIONS    "GET_TYPE"               ,
			   "ENTRY_RESULT_LIST"	    ,
			   "DATABASE_NAME"

	END CLASS

	DEFINE CLASS STD_BATCH_ENTRY_BLANK

		INHERIT    STD_BATCH_ENTRY_STANDARD

		ACTIONS    "GET_TYPE"               ,
			   "ENTRY_RESULT_LIST"	    ,
			   "DATABASE_NAME"

	END CLASS

	DEFINE CLASS STD_BATCH_ENTRY_CAL_STD

		INHERIT    STD_BATCH_ENTRY_STANDARD

		ACTIONS    "GET_TYPE"               ,
			   "DATABASE_NAME"
	END CLASS

	DEFINE CLASS STD_BATCH_ENTRY_CAL_BLANK

		INHERIT    STD_BATCH_ENTRY_STANDARD

		ACTIONS    "GET_TYPE"               ,
		           "ENTRY_RESULT_LIST"      ,
		           "DATABASE_NAME"

	END CLASS

	DEFINE CLASS STD_BATCH_ENTRY_BLANK_CHK

		INHERIT    STD_BATCH_ENTRY_STANDARD

		ACTIONS    "GET_TYPE"               ,
			   "ENTRY_RESULT_LIST"	    ,
			   "DATABASE_NAME"

	END CLASS

	DEFINE CLASS STD_BATCH_ENTRY_METH_BLANK

		INHERIT    STD_BATCH_ENTRY_STANDARD

		ACTIONS    "GET_TYPE"               ,
			   "ENTRY_RESULT_LIST"	    ,
			   "DATABASE_NAME"

	END CLASS

	DEFINE CLASS STD_BATCH_ENTRY_CAL_CHK

		INHERIT    STD_BATCH_ENTRY_STANDARD

		ACTIONS    "GET_TYPE"               ,
			   "ENTRY_RESULT_LIST"	    ,
			   "DATABASE_NAME"

	END CLASS

	DEFINE CLASS STD_BATCH_ENTRY_INDEP_CHK

		INHERIT    STD_BATCH_ENTRY_STANDARD

		ACTIONS    "GET_TYPE"               ,
			   "ENTRY_RESULT_LIST"	    ,
			   "DATABASE_NAME"

	END CLASS

	DEFINE CLASS STD_BATCH_ENTRY_INIT_CHK

		INHERIT    STD_BATCH_ENTRY_STANDARD

		ACTIONS    "GET_TYPE"               ,
			   "ENTRY_RESULT_LIST"	    ,
			   "DATABASE_NAME"

	END CLASS

	DEFINE CLASS STD_BATCH_ENTRY_INTERF_CHK

		INHERIT    STD_BATCH_ENTRY_STANDARD

		ACTIONS    "GET_TYPE"               ,
			   "ENTRY_RESULT_LIST"	    ,
			   "DATABASE_NAME"

	END CLASS

	DEFINE CLASS STD_BATCH_ENTRY_DUPLICATE

		INHERIT    STD_BATCH_ENTRY_STANDARD

		ACTIONS    "GET_TYPE"               ,
			   "DATABASE_NAME"          ,
                           "WANT_PARENT"            ,
			   "ENTRY_RESULT_LIST"	    ,
			   "PROMPT_IDENTITY"

	END CLASS




	DEFINE CLASS STD_BATCH_RESULT_COLLECTION

		INHERIT    "STD_COLLECTED"

		PROPERTIES "TEST_NUMBER"  ,
			   "RESULTS"      ,
			   "UPDATED"

	END CLASS

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_entry_base_class_initialisation ( self )

{
*	Set up an object
*
******************************************************************************}

	self . repeat_section   = 0
	self . test_number      = EMPTY
	self . standard_version = 0
	self . review           = MLP_CONST_FAIL
	self . template         = EMPTY
	self . children         = EMPTY
	self . parent_test      = EMPTY

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_entry_base_action_find_version (       self      ,
					           VALUE standard  ,
							 version   ,
							 message   )
{
*	Find the version for the standard
*	Either use the given version or use the latest.
*	Check the usage to see if it can be used.
*
******************************************************************************}

	DECLARE ok          ,
		exp_type    ,
		usage_num   ,
		expiry_date ,
		maxus       ,
		life        ,
		message_ptr

	ok      = TRUE
	version = self . standard_version

	IF version = 0 THEN

		REPEAT

			version = SELECT standard_versions . version
				  FOR UPDATE
			          WHERE  ( identity = standard ) AND
				         ( status   = "A"      )
      			          ORDER ON version DESCENDING

			IF version = locked THEN

				SLEEP FOR "0 00:00:02"

			ENDIF


		UNTIL version <> LOCKED

	ELSE

		REPEAT

			version = SELECT standard_versions . version
				  FOR UPDATE
				  WHERE  ( identity = standard ) AND
					 ( version  = version  ) AND
					 ( status   = "A"      )
    				  ORDER ON version DESCENDING

			IF version = locked THEN

				SLEEP FOR "0 00:00:02"

			ENDIF


		UNTIL version <> LOCKED

	ENDIF

	IF ( version <> EMPTY  ) AND
	   ( version <> LOCKED ) THEN

		{ Validate this version }

		exp_type    = SELECT standard_versions . expiry_type
		usage_num   = SELECT standard_versions . usage_count
		expiry_date = SELECT standard_versions . expiry_date
		maxus       = SELECT standard_versions . maximum_usage
		life        = SELECT standard_versions . lifetime

          	IF (exp_type = "B") THEN

			IF (expiry_date < NOW ) AND
                           (life <> 0         )  THEN

				ok = FALSE

	                ELSEIF ( usage_num  >= maxus ) AND
        	               ( maxus      <> 0     ) THEN

				ok = FALSE

			ENDIF

		ELSEIF (exp_type = "U") THEN

			IF ( usage_num >= maxus) AND
                           ( maxus     <> 0    ) THEN

				ok = FALSE

	                ENDIF

		ELSEIF (exp_type = "T") THEN

	                IF ( expiry_date <  NOW ) AND
                           ( life        <> 0   ) AND
                           ( expiry_date <> "           " )  THEN

				ok = FALSE

			ENDIF

		ENDIF

	ELSE

		ok = FALSE

	ENDIF

	IF ok THEN

		usage_num = usage_num + 1

		ASSIGN standard_versions.usage_count = usage_num

		IF (exp_type = "U") THEN

			IF ( usage_num >= maxus ) AND
                           ( maxus     <> 0     ) THEN

				ASSIGN standard_versions.status = "B"


			ENDIF

		ENDIF

                UPDATE standard_versions

	ENDIF

	IF ok THEN

		message = ""

	ELSE

		message_fetch ( "BATCH_ENTRY_NO_ACTIVE_STANDARD" ,
				 message_ptr                     )

		message_add_parameter ( message_ptr        ,
					strip ( standard ))

		message = message_get_text ( message_ptr , 1 )

	ENDIF

	RETURN ( ok )

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_entry_base_action_get_sample_details ( self      ,
					                 standard  ,
							 version   ,
							 template  ,
							 message   )

{
*	Get the standard ID, version and template to use
*
******************************************************************************}

	DECLARE valid

	valid    = TRUE
	message  = ""
	standard = self . template . get_standard ()
	version  = packed_decimal ( 0 )
	template = ""

	IF NOT blank ( standard ) THEN

		IF self . find_version ( standard ,
					 version  ,
					 message  ) THEN

			template       = SELECT standard . template_id
					 WHERE  identity = standard

		ELSE

			valid = FALSE

		ENDIF


	ENDIF

	IF blank ( template ) THEN

		template = batch_user_get_sample_template ( self )

	ENDIF

	RETURN ( valid )

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_entry_base_action_login_sample (       self           ,
							 batch_header   ,
						   VALUE standard       ,
						   VALUE version        ,
					           VALUE template       ,
						   VALUE mlp            ,
					           VALUE analysis       ,
						   VALUE component_list ,
							 result_list    )

{
*	Login a sample/test (and results)
*
******************************************************************************}

	DECLARE login_details  ,
		test_list      ,
		grid           ,
		test_schedule  ,
		batch_template

	batch_template = batch_header . get_field ( "TEMPLATE_ID" )

	IF SELECT test_sched_entry . identity <> batch_template THEN

		test_schedule = SELECT test_sched_entry . identity
				WHERE  identity = batch_template

	ELSE

		test_schedule = batch_template

	ENDIF

	{ Create the test record }

        test_editor_initialise ( " "                          ,
                                 TRUE                         ,
                                 FALSE                        ,
                                 FALSE                        ,
                                 global ( "CURRENT_LIBRARY" ) ,
                                 test_list                    )

	test_editor_pre_insert ( 1  , test_list )

	ASSIGN test . analysis         = analysis

	ASSIGN test . analysis_version = lib_utils_highest_version ( "VERSIONED_ANALYSIS" ,
		                                                      analysis      )
	ASSIGN test . component_list   = component_list

	batch_header . put_test_on_batch ( self )

	IF test_schedule <> EMPTY THEN

		ASSIGN test . instrument = SELECT test_sched_entry . instrument_id

	ENDIF

	test_add_analysis ( test_list              ,
		            test_schedule <> EMPTY ,
			    1                      ,
			    "ASSIGN_TEST"          )

	test_editor_set_repeat   ( 1           , test_list )
	test_editor_set_assign   ( TRUE        , test_list )

	IF self . parent_test <> EMPTY THEN

		ASSIGN test . parent_test = self . parent_test

	ENDIF

	IF result_list <> EMPTY THEN

		test_editor_set_result_list ( result_list , test_list )

	ENDIF

	CREATE OBJECT SAMP_JOB_SAMPLE_LOGIN_CLASS, login_details

	IF blank ( template ) THEN

		login_details . template_id = "NOINPUT"

	ELSE

		login_details . template_id = template

	ENDIF

	login_details . job_name                = ""
	login_details . syntax                  = ""
	login_details . user_status             = "V"
	login_details . user_add_tests          = TRUE
	login_details . user_test_list          = test_list
	login_details . use_current_transaction = TRUE

	lib_utils_set_field_value (  login_details . field_values ,
				    "TEMPLATE_ID"                 ,
				     template                     )

	lib_utils_set_field_value (  login_details . field_values ,
				    "STANDARD_ID"                 ,
				     standard                     )

	lib_utils_set_field_value (  login_details . field_values ,
				    "STANDARD_VERSION"            ,
				     version                      )

	lib_utils_set_field_value (  login_details . field_values ,
				    "PRODUCT"                     ,
				     mlp                          )

	lib_utils_set_field_value (  login_details . field_values ,
				    "STANDARD"                    ,
				     TRUE                         )

	IF self . template <> EMPTY THEN

		lib_utils_set_field_value (  login_details . field_values ,
					    "STANDARD_TYPE"               ,
					     self . get_type ()           )


	ENDIF

	lib_utils_set_field_value (  login_details . field_values           ,
				    "BATCH_ID"                              ,
				     batch_header . get_field ( "IDENTITY" ))

	login_details . login_a_sample ()

	test_editor_make_current ( 1 , test_list )

	self . set_test ( SELECT test . test_number ,
			  grid                      ,
			  0                         )

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_entry_base_action_base_prompt_sampletest (       self           ,
    						                   grid           ,
                                                             VALUE cell_column    ,
		                                             VALUE cell_row       ,
		                                             VALUE column         ,
		                                             VALUE row            ,
			                                     VALUE cell_width     ,
			                                           screen         ,
					                     VALUE is_display     )


{
*	If the element is defined then display the sample id -
*	else if this a modify screen then allow the user to enter a sampletest.
*
******************************************************************************}

	DECLARE test_number      ,
		prompt_object    ,
		template         ,
		batch

	template    = grid . get_template_header ()
	batch       = grid . batch
	test_number = self . get_test ()

	PROMPT OBJECT    prompt_object
	       ON LINE   row
	       FROM      column
	       TO        column + cell_width - 1
	       IN WINDOW screen
	       CLASS     PROMPT_TEST_SAMPLES_CLASS
	       WITH ( display_only = grid . parent_prompt . is_display () ,
		      return_test  = TRUE                                 )

	object_copy_table ( prompt_object , self , "SAMP_TEST_VIEW" )

	IF is_display THEN

		IF test_number = EMPTY THEN

			CLEAR LINE row
			      FROM column
			      TO   column + cell_width - 1
			      IN WINDOW screen

		ELSE

			prompt_object . value = test_number

			prompt_object . start_prompt ()
			prompt_object . end_prompt   ()

		ENDIF

	ELSEIF test_number = EMPTY THEN

		template . add_criteria                  ( prompt_object . mandatory_array )
		batch    . alter_test_selection_criteria ( prompt_object . mandatory_array )

		prompt_object . analysis    = template . get_analysis ()
		prompt_object . test_status = "CVP"

		prompt_object . start_prompt ()
		prompt_object . wait_prompt  ()
		prompt_object . end_prompt   ()

		self . set_test ( prompt_object . value ,
				  grid                  ,
				  cell_row              )

		prompt_object . set_globals ()

	ELSE

		template . add_criteria                  ( prompt_object . mandatory_array )
		batch    . alter_test_selection_criteria ( prompt_object . mandatory_array )

		prompt_object . analysis = template . get_analysis ()
		prompt_object . test_status = "CVP"

		prompt_object . value = test_number
		prompt_object . start_prompt ()
		prompt_object . wait_prompt  ()
		prompt_object . end_prompt   ()

		IF ( test_number <> EMPTY                 ) AND
		   ( test_number <> prompt_object . value ) THEN

			grid . remove_test ( test_number )

		ENDIF

		self . set_test ( prompt_object . value ,
				  grid                  ,
				  cell_row              )

		prompt_object . set_globals ()

	ENDIF

	object_copy_table ( self , prompt_object , "SAMP_TEST_VIEW" )

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_entry_base_action_base_display_sampletest (       self           ,
    						                    grid           ,
                                                              VALUE cell_column    ,
		                                              VALUE cell_row       ,
		                                              VALUE column         ,
		                                              VALUE row            ,
			                                      VALUE cell_width     ,
			                                            screen         ,
					                      VALUE is_display     )


{
*	If the element is defined then display the sample id -
*	else if this a modify screen then allow the user to enter a sampletest.
*
******************************************************************************}

	DECLARE prompt_object

	PROMPT OBJECT    prompt_object
	       ON LINE   row
	       FROM      column
	       TO        column + cell_width - 1
	       IN WINDOW screen
	       CLASS     PROMPT_TEST_SAMPLES_CLASS
	       WITH ( display_only = TRUE  ,
	              return_test  = TRUE  )

	prompt_object . value = self . get_test ()

	IF is_display THEN

		prompt_object . start_prompt ()
    		prompt_object . end_prompt   ()

	ELSE

		prompt_object . start_prompt ()
		prompt_object . wait_prompt  ()
    		prompt_object . end_prompt   ()

		prompt_object . set_globals ()

	ENDIF

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_entry_base_action_base_prompt_standard (       self           ,
    						                 grid           ,
                                                           VALUE cell_column    ,
		                                           VALUE cell_row       ,
		                                           VALUE column         ,
		                                           VALUE row            ,
			                                   VALUE cell_width     ,
			                                         screen         ,
					                   VALUE is_display     )


{
*	If the element is defined then display the sample id -
*	else if this a modify screen then allow the user to enter a sampletest.
*
******************************************************************************}

	DECLARE test_number

        test_number = self . get_test ()

	IF test_number <> EMPTY THEN

		self . base_display_sampletest ( grid        ,
					         cell_column ,
						 cell_row    ,
						 column      ,
						 row         ,
						 cell_width  ,
						 screen      ,
						 is_display  )

	ELSEIF is_display THEN

		CLEAR LINE row
			   FROM column
			   TO   column + cell_width - 1
			   IN WINDOW screen

	ELSE

		PROMPT

		       ON LINE   row
 		       FROM      column
		       TO        column + cell_width - 1
		       IN WINDOW screen

	ENDIF

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_entry_base_action_base_prompt_parent (       self          ,
    						               grid          ,
                                                         VALUE cell_column   ,
		                                         VALUE cell_row      ,
		                                         VALUE column        ,
		                                         VALUE row           ,
			                                 VALUE cell_width    ,
			                                       screen        ,
					                 VALUE is_display    ,
							 VALUE change_parent )


{
*
*
******************************************************************************}

	DECLARE prompt_object ,
		template      ,
		batch

	PROMPT OBJECT    prompt_object
	       ON LINE   row
	       FROM      column
	       TO        column + cell_width - 1
	       IN WINDOW screen
	       CLASS     PROMPT_TEST_SAMPLES_CLASS

	prompt_object . value = self . parent_test

	IF is_display THEN

		prompt_object . start_prompt ()
    	  	prompt_object . end_prompt   ()

  	ELSE

		template    = grid . get_template_header ()
	   	batch       = grid . batch

		template . add_criteria                  ( prompt_object . mandatory_array )
		batch    . alter_test_selection_criteria ( prompt_object . mandatory_array )

		prompt_object . analysis    = template . get_analysis ()
		prompt_object . test_status = "CVP"

		prompt_object . start_prompt ()
	   	prompt_object . wait_prompt  ()
    		prompt_object . end_prompt   ()

		IF prompt_object . get_lastkey () <> "EXIT" THEN

			self . set_parent_test (  prompt_object . value )

		ENDIF

		prompt_object . set_globals ()

	ENDIF

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_entry_base_action_prompt_identity (       self           ,
    						            grid           ,
                                                      VALUE cell_column    ,
		                                      VALUE cell_row       ,
		                                      VALUE column         ,
		                                      VALUE row            ,
			                              VALUE cell_width     ,
			                                    screen         ,
					              VALUE is_display     )

{
*	Overridable routine to prompt for an identity
*
******************************************************************************}

	IF is_display THEN

		CLEAR LINE      row
		      FROM      column
		      TO        column + cell_width - 1
		      IN WINDOW screen

	ELSE

		PROMPT ON LINE   row
		       FROM      column
		       TO        column + cell_width - 1
		       IN WINDOW screen

	ENDIF

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_entry_base_action_entry_result_list ( self            ,
							batch_header    ,
						        template_header ,
						        result_list     )

{
*	Alter an existing test to add extra results.
*
*
*******************************************************************************}

	result_list . copy_category_test (  self . test_number ,
				            CATEGORY_READING   )

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_entry_base_action_update_results ( self )

{
*	Update the results.
*
*
*******************************************************************************}

	DECLARE test_number ,
		results

	test_number = self . get_test ()

	IF test_number <> EMPTY THEN

		results = batch_entry_result_collection . get_by_index ( "TEST_NUMBER" ,
									  test_number  )


		IF results <> EMPTY THEN

			IF NOT results . updated THEN

				results . results . update ()
				results . updated = TRUE

			ENDIF

		ENDIF

	ENDIF

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_entry_base_action_release_results ( self )

{
*	Release the results.
*
*
*******************************************************************************}

	DECLARE test_number ,
		results

	test_number = self . get_test ()

	IF test_number <> EMPTY THEN

		results = batch_entry_result_collection . get_by_index ( "TEST_NUMBER" ,
									  test_number  )

		IF results <> EMPTY THEN

			results . results . release ()

		ENDIF

	ENDIF

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_entry_base_action_create_row (       self         ,
						 VALUE batch_name   ,
						 VALUE order_number )

{
*	Reserve the row for the batch entry
*
*
*******************************************************************************}

	DECLARE status     ,
		message

	order_number = justify ( pad ( order_number , " " ,10 ),"RIGHT")

	RESERVE ENTRY NOCHECK batch_entry IN OBJECT self                      ,
					            batch_name : order_number ,
					            status

	IF status <> EMPTY THEN

		message = get_user_message ( "BATCH_ENTRY_ERROR_ENTRY_RESERVE" ,1)
		message = message : " " : strip ( status )

		fatal_error ( message )

	ENDIF

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_entry_base_action_delete ( self         ,
					     batch_header )

{
*	Take the test off the batch and delete the entry.
*
*
******************************************************************************}

	IF self . get_test () <> EMPTY THEN

		self . take_off_batch (batch_header )

	ENDIF

	IF SELECT batch_entry . identity IN OBJECT self <> EMPTY THEN

		DELETE batch_entry IN OBJECT self

	ENDIF

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_entry_base_action_take_off_batch ( self         ,
					             batch_header )

{
*	Take the test off the batch.
*
*
******************************************************************************}

	DECLARE test_locked ,
		status

	status = EMPTY

	IF self . test_number <> EMPTY THEN

		test_locked = FALSE

		IF self . select_test_update ( test_locked ) THEN

	   		batch_header . take_test_off_batch ( self )

    			UPDATE test

			status = EMPTY

		ELSE

			status = LOCKED

		ENDIF

	ENDIF

	RETURN ( status )

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_entry_base_action_type_result_list ( self         ,
					               batch_header ,
						       result_list  )

{
*	Add all the result things
*
*
******************************************************************************}

 	batch_header . update_result_list ( result_list  ,
				            self         )

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_entry_base_action_modify_sample ( self            ,
					            batch_header    ,
					            template_header ,
						    message         )

{
*	Overridable routine for the sample after modification.
*
*******************************************************************************}

	DECLARE result_list  ,
		test_locked

	test_locked = FALSE

	IF self . test_number <> EMPTY THEN

		self . select_test_update ( test_locked )

	ENDIF

	IF test_locked THEN

		IF ( batch_header . type_supports_result_lists ) AND
		   (( blank ( SELECT test . component_list     )) OR
                    ( self . is_sample ()                      ))                      THEN

			IF batch_entry_result_list_name <>
				template_header . get_work_profile () THEN

				CREATE OBJECT RESULT_LIST_CREATE_HEADER, result_list
				batch_entry_result_list_name =
					template_header . get_work_profile ()

			ELSE

				result_list = batch_entry_result_list

			ENDIF

			result_list . ignore_error     = TRUE
  			result_list . analysis         = template_header . get_analysis ()
  			result_list . analysis_version = SELECT test . analysis_version
			result_list . test_number      = self . test_number

			IF batch_entry_result_list = EMPTY THEN

	      			result_list . read_component_list ( template_header . get_work_profile (),
								    TRUE                                 ,
								    TRUE                                 )

			ELSE

				result_list . reset_component_list ( TRUE )

			ENDIF

		        self . entry_result_list ( batch_header    ,
					           template_header ,
						   result_list     )

			self . type_result_list ( batch_header ,
						  result_list  )

			IF result_list . results_to_create () THEN

				result_list . remove_created ()

				result_list . create ()

			ENDIF

			batch_entry_result_list = result_list

		ENDIF

		batch_header . put_test_on_batch ( self )

		IF self . parent_test <> EMPTY THEN

			ASSIGN test . parent_test = self . parent_test

		ENDIF

		UPDATE test

	ENDIF

	RETURN ( EMPTY )

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_entry_base_action_create_sample ( self            ,
					            batch_header    ,
					            template_header ,
						    message         )

{
*	Overridable routine for the sample after modification.
*
*******************************************************************************}

	DECLARE status

	status = self . modify_sample ( batch_header    ,
					template_header ,
					message         )

	RETURN ( status )

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_entry_base_action_validate ( self    ,
                                               batch   ,
					       message )

{
*
*
*******************************************************************************}

	DECLARE valid

	valid = TRUE

	IF self . parent_test <> EMPTY THEN

		IF batch . find_test ( self . parent_test ) = 0 THEN

			message = get_user_message ( "BATCH_ENTRY_NO_PARENT" ,
						      1                      )
			valid = FALSE

		ENDIF

	ENDIF

	RETURN ( valid )

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_entry_base_action_set_fields ( self )

{
*	Set the fields in the row
*
*
*******************************************************************************}

	DECLARE test_number

	ASSIGN batch_entry . type IN OBJECT self = self . database_name()

	test_number = self . get_test ()

	IF test_number = EMPTY THEN

		ASSIGN batch_entry . test IN OBJECT self = 0

	ELSE

		ASSIGN batch_entry . test IN OBJECT self = test_number

	ENDIF

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_entry_base_action_set_parent_pointer ( self   ,
							 parent )

{
*	Set the parent pointer.
*
*
*******************************************************************************}

	IF ( parent = 0     )  OR
	   ( blank ( parent )) THEN

		parent = EMPTY

	ENDIF

	self . parent_pointer = parent

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_entry_base_action_set_child_pointer ( self  ,
							child )

{
*	Set the child pointer
*
*
*******************************************************************************}

	DECLARE position

	IF self . children = EMPTY THEN

		ARRAY self . children

	ENDIF

	position = size_of_array ( self . children ) + 1

	self . children [ position ] = child

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_entry_base_action_set_child_tests (       self        ,
						      VALUE test_number ,
							    grid        )

{
*	Set the child pointer
*
*
*******************************************************************************}

	DECLARE count  ,
		entry

	IF self . children <> EMPTY THEN

		count = 1

		WHILE count <= size_of_array ( self . children ) DO

			entry = self . children [ count ]

			entry . set_parent_test ( test_number )
                        entry . set_child_tests ( test_number ,
						  grid        )

			count = count + 1

		ENDWHILE

		IF variable_is_assigned ( grid ) THEN

			grid . redisplay_contents ()

		ENDIF


	ENDIF

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_entry_base_action_set_parent_test (       self        ,
						      VALUE test_number )
{
*	Set the parent test.
*
*
*******************************************************************************}

	self . parent_test = test_number

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_entry_base_action_find_parent ( self    ,
						  batch   )

{
*	Find the parent entry
*
*
*******************************************************************************}

	DECLARE position ,
		entry

	position = batch . find_test ( self . parent_test )

	IF position <> 0 THEN

		entry = batch . get_entry ( position )

	ELSE

		entry = EMPTY

	ENDIF

	RETURN ( entry )

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_entry_base_action_find_real_parent ( self    ,
						       batch   )

{
*	Find the real parent entry
*
*
*******************************************************************************}

	DECLARE position   ,
		entry      ,
		temp       ,
		keep_going

	temp  = self
	entry = EMPTY

	keep_going = TRUE

	WHILE keep_going DO

		position = batch . find_test ( temp . parent_test )

		IF position <> 0 THEN

			temp  = batch . get_entry ( position )
			entry = temp

		ELSE

			keep_going = FALSE

		ENDIF

	ENDWHILE

	RETURN ( entry )

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_entry_base_action_set_order (       self      ,
					        VALUE new_order )

{
*	Change the order of the current element
*
*
*******************************************************************************}

	batch_entry_reorder ( self , new_order )

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_entry_base_action_get_order ( self )

{
*	Change the order of the current element
*
*
*******************************************************************************}

	RETURN ( SELECT batch_entry . order_number IN OBJECT self )

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_entry_base_action_update ( self )

{
*	Update the row
*
*
*******************************************************************************}

	ASSIGN batch_entry . repeat_section IN OBJECT self = self . repeat_section
	UPDATE batch_entry IN OBJECT self

	RETURN ( EMPTY )

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_entry_base_action_read ( self )

{
*	Read the row into the object.
*
*
*******************************************************************************}

	DECLARE temp

	object_copy_current_table (  self          ,
				    "BATCH_ENTRY"  )

	self . test_number = SELECT batch_entry . test IN OBJECT self

	IF self . test_number = 0 THEN

		self . test_number = EMPTY

	ELSE

		temp = SELECT samp_test_view . test_number
		       WHERE  test_number = self . test_number

		IF temp = EMPTY THEN

			self . test_number = EMPTY

		ELSE

			object_copy_current_table (  self             ,
					            "SAMP_TEST_VIEW"  )


		ENDIF

	ENDIF

        self . parent_test = SELECT samp_test_view . parent_test
			      IN OBJECT self

	IF self . parent_test = NULL THEN

		self . parent_test = EMPTY

	ELSEIF self . parent_test = 0 THEN

		self . parent_test = EMPTY

	ENDIF

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_entry_base_action_exists ( self )

{
*	See if the row already exists.
*
*
*******************************************************************************}

	RETURN ( SELECT batch_entry . test IN OBJECT self <> EMPTY )

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_entry_base_action_get_type ( self )

{
*	Return the type of the entry
*
*
*******************************************************************************}

	RETURN ( " " )

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_entry_base_action_database_name ( self )

{
*	Return the Database name of the entry
*
*
*******************************************************************************}

	RETURN ( " " )

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_entry_base_action_get_test ( self )

{
*	Return the test number stored in the batch.
*
*
*******************************************************************************}

	RETURN ( self . test_number )

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_entry_base_action_select_test_update ( self        ,
							 test_locked )

{
*	Select and lock the test.
*
*
*******************************************************************************}

	DECLARE test

	IF NOT test_locked THEN

		test = SELECT test . test_number
		       FOR UPDATE
	       	       WHERE test_number = self . test_number

		test_locked = test = self . test_number

	ENDIF

	RETURN ( test_locked )

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_entry_base_action_get_sample ( self )

{
*	Return the sample stored in the batch.
*
*
*******************************************************************************}

	RETURN ( self . get_samp_test_field ( "ID_NUMERIC" ))

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_entry_base_action_set_test (       self        ,
					       VALUE test_number ,
						     grid        ,
					       VALUE grid_row    )

{
*	Set the test number in the batch.
*
*
*******************************************************************************}

	DECLARE temp

	IF ( self . test_number = test_number ) THEN

	ELSEIF ( test_number <> EMPTY ) AND
	       ( test_number <> 0     ) THEN

		temp = SELECT test . test_number
		       WHERE test_number = test_number

		IF temp = test_number THEN

			self . test_number = test_number

			self . set_child_tests ( test_number ,
						 grid        )

			IF SELECT samp_test_view . test_number <> test_number THEN

				temp = SELECT samp_test_view . test_number
				       WHERE  test_number = test_number

			ENDIF

			object_copy_current_table (  self             ,
					            "SAMP_TEST_VIEW"  )

		ENDIF

		IF grid_row <> 0 THEN

			grid . redisplay_row ( grid_row )

		ENDIF

	ELSE

		self . test_number = EMPTY
                NEXT samp_test_view IN OBJECT self

		IF grid_row <> 0 THEN

			grid . redisplay_row ( grid_row )

		ENDIF

	ENDIF


ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_entry_base_action_get_results (       self      ,
						  VALUE call_bind )

{
*	Return the result object for the test.
*       Create the thing if necessary
*
*******************************************************************************}

	DECLARE test_number ,
		results     ,
		collected

	test_number = self . get_test ()

	collected = batch_entry_result_collection . get_by_index ( "TEST_NUMBER",
                                                                    test_number )

	IF collected = EMPTY THEN

		CREATE OBJECT "STD_RESULT_INTERFACE" , results

		results . call_bind = call_bind

		results . component_collection = batch_entry_component_collection

		IF test_number <> EMPTY THEN

			results . set_modify_mode ()

			results . allowed_test_status =
				self . get_samp_test_field ( "TEST_STATUS" )
			results . allowed_sample_status =
				self . get_samp_test_field ( "STATUS" )

			results . select_results ( test_number  )

		ELSE

			results = EMPTY

		ENDIF

		CREATE OBJECT STD_BATCH_RESULT_COLLECTION , collected

		collected . test_number = test_number
		collected . results     = results
		collected . updated     = FALSE

		batch_entry_result_collection . add ( collected )

	ELSE

		IF ( call_bind                             ) AND
                   ( NOT collected . results . bind_called ) THEN

			collected . results . bind ()

		ENDIF

	ENDIF

	RETURN ( collected . results )

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_entry_base_action_get_review ( self )

{
*	Get the review flag.
*
*******************************************************************************}

	RETURN ( self . review )

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_entry_base_action_get_parent ( self )

{
*	Get the parent sample id.
*
*******************************************************************************}

	RETURN ( self . parent_test )

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_entry_base_action_clear_slot ( self )

{
*	Clear the element of all details.
*
*
*******************************************************************************}

	self . test_number    = EMPTY

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_entry_base_action_set_template ( self     ,
						   template )

{
*	Set the template entry pointer
*
*******************************************************************************}

	self . template = template

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_entry_base_action_get_template ( self )

{
*	Get the template entry pointer
*
*******************************************************************************}

	RETURN ( self . template )

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_entry_base_action_get_class_name ( self )

{
*	Get the name of the class.
*
*******************************************************************************}

	RETURN ( object_get_class_name ( self ))

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_entry_base_action_want_parent ( self )

{
*	Overridable routine to say if we need a parent sample.
*
*******************************************************************************}

	RETURN ( FALSE )

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_entry_base_action_set_repeat (       self    ,
						 VALUE section )

{
*	Set the repeat section of the current element
*
*******************************************************************************}

	self . repeat_section = section

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_entry_base_action_get_repeat ( self )

{
*	Get the repeat section of the current element.
*
*******************************************************************************}

	RETURN ( self . repeat_section )

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_entry_base_action_should_create_section ( self )

{
*	Overridable routine to state that if you find one of these things
*	in a section then create the section
*
*******************************************************************************}

	RETURN ( FALSE )

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_entry_base_action_should_create ( self )

{
*	Overridable routine to state that if the current element should have
*	its create action called.
*
*******************************************************************************}

	DECLARE should_create

	should_create = self . get_test () <> EMPTY

	RETURN ( should_create )

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_entry_base_action_is_sample ( self )

{
*	Overridable routine to state that if this thing is a real sample.
*
*******************************************************************************}

	RETURN ( FALSE )

ENDROUTINE


{******************************************************************************}

ROUTINE std_batch_entry_base_action_set_will_update (       self        ,
                                                      VALUE will_update )
{
*	Set the Will_Update flag.
*
*
*******************************************************************************}

	self . will_update = will_update

ENDROUTINE


{******************************************************************************}

ROUTINE std_batch_entry_base_action_get_will_update ( self )

{
*	Return the will update flag
*
*******************************************************************************}

	RETURN ( self . will_update )

ENDROUTINE


{******************************************************************************}

ROUTINE std_batch_entry_base_action_get_samp_test_field (       self       ,
							     VALUE field_name )

{
*	Get the value of the given field in the samp_test view.
*	May need to read the row in if its not already there.
*
*******************************************************************************}

	DECLARE field_value  ,
		test_number

	field_value = SELECT samp_test_view . 'field_name'
		      IN OBJECT self

	IF field_value = EMPTY THEN

		test_number = self . get_test ()

		IF test_number <> EMPTY THEN

			field_value = SELECT samp_test_view . 'field_name'
				      IN OBJECT self
				      WHERE test_number = test_number

			object_copy_current_table ( self , "SAMP_TEST_VIEW" )

		ELSEIF self . template = EMPTY THEN

			field_value = ""

        	ELSEIF field_name = "PRODUCT" THEN

			field_value = self . template . get_limit ()

        	ELSEIF field_name = "STANDARD_ID" THEN

			field_value = self . template . get_standard ()

		ENDIF

	ENDIF

	RETURN ( field_value )

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_entry_base_action_is_same_as ( self       ,
						 instrument )

{
*	Does the entry match what the instrument has returned.
*
*******************************************************************************}

	DECLARE is_the_same

	is_the_same = ( self       . get_test () =
                        instrument . get_test ()   )

	RETURN ( is_the_same )

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_entry_base_action_is_complete ( self       ,
						  components )

{
*	Get the results and see if they are all entered
*
*
*******************************************************************************}

	DECLARE results   ,
		completed

	IF self . test_number <> EMPTY THEN

		results   = self . get_results ( FALSE )

		IF results <> EMPTY THEN
			completed = results . is_complete ( components )
		ELSE
			completed = TRUE
		ENDIF

	ELSE

		completed = FALSE

	ENDIF

	RETURN ( completed )

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_entry_base_action_test_is_complete ( self )

{
*	Check the test status for completion.
*
*
*******************************************************************************}

	DECLARE completed, test

	completed = FALSE

	IF self . test_number <> EMPTY THEN

		test = SELECT test . status
	       	       WHERE test_number = self . test_number

		completed = ( test = "C" )

	ENDIF

	RETURN ( completed )

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_entry_base_action_test_is_inspected ( self )

{
*	Check the test status for inspected.
*
*
*******************************************************************************}

	DECLARE inspected, test

	inspected = FALSE

	IF self . test_number <> EMPTY THEN

		test = SELECT test . status
	       	       WHERE test_number = self . test_number

		inspected = ( test = "I" )

	ENDIF

	RETURN ( inspected )

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_entry_base_action_update_sample_status (       self       ,
							   VALUE new_status )

{
*	Try to set the sample status
*
*
*******************************************************************************}

	DECLARE sample_id ,
		temp      ,
		status

	sample_id = self . get_samp_test_field ( "ID_NUMERIC" )

	IF  ( sample_id <> EMPTY      )
	AND ( NOT BLANK ( sample_id ) ) THEN

		temp = SELECT sample . id_numeric
		       FOR UPDATE
		       WHERE id_numeric = sample_id

		IF sample_id = temp THEN

			CHANGE SAMPLE STATUS TO new_status , status

			IF status = EMPTY THEN
		    		UPDATE sample
		    	ENDIF

     		ELSE

			status = get_user_message ( "BATCH_ENTRY_ERROR_SAMPLE_SELECT" , 1 )

   		ENDIF

	ELSE

		status = EMPTY

	ENDIF

	RETURN ( status )

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_entry_base_action_inspect_test ( self         ,
                                                   batch_header )

{
*
*	Inspect the test for this batch entry
*
*******************************************************************************}

	DECLARE test_locked , status

	status = EMPTY

	IF self . test_number <> EMPTY THEN

		test_locked = FALSE

		IF self . select_test_update ( test_locked ) THEN

			CHANGE TEST STATUS TO "I" USING test PROPAGATE , status

			IF status = EMPTY THEN
				UPDATE test
			ENDIF

		ELSE

			status = LOCKED

		ENDIF

	ENDIF

	RETURN ( status )

ENDROUTINE


{******************************************************************************}

ROUTINE std_batch_entry_base_action_inspect ( self         ,
				              components   ,
					      batch_header )

{
*	Inspect all the entry
*
*
*******************************************************************************}


	DECLARE status     ,
	        do_results ,
	        is_standard

	status     = EMPTY
	do_results = TRUE

	IF batch_header . type_authorise_standards THEN

		is_standard = self . get_samp_test_field ( "STANDARD" )

		IF  ( NOT BLANK ( is_standard ))
		AND ( is_standard              ) THEN

			do_results = FALSE

			self . update_sample_status ( "I" )

		ENDIF

	ENDIF

	IF do_results THEN

		IF GLOBAL ( "BATCH_AUTHORISE_TEST" ) AND
		   self . test_is_complete ( )       THEN

			status = self . inspect_test ( batch_header )

		ENDIF

	ENDIF

	RETURN ( status )

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_entry_base_action_authorise_test ( self         ,
                                                     batch_header )

{
*
*	Authorise the test for this batch entry
*
*******************************************************************************}

	DECLARE test_locked , status , sample_id

	status = EMPTY

	IF self . test_number <> EMPTY THEN

		test_locked = FALSE

		IF self . select_test_update ( test_locked ) THEN

			CHANGE TEST STATUS TO "A" USING test PROPAGATE , status

			IF status = EMPTY THEN

		   		batch_header . take_test_off_batch ( self )

				UPDATE test
				
				sample_id  = self . get_samp_test_field ( "ID_NUMERIC" )
			
				IF  ( sample_id <> EMPTY     ) AND
				    ( NOT BLANK ( sample_id )) THEN
					CALL_ROUTINE "auto_validate_sample" IN LIBRARY
					"$lib_samp_validate" USING sample_id, self . test_number
				ENDIF

			ENDIF

		ELSE

			status = LOCKED

		ENDIF

	ENDIF

	RETURN ( status )

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_entry_base_action_authorise_results ( self         ,
						        components   ,
						        batch_header )

{
*	Authorise all the given components.
*
*
*******************************************************************************}

	DECLARE status         ,
		name           ,
		count          ,
		result_object  ,
		reselected     ,
		results        ,
		internal_param


	status = EMPTY
	results  = self . get_results ( FALSE )

	IF results <> EMPTY THEN

		count    = 1

		WHILE count <= size_of_array ( components ) DO

			name = components [ count ]

			result_object = results . get_result_first ( EMPTY          ,
					                             name           ,
								     internal_param )

          		WHILE result_object <> EMPTY DO

				IF ( result_object . result_status = "A" ) OR
				   ( result_object . result_status = "R" ) OR
				   ( result_object . result_status = "X" ) THEN

					result_object = results .
					     get_result_next ( EMPTY          ,
					                       name           ,
					                       internal_param )

	  			ELSEIF result_object . upgrade_lock ( reselected ) THEN

					result_object . result_status = "A"
					result_object . store_status ( results )
                	                result_object . downgrade_lock ( results )

					result_object = results . get_result_next ( EMPTY          ,
								                         name           ,
									    	 internal_param )

				ELSE

					status        = locked
					count         = size_of_array ( components ) + 1
					result_object = EMPTY

	   			ENDIF

			ENDWHILE

     			count = count + 1

		ENDWHILE

	ENDIF

	RETURN ( status )

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_entry_base_action_authorise ( self         ,
						components   ,
						batch_header )

{
*	Authorise all the entry
*
*
*******************************************************************************}


	DECLARE status      ,
	        do_results  ,
	        is_standard

	do_results = TRUE

	IF batch_header . type_authorise_standards THEN

		is_standard = self . get_samp_test_field ( "STANDARD" )

		IF  ( NOT BLANK ( is_standard ))
		AND ( is_standard              ) THEN

			do_results = FALSE
			status = self . take_off_batch ( batch_header )

			IF status = EMPTY THEN

				self . update_sample_status ( "A" )

			ENDIF

		ENDIF

	ENDIF

	IF do_results THEN

		IF GLOBAL ( "BATCH_AUTHORISE_TEST"  ) AND
		   ( ( self . test_is_complete  ( ) ) OR
		     ( self . test_is_inspected ( ) )) THEN

			status = self . authorise_test ( batch_header )

		ELSE

			status = self . take_off_batch ( batch_header )

			IF status = EMPTY THEN

				status = self . authorise_results
				                      ( components   ,
						        batch_header )

			ENDIF

		ENDIF

	ENDIF

	RETURN ( status )

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_entry_base_action_reactivate ( self         ,
						 batch_header )

{
*	Reactivate the batch entry
*
*
*******************************************************************************}

	batch_header . put_test_on_batch ( self )

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_entry_base_action_cancel ( self         ,
				             batch_header )

{
*	Cancel the batch entry
*
*
*******************************************************************************}

	DECLARE status

	status = self . take_off_batch ( batch_header )

	IF status = EMPTY THEN
		status = self . update_sample_status ( "X" )
	ENDIF

	RETURN ( status )

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_entry_base_action_commit (       self        ,
				             VALUE destination )

{
*	Commit the batch entry
*
*
*******************************************************************************}

	DECLARE status ,
		sample ,
		form

	status = EMPTY

	sample = self . get_sample ()

	IF  ( NOT self . is_sample () )
	AND ( self . should_commit () ) THEN

		status = silent_sample ( sample , destination , "" )

	ENDIF

	IF status = EMPTY THEN

		CONSIGN BATCH_ENTRY IN OBJECT self TO destination , status

		IF status = EMPTY THEN

			form = EMPTY
			commit_audit_records ( form                           ,
			                       "BATCH_ENTRY"                  ,
			                       SELECT batch_entry . identity
			                               IN OBJECT self         ,
			                       destination                    ,
			                       status                         ,
			                       ""                             )

		ENDIF

	ENDIF

	RETURN ( status )

ENDROUTINE


{******************************************************************************}

ROUTINE std_batch_entry_base_action_should_commit ( self )


{
*	Determines whether this entry type should be committed?
*
*
*******************************************************************************}

	RETURN ( TRUE )

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_entry_base_action_review_full ( self )

{
*	Do a MLP comparison irrespective of batch type
*
*
*******************************************************************************}

	DECLARE limit         ,
		limit_version ,
		results       ,
		comparison

	limit         = self . get_samp_test_field ( "PRODUCT"         )
	limit_version = self . get_samp_test_field ( "PRODUCT_VERSION" )

	results = self . get_results ( FALSE )

	IF results <> EMPTY THEN

		comparison = results . mlp_compare ( limit         ,
						     limit_version ,
						     EMPTY         ,
					             FALSE         )

	ELSE

		comparison = "I"

	ENDIF

	self . review = comparison

	ASSIGN batch_entry . review_status IN OBJECT self = comparison

	RETURN ( comparison )

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_entry_base_action_review ( self )

{
*	Get the results and then compare against the limits for
*	the batch.
*
*******************************************************************************}

	DECLARE standard      ,
		limit         ,
		limit_version ,
		results       ,
		comparison

	limit         = self . get_samp_test_field ( "PRODUCT"         )
	limit_version = self . get_samp_test_field ( "PRODUCT_VERSION" )
	standard      = self . get_samp_test_field ( "STANDARD"        )

	IF  ( NOT BLANK ( standard ))
	AND ( standard              ) THEN

		results = self . get_results ( FALSE )

		IF results <> EMPTY THEN

			comparison = results . mlp_compare ( limit         ,
						             limit_version ,
							     EMPTY         ,
							     FALSE         )

		ELSE

			comparison = "I"

		ENDIF

	ELSE

		comparison = "P"

	ENDIF

	self . review = comparison

	ASSIGN batch_entry . review_status IN OBJECT self = comparison

	RETURN ( comparison )

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_entry_base_action_review_update ( self )

{
*	Update the record after review.
*
*******************************************************************************}

	UPDATE batch_entry IN OBJECT self

ENDROUTINE

{******************************************************************************}
{******************************************************************************}

ROUTINE std_batch_entry_sample_action_prompt_identity (       self           ,
    						              grid           ,
                                                        VALUE cell_column    ,
		                                        VALUE cell_row       ,
		                                        VALUE column         ,
		                                        VALUE row            ,
			                                VALUE cell_width     ,
			                                      screen         ,
					                VALUE is_display     )

{
*	Prompt for a test.
*
******************************************************************************}

	self . base_prompt_sampletest ( grid        ,
					cell_column ,
					cell_row    ,
					column      ,
					row         ,
					cell_width  ,
					screen      ,
					is_display  )

ENDROUTINE


{******************************************************************************}

ROUTINE std_batch_entry_sample_action_get_type ( self )

{
*	Return the type of the entry
*
*
*******************************************************************************}

	DECLARE name

	name = get_user_message ( "BATCH_ENTRY_SAMPLE_NAME" , 1 )

	RETURN ( name )

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_entry_sample_action_database_name ( self )

{
*	Return the database name of the entry
*
*
*******************************************************************************}

	RETURN ( BATCH_ENTRY_SAMPLE )

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_entry_sample_action_should_create_section ( self )

{
*	Overridable routine to state that if you find one of these things
*	in a section then create the section
*
*******************************************************************************}

	RETURN ( self . test_number <> EMPTY )

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_entry_sample_action_entry_result_list ( self            ,
							  batch_header    ,
						          template_header ,
						          result_list     )

{
*	Alter an existing test to add extra results.
*
*
*******************************************************************************}

	IF batch_header . type_reporting_category <> EMPTY THEN

		result_list . copy_category_test (  self . test_number ,
					            CATEGORY_READING   )

	ENDIF

ENDROUTINE


{******************************************************************************}

ROUTINE std_batch_entry_sample_action_is_sample ( self )

{
*	Overridable routine to state that if this thing is a real sample
*
*******************************************************************************}

	RETURN ( TRUE )

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_entry_sample_action_cancel ( self         ,
					       batch_header )

{
*	Cancel the sample from the batch
*
*******************************************************************************}

DECLARE status

	status = EMPTY

	IF self . test_number <> EMPTY THEN

		status = self . take_off_batch ( batch_header )

	ENDIF

	RETURN ( status )

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_entry_sample_action_review ( self )

{
*	Review a sample - only do surrogate components
*
*******************************************************************************}


	DECLARE limit         ,
		limit_version ,
		results       ,
		comparison    ,
		result        ,
		name          ,
		count         ,
		status

	comparison = MLP_CONST_PASS

	limit         = self . get_samp_test_field ( "PRODUCT"         )
	limit_version = self . get_samp_test_field ( "PRODUCT_VERSION" )
	results       = self . get_results ( FALSE )

	IF results <> EMPTY THEN

		count  = 1

		WHILE count <= results . size () DO

			result = results . get_by_number ( count )

			name   = result . get_name ()

			IF lib_comp_has_category ( name               ,
						   CATEGORY_SURROGATE ) THEN


				IF result . result_entered () THEN

					status = result . mlp_compare ( results        ,
									limit          ,
									limit_version  ,
									EMPTY          ,
									FALSE          )

				ELSE

					status = MLP_CONST_INDETERMINATE

				ENDIF

				IF status = MLP_CONST_INDETERMINATE THEN

					IF comparison = MLP_CONST_PASS THEN

						comparison = MLP_CONST_INDETERMINATE

					ENDIF

				ELSEIF status = MLP_CONST_FAIL THEN

					comparison = MLP_CONST_FAIL

				ENDIF

			ENDIF

			count = count + 1

		ENDWHILE

	ENDIF

	self . review = comparison

	ASSIGN batch_entry . review_status IN OBJECT self = comparison

	RETURN ( comparison )

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_entry_sample_action_review_update ( self )

{
*	Post review update
*
*******************************************************************************}

	UPDATE batch_entry IN OBJECT self

ENDROUTINE

{******************************************************************************}
{******************************************************************************}

ROUTINE std_batch_entry_standard_action_get_type ( self )

{
*	Return the type of the entry
*
*
*******************************************************************************}

	DECLARE name

	name = get_user_message ( "BATCH_ENTRY_STANDARD_NAME" , 1 )

	RETURN ( name )

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_entry_standard_action_database_name ( self )

{
*	Return the database name of the entry
*
*
*******************************************************************************}

	RETURN ( BATCH_ENTRY_STANDARD )

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_entry_standard_action_should_create_section ( self )

{
*	Overridable routine to state that if you find one of these things
*	in a section then create the section
*
*******************************************************************************}

	RETURN ( FALSE )

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_entry_standard_action_prompt_identity (       self           ,
    						                grid           ,
                                                          VALUE cell_column    ,
		                                          VALUE cell_row       ,
		                                          VALUE column         ,
		                                          VALUE row            ,
			                                  VALUE cell_width     ,
			                                        screen         ,
					                  VALUE is_display     )

{
*	Prompt for a standard ID
*
******************************************************************************}

	self . base_prompt_standard ( grid        ,
			              cell_column ,
			              cell_row    ,
				      column      ,
				      row         ,
				      cell_width  ,
				      screen      ,
				      is_display  )

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_entry_standard_action_create_sample ( self            ,
							batch_header    ,
							template_header ,
							message         )

{
*	Create a sample for a standard
*
*******************************************************************************}

	DECLARE template       ,
		limit          ,
		analysis       ,
		result_list    ,
		component_list ,
		standard       ,
		version        ,
		worked

	IF self . get_sample_details ( standard ,
				       version  ,
				       template ,
				       message  ) THEN

		result_list    = EMPTY
		component_list = ""
		limit          = template_header . get_limit ()

		IF batch_header . type_supports_component_lists THEN

			component_list = self . template . get_component_list ()

		ENDIF

		IF ( batch_header . type_supports_result_lists ) AND
		   ( blank ( component_list )                  ) THEN

			IF batch_entry_result_list_name <>
					template_header . get_work_profile () THEN

				CREATE OBJECT RESULT_LIST_CREATE_HEADER, result_list
				batch_entry_result_list_name =
					template_header . get_work_profile ()

			ELSE

				result_list = batch_entry_result_list

			ENDIF

			result_list . ignore_error = TRUE
			result_list . analysis = template_header . get_analysis ()
			result_list . analysis_version =
				lib_utils_highest_version ( "VERSIONED_ANALYSIS" ,
					                     result_list . analysis )

			IF batch_entry_result_list = EMPTY THEN

	      			result_list . read_component_list ( template_header . get_work_profile (),
								    TRUE                                 ,
								    TRUE                                 )

			ELSE

				result_list . reset_component_list ( TRUE )

			ENDIF

			self . entry_result_list ( batch_header      ,
						   template_header   ,
						   result_list       )

			self . type_result_list ( batch_header ,
						  result_list  )

			batch_entry_result_list = result_list

		ELSEIF blank ( component_list ) THEN

	        	component_list = template_header . get_work_profile ()

		ENDIF

		IF batch_header . type_supports_mlps THEN

			IF NOT blank ( self . template . get_limit ()) THEN

				limit          = self . template . get_limit  ( )

			ENDIF

		ENDIF


		analysis       = template_header . get_analysis ()

		self . login_sample ( batch_header   ,
				      standard       ,
				      version        ,
				      template       ,
				      limit          ,
				      analysis       ,
				      component_list ,
				      result_list    )

		worked = EMPTY

	ELSE

		worked = message

	ENDIF


	RETURN ( worked )

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_entry_standard_action_standard_result_list (       self            ,
							             batch_header    ,
							             template_header ,
							             result_list     ,
							       VALUE extra_category  )

{
*	Create the result list for a standard sample.
*
*
*******************************************************************************}

	DECLARE count       ,
		entry       ,
		test_number ,
		category

 	IF batch_header . type_supports_category  THEN

		category = CATEGORY_READING

	ELSE

		category = EMPTY

	ENDIF

	count = 1

	WHILE count <= batch_header . size () DO

		entry       = batch_header . get_entry ( count )
  		test_number = entry . test_number

		IF ( test_number <> EMPTY ) AND
  		   ( entry . is_sample () ) THEN

			result_list . copy_category_test ( test_number ,
							   category    )


		ENDIF

		count = count + 1

     	ENDWHILE

	IF extra_category <> EMPTY THEN

		result_list . copy_category ( category       ,
					      extra_category )

	ENDIF

ENDROUTINE


{******************************************************************************}

ROUTINE std_batch_entry_standard_action_entry_result_list ( self              ,
							    batch_header      ,
							    template_header   ,
							    result_list       )

{
*	Create the result list for a standard sample.
*
*
*******************************************************************************}

	self . standard_result_list ( batch_header    ,
				      template_header ,
                                      result_list     ,
				      EMPTY           )

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_entry_standard_action_delete ( self         ,
					         batch_header )

{
*	Take the test off the batch and delete the entry.
*	Cancel the sample
*
*
******************************************************************************}

	IF self . get_test () <> EMPTY THEN

		self . take_off_batch ( batch_header )
		self . update_sample_status ( "X" )

	ENDIF

	IF SELECT batch_entry . identity IN OBJECT self <> EMPTY THEN

		DELETE batch_entry IN OBJECT self

	ENDIF

ENDROUTINE


{******************************************************************************}
{******************************************************************************}

ROUTINE std_batch_entry_control_action_get_type ( self )

{
*	Return the type of the entry
*
*
*******************************************************************************}

	DECLARE name

	name = get_user_message ( "BATCH_ENTRY_CONTROL_NAME" , 1 )

	RETURN ( name )

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_entry_control_action_database_name ( self )

{
*	Return the type of the entry
*
*
*******************************************************************************}

	RETURN ( BATCH_ENTRY_CONTROL )

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_entry_control_action_entry_result_list ( self              ,
							   batch_header      ,
							   template_header   ,
							   result_list       )

{
*	Create the result list for a control sample.
*
*
*******************************************************************************}

	self . standard_result_list ( batch_header     ,
				      template_header  ,
                                      result_list      ,
				      CATEGORY_CONTROL )

ENDROUTINE



{******************************************************************************}

ROUTINE std_batch_entry_blank_action_get_type ( self )

{
*	Return the type of the entry
*
*
*******************************************************************************}

	DECLARE name

	name = get_user_message ( "BATCH_ENTRY_BLANK_NAME" , 1 )

	RETURN ( name )

ENDROUTINE
{******************************************************************************}

ROUTINE std_batch_entry_blank_action_database_name ( self )

{
*	Return the database name of the entry
*
*
*******************************************************************************}

	RETURN ( BATCH_ENTRY_BLANK )

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_entry_blank_action_entry_result_list ( self              ,
							 batch_header      ,
							 template_header   ,
							 result_list       )

{
*	Create the result list for a blank sample.
*
*
*******************************************************************************}

	DECLARE category

	IF global ( "BATCH_BLANK_CATEGORY" ) THEN

		category = CATEGORY_BLANK

	ELSE

		category = EMPTY

	ENDIF

	self . standard_result_list ( batch_header     ,
				      template_header  ,
                                      result_list      ,
				      category         )

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_entry_wash_action_create_sample ( self            ,
					            batch_header    ,
						    template_header ,
						    message         )

{
*	Create a sample for a wash i.e do nothing
*
*******************************************************************************}

	RETURN ( EMPTY )

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_entry_wash_action_modify_sample ( self            ,
					            batch_header    ,
						    template_header ,
						    message         )

{
*	Modify a sample for a wash i.e do nothing
*
*******************************************************************************}

	RETURN ( TRUE )

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_entry_wash_action_should_create_section ( self )

{
*	Overridable routine to state that if you find one of these things
*	in a section then create the section
*
*******************************************************************************}

	RETURN ( FALSE )

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_entry_wash_action_should_create ( self )

{
*	Overridable routine to state that if you find one of these things
*	in a section then create the section
*
*******************************************************************************}

	RETURN ( TRUE )

ENDROUTINE


{******************************************************************************}

ROUTINE std_batch_entry_wash_action_get_type ( self )

{
*	Return the type of the entry
*
*
*******************************************************************************}

	DECLARE name

	name = get_user_message ( "BATCH_ENTRY_WASH_NAME" , 1 )

	RETURN ( name )

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_entry_wash_action_database_name ( self )

{
*	Return the database name of the entry
*
*
*******************************************************************************}

	RETURN ( BATCH_ENTRY_WASH )

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_entry_wash_action_prompt_identity (       self           ,
    						            grid           ,
                                                      VALUE cell_column    ,
		                                      VALUE cell_row       ,
		                                      VALUE column         ,
		                                      VALUE row            ,
			                              VALUE cell_width     ,
			                                    screen         ,
					              VALUE is_display     )

{
*	Prompt for a parent ID
*
******************************************************************************}

	IF is_display THEN

		CLEAR LINE row
		      FROM column
		      TO   column + cell_width - 1
		      IN WINDOW screen

	ELSE

		PROMPT ON LINE   row
		       FROM      column
		       TO        column + cell_width - 1
		       IN WINDOW screen


	ENDIF

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_entry_wash_action_review ( self )

{
*	Review a wash - do nothing
*
*******************************************************************************}

	DECLARE comparison

	comparison = MLP_CONST_PASS

	self . review = comparison

	ASSIGN batch_entry . review_status IN OBJECT self = comparison

	RETURN ( comparison )

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_entry_wash_action_is_complete ( self       ,
						  components )

{
*	Get the results and see if they are all entered
*	Given that there never will be any results - this is easy!.
*
*
*******************************************************************************}

	RETURN  ( TRUE )

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_entry_wash_action_should_commit ( self )


{
*	Determines whether this entry type should be committed?
*
*
*******************************************************************************}

	RETURN ( FALSE )

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_entry_ms_action_want_parent ( self )

{
*	Overridable routine to state that if this element wants a parent.
*
*******************************************************************************}

	RETURN ( TRUE )

ENDROUTINE


{******************************************************************************}

ROUTINE std_batch_entry_ms_action_prompt_identity (       self           ,
    						          grid           ,
                                                    VALUE cell_column    ,
		                                    VALUE cell_row       ,
		                                    VALUE column         ,
		                                    VALUE row            ,
			                            VALUE cell_width     ,
			                                  screen         ,
					            VALUE is_display     )

{
*	Prompt for a parent ID
*
******************************************************************************}

	IF self . test_number <> EMPTY THEN

		self . base_prompt_standard ( grid        ,
				              cell_column ,
				              cell_row    ,
					      column      ,
					      row         ,
	  				      cell_width  ,
					      screen      ,
					      is_display  )

	ELSE

		self . base_prompt_parent ( grid        ,
				            cell_column ,
				            cell_row    ,
					    column      ,
					    row         ,
		   			    cell_width  ,
					    screen      ,
					    is_display  ,
       					    FALSE       )

	ENDIF

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_entry_ms_action_get_type ( self )

{
*	Return the type of the entry
*
*
*******************************************************************************}

	DECLARE name

	name = get_user_message ( "BATCH_ENTRY_MS_NAME" , 1 )

	RETURN ( name )

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_entry_ms_action_database_name ( self )

{
*	Return the database name of the entry
*
*
*******************************************************************************}

	RETURN ( BATCH_ENTRY_MS )

ENDROUTINE


{******************************************************************************}

ROUTINE std_batch_entry_ms_action_entry_result_list ( self              ,
					              batch_header      ,
					              template_header   ,
						      result_list       )

{
*	Create the result list for a MS sample.
*
*
*******************************************************************************}

	DECLARE parent     ,
		parent_test

	parent = self . find_parent ( batch_header )

	IF parent <> EMPTY THEN

		parent_test = parent . test_number

		result_list . copy_category_test (  parent_test      ,
				                    CATEGORY_READING )

		result_list . copy_category ( CATEGORY_READING ,
					      CATEGORY_MS      )

	ENDIF

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_entry_msd_action_want_parent ( self )

{
*	Overridable routine to state that if this element wants a parent.
*
*******************************************************************************}

	RETURN ( TRUE )

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_entry_msd_action_get_type ( self )

{
*	Return the type of the entry
*
*
*******************************************************************************}

	DECLARE name

	name = get_user_message ( "BATCH_ENTRY_MSD_NAME" , 1 )

	RETURN ( name )

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_entry_msd_action_database_name ( self )

{
*	Return the database name of the entry
*
*
*******************************************************************************}

	RETURN ( BATCH_ENTRY_MSD )

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_entry_msd_action_set_ms_parent ( self    ,
						   batch   ,
						   parent  )

{
*	Set the parent of the MSD to be a MS if it is a sample.
*
*
*******************************************************************************}

	DECLARE count  ,
		entry

	IF parent . get_class_name () <> STD_BATCH_ENTRY_MS THEN

		count = 1

		WHILE count <= batch . size () DO

			entry = batch . get_entry ( count )

			IF ( entry . parent_test       = self . parent_test ) AND
			   ( entry . get_class_name () = "STDBATCHENTRYMS" ) THEN

				self . parent_test = entry . test_number
				count = batch . size ()

			ENDIF

			count = count + 1

		ENDWHILE

	ENDIF

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_entry_msd_action_entry_result_list ( self              ,
						       batch_header      ,
						       template_header   ,
						       result_list       )

{
*	Create the result list for a MSD sample.
*
*
*******************************************************************************}

	DECLARE parent_test ,
		parent

	parent = self . find_real_parent ( batch_header )


	IF parent <> EMPTY THEN

		self . set_ms_parent ( batch_header ,
				       parent       )


		parent_test = parent . test_number

		result_list . copy_category_test ( parent_test      ,
					           CATEGORY_READING )

		result_list . copy_category ( CATEGORY_READING ,
			                      CATEGORY_MSD     )

		result_list . copy_category ( CATEGORY_READING  ,
					      CATEGORY_RPD      )

	ENDIF

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_entry_msd_action_prompt_identity (       self           ,
    						           grid           ,
                                                     VALUE cell_column    ,
		                                     VALUE cell_row       ,
		                                     VALUE column         ,
		                                     VALUE row            ,
			                             VALUE cell_width     ,
			                                   screen         ,
					             VALUE is_display     )

{
*	Prompt for a parent ID
*
******************************************************************************}

	IF self . test_number <> EMPTY THEN

		self . base_prompt_standard ( grid        ,
				              cell_column ,
				              cell_row    ,
					      column      ,
					      row         ,
	  				      cell_width  ,
					      screen      ,
					      is_display  )

	ELSE

		self . base_prompt_parent ( grid        ,
				            cell_column ,
				            cell_row    ,
					    column      ,
					    row         ,
		   			    cell_width  ,
					    screen      ,
					    is_display  ,
       					    FALSE       )

	ENDIF

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_entry_cal_std_action_get_type ( self )

{
*	Return the type of the entry
*
*
*******************************************************************************}

	DECLARE name

	name = get_user_message ( "BATCH_ENTRY_CAL_STD_NAME" , 1 )

	RETURN ( name )

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_entry_cal_std_action_database_name ( self )

{
*	Return the database name of the entry
*
*
*******************************************************************************}

	RETURN ( BATCH_ENTRY_CAL_STD )

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_entry_cal_blank_action_get_type ( self )

{
*	Return the type of the entry
*
*
*******************************************************************************}

	DECLARE name

	name = get_user_message ( "BATCH_ENTRY_CAL_BLANK_NAME" , 1 )

	RETURN ( name )

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_entry_cal_blank_action_database_name ( self )

{
*	Return the database name of the entry
*
*
*******************************************************************************}

	RETURN ( BATCH_ENTRY_CAL_BLANK )

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_entry_cal_blank_action_entry_result_list ( self              ,
							     batch_header      ,
							     template_header   ,
							     result_list       )

{
*	Create the result list for a blank sample.
*
*
*******************************************************************************}

	DECLARE category

	IF global ( "BATCH_BLANK_CATEGORY" ) THEN

		category = CATEGORY_BLANK

	ELSE

		category = EMPTY

	ENDIF

	self . standard_result_list ( batch_header     ,
				      template_header  ,
                                      result_list      ,
				      category         )


ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_entry_blank_chk_action_get_type ( self )

{
*	Return the type of the entry
*
*
*******************************************************************************}

	DECLARE name

	name = get_user_message ( "BATCH_ENTRY_BLANK_CHK_NAME" , 1 )

	RETURN ( name )

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_entry_blank_chk_action_database_name ( self )

{
*	Return the database name of the entry
*
*
*******************************************************************************}

	RETURN ( BATCH_ENTRY_BLANK_CHK )

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_entry_blank_chk_action_entry_result_list ( self              ,
							     batch_header      ,
							     template_header   ,
							     result_list       )

{
*	Create the result list for a blank sample.
*
*
*******************************************************************************}

	DECLARE category

	IF global ( "BATCH_BLANK_CATEGORY" ) THEN

		category = CATEGORY_BLANK

	ELSE

		category = EMPTY

	ENDIF

	self . standard_result_list ( batch_header     ,
				      template_header  ,
                                      result_list      ,
				      category         )

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_entry_meth_blank_action_get_type ( self )

{
*	Return the type of the entry
*
*
*******************************************************************************}

	DECLARE name

	name = get_user_message ( "BATCH_ENTRY_METH_BLANK_NAME" , 1 )

	RETURN ( name )

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_entry_meth_blank_action_database_name ( self )

{
*	Return the database name of the entry
*
*
*******************************************************************************}

	RETURN ( BATCH_ENTRY_METH_BLANK )

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_entry_meth_blank_action_entry_result_list ( self              ,
							      batch_header      ,
							      template_header   ,
							      result_list       )

{
*	Create the result list for a blank sample.
*
*
*******************************************************************************}

	self . standard_result_list ( batch_header     ,
				      template_header  ,
                                      result_list      ,
				      CATEGORY_BLANK   )

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_entry_cal_chk_action_get_type ( self )

{
*	Return the type of the entry
*
*
*******************************************************************************}

	DECLARE name

	name = get_user_message ( "BATCH_ENTRY_CAL_CHK_NAME" , 1 )

	RETURN ( name )

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_entry_cal_chk_action_database_name ( self )

{
*	Return the database name of the entry
*
*
*******************************************************************************}

	RETURN ( BATCH_ENTRY_CAL_CHK )

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_entry_cal_chk_action_entry_result_list ( self              ,
							   batch_header      ,
							   template_header   ,
							   result_list       )

{
*	Create the result list for a cal_chk sample.
*
*
*******************************************************************************}

	self . standard_result_list ( batch_header     ,
				      template_header  ,
                                      result_list      ,
				      CATEGORY_CAL_CHK )

ENDROUTINE


{******************************************************************************}

ROUTINE std_batch_entry_indep_chk_action_get_type ( self )

{
*	Return the type of the entry
*
*
*******************************************************************************}

	DECLARE name

	name = get_user_message ( "BATCH_ENTRY_INDEP_CHK_NAME" , 1 )

	RETURN ( name )

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_entry_indep_chk_action_database_name ( self )

{
*	Return the database name of the entry
*
*
*******************************************************************************}

	RETURN ( BATCH_ENTRY_INDEP_CHK )

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_entry_indep_chk_action_entry_result_list ( self              ,
							     batch_header      ,
							     template_header   ,
							     result_list       )

{
*	Create the result list for a cal_chk sample.
*
*
*******************************************************************************}

	self . standard_result_list ( batch_header       ,
				      template_header    ,
                                      result_list        ,
				      CATEGORY_INDEP_CHK )

ENDROUTINE


{******************************************************************************}

ROUTINE std_batch_entry_init_chk_action_get_type ( self )

{
*	Return the type of the entry
*
*
*******************************************************************************}

	DECLARE name

	name = get_user_message ( "BATCH_ENTRY_INIT_CHK_NAME" , 1 )

	RETURN ( name )

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_entry_init_chk_action_database_name ( self )

{
*	Return the database name of the entry
*
*
*******************************************************************************}

	RETURN ( BATCH_ENTRY_INIT_CHK )

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_entry_init_chk_action_entry_result_list ( self              ,
							    batch_header      ,
							    template_header   ,
							    result_list       )

{
*	Create the result list for a cal_chk sample.
*
*
*******************************************************************************}

	self . standard_result_list ( batch_header      ,
				      template_header   ,
                                      result_list       ,
				      CATEGORY_INIT_CHK )

ENDROUTINE


{******************************************************************************}

ROUTINE std_batch_entry_interf_chk_action_get_type ( self )

{
*	Return the type of the entry
*
*
*******************************************************************************}

	DECLARE name

	name = get_user_message ( "BATCH_ENTRY_INTERF_CHK_NAME" , 1 )

	RETURN ( name )

ENDROUTINE
{******************************************************************************}

ROUTINE std_batch_entry_interf_chk_action_database_name ( self )

{
*	Return the database name of the entry
*
*
*******************************************************************************}

	RETURN ( BATCH_ENTRY_INTERF_CHK )

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_entry_interf_chk_action_entry_result_list ( self              ,
							      batch_header      ,
							      template_header   ,
							      result_list       )

{
*	Create the result list for a interf_chk sample.
*
*
*******************************************************************************}

	self . standard_result_list ( batch_header        ,
				      template_header     ,
                                      result_list         ,
				      CATEGORY_INTERF_CHK )

ENDROUTINE



{******************************************************************************}

ROUTINE std_batch_entry_duplicate_action_get_type ( self )

{
*	Return the type of the entry
*
*
*******************************************************************************}

	DECLARE name

	name = get_user_message ( "BATCH_ENTRY_DUPLICATE_NAME" , 1 )

	RETURN ( name )

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_entry_duplicate_action_database_name ( self )

{
*	Return the database name of the entry
*
*
*******************************************************************************}

	RETURN ( BATCH_ENTRY_DUPLICATE )

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_entry_duplicate_action_want_parent ( self )

{
*	Overridable routine to state that if this element wants a parent.
*
*******************************************************************************}

	RETURN ( TRUE )

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_entry_duplicate_action_prompt_identity (       self           ,
    						                 grid           ,
                                                           VALUE cell_column    ,
		                                           VALUE cell_row       ,
		                                           VALUE column         ,
		                                           VALUE row            ,
			                                   VALUE cell_width     ,
			                                         screen         ,
					                   VALUE is_display     )

{
*	Prompt for a parent ID
*
******************************************************************************}

	IF self . test_number <> EMPTY THEN

		self . base_prompt_standard ( grid        ,
				              cell_column ,
				              cell_row    ,
					      column      ,
					      row         ,
	  				      cell_width  ,
					      screen      ,
					      is_display  )

	ELSE

		self . base_prompt_parent ( grid        ,
				            cell_column ,
				            cell_row    ,
					    column      ,
					    row         ,
		   			    cell_width  ,
					    screen      ,
					    is_display  ,
       					    FALSE       )

	ENDIF

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_entry_duplicate_action_entry_result_list ( self              ,
					                     batch_header      ,
					                     template_header   ,
						             result_list       )

{
*	Create the result list for a duplicate sample.
*
*
*******************************************************************************}

	DECLARE parent     ,
		parent_test

	parent = self . find_parent ( batch_header )

	IF parent <> EMPTY THEN

		parent_test = parent . test_number

		result_list . copy_category_test (  parent_test      ,
				                    CATEGORY_READING )

		result_list . copy_category ( CATEGORY_READING   ,
					      CATEGORY_DUPLICATE )

	ENDIF

ENDROUTINE


