{******************************************************************************
*
* Module Name   : $BATCH_CHROM.RPF
*
* Purpose       : Contains the classes supporting the chrom link
*
* Document Ref. : 
*
* Specification : SE/T/VGSM320-WORK-BATCH
*
* Portability   : Not Checked
*
* Re-entrant    : 
*
*******************************************************************************}

ENABLE WINDOWS
SET NOTPROTECTED
SET NAME "DEFER/"
SET COMPILE_OPTION DECLARE

JOIN STANDARD_LIBRARY STD_MULTICHROM
JOIN STANDARD_LIBRARY STD_MESSAGE
JOIN STANDARD_LIBRARY STD_ARRAY
JOIN STANDARD_LIBRARY STD_CLASS

JOIN LIBRARY $BATCH_UTILS
JOIN LIBRARY $BATCH_USER
JOIN LIBRARY $LIB_COMP

DECLARE batch_chrom_lookup_table

{******************************************************************************}

GLOBAL ROUTINE batch_chrom_initialise

{
*
*
*******************************************************************************}

	IF NOT global ( "LIBRARY_INITIALISED" ) THEN

		batch_chrom_define_classes ()
		batch_chrom_define_lookup  ()

		SET GLOBAL "LIBRARY_INITIALISED" TO TRUE

	ENDIF
	
ENDROUTINE

{******************************************************************************}

ROUTINE batch_chrom_define_classes

{
*
*
*******************************************************************************}


	DEFINE CLASS STD_BATCH_CHROM_ANALYSIS

		PROPERTIES "DEVICE_NAME"           ,
			   "PROJECT_NAME"          ,
			   "ANALYSIS_NAME"         ,
			   "CHANNEL_NUMBER"        ,
			   "SAMPLES"               ,	
			   "USER_INFO"	

		ACTIONS    "SET_ANALYSIS"          ,
			   "READ_ANALYSIS"         ,
			   "READ_SAMPLES"          ,
			   "SAMPLE_SIZE"           ,
			   "GET_ENTRY"             ,
			   "GET_SAMPLE"            ,
			   "GET_TEST"              ,
			   "GET_RESULT"            ,
			   "GET_NUMBER_OF_SAMPLES" ,
			   "CREATE_DOWNLOAD"       ,
			   "MODIFY_DOWNLOAD"	   ,
			   "FINISH_DOWNLOAD"       ,
			   "DOWNLOAD_HEADER"       ,
			   "DOWNLOAD_SAMPLE"       ,
			   "CREATE_UPLOAD"         ,
			   "FINISH_UPLOAD"         ,
			   "ASSIGN"

	END CLASS

	DEFINE CLASS STD_BATCH_CHROM_SAMPLE

		PROPERTIES "SAMPLE_NUMBER"     ,
			   "INJECTION_NUMBER"  ,
			   "SAMPLE_NAME"       ,
			   "LIMS_NAME"         ,
			   "SAMPLE_TYPE"       ,
			   "BAD_INJECTION"     ,
			   "PEAKS"	       ,	
			   "USER_INFO"	

		ACTIONS    "READ_SAMPLE"         ,
			   "READ_PEAKS"          ,
			   "GET_PEAKS"           ,
			   "GET_MISSING_PEAKS"   ,
			   "GET_COMPOSITE_PEAKS" ,
			   "GET_GROUP_PEAKS"	 ,			
			   "GET_RESULT"		 ,
			   "IS_BATCH_CLASS"	 ,
			   "GET_BATCH_CLASS"     ,
			   "SET_TEST" 	         ,
			   "GET_TEST" 	         ,
			   "GET_SAMPLE" 	 ,
			   "ASSIGN"

	END CLASS

	DEFINE CLASS STD_BATCH_CHROM_PEAK

		PROPERTIES "COMPONENT_NAME"    ,
			   "PEAK_NAME"         ,
			   "AMOUNT"            ,
			   "DETECTED"          ,
			   "USER_INFO"	


	END CLASS

ENDROUTINE

{******************************************************************************}

ROUTINE batch_chrom_define_lookup

{
*
*
*******************************************************************************}

	DECLARE count	

	ARRAY batch_chrom_lookup_table ARRAY_SIZE ( 0 , 2 ) 


	batch_chrom_lookup_table [ 1, 1] = BATCH_ENTRY_SAMPLE 
	batch_chrom_lookup_table [ 1, 2] = "SA"

	batch_chrom_lookup_table [ 2, 1] = BATCH_ENTRY_BLANK 
	batch_chrom_lookup_table [ 2, 2] = "BL"

	batch_chrom_lookup_table [ 3, 1] = BATCH_ENTRY_CONTROL 
	batch_chrom_lookup_table [ 3, 2] = "CO"

   	batch_chrom_lookup_table [ 4, 1] = BATCH_ENTRY_STANDARD 
	batch_chrom_lookup_table [ 4, 2] = "ST"

	batch_chrom_lookup_table [ 5, 1] = BATCH_ENTRY_MS 
	batch_chrom_lookup_table [ 5, 2] = "SA"
   
	batch_chrom_lookup_table [ 6, 1] = BATCH_ENTRY_MSD 
	batch_chrom_lookup_table [ 6, 2] = "SA"
   
	batch_chrom_lookup_table [ 7, 1] = BATCH_ENTRY_CAL_STD 
	batch_chrom_lookup_table [ 7, 2] = "ST"
      
	batch_chrom_lookup_table [ 8, 1] = BATCH_ENTRY_CAL_BLANK 
	batch_chrom_lookup_table [ 8, 2] = "ST"
   
	batch_chrom_lookup_table [ 9, 1] = BATCH_ENTRY_BLANK_CHK 
	batch_chrom_lookup_table [ 9, 2] = "ST"
   
	batch_chrom_lookup_table [ 10, 1] = BATCH_ENTRY_METH_BLANK 
	batch_chrom_lookup_table [ 10, 2] = "ST"
   
	batch_chrom_lookup_table [ 11, 1] = BATCH_ENTRY_CAL_CHK 
	batch_chrom_lookup_table [ 11, 2] = "ST"

	batch_chrom_lookup_table [ 12, 1] = BATCH_ENTRY_INDEP_CHK 
	batch_chrom_lookup_table [ 12, 2] = "ST"

	batch_chrom_lookup_table [ 13, 1] = BATCH_ENTRY_INTERF_CHK 
	batch_chrom_lookup_table [ 13, 2] = "ST"

	batch_chrom_lookup_table [ 14, 1] = BATCH_ENTRY_DUPLICATE 
	batch_chrom_lookup_table [ 14, 2] = "SA"

	batch_chrom_lookup_table [ 15, 1] = BATCH_ENTRY_WASH 
	batch_chrom_lookup_table [ 15, 2] = "SA"

	batch_user_multichrom_type_lookup ( batch_chrom_lookup_table )

	count = 1

	WHILE count <= size_of_array ( batch_chrom_lookup_table ) DO

		batch_chrom_lookup_table [ count , 1 ] = 
			substitute ( batch_chrom_lookup_table [ count , 1 ] ,
				     "_" , "" )

		count = count + 1

	ENDWHILE

ENDROUTINE

{******************************************************************************}

ROUTINE batch_chrom_lookup_type ( VALUE type )

{
*
*
*******************************************************************************}

	DECLARE count  

	count =1 

	WHILE count <= size_of_array ( batch_chrom_lookup_table ) DO

		IF batch_chrom_look_up_table [ count , 1 ] = type THEN

			RETURN ( batch_chrom_lookup_table [ count , 2 ])

		ENDIF

		count = count + 1

	ENDWHILE

	RETURN ( "SA" )

ENDROUTINE

{******************************************************************************}

GLOBAL ROUTINE batch_chrom_error_to_text ( VALUE status )

{
*
*
******************************************************************************}

	DECLARE message

        IF status =  STATUS_UNDEFINED THEN

		message = "STD_MULTICHROM_STATUS_UNDEFINED"

        ELSEIF status =  STATUS_OK THEN

		message = "STD_MULTICHROM_STATUS_OK"

        ELSEIF status =  ANALYSIS_ERROR THEN

		message = "STD_MULTICHROM_ANALYSIS_ERROR"

        ELSEIF status =  INVALID_CHANNEL THEN

		message = "STD_MULTICHROM_INVALID_CHANNEL"

        ELSEIF status =  ANALYSIS_NOT_SET THEN

		message = "STD_MULTICHROM_ANALYSIS_NOT_SET"

        ELSEIF status =  SAMPLE_ERROR THEN

		message = "STD_MULTICHROM_SAMPLE_ERROR"

        ELSEIF status =  INJECTION_OUT_RANGE THEN

		message = "STD_MULTICHROM_INJECTION_OUT_RANGE"

        ELSEIF status =  SAMPLE_OUT_RANGE THEN

		message = "STD_MULTICHROM_SAMPLE_OUT_RANGE"

        ELSEIF status =  SAMPLE_NOT_SET THEN

		message = "STD_MULTICHROM_SAMPLE_NOT_SET"

        ELSEIF status =  NO_PEAK_DATA THEN

		message = "STD_MULTICHROM_NO_PEAK_DATA"

        ELSEIF status =  NO_AMOUNT_DATA THEN

		message = "STD_MULTICHROM_NO_AMOUNT_DATA"

        ELSEIF status =  RAW_OPEN_ERROR THEN

		message = "STD_MULTICHROM_RAW_OPEN_ERROR"

        ELSEIF status =  ALREADY_OPEN THEN

		message = "STD_MULTICHROM_ALREADY_OPEN"

        ELSEIF status =  NOT_OPEN THEN

		message = "STD_MULTICHROM_NOT_OPEN"

        ELSEIF status =  BAD_RT THEN

		message = "STD_MULTICHROM_BAD_RT"

        ELSEIF status =  PEAK_OPEN_ERROR THEN

		message = "STD_MULTICHROM_PEAK_OPEN_ERROR"

        ELSEIF status =  INVALID_PEAK THEN

		message = "STD_MULTICHROM_INVALID_PEAK"

        ELSEIF status =  GET_PEAK_ERROR THEN

		message = "STD_MULTICHROM_GET_PEAK_ERROR"

        ELSEIF status =  USERNAME_UNDEFINED THEN

		message = "STD_MULTICHROM_USERNAME_UNDEFINED"

        ELSEIF status =  PROJECT_UNDEFINED THEN

		message = "STD_MULTICHROM_PROJECT_UNDEFINED"

        ELSEIF status =  INJECTION_NOT_SET THEN

		message = "STD_MULTICHROM_INJECTION_NOT_SET"

        ELSEIF status =  CHANNEL_NOT_SET THEN

		message = "STD_MULTICHROM_CHANNEL_NOT_SET"

        ELSEIF status =  PROJECT_ERROR THEN

		message = "STD_MULTICHROM_PROJECT_ERROR"

        ELSEIF status =  NO_PEAKS_FOUND THEN

		message = "STD_MULTICHROM_NO_PEAKS_FOUND"

        ELSEIF status =  INVALID_LEVEL THEN

		message = "STD_MULTICHROM_INVALID_LEVEL"

        ELSEIF status =  NOT_ISTD_PEAK THEN

		message = "STD_MULTICHROM_NOT_ISTD_PEAK"

        ELSEIF status =  CALIBRATION_ERROR THEN

		message = "STD_MULTICHROM_CALIBRATION_ERROR"

        ELSEIF status =  CALIBRATION_NOT_SET THEN

		message = "STD_MULTICHROM_CALIBRATION_NOT_SET"

        ELSEIF status =  GPC_NOT_OPEN THEN

		message = "STD_MULTICHROM_GPC_NOT_OPEN"

        ELSEIF status =  GPC_ALREADY_OPEN THEN

		message = "STD_MULTICHROM_GPC_ALREADY_OPEN"

        ELSEIF status =  NO_GPC_PEAK_DATA THEN

		message = "STD_MULTICHROM_NO_GPC_PEAK_DATA"

        ELSEIF status =  GPC_PEAK_OPEN_ERROR THEN

		message = "STD_MULTICHROM_GPC_PEAK_OPEN_ERROR"

        ELSEIF status =  INVALID_SLICE THEN

		message = "STD_MULTICHROM_INVALID_SLICE"

        ELSEIF status =  GET_SLICE_ERROR THEN

		message = "STD_MULTICHROM_GET_SLICE_ERROR"

        ELSEIF status =  INVALID_COMPOSITE_PEAK THEN

		message = "STD_MULTICHROM_INVALID_COMPOSITE_PEAK"

        ELSEIF status =  GET_COMPOSITE_PEAK_ERROR THEN

		message = "STD_MULTICHROM_GET_COMPOSITE_PEAK_ERROR"

        ELSEIF status =  PRINTER_NOT_SET THEN

		message = "STD_MULTICHROM_PRINTER_NOT_SET"

        ELSEIF status =  NODE_UNDEFINED THEN

		message = "STD_MULTICHROM_NODE_UNDEFINED"

        ELSEIF status =  QUEUE_UNDEFINED THEN

		message = "STD_MULTICHROM_QUEUE_UNDEFINED"

        ELSEIF status =  PEAK_NOT_SET THEN

		message = "STD_MULTICHROM_PEAK_NOT_SET"

        ELSEIF status =  PUT_PEAK_ERROR THEN

		message = "STD_MULTICHROM_PUT_PEAK_ERROR"

        ELSEIF status =  METHOD_NOT_SET THEN

		message = "STD_MULTICHROM_METHOD_NOT_SET"

        ELSEIF status =  PUT_METHOD_ERROR THEN

		message = "STD_MULTICHROM_PUT_METHOD_ERROR"

        ELSEIF status =  METHOD_ERROR THEN

		message = "STD_MULTICHROM_METHOD_ERROR"

        ELSEIF status =  RUN_SEQUENCE_ERROR THEN

		message = "STD_MULTICHROM_RUN_SEQUENCE_ERROR"

        ELSEIF status =  RUN_SEQUENCE_NOT_SET THEN

		message = "STD_MULTICHROM_RUN_SEQUENCE_NOT_SET"

        ELSEIF status =  GET_SAMPLE_ERROR THEN

		message = "STD_MULTICHROM_GET_SAMPLE_ERROR"

        ELSEIF status =  PUT_SAMPLE_ERROR THEN

		message = "STD_MULTICHROM_PUT_SAMPLE_ERROR"

        ELSEIF status =  INVALID_SAMPLE THEN

		message = "STD_MULTICHROM_INVALID_SAMPLE"

        ELSEIF status =  PUT_RSF_HEADER_ERROR THEN

		message = "STD_MULTICHROM_PUT_RSF_HEADER_ERROR"

        ELSEIF status =  ALREADY_EXISTS THEN

		message = "STD_MULTICHROM_ALREADY_EXISTS"

        ELSEIF status =  ACCESS_ERROR THEN

		message = "STD_MULTICHROM_ACCESS_ERROR"

        ELSEIF status =  TEMPLATE_ERROR THEN

		message = "STD_MULTICHROM_TEMPLATE_ERROR"

        ELSEIF status =  CREATE_ERROR THEN

		message = "STD_MULTICHROM_CREATE_ERROR"

        ELSEIF status =  SIMDIS_NOT_OPEN THEN

		message = "STD_MULTICHROM_SIMDIS_NOT_OPEN"

        ELSEIF status =  SIMDIS_ALREADY_OPEN THEN

		message = "STD_MULTICHROM_SIMDIS_ALREADY_OPEN"

        ELSEIF status =  NO_SIMDIS_PEAK_DATA THEN

		message = "STD_MULTICHROM_NO_SIMDIS_PEAK_DATA"

        ELSEIF status =  SIMDIS_PEAK_OPEN_ERROR THEN

		message = "STD_MULTICHROM_SIMDIS_PEAK_OPEN_ERROR"

        ELSEIF status =  GET_CUT_ERROR THEN

		message = "STD_MULTICHROM_GET_CUT_ERROR"

        ELSEIF status =  INVALID_CUT THEN

		message = "STD_MULTICHROM_INVALID_CUT"

        ELSEIF status =  INVALID_CUT_RECORD THEN

		message = "STD_MULTICHROM_INVALID_CUT_RECORD"

        ELSEIF status =  INVALID_SLICE_RECORD THEN

		message = "STD_MULTICHROM_INVALID_SLICE_RECORD"

        ELSEIF status =  DATA_POINTER_UNDEFINED THEN

		message = "STD_MULTICHROM_DATA_POINTER_UNDEFINED"

        ELSEIF status =  SLAVE_ERROR THEN

		message = "STD_MULTICHROM_SLAVE_ERROR"

        ELSEIF status =  QUEUE_OPEN_ERROR THEN

		message = "STD_MULTICHROM_QUEUE_OPEN_ERROR"

        ELSEIF status =  NO_RUN_SEQUENCE THEN

		message = "STD_MULTICHROM_NO_RUN_SEQUENCE"

        ELSEIF status =  ANALYSIS_ALREADY_EXISTS THEN

		message = "STD_MULTICHROM_ANALYSIS_ALREADY_EXISTS"

        ELSEIF status =  QUEUE_FULL THEN

		message = "STD_MULTICHROM_QUEUE_FULL"

        ELSEIF status =  ALREADY_IN_QUEUE THEN

		message = "STD_MULTICHROM_ALREADY_IN_QUEUE"

        ELSEIF status =  START_RUN_ERROR THEN

		message = "STD_MULTICHROM_START_RUN_ERROR"

        ELSEIF status =  INVALID_ENTRY THEN

		message = "STD_MULTICHROM_INVALID_ENTRY"

        ELSEIF status =  RUN_CONTROL_ERROR THEN

		message = "STD_MULTICHROM_RUN_CONTROL_ERROR"

        ELSEIF status =  DELETE_RUN_ERROR THEN

		message = "STD_MULTICHROM_DELETE_RUN_ERROR"

        ELSEIF status =  QUEUE_EMPTY THEN

		message = "STD_MULTICHROM_QUEUE_EMPTY"

        ELSEIF status =  QUIT_ERROR THEN

		message = "STD_MULTICHROM_QUIT_ERROR"

        ELSEIF status =  NOT_BATCHED THEN

		message = "STD_MULTICHROM_NOT_BATCHED"
                                         
        ELSEIF status =  NOT_ACQUIRING THEN

		message = "STD_MULTICHROM_NOT_ACQUIRING"

        ELSEIF status =  ENTRY_NOT_INSERTED THEN

		message = "STD_MULTICHROM_ENTRY_NOT_INSERTED"

        ELSEIF status =  ILLEGAL_COMMAND_MNEMONIC THEN

		message = "STD_MULTICHROM_ILLEGAL_COMMAND_MNEMONIC"

        ELSEIF status =  QUEUE_NOT_OPENED THEN

		message = "STD_MULTICHROM_QUEUE_NOT_OPENED"

        ELSEIF status =  NO_ANALYSIS THEN

		message = "STD_MULTICHROM_NO_ANALYSIS"

        ELSEIF status =  NO_INJECTION THEN

		message = "STD_MULTICHROM_NO_INJECTION"

        ELSEIF status =  NO_COMMON_ACCESS THEN

		message = "STD_MULTICHROM_NO_COMMON_ACCESS"

        ELSEIF status =  NO_USER_NAME THEN

		message = "STD_MULTICHROM_NO_USER_NAME"


	ELSE

		message = "STD_MULTICHROM_STATUS_UNDEFINED"

	ENDIF


	RETURN ( get_user_message ( message , 1 ))

ENDROUTINE

{*****************************************************************************}

ROUTINE std_batch_chrom_analysis_action_set_analysis (  self         ,
							batch_header )

{
*
*
******************************************************************************}

	self . project_name   = batch_header . get_batch_field ( "CDS_PROJECT" ) 
	self . analysis_name  = batch_header . get_batch_field ( "CDS_ANALYSIS_NAME"    )

	IF blank ( self . analysis_name ) THEN

		self . analysis_name  = batch_header . get_batch_field ( "IDENTITY"    )

	ENDIF

	self . channel_number = batch_header . get_batch_field ( "CDS_CHANNEL_NUMBER" ) 	

ENDROUTINE

{*****************************************************************************}

ROUTINE std_batch_chrom_analysis_action_read_analysis (       self         ,
							VALUE read_samples )

{
*
*
******************************************************************************}

	DECLARE status     ,
		message    ,
		message_id

	set_analysis ( self . device_name    ,
		       self . project_name   ,
		       self . analysis_name  ,
		       self . channel_number ,
		       status                )	

	IF status = status_ok THEN

		IF read_samples THEN

			self . read_samples ( TRUE )

		ENDIF

		message = EMPTY

	ELSE

		message = batch_chrom_error_to_text ( status )

   		message_fetch ( "STD_MULTICHROM_SET_ANAL_FAILED" ,
			         message_id                      )

		message_add_parameter ( message_id       ,
				        strip ( message ))

		message = message_get_text ( message_id , 1 )		

	ENDIF

	RETURN ( message )			

ENDROUTINE

{*****************************************************************************}

ROUTINE std_batch_chrom_analysis_action_read_samples (       self       ,
                                                       VALUE read_peaks )

{
*
*
******************************************************************************}

	DECLARE sample_number    ,
		injection_number ,
		keep_going       ,    
		sample_object    ,
		status           ,
		count

	ARRAY self . samples 

	count            = 1
	keep_going       = TRUE

	sample_number    = 1
	injection_number = 1

	WHILE keep_going DO

		set_sample ( sample_number    ,
			     injection_number ,
			     status            )		

		IF status = STATUS_OK THEN

			CREATE OBJECT STD_BATCH_CHROM_SAMPLE , sample_object

			sample_object . sample_number    = sample_number
			sample_object . injection_number = injection_number
	
                        sample_object . read_sample ( read_peaks )

                        self . samples [ count ] = sample_object
			
			count            = count            + 1
			injection_number = injection_number + 1

		ELSEIF injection_number = 1 THEN

			keep_going = FALSE

		ELSE

			sample_number    = sample_number + 1
			injection_number = 1

		ENDIF
		
	ENDWHILE
			
ENDROUTINE

{*****************************************************************************}

ROUTINE std_batch_chrom_analysis_action_download_sample (       self          ,
						                batch_entry   ,
                                                          VALUE sample_number )

{
*
*
******************************************************************************}
        
	DECLARE sample_name       ,
		lims_id           ,
		sample_type       ,
		sample_amount     ,
		number_injections ,
		retention_time    ,
		response_factor   ,
		calibration_level ,
		class_name        ,
		status            ,
		message

	SET FORMAT "999"

	IF global ( "SAMP_BROWSE" ) = "T" THEN

		sample_name = strip ( batch_entry . get_samp_test_field ( "ID_TEXT" )) :
			      "/"                                                      :
			      strip ( batch_entry . get_samp_test_field ( "TEST_COUNT"))		 

	ELSE

		sample_name = strip ( batch_entry . get_samp_test_field ( "ID_NUMERIC" )) :
			      "/"                                                      :
			      strip ( batch_entry . get_samp_test_field ( "TEST_COUNT"))		 


	ENDIF                        
   
	lims_id     = batch_entry . get_test ()

	IF lims_id  = EMPTY THEN

		sample_name = ""
		lims_id     = ""

	ENDIF

	class_name  = batch_entry . database_name ()

	sample_type = batch_chrom_lookup_type ( class_name )

	sample_amount     = -1
	number_injections = -1

        retention_time    = ""
	response_factor   = ""
	calibration_level = ""

	batch_user_put_rsf_sample ( self              ,
				    batch_entry       ,	
				    sample_number     ,
			            sample_name       ,
			            lims_id           ,
			            sample_type       ,
			            sample_amount     ,
			            number_injections ,
			            retention_time    ,
			            response_factor   ,
			            calibration_level )
	

	put_rsf_sample ( sample_number     ,
			 sample_name       ,
			 lims_id           ,
			 sample_type       ,
			 sample_amount     ,
			 number_injections ,
			 retention_time    ,
			 response_factor   ,
			 calibration_level ,
			 status            )	

	IF status <> status_ok THEN	

		message = batch_chrom_error_to_text ( status )

	ELSE

		message = EMPTY

	ENDIF

	RETURN ( message )
	
ENDROUTINE

{*****************************************************************************}

ROUTINE std_batch_chrom_analysis_action_download_header ( self         ,
						          batch_header )

{
*
*
******************************************************************************}
                                   
	DECLARE analysis_file        , 
		method_file          ,
		calibration_file     ,
		run_sequence_file    ,
		subtract_analysis    ,
		subtract_sample      ,
		subtract_injection   ,  
		rvs_calibration      ,
		control_name         ,
		calibration_sequence ,
		lims_analysis        ,
		analyst_name         ,
		comment              ,
		number_of_pages      ,
		status               ,
		message		     ,
		message_id	

	analysis_file  = batch_header . get_batch_field ( "CDS_ANALYSIS_NAME"    )

	IF blank ( analysis_file ) THEN

		analysis_file  = batch_header . get_batch_field ( "IDENTITY"    )

	ENDIF

	method_file          = batch_header . get_batch_field ( "CDS_METHOD_NAME" )
	calibration_file     = batch_header . get_batch_field ( "CDS_CALIBRATION_NAME" )
	run_sequence_file    = batch_header . get_batch_field ( "CDS_RSF_NAME" )
	subtract_analysis    = batch_header . get_batch_field ( "CDS_SUBTRACT_NAME" )
	subtract_sample      = batch_header . get_batch_field ( "CDS_SUBTRACT_SAMPLE" )
	subtract_injection   = batch_header . get_batch_field ( "CDS_SUBTRACT_INJECTION" )
	rvs_calibration      = batch_header . get_batch_field ( "CDS_RVS_CALIBRATION_NAME" )
	control_name         = batch_header . get_batch_field ( "CDS_CONTROL_NAME" )
	calibration_sequence = "SE"
	lims_analysis        = batch_header . get_analysis ()
	analyst_name         = operator
	number_of_pages      = batch_header . size ()
	comment              = batch_header . get_batch_field ( "DESCRIPTION" )

	batch_user_put_rsf_header_info ( batch_header         ,
					 analysis_file        ,
		      	                 method_file          ,
			                 calibration_file     ,
			                 run_sequence_file    ,
			                 subtract_analysis    ,	
			                 subtract_sample      ,
			                 subtract_injection   ,
			                 rvs_calibration      ,  
			                 control_name         ,
			                 calibration_sequence ,
			                 lims_analysis        ,
			                 analyst_name         ,	
			                 comment              ,
			                 number_of_pages      )

	put_rsf_header_info ( analysis_file        ,
			      method_file          ,
			      calibration_file     ,
			      run_sequence_file    ,
			      subtract_analysis    ,	
			      subtract_sample      ,
			      subtract_injection   ,
			      rvs_calibration      ,  
			      control_name         ,
			      calibration_sequence ,
			      lims_analysis        ,
			      analyst_name         ,	
			      comment              ,
			      number_of_pages      ,
			      status               )

	IF status <> status_ok THEN	

		message = batch_chrom_error_to_text ( status )

   		message_fetch ( "STD_MULTICHROM_PUT_RSF_HEAD_FAILED" ,
			         message_id                          )

		message_add_parameter ( message_id       ,
				        strip ( message ))

		message = message_get_text ( message_id , 1 )		

	ELSE

		message = EMPTY

	ENDIF


	RETURN ( message ) 
ENDROUTINE

{*****************************************************************************}

ROUTINE std_batch_chrom_analysis_action_create_download ( self         ,
						          batch_header )

{
*
*
******************************************************************************}

	DECLARE status         ,
		machine        ,
		port           ,
		protocol       ,
		device_name    ,
		project_name   ,
		run_sequence   ,
		template       ,
		channel_number ,
		message        ,
		message_id

	message = EMPTY

	batch_user_get_multichrom_details ( batch_header ,
					    machine      ,
					    port         ,
					    protocol     ,
					    device_name  )	

        status = multichrom_connect ( machine     ,  
			              port        , 
			              protocol    )

	IF status <> EMPTY

		message_fetch ( "STD_MULTICHROM_CONNECT_FAILED" ,
				 message                        )

		message_add_parameter ( message         ,
					strip ( status ))

		message = message_get_text ( message , 1 )		

	ELSE

		project_name   = batch_header . get_batch_field ( "CDS_PROJECT"  ) 
		run_sequence   = batch_header . get_batch_field ( "CDS_RSF_NAME" )
		template       = batch_header . get_batch_field ( "CDS_TEMPLATE_NAME"    )
		channel_number = batch_header . get_batch_field ( "CDS_CHANNEL_NUMBER" ) 	

		create_run_sequence ( device_name    ,
	 			      project_name   ,
	 			      run_sequence   ,
				      template       ,
       				      channel_number ,
				      status         )


		set_run_sequence ( device_name    ,
				   project_name   ,
				   run_sequence   ,
	      		           channel_number ,
				   status         )


   		IF status = status_ok THEN

			self . download_header ( batch_header )

		ELSE
	

			message = batch_chrom_error_to_text ( status )

   			message_fetch ( "STD_MULTICHROM_CREATE_RSF_FAILED" ,
					 message_id                        )

			message_add_parameter ( message_id       ,
						strip ( message ))

			message = message_get_text ( message_id , 1 )		

		        multichrom_release ()

		ENDIF

	ENDIF								

	RETURN ( message )

ENDROUTINE

{*****************************************************************************}

ROUTINE std_batch_chrom_analysis_action_finish_download ( self )

{
*
*
******************************************************************************}

	DECLARE status

	close_run_sequence ( status )

        multichrom_release ()

	RETURN ( status = status_ok )

ENDROUTINE

{*****************************************************************************}

ROUTINE std_batch_chrom_analysis_action_sample_size ( self )

{
*
*
******************************************************************************}

	RETURN ( size_of_array ( self . samples ))

ENDROUTINE
{*****************************************************************************}

ROUTINE std_batch_chrom_analysis_action_get_entry (       self       ,
						    VALUE sample_num )	

{
*
*
******************************************************************************}

	RETURN ( self . samples [ sample_num ])

ENDROUTINE


{*****************************************************************************}

ROUTINE std_batch_chrom_analysis_action_get_sample (       self       ,
						     VALUE sample_num )	

{
*
*
******************************************************************************}

	RETURN ( self . samples [ sample_num ] . sample_name )

ENDROUTINE

{*****************************************************************************}

ROUTINE std_batch_chrom_analysis_action_get_test   (       self       ,
						     VALUE sample_num )	

{
*
*
******************************************************************************}

	RETURN ( self . samples [ sample_num ] . lims_name )

ENDROUTINE

{*****************************************************************************}

ROUTINE std_batch_chrom_analysis_action_get_number_of_samples ( self )

{
*
*
******************************************************************************}

	RETURN ( size_of_array ( self . samples ))

ENDROUTINE

{*****************************************************************************}

ROUTINE std_batch_chrom_analysis_action_get_result (       self        ,
						     VALUE sample_num  ,
						     VALUE result_name ,
							   result      ,
							   detected    )

{
*
*
******************************************************************************}

	DECLARE sample_object 

	sample_object = self . samples [ sample_num ]

	sample_object . get_result ( result_name ,
			             result      ,
				     detected    )		
	

ENDROUTINE

{*****************************************************************************}

ROUTINE std_batch_chrom_analysis_action_assign (       self        ,
						       entry       ,	
						 VALUE sample_num  ,
						 VALUE result_name )

{
*
*
******************************************************************************}

	DECLARE sample_object 

	sample_object = self . samples [ sample_num ]

	sample_object . assign ( entry       ,
				 result_name )
	
ENDROUTINE

{*****************************************************************************}

ROUTINE std_batch_chrom_sample_action_read_sample (       self       ,
                                                    VALUE read_peaks )

{
*
*
******************************************************************************}

	DECLARE status        ,
		sample_name   ,
		lims_name     ,
		sample_type   ,
		sample_amount ,
		bad_injection ,
		message

	get_sample_info ( sample_name   ,
			  lims_name     ,
			  sample_type   ,
			  sample_amount ,
			  status        )


	IF status = STATUS_OK THEN

		get_bad_injection_flag ( bad_injection ,
					 status        )


	ENDIF

	IF status = STATUS_OK THEN

		self . sample_name   = sample_name
		self . lims_name     = substring ( lims_name , 1 , 10 )
		self . sample_type   = sample_type
		self . bad_injection = bad_injection

		IF read_peaks THEN

			message = self . read_peaks ()

		ELSE

			message = EMPTY

		ENDIF

	ELSE

		message = batch_chrom_error_to_text ( status )

	ENDIF

	RETURN ( message )	

ENDROUTINE

{*****************************************************************************}

ROUTINE std_batch_chrom_sample_action_read_peaks ( self )

{
*
*
******************************************************************************}

	DECLARE status   ,
		count    ,
		message
	
	ARRAY self . peaks

	count = 1        

	open_peak ( status )

	IF status = STATUS_OK THEN

		self . get_peaks           ( count )
		self . get_missing_peaks   ( count )
		self . get_composite_peaks ( count )		
		self . get_group_peaks     ( count )		
		close_peak ( status )

		message = EMPTY

	ELSE

		message = batch_chrom_error_to_text ( status )
		
	ENDIF              

	RETURN ( message )
	

ENDROUTINE


{*****************************************************************************}

ROUTINE std_batch_chrom_sample_action_get_peaks ( self  ,
						  count )	

{
*
*
******************************************************************************}

	DECLARE peak_number               ,
		peak_object               ,
		peak_name                 ,
	        quantitation_flags        ,
		retention_time            ,
		corrected_rentention_time ,
		area                      ,
		height_1                  ,
	        amount                    ,
		retention_value           ,
	        width_at_half_height      ,
		response_factor_slope     ,
		response_factor_intercept ,
		composite_sub_peak        ,
		status                    ,
		keep_going

	keep_going  = TRUE

	peak_number = 1


	WHILE keep_going DO

		get_peak ( peak_number               ,
			   peak_name                 ,
			   quantitation_flags        ,
			   retention_time            ,
			   corrected_rentention_time ,
			   area                      ,
			   height_1                  ,
			   amount                    ,
			   retention_value           ,
			   width_at_half_height      ,
			   response_factor_slope     ,
			   response_factor_intercept ,
			   composite_sub_peak        ,
			   status                    )

		IF status = STATUS_OK THEN

			CREATE OBJECT STD_BATCH_CHROM_PEAK , peak_object										

                        peak_object . component_name = peak_name
			peak_object . peak_name      = peak_name
			peak_object . amount         = amount
			peak_object . detected       = TRUE

			batch_user_multichrom_peak ( peak_object , 
						     peak_number )

			IF NOT blank ( peak_object . component_name ) THEN

				
				self . peaks [ count ] = peak_object

				count = count + 1

			ENDIF


			peak_number = peak_number + 1

		ELSE

			keep_going = FALSE

		ENDIF
			
	ENDWHILE

ENDROUTINE

{*****************************************************************************}

ROUTINE std_batch_chrom_sample_action_get_missing_peaks ( self  ,
						          count )	

{
*
*
******************************************************************************}

	DECLARE peak_number     ,
		peak_object     , 	
		peak_name       ,
		status          ,
		keep_going

	keep_going  = TRUE

	peak_number = 1


	WHILE keep_going DO

		get_missing_peak ( peak_number ,
				   peak_name   ,
				   status      )
		IF status = STATUS_OK THEN

			CREATE OBJECT STD_BATCH_CHROM_PEAK , peak_object										

                        peak_object . component_name = peak_name
			peak_object . peak_name      = peak_name
			peak_object . amount         = EMPTY
			peak_object . detected       = FALSE
				
       			batch_user_multichrom_missing_peak ( peak_object )

			IF NOT blank ( peak_object . component_name ) THEN

				self . peaks [ count ] = peak_object

				count = count + 1

			ENDIF

			peak_number = peak_number + 1

		ELSE

			keep_going = FALSE

		ENDIF
			
	ENDWHILE

ENDROUTINE

{*****************************************************************************}

ROUTINE std_batch_chrom_sample_action_get_composite_peaks ( self  ,
						            count )	

{
*
*
******************************************************************************}

	DECLARE peak_number               ,
		peak_object               ,
		peak_name                 ,
	        quantitation_flags        ,
		area                      ,
		height_1                  ,
		amount                    ,
		number_first_peak         ,
		number_last_peak          ,
		status                    ,
		keep_going

	keep_going  = TRUE

	peak_number = 1


	WHILE keep_going DO

		get_composite_peak ( peak_number               ,
			             peak_name                 ,
			             quantitation_flags        ,
			             area                      ,
			             height_1                  ,
			             amount                    ,
				     number_first_peak         ,
				     number_last_peak          ,
			             status                    )

		IF status = STATUS_OK THEN

			CREATE OBJECT STD_BATCH_CHROM_PEAK , peak_object										

                        peak_object . component_name = peak_name
			peak_object . peak_name      = peak_name
			peak_object . amount         = amount
			peak_object . detected       = TRUE

			batch_user_multichrom_composite ( peak_object , 
							  peak_number )

			IF NOT blank ( peak_object . component_name ) THEN

				self . peaks [ count ] = peak_object

				count = count + 1

			ENDIF


			peak_number = peak_number + 1

		ELSE

			keep_going = FALSE

		ENDIF
			
	ENDWHILE

ENDROUTINE

{*****************************************************************************}

ROUTINE std_batch_chrom_sample_action_get_group_peaks ( self  ,
						        count )	

{
*
*
******************************************************************************}

	DECLARE group_number              ,
		group_object              ,
		group_name                ,
		area                      ,
		height_1                  ,
		amount                    ,
		status                    ,
		keep_going

	keep_going  = TRUE

	group_number = 1

	WHILE keep_going DO

		get_group ( group_number  ,
			    group_name    ,
			    area          ,
			    height_1      ,
			    amount        ,
			    status        )

		IF status = STATUS_OK THEN

			CREATE OBJECT STD_BATCH_CHROM_PEAK , group_object										

                        group_object . component_name = group_name
			group_object . peak_name      = group_name
			group_object . amount         = amount
			group_object . detected       = TRUE

			batch_user_multichrom_group ( group_object , 
						      group_number )

			IF NOT blank ( group_object . component_name ) THEN

				self . peaks [ count ] = group_object

				count = count + 1

			ENDIF

			group_number = group_number + 1

		ELSE

			keep_going = FALSE

		ENDIF
			
	ENDWHILE

ENDROUTINE

{*****************************************************************************}

ROUTINE std_batch_chrom_sample_action_get_result (       self     ,
						   VALUE name     ,
							 result   ,
							 detected )

{
*
*
******************************************************************************}

	DECLARE count       ,
		temp        ,
		peak_object 

	result   = EMPTY
	detected = FALSE

	name  = strip ( name )

	count = 1

	WHILE count <= size_of_array ( self . peaks ) DO

		peak_object = self . peaks [ count ]

		IF strip ( peak_object . component_name ) = name THEN

			result   = peak_object . amount       
			detected = peak_object . detected  

			count = size_of_array ( self . peaks )

		ELSE

			temp = lib_comp_get_base (peak_object . component_name )
					    
			IF STRIP ( temp ) = name THEN

				result   = peak_object . amount
				detected = peak_object . detected

			ENDIF

		ENDIF

		count = count + 1 

        ENDWHILE

ENDROUTINE

{*****************************************************************************}

ROUTINE std_batch_chrom_sample_action_assign (       self     ,
						     entry    ,	
					       VALUE name     )

{
*
*
******************************************************************************}

	DECLARE count         ,
		temp          ,
		peak_object   ,
		results       ,
		result_object ,
		reselected

	name  = strip ( name )

	results       = entry . get_results ( TRUE )
	result_object = results . get_result ( EMPTY                              ,
				               lib_comp_add_replicate ( name , 1 ))

	count = 1

	WHILE count <= size_of_array ( self . peaks ) DO

		peak_object = self . peaks [ count ]

		temp = lib_comp_get_base (peak_object . component_name )

		IF ( strip ( peak_object . component_name ) = name ) 
		OR ( strip ( temp                         ) = name ) THEN

			IF result_object = EMPTY THEN

			ELSEIF result_object . upgrade_lock ( reselected ) THEN

   				IF NOT peak_object . detected THEN

					result_object . set_field ( "LESS_THAN_PQL" ,
								     TRUE	    ,
								     results 	    )
	

				ELSE

					result_object . set_field ( "TEXT"                ,
								     peak_object . amount ,
								     results              )

				ENDIF		

			ENDIF	

			count = size_of_array ( self . peaks )

		ENDIF

		count = count + 1 

        ENDWHILE

ENDROUTINE

{*****************************************************************************}

ROUTINE std_batch_chrom_sample_action_get_batch_class ( self )

{
*
*
******************************************************************************}

	RETURN ( "STD_BATCH_ENTRY_SAMPLE" )

ENDROUTINE

{*****************************************************************************}

ROUTINE std_batch_chrom_sample_action_is_batch_class (       self        ,
						       VALUE batch_class )	

{
*
*
******************************************************************************}

	DECLARE sample_type

	sample_type = batch_chrom_lookup_type ( batch_class )

	RETURN ( sample_type = self . sample_type )

ENDROUTINE

{*****************************************************************************}

ROUTINE std_batch_chrom_sample_action_set_test (       self        ,
						 VALUE test_number )

{
*
*
******************************************************************************}

	self . lims_name = test_number

ENDROUTINE


{*****************************************************************************}

ROUTINE std_batch_chrom_sample_action_get_test ( self )

{
*
*
******************************************************************************}

	RETURN ( self . lims_name )

ENDROUTINE

{*****************************************************************************}

ROUTINE std_batch_chrom_sample_action_get_sample ( self )

{
*
*
******************************************************************************}

	RETURN ( self . sample_name )

ENDROUTINE

{*****************************************************************************}

ROUTINE std_batch_chrom_analysis_action_create_upload ( self         ,
							batch_header )

{
*
*
******************************************************************************}

	DECLARE machine        ,
		port           ,
		protocol       ,
		device_name    ,
		status         ,
		message

	batch_user_get_multichrom_details ( batch_header ,
					    machine      ,
					    port         ,
					    protocol     ,
					    device_name  )	

        status = multichrom_connect ( machine  , 
			              port     , 
			              protocol )


	self . device_name    = device_name

	IF status <> EMPTY

		message_fetch ( "STD_MULTICHROM_CONNECT_FAILED" ,
				 message                        )

		message_add_parameter ( message         ,
					strip ( status ))

		message = message_get_text ( message , 1 )		

	ELSE

		message = EMPTY

	ENDIF

	RETURN ( message )

ENDROUTINE

{*****************************************************************************}

ROUTINE std_batch_chrom_analysis_action_finish_upload ( self )

{
*
*
******************************************************************************}

        multichrom_release ()

	RETURN ( TRUE )

ENDROUTINE
