{******************************************************************************
*
* Module Name   : $BATCH_HEADER.RPF
*
* Purpose       : Contains the class supporting the batch header object.
*
* Document Ref. :
*
* Specification : SE/T/VGSM320-WORK-BATCH
*
* Portability   : Not Checked
*
* Re-entrant    :
*
*******************************************************************************}

ENABLE WINDOWS
SET NOTPROTECTED
SET NAME "DEFER/"
SET COMPILE_OPTION DECLARE

JOIN STANDARD_LIBRARY STD_ARRAY
JOIN STANDARD_LIBRARY STD_ARRAY_SELECT
JOIN STANDARD_LIBRARY STD_CLASS
JOIN STANDARD_LIBRARY STD_CLIENT
JOIN STANDARD_LIBRARY STD_DATABASE
JOIN STANDARD_LIBRARY STD_LOGIN
JOIN STANDARD_LIBRARY STD_MESSAGE

JOIN LIBRARY $BATCH_PRINT
JOIN LIBRARY $BATCH_TEMPLATE_ENT
JOIN LIBRARY $BATCH_USER
JOIN LIBRARY $BATCH_UTILS
JOIN LIBRARY $LIB_COMM
JOIN LIBRARY $LIB_COMP
JOIN LIBRARY $LIB_UTILS
JOIN LIBRARY $MRU_LIST_FIELD

{* CONSTANTS ******************************************************************}

CONSTANT BATCH_HEADER_SECTION_DONT_CREATE = "D"
CONSTANT BATCH_HEADER_SECTION_LEAVE_SLOTS = "L"
CONSTANT BATCH_HEADER_SECTION_TRUNCATE    = "T"


{* VARIABLES ******************************************************************}


{******************************************************************************}

GLOBAL

ROUTINE batch_header_initialise

{
*	Initialise all the batch header modules
*
*******************************************************************************}

	IF NOT global ( "LIBRARY_INITIALISED" ) THEN

		batch_header_define_class ()

		SET GLOBAL "LIBRARY_INITIALISED" TO TRUE

	ENDIF

ENDROUTINE

{******************************************************************************}

ROUTINE batch_header_define_class

{
*	Define the classes for the batch header table
*
*******************************************************************************}

	DEFINE CLASS STD_BATCH_HEADER_BASE

		PROPERTIES "ENTRIES"             ,
			   "DELETED_ENTRIES"     ,

			   "TEMPLATE_LIST"       ,
			   "TEMPLATE_HEADER"     ,
			   "BATCH_NAME"          ,
			   "IS_DISPLAY"          ,
			   "LAST_REPEAT_SECTION" ,
			   "TRAIL_START"         ,

			   "REVIEW_STATUS"       ,

			   "TYPE_ALLOW_STANDARDS"          ,
			   "TYPE_SUPPORTS_CATEGORY"        ,
			   "TYPE_SUPPORTS_RESULT_LISTS"    ,
			   "TYPE_SUPPORTS_COMPONENT_LISTS" ,
			   "TYPE_SUPPORTS_MLPS"            ,
			   "TYPE_AUTHORISE_STANDARDS"      ,
			   "TYPE_TEST_INCLUDE_FIELD"       ,
			   "TYPE_TEST_FIELD"               ,
			   "TYPE_REPORTING_CATEGORY"       ,

			   "USER_INFO"

		ACTIONS   "INITIALISE"       ,
			   "CREATE"              ,
			   "CREATE_CLASS"        ,
			   "SET_TYPE"            ,
			   "RESERVE"             ,
			   "BUILD"               ,
			   "UPDATE"              ,
			   "UPDATE_RESULTS"      ,
			   "REMOVE_UNWANTED"     ,
			   "CREATE_RANDOMS"      ,
			   "READ_TEMPLATE"       ,
			   "READ_ENTRIES"        ,
			   "SET_INFINITE"        ,
			   "READ_FOR_MODIFY"     ,
			   "READ_FOR_DISPLAY"    ,
			   "VALIDATE"            ,
			   "INSERT_ENTRY"        ,
			   "DELETE_ENTRY"        ,
			   "SET_WILL_UPDATE"     ,
			   "DELETE_SECTION"      ,
			   "COMPRESS"            ,
			   "NUMBER_OF_SAMPLES"   ,

			   "PUT_TEST_ON_BATCH"             ,
			   "TAKE_TEST_OFF_BATCH"           ,
			   "ALTER_TEST_SELECTION_CRITERIA" ,
			   "UPDATE_RESULT_LIST"	           ,
			   "INCLUDE_SELECTION_CRITERIA"    ,

			   "ADD_TO_DELETE"       ,
			   "ADD_TEST_TO_DELETE"  ,
			   "FIND_IN_DELETE"      ,
			   "REMOVE_FROM_DELETE"  ,
			   "UPDATE_DELETE"       ,


			   "SET_IS_DISPLAY"      ,
			   "IS_DISPLAY"          ,

			   "SIZE"                   ,
			   "GET_ENTRY"              ,
			   "GET_TEMPLATE_HEADER"    ,
			   "IS_RUNTIME"             ,
			   "GET_ANALYSIS"           ,
			   "GET_BATCH_FIELD"        ,

			   "CREATE_ENTRY"        ,
			   "SET_PARENT_POINTERS" ,
			   "CREATE_SECTION"      ,

			   "FIND_TEST"           ,
			   "FIND_NEXT_SLOT"      ,
			   "ADD_TEST"            ,
			   "SELECT_SAMPLES"      ,
			   "INCLUDE_BATCH"       ,
			   "TEST_ON_BATCH"       ,
			   "VALID_TEST"          ,

			   "SECTION_EMPTY"       ,
			   "SET_PROMPT_POSITION" ,

			   "REVIEW"		 ,
			   "REVIEW_FULL"         ,
			   "GET_REVIEW"          ,
			   "REVIEW_UPDATE"       ,

			   "GET_FIELD"		 ,

			   "DOWNLOAD"			 ,
			   "UPLOAD"              	 ,
			   "UPLOAD_REBUILD"      	 ,
			   "CREATE_CHROM_TEMPLATE_ENTRY" ,
			   "GET_ORIGINAL_CLASS"  	 ,

			   "IS_COMPLETE"         ,

			   "SET_COMPLETE"        ,
			   "SET_INSPECTED"       ,
			   "SET_AVAILABLE"       ,
			   "SET_AUTHORISED"      ,
			   "SET_CANCELLED"       ,
			   "SET_STATUS"	         ,

			   "COMMIT"


		TABLES     BATCH_HEADER

		INITIALISATION

	END CLASS


ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_header_base_class_initialisation ( self )

{
*	Initialise a header class.
*
*******************************************************************************}

	self . initialise ()

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_header_base_action_initialise ( self )

{
*	Initialise a header class.
*
*******************************************************************************}

	ARRAY self . entries         ARRAY_SIZE ( 0 )
	ARRAY self . deleted_entries ARRAY_SIZE ( 0 )

	self . batch_name = EMPTY
	self . is_display = FALSE

	self . last_repeat_section = -1
	self . trail_start         = -1

	self . review_status       = EMPTY

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_header_base_action_size ( self )

{
*	Return the current size of the batch.
*
*******************************************************************************}

	RETURN ( size_of_array ( self . entries ))

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_header_base_action_set_is_display ( self )

{
*	The batch is display only
*
*******************************************************************************}

	self . is_display = TRUE

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_header_base_action_is_display ( self )

{
*	Is the batch display only
*
*******************************************************************************}

	RETURN ( self . is_display )

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_header_base_action_get_entry (       self     ,
						 VALUE position )

{
*	Return the given element of the batch.
*
*******************************************************************************}

	RETURN ( self . entries [ position ])

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_header_base_action_get_template_header ( self )

{
*	Return the template header
*
*******************************************************************************}

	RETURN ( self . template_header )

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_header_base_action_is_runtime ( self )

{
*	Return if in run time mode - used by insert code
*
*******************************************************************************}

	RETURN ( TRUE )

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_header_base_action_get_analysis ( self )

{
*	Return the analysis
*
*******************************************************************************}

	DECLARE analysis

	analysis = SELECT batch_header . analysis

	RETURN ( analysis )

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_header_base_action_get_batch_field (       self          ,
						       VALUE the_field_name )

{
*	Return the field
*
*******************************************************************************}

	DECLARE answer

	answer = SELECT batch_header . 'the_field_name'

	RETURN ( answer )

ENDROUTINE


{*****************************************************************************}

ROUTINE std_batch_header_base_action_put_test_on_batch ( self         ,
						         batch_entry  )

{
*
*
*
******************************************************************************}

	IF self . type_test_field <> EMPTY THEN

		ASSIGN test . 'self . type_test_field' = self . batch_name

	ENDIF

ENDROUTINE

{*****************************************************************************}

ROUTINE std_batch_header_base_action_take_test_off_batch ( self         ,
						           batch_entry  )

{
*
*
*
******************************************************************************}

	IF self . type_test_field <> EMPTY THEN

		ASSIGN test . 'self . type_test_field' = ""

	ENDIF

ENDROUTINE

{*****************************************************************************}

ROUTINE std_batch_header_base_action_alter_test_selection_criteria ( self     ,
							             criteria )

{
*
*
*
******************************************************************************}

	DECLARE batch_name ,
		batch_field

	batch_name  = self . batch_name
	batch_field = self . type_test_field

	IF batch_field <> EMPTY THEN

		IF blank ( batch_name ) THEN

			array_select_add (  criteria        ,
					    ARRAY_SELECT_EQ ,
				            batch_field     ,
					   ""               )

		ELSE

			array_select_add (  criteria          ,
					    ARRAY_SELECT_PUSH ,
				            EMPTY             ,
					    EMPTY             )

  			array_select_add (  criteria        ,
					    ARRAY_SELECT_EQ ,
				            batch_field     ,
					   ""               )


			array_select_add (  criteria        ,
					    ARRAY_SELECT_OR ,
				            EMPTY           ,
					    EMPTY           )

			array_select_add (  criteria        ,
					    ARRAY_SELECT_EQ ,
				            batch_field     ,
					    batch_name      )

  			array_select_add (  criteria          ,
					    ARRAY_SELECT_POP  ,
				            EMPTY             ,
					    EMPTY             )


 		ENDIF

	ENDIF

	IF NOT self . type_allow_standards THEN

		array_select_add ( criteria         ,
				   ARRAY_SELECT_EQ  ,
				   "STANDARD"       ,
				   FALSE            )

	ENDIF

ENDROUTINE


{*****************************************************************************}

ROUTINE std_batch_header_base_action_update_result_list ( self         ,
							  result_list  ,
							  batch_entry  )

{
*
*
*
******************************************************************************}

	IF self . type_reporting_category <> EMPTY THEN

		result_list . copy_category ( CATEGORY_READING               ,
					      self . type_reporting_category )

	ENDIF

ENDROUTINE

{*****************************************************************************}

ROUTINE std_batch_header_base_action_include_selection_criteria ( self          ,
								  mandatory_array )

{
*
*
*
******************************************************************************}

	IF self . type_test_include_field <> EMPTY THEN

		array_select_add (  mandatory_array        ,
				    ARRAY_SELECT_EQ        ,
			           "ANALYSIS"              ,
				    self . get_analysis () )

		array_select_add (  mandatory_array                    ,
				    ARRAY_SELECT_NE                    ,
			           "BATCH_CLASS"                       ,
				    self . get_field  ( "BATCH_CLASS" ))

	ENDIF

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_header_base_action_set_type (       self       ,
						VALUE batch_type )

{
*	Set the batch type info
*
*******************************************************************************}

	IF batch_type = "BASE" THEN

		self . type_allow_standards           = FALSE
		self . type_supports_category         = FALSE
		self . type_supports_result_lists     = FALSE
		self . type_supports_component_lists  = TRUE
		self . type_supports_mlps             = TRUE
		self . type_authorise_standards       = TRUE
		self . type_test_include_field        = EMPTY
		self . type_test_field                = EMPTY
		self . type_reporting_category        = EMPTY

	ELSEIF batch_type = "FULLNOREP" THEN

		self . type_allow_standards           = FALSE
		self . type_supports_category         = TRUE
		self . type_supports_result_lists     = TRUE
		self . type_supports_component_lists  = TRUE
		self . type_supports_mlps             = TRUE
		self . type_authorise_standards       = TRUE
		self . type_test_include_field        = EMPTY
		self . type_test_field                = "INSTRUMENT_BATCH"
		self . type_reporting_category        = EMPTY

	ELSEIF batch_type = "FULLREP" THEN

		self . type_allow_standards           = FALSE
		self . type_supports_category         = TRUE
		self . type_supports_result_lists     = TRUE
		self . type_supports_component_lists  = TRUE
		self . type_supports_mlps             = TRUE
		self . type_authorise_standards       = TRUE
		self . type_test_include_field        = EMPTY
		self . type_test_field                = "INSTRUMENT_BATCH"
		self . type_reporting_category        = CATEGORY_REPORT

	ELSEIF batch_type = "FULLWEIGHT" THEN

		self . type_allow_standards           = FALSE
		self . type_supports_category         = TRUE
		self . type_supports_result_lists     = TRUE
		self . type_supports_component_lists  = TRUE
		self . type_supports_mlps             = TRUE
		self . type_authorise_standards       = TRUE
		self . type_test_include_field        = EMPTY
		self . type_test_field                = "INSTRUMENT_BATCH"
		self . type_reporting_category        = CATEGORY_BYWEIGHT

	ELSEIF batch_type = "FULLLIQUID" THEN

		self . type_allow_standards           = FALSE
		self . type_supports_category         = TRUE
		self . type_supports_result_lists     = TRUE
		self . type_supports_component_lists  = TRUE
		self . type_supports_mlps             = TRUE
		self . type_authorise_standards       = TRUE
		self . type_test_include_field        = EMPTY
		self . type_test_field                = "INSTRUMENT_BATCH"
		self . type_reporting_category        = CATEGORY_BYVOLUME

	ELSEIF batch_type = "FULLFILTER" THEN

		self . type_allow_standards           = FALSE
		self . type_supports_category         = TRUE
		self . type_supports_result_lists     = TRUE
		self . type_supports_component_lists  = TRUE
		self . type_supports_mlps             = TRUE
		self . type_authorise_standards       = TRUE
		self . type_test_include_field        = EMPTY
		self . type_test_field                = "INSTRUMENT_BATCH"
		self . type_reporting_category        = CATEGORY_BYFILTER


	ELSEIF batch_type = "FULLWIPE" THEN

		self . type_allow_standards           = FALSE
		self . type_supports_category         = TRUE
		self . type_supports_result_lists     = TRUE
		self . type_supports_component_lists  = TRUE
		self . type_supports_mlps             = TRUE
		self . type_authorise_standards       = TRUE
		self . type_test_include_field        = EMPTY
		self . type_test_field                = "INSTRUMENT_BATCH"
		self . type_reporting_category        = CATEGORY_BYWIPE

	ELSEIF batch_type = "INSTRUMENT" THEN

		self . type_allow_standards           = TRUE
		self . type_supports_category         = TRUE
		self . type_supports_result_lists     = TRUE
		self . type_supports_component_lists  = TRUE
		self . type_supports_mlps             = TRUE
		self . type_authorise_standards       = TRUE
		self . type_test_include_field        = "PREPARATION_BATCH"
		self . type_test_field                = "INSTRUMENT_BATCH"
		self . type_reporting_category        = EMPTY

	ELSEIF batch_type = "PREP" THEN

		self . type_allow_standards           = FALSE
		self . type_supports_category         = TRUE
		self . type_supports_result_lists     = TRUE
		self . type_supports_component_lists  = TRUE
		self . type_supports_mlps             = TRUE
		self . type_authorise_standards       = TRUE
		self . type_test_include_field        = EMPTY
		self . type_test_field                = "PREPARATION_BATCH"
		self . type_reporting_category        = CATEGORY_REPORT

	ELSEIF batch_type = "PREPWEIGHT" THEN

		self . type_allow_standards           = FALSE
		self . type_supports_category         = TRUE
		self . type_supports_result_lists     = TRUE
		self . type_supports_component_lists  = TRUE
		self . type_supports_mlps             = TRUE
		self . type_authorise_standards       = TRUE
		self . type_test_include_field        = EMPTY
		self . type_test_field                = "PREPARATION_BATCH"
		self . type_reporting_category        = CATEGORY_BYWEIGHT

	ELSEIF batch_type = "PREPLIQUID" THEN

		self . type_allow_standards           = FALSE
		self . type_supports_category         = TRUE
		self . type_supports_result_lists     = TRUE
		self . type_supports_component_lists  = TRUE
		self . type_supports_mlps             = TRUE
		self . type_authorise_standards       = TRUE
		self . type_test_include_field        = EMPTY
		self . type_test_field                = "PREPARATION_BATCH"
		self . type_reporting_category        = CATEGORY_BYVOLUME

	ELSEIF batch_type = "PREPFILTER" THEN

		self . type_allow_standards           = FALSE
		self . type_supports_category         = TRUE
		self . type_supports_result_lists     = TRUE
		self . type_supports_component_lists  = TRUE
		self . type_supports_mlps             = TRUE
		self . type_authorise_standards       = TRUE
		self . type_test_include_field        = EMPTY
		self . type_test_field                = "PREPARATION_BATCH"
		self . type_reporting_category        = CATEGORY_BYFILTER

	ELSEIF batch_type = "PREPWIPE" THEN

		self . type_allow_standards           = FALSE
		self . type_supports_category         = TRUE
		self . type_supports_result_lists     = TRUE
		self . type_supports_component_lists  = TRUE
		self . type_supports_mlps             = TRUE
		self . type_authorise_standards       = TRUE
		self . type_test_include_field        = EMPTY
		self . type_test_field                = "PREPARATION_BATCH"
		self . type_reporting_category        = CATEGORY_BYWIPE

	ENDIF

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_header_base_action_create_class ( self )

{
*	Create the associated class name for the batch.
*
*******************************************************************************}

	DECLARE batch_class

	batch_class = SELECT batch_header . batch_class

	IF ( blank ( batch_class )) OR
	   ( batch_class = EMPTY )  THEN

		batch_class = self . template_header . get_batch_class ()
		ASSIGN batch_header . batch_class = batch_class

	ENDIF

	self . set_type ( batch_class )

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_header_base_action_create_entry (       self           ,
						    VALUE class_name     ,
					                  template       ,
						    VALUE position       ,
						    VALUE repeat_section )

{
*	Find the class - create the object and place it into the
*	entry list.
*
*******************************************************************************}

	DECLARE new_entry

	CREATE OBJECT class_name , new_entry

	IF template <> EMPTY THEN

		template . set_up_batch ( new_entry )
		new_entry . set_template ( template )

	ENDIF

	new_entry . set_repeat ( repeat_section )

        array_insert_slice ( self . entries ,
			     1              ,
			     position       )

	self . entries [ position ] = new_entry

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_header_base_action_insert_entry (       self      ,
							  new_entry ,
						    VALUE position  )

{
*	Insert an entry at the given point.
*
*
*******************************************************************************}

        array_insert_slice ( self . entries ,
			     1              ,
			     position       )

	self . entries [ position ] = new_entry

	IF self . trail_start <> -1 THEN

		self . trail_start = self . trail_start + 1

	ENDIF

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_header_base_action_delete_entry (       self     ,
						    VALUE position )

{
*	Delete the given entry.
*
*
*******************************************************************************}

	DECLARE entry

	entry = self . get_entry ( position )
        self . add_to_delete ( entry )

        array_remove_slice ( self . entries ,
			     1              ,
			     position       )

	IF self . trail_start <> -1 THEN

		self . trail_start = self . trail_start - 1

	ENDIF

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_header_base_action_set_parent_pointers (       self              ,
								 template_entry    ,
								 batch_entry       ,
							   VALUE template_position ,
							   VALUE batch_position    )
{
*	IF the element wants a parent then find the right one for it.
*
*******************************************************************************}

	DECLARE parent_offset   ,
		template_temp   ,
		parent_id       ,
		parent_number   ,
		parent          ,
		count

	IF template_entry . want_parent () THEN

		parent_number = template_entry . get_parent ()

		IF parent_number > 0 THEN

			parent_offset = 0

			count = template_position - 1

			WHILE count >= parent_number DO

				template_temp = self . template_list .
						get_entry ( count )

				parent_offset = parent_offset +
						template_temp . get_repeat ()

				count = count - 1

			ENDWHILE

			parent_id     = batch_position - parent_offset
			parent        = self . get_entry ( parent_id )

			parent . set_child_pointer ( batch_entry )

        	ENDIF

	ENDIF

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_header_base_action_create_section (       self           ,
					              VALUE section        ,
						      VALUE position       ,
						      VALUE repeat_section )

{
*	Create the given section ( if there is one )
*
*******************************************************************************}


	DECLARE start_template ,
		end_template   ,
		count          ,
		template_entry ,
		class_name     ,
		repeat_count

	IF self . template_list . has_section ( section        ,
                                                start_template ) THEN

		end_template = start_template

		self . template_list . find_last_of ( section      ,
				       	              end_template )

		count = start_template

		WHILE count <= end_template DO

			template_entry = self . template_list . get_entry ( count )

			class_name = template_entry . get_class ()

			repeat_count = 1

			WHILE repeat_count <= template_entry . get_repeat () DO

				IF class_name <> EMPTY THEN

					self . create_entry (  class_name     ,
						               template_entry ,
							       position       ,
							       repeat_section )

					self . set_parent_pointers ( template_entry           ,
								     self . entries [ position ] ,
								     count                    ,
								     position                 )


					position = position + 1

	   			ENDIF

				repeat_count = repeat_count + 1

			ENDWHILE

			count    = count + 1

		ENDWHILE

	ENDIF

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_header_base_action_create (       self     ,
					      VALUE template )

{
*	Read the template structure into the data structure.
*
*******************************************************************************}

	DECLARE count        ,
		repeat_count ,
		set_infinite

	batch_header_create ()

	ASSIGN batch_header . batch_class = ""

	CREATE OBJECT STD_BATCH_TEMPLATE_BASE, self . template_header

	self . template_header . read_for_batch ( template )

	self . create_class ()

	CREATE OBJECT STD_BATCH_TEMPLATE_LIST, self . template_list

	self . template_list . read_for_display ( template )

	self . create_section ( BATCH_TEMPLATE_START_SECTION ,
				1                            ,
				0                            )

	IF ( self . template_list . has_repeat_section ( repeat_count )) THEN

		IF repeat_count = 0 THEN

			set_infinite = TRUE
			repeat_count = 2

		ELSE

			set_infinite = FALSE

		ENDIF

		count = 1

		WHILE count <= repeat_count DO

			self . create_section ( BATCH_TEMPLATE_REPEAT_SECTION ,
						self . size () + 1            ,
						count                         )

			count = count + 1

		ENDWHILE

		IF set_infinite THEN

			self . last_repeat_section = repeat_count
			self . trail_start         = self . size () + 1

		ENDIF

	ENDIF

	self . create_section ( BATCH_TEMPLATE_TRAIL_SECTION ,
				self . size () + 1           ,
				0                            )

	ASSIGN batch_header . template_id = template
	ASSIGN batch_header . analysis    = self . template_header . get_analysis ()

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_header_base_action_reserve ( self     ,
				      	       new_name )

{
*	Reserve the new name for the table. Return EMPTY if the reserve
*	succeceded else return an error message
*
*******************************************************************************}

	DECLARE status    ,
		syntax    ,
		key0_size

	syntax = self . get_template_header () . get_syntax ()

	IF NOT blank ( syntax ) THEN

		new_name = get syntax ( syntax )

	ENDIF

	IF NOT blank ( new_name ) THEN

		get_field_details batch_header . identity ,
		                  "FIELD_SIZE"            ,
		                  key0_size

		new_name = pad       ( new_name , " " , key0_size )
		new_name = substring ( new_name , 1   , key0_size )

		self . batch_name = new_name

		status = batch_header_reserve ( new_name )

		IF status <> EMPTY THEN

			status = status : " - " : new_name

		ENDIF

	ELSE

		status = GET_USER_MESSAGE ( "BATCH_HEADER_CREATE_NO_NAME", 1 )

	ENDIF

	RETURN ( status )

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_header_base_action_build ( self    ,
					     message )

{
*	Update the database with all the changes. This routine will start a
*	write transaction and perform a commit. It returns EMPTY if everything
*	was successful else an error message
*
*
*******************************************************************************}

	DECLARE count    ,
		entry    ,
		ok

	ok      = EMPTY
	message = ""

	self . remove_unwanted ()
	self . create_randoms  ()

	START WRITE TRANSACTION get_user_message ( "BATCH_HEADER_CREATION_TRANSACTION" , 1 )

	IF ok = EMPTY THEN

		ok      = self . reserve ( self . batch_name )
		message = ok

	ENDIF


	IF ok = EMPTY THEN

		ASSIGN batch_header . template_id = self . template_header . get_field ( "IDENTITY" )
		ASSIGN batch_header . analysis    = self . template_header . get_analysis ()
		ASSIGN batch_header . batch_class = self . template_header . get_batch_class ()

		ASSIGN batch_header . date_created = now
		ASSIGN batch_header . creator      = operator
		ASSIGN batch_header . status       = "V"

		batch_user_set_available ( self, " " )

		UPDATE batch_header

	ENDIF

        IF ok = EMPTY THEN

		count    = 1

		WHILE count <= self . size () DO

			entry = self . get_entry ( count )
    			ok  = entry . create_sample ( self                   ,
						      self . template_header ,
						      message                )

			IF ok <> EMPTY THEN

				count = self . size () + 1

    			ENDIF

			count = count + 1

 		ENDWHILE

	ENDIF

	IF ok = EMPTY THEN

		count    = 1

		WHILE count <= self . size () DO

			entry = self . get_entry ( count )

			entry . create_row ( self . batch_name ,
					     count             )

			entry . set_fields ()
 			entry . update ()

			count = count + 1

		ENDWHILE

	ENDIF


	IF ok = EMPTY THEN

		COMMIT

		mru_list_field_add ( "BATCH_HEADER"    ,
		                     "IDENTITY"        ,
		                     self . batch_name )

	ELSE

		ROLLBACK

	ENDIF

	IF ok = EMPTY THEN

		IF self . template_header . get_field ( "PRINT_ON_CREATION" ) THEN

			batch_print_automatic ( self . batch_name                               ,
						self . template_header . get_field ( "PRINTER" ))

		ENDIF

	ENDIF

	RETURN ( ok )

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_header_base_action_read_template (       self          ,
					             VALUE template_name )

{
*	Get the template used to create the batch.
*
*
*******************************************************************************}

	CREATE OBJECT STD_BATCH_TEMPLATE_BASE, self . template_header

	self . template_header . read_for_batch ( template_name )

	CREATE OBJECT STD_BATCH_TEMPLATE_LIST, self . template_list

	self . template_list . read_for_display ( template_name )

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_header_base_action_read_entries ( self )

{
*	Read all the entries into the object
*
*
*******************************************************************************}

	DECLARE entry         ,
		count         ,
		type          ,
		template      ,
		class_name    ,
		type_info

	template = EMPTY
	count    = 1
	type     = SELECT batch_entry . type

	WHILE type <> EMPTY DO

                type_info  = batch_template_entry_get_type ( type )
		class_name = type_info . batch_class

		self . create_entry ( class_name                          ,
				      template                            ,
				      count                               ,
				      SELECT batch_entry . repeat_section )

		entry = self . get_entry ( count )
		entry . read ()

		NEXT batch_entry
		type  = SELECT batch_entry . type
		count = count + 1

	ENDWHILE

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_header_base_action_set_infinite ( self )

{
*	Set up the batch infinite pointers when reading in a batch.
*
*
*******************************************************************************}

	DECLARE repeat_count     ,
		entry            ,
		current          ,
		count            ,
		create_row       ,
		number_to_create

	IF ( self . template_list . has_repeat_section ( repeat_count )) THEN

		IF repeat_count = 0 THEN

			count = self . size ()

			WHILE count > 0 DO

				entry   = self . get_entry ( count )
                                current = entry . get_repeat ()

				IF current > 0 THEN

					self . last_repeat_section = current
					self . trail_start         = count + 1

					self . set_prompt_position ( count            ,
								     create_row       ,
								     number_to_create )
					count = 0

				ELSE

					count = count - 1

				ENDIF


			ENDWHILE

		ENDIF

	ENDIF

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_header_base_action_read_for_modify (       self       ,
					               VALUE batch_name ,
						       VALUE expand     )

{
*       Read the batch for possible modification. If it works then return
*	TRUE else return
*
*
*******************************************************************************}

	DECLARE temp

	temp = SELECT batch_header . identity
	       FOR UPDATE
	       WHERE ( identity = batch_name )

	self . batch_name = batch_name

	IF temp = batch_name THEN

		self . read_template ( SELECT batch_header . template_id )

		self . create_class ()

		batch_name = SELECT batch_entry . identity
     			     FOR UPDATE
	        	     WHERE  identity = batch_name
		             ORDER ON order_number

		self . read_entries ()

		IF expand THEN

			self . set_infinite ()

		ENDIF

	ENDIF

	RETURN ( temp = batch_name )

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_header_base_action_read_for_display (       self       ,
					                VALUE batch_name )

{
*       Read the batch for display purposes. If it works then return
*	EMPTY else return an error message.
*
*
*******************************************************************************}

	IF SELECT batch_header . identity <> batch_name THEN

		batch_name = SELECT batch_header . identity
			     WHERE  identity = batch_name

	ENDIF

	IF batch_name <> EMPTY THEN

		self . set_is_display ()
		self . read_template ( SELECT batch_header . template_id )

		self . create_class ()

		batch_name = SELECT batch_entry . identity
		             WHERE  identity = batch_name
		             ORDER ON order_number

		self . read_entries ()

	ENDIF

	RETURN ( batch_name <> EMPTY )

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_header_base_action_section_empty (       self              ,
						     VALUE requested_section )

{
*	Check to see if the given section is empty
*
*
*
*
*******************************************************************************}

	DECLARE count            ,
		entry            ,
		section          ,
		section_is_empty

	section_is_empty = TRUE
	count            = 1

	WHILE count <= self . size () DO

		entry   = self . get_entry ( count )

		section = entry . get_repeat ()

		IF section = requested_section THEN

			IF entry . should_create_section () THEN

				section_is_empty = FALSE

			ENDIF

		ELSEIF section > requested_section THEN

			count = self . size ()

		ENDIF

		count = count + 1

	ENDWHILE

	RETURN ( section_is_empty )

ENDROUTINE


{******************************************************************************}

ROUTINE std_batch_header_base_action_set_prompt_position (       self       ,
						           VALUE position   ,
								 create_row ,
								 number_to_create )

{
*
*
*******************************************************************************}

	DECLARE entry     ,
		section   ,
		old_size  ,
		offset

	entry   = self  . get_entry ( position )
	section = entry . get_repeat ()

	IF self . last_repeat_section = section THEN

		old_size   = self . size ()
		offset     = old_size - self . trail_start
        	create_row = self . trail_start

		self . create_section ( BATCH_TEMPLATE_REPEAT_SECTION  ,
					self . trail_start             ,
					self . last_repeat_section + 1 )

		self . last_repeat_section = self . last_repeat_section + 1
		self . trail_start         = self . size () - offset

		number_to_create  = self . size () - old_size

	ELSE

		create_row       = 0
		number_to_create = 0

	ENDIF

ENDROUTINE


{******************************************************************************}

ROUTINE std_batch_header_base_action_set_will_update ( self )

{
*	Initialise all the will create flags
*
*
*******************************************************************************}

	DECLARE count

	count = 1

	WHILE count <= size_of_array ( self . entries ) DO

		self . entries [ count ] . will_update = TRUE

		count = count + 1

	ENDWHILE

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_header_base_action_delete_section (       self              ,
						      VALUE requested_section ,
						      VALUE start_point       )

{
*	Delete a section of a batch.
*
*
*******************************************************************************}

	DECLARE count    ,
		entry    ,
		section  ,
		finished

	count    = start_point
	finished = FALSE

	WHILE (     count <= self . size ()) AND
	      ( NOT finished    	   ) DO

		entry   = self . get_entry ( count )

		section = entry . get_repeat ()

		IF section = requested_section THEN

			entry . will_update = FALSE

		ELSEIF section > requested_section THEN

			finished = TRUE

		ENDIF

		count = count + 1

	ENDWHILE

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_header_base_action_compress ( self )

{
*	Compress the batch based on the parameters in the header
*
*
*******************************************************************************}

	DECLARE count            ,
		section          ,
		entry            ,
		section_start    ,
		current_section  ,
		delete_section   ,
		mode

	mode              = self . template_header . get_field ( "compression" )

	delete_section    = FALSE
	current_section   = -1
	count             = 1
	section_start     = 1

	WHILE count <= size_of_array ( self . entries ) DO

		entry   = self . entries [ count ]
		section = entry . get_repeat ()

		IF section <> current_section THEN

			IF delete_section THEN

				self . delete_section ( current_section ,
							section_start   )

			ENDIF

			section_start    = count
			current_section  = section

			IF section > 0 THEN

				IF mode = BATCH_HEADER_SECTION_DONT_CREATE THEN

					delete_section = FALSE

				ELSEIF mode = BATCH_HEADER_SECTION_LEAVE_SLOTS THEN

					delete_section = section = self . last_repeat_section

				ELSE

					delete_section = TRUE

				ENDIF

			ELSE

				delete_section = FALSE

			ENDIF

		ENDIF

                IF (     entry . is_sample     () ) AND
		   ( NOT entry . should_create () ) THEN

			IF mode = BATCH_HEADER_SECTION_DONT_CREATE THEN

				delete_section = TRUE

			ELSEIF mode = BATCH_HEADER_SECTION_TRUNCATE THEN

				entry . will_update = FALSE

			ENDIF


                ELSEIF ( entry . is_sample     ()) AND
		       ( entry . should_create ()) THEN

			IF mode <> BATCH_HEADER_SECTION_DONT_CREATE THEN

				delete_section = FALSE

			ENDIF

		ELSE

			IF entry . should_create_section () THEN

				delete_section    = FALSE

			ENDIF

		ENDIF

		count = count + 1

	ENDWHILE

	IF delete_section THEN

		self . delete_section ( section       ,
					section_start )

	ENDIF

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_header_base_action_number_of_samples ( self )

{
*	Find the number of samples on the batch after creation
*
*
*******************************************************************************}

	DECLARE count             ,
		number_of_samples ,
		entry

        number_of_samples = 0
	count             = 1

	WHILE count <= size_of_array ( self . entries ) DO

		entry   = self . entries [ count ]

		IF ( entry . is_sample ()) AND
		   ( entry . will_update ) THEN

			number_of_samples = number_of_samples + 1

		ENDIF

		count = count + 1

	ENDWHILE

	RETURN ( number_of_samples )

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_header_base_action_validate ( self        ,
						message     ,
						invalid_row )

{
*	Validate the batch to see if it obeys all the rules.
*
*
*
*
*******************************************************************************}

	DECLARE number_of_samples ,
		valid             ,
		min_samples       ,
		max_samples       ,
		count             ,
		message_ptr

	valid       = TRUE
	invalid_row = 0

	min_samples = self . template_header . get_field ( "Minimum_samples" )
	max_samples = self . template_header . get_field ( "Maximum_samples" )


	self . set_will_update ()

	self . compress ()


	IF min_samples > 0 THEN

		number_of_samples = self . number_of_samples ()

		IF min_samples > number_of_samples THEN

			valid   = FALSE

			message_fetch ( "BATCH_HEADER_TOO_FEW_SAMPLES" ,
					 message_ptr                   )

			message_add_parameter ( message_ptr ,
						min_samples )

			message_add_parameter ( message_ptr       ,
						number_of_samples )

			message = message_get_text ( message_ptr , 1 )

		ENDIF

	ENDIF

	IF max_samples > 0 THEN

		number_of_samples = self . number_of_samples ()

		IF max_samples < number_of_samples THEN

			message_fetch ( "BATCH_HEADER_TOO_MANY_SAMPLES" ,
					 message_ptr                    )

			message_add_parameter ( message_ptr ,
						max_samples )

			message_add_parameter ( message_ptr       ,
						number_of_samples )

			message = message_get_text ( message_ptr , 1 )

			valid   = FALSE

		ENDIF

	ENDIF

	IF valid THEN

		count = 1

		WHILE ( count <= size_of_array ( self . entries )) AND
		      ( valid                                    ) DO

			IF NOT self . entries [ count ] . validate ( self     ,
								     message  ) THEN

				valid       = FALSE
			        invalid_row = count

			ENDIF

			count = count + 1

		ENDWHILE


	ENDIF

	RETURN ( valid )

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_header_base_action_remove_unwanted ( self )

{
*	Remove the unwanted entries
*
*
*******************************************************************************}

	DECLARE count

	count = 1

	WHILE count <= size_of_array ( self . entries ) DO

		IF NOT self . entries [ count ] . will_update THEN

			self . delete_entry ( count )

		ELSE

			count = count + 1

		ENDIF

	ENDWHILE

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_header_base_action_create_randoms ( self )

{
*	Create the random entries
*
*******************************************************************************}

	DECLARE random_control   ,
		random_number    ,
		random_class     ,
		number_to_create ,
		batch_size       ,
		count            ,
		repeat_section   ,
		position         ,
		random_base

	self . template_header . get_random ( random_control ,
					      random_class   ,
					      random_number  )

	IF ( random_control <> EMPTY ) AND ( random_number > 0 ) THEN

		batch_size       = size_of_array ( self . entries )

		number_to_create = batch_size
		number_to_create = number_to_create + ( random_number - 1 ) / 2
		number_to_create = round ( number_to_create / random_number )

		random_base = 0.511

		IF size_of_array ( self . entries ) > 0 THEN
			IF self . entries [1] <> EMPTY THEN
				IF self . entries [1] . test_number <> EMPTY THEN
					random_base = self. entries [1] . test_number
				ENDIF
			ENDIF
		ENDIF

		count = 1

		WHILE count <= number_to_create DO

			position = 1 + abs ( round ( random ( random_base ) * ( batch_size )))

			IF position <= 0 THEN

				position = 1

			ELSEIF position > batch_size THEN

				position = batch_size

			ENDIF

			repeat_section = self . entries [ position ] . get_repeat ()

			self . create_entry ( random_class   ,
					      random_control ,
					      position       ,
					      repeat_section )

			batch_size = batch_size + 1
			count = count + 1

		ENDWHILE

	ENDIF

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_header_base_action_update ( self    ,
					      message )

{
*	Update everything.
*
*
*
*
*******************************************************************************}

	DECLARE count     ,
		entry     ,
		ok        ,
		orig_batch_status

	ok = EMPTY

	self . remove_unwanted ()

	orig_batch_status = SELECT batch_header . status

	IF self . is_complete () THEN

		ASSIGN batch_header . status = "C"

	ELSE

		ASSIGN batch_header . status = "V"

	ENDIF

	START WRITE TRANSACTION get_user_message ( "BATCH_HEADER_UPDATE_TRANSACTION", 1 )

	self . update_delete ()

	{ Move entries up to create holes for new }

	count = self . size ()

	WHILE ( count >= 1     ) AND
	      ( ok     = EMPTY ) DO

		entry = self . get_entry ( count )

		IF entry . exists ( ) THEN

			IF ( entry . get_order ( ) < count ) THEN

				entry . set_order ( count )

				entry . set_fields ()

				ok = entry . modify_sample ( self                   ,
							     self . template_header ,
							     message                )

				entry . update ()

			ENDIF
		ENDIF

		count = count - 1

	ENDWHILE

	{ Move entries down to remove holes for deleted }

	count = 1

	WHILE ( count <= self . size ()) AND
	      ( ok     = EMPTY         ) DO

		entry = self . get_entry ( count )

		IF entry . exists ( ) THEN

			IF ( entry . get_order ( ) > count ) THEN

				entry . set_order ( count )

				entry . set_fields ()

				ok = entry . modify_sample ( self                   ,
							     self . template_header ,
							     message                )

				entry . update ()

			ENDIF
		ENDIF

		count = count + 1

	ENDWHILE

	{ Insert new }

	count = 1

	WHILE ( count <= self . size ()) AND
	      ( ok     = EMPTY         ) DO

		entry = self . get_entry ( count )

		IF NOT entry . exists () THEN

			entry . create_row ( self . batch_name ,
					     count             )

			ok = entry . create_sample ( self                   ,
						     self . template_header ,
						     message                )

			entry . set_order ( count )

			entry . set_fields ()

			entry . update ()

		ENDIF

		count = count + 1

	ENDWHILE

	IF ok = EMPTY THEN

		IF ( SELECT batch_header . status = "C" ) THEN
			batch_user_set_complete ( self, orig_batch_status )
		ELSE
			batch_user_set_available ( self, orig_batch_status )
		ENDIF

		UPDATE batch_header

		COMMIT

	ELSE

		ROLLBACK

	ENDIF

	RETURN ( ok )

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_header_base_action_update_results ( self )

{
*	Update all the results on the batch.
*
*
*
*
*******************************************************************************}

	DECLARE count ,
		entry ,
		orig_batch_status


	START WRITE TRANSACTION get_user_message ( "BATCH_HEADER_UPDATE_TRANSACTION" , 1 )

	orig_batch_status = SELECT batch_header . status

	count = 1

	WHILE count <= self . size () DO

		entry = self . get_entry ( count )

	     	entry . update_results ()

		count = count + 1

	ENDWHILE

	IF self . is_complete () THEN

		ASSIGN batch_header . status = "C"
		batch_user_set_complete ( self, orig_batch_status )

	ELSE

		ASSIGN batch_header . status = "V"
		batch_user_set_available ( self, orig_batch_status )

	ENDIF

	UPDATE batch_header

	COMMIT

	count = 1

	WHILE count <= self . size () DO

		entry = self . get_entry ( count )

	     	entry . release_results ()

		count = count + 1

	ENDWHILE


ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_header_base_action_find_test (       self        ,
						 VALUE test_number )

{
*	Find a given test
*
*
*
*
*******************************************************************************}

	DECLARE count    ,
		entry    ,
		size

	IF test_number <> EMPTY THEN

		size  = self . size ()
		count = 1

		WHILE count <= size DO

			entry = self . entries [ count ]

			IF entry . test_number = test_number THEN

				RETURN ( count )

			ENDIF

			count = count + 1

		ENDWHILE

	ENDIF

	RETURN ( 0 )

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_header_base_action_find_next_slot (       self ,
                                                      VALUE row  )

{
*	Find the next empty slot
*
*******************************************************************************}

	DECLARE entry

	WHILE row <= size_of_array ( self . entries ) DO

		entry = self . entries [ row ]

		IF (     entry . is_sample     ()) AND
		   ( NOT entry . should_create ()) THEN

			RETURN ( row )

		ENDIF

		row = row + 1

	ENDWHILE

	RETURN ( 0 )

ENDROUTINE

{******************************************************************************}


ROUTINE std_batch_header_base_action_add_test (       self             ,
						VALUE test_number      ,
						      row              ,
					              create_row       ,
						      number_to_create )


{
*	Add the given test to the batch
*
*
*******************************************************************************}

	DECLARE temp_create_row        ,
		temp_number_to_create  ,
		entry                  ,
		grid

	IF self . last_repeat_section > -1 THEN

		self . set_prompt_position ( row                   ,
					     temp_create_row       ,
					     temp_number_to_create )


		IF temp_number_to_create > 0 THEN

			IF create_row = 0 THEN

				create_row = temp_create_row

			ENDIF

			number_to_create = number_to_create + temp_number_to_create


		ENDIF

	ENDIF

	row   = self . find_next_slot ( row )

	IF row > 0 THEN

		entry = self . get_entry ( row )
		entry . set_test ( test_number ,
				   grid        ,
				   0           )

		row   = row   + 1

	ENDIF

	RETURN ( row > 0 )

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_header_base_action_include_batch (       self             ,
						     VALUE row              ,
						     VALUE include_batch    ,
							   create_row       ,
							   number_to_create )


{
*	Read in the given batch and add all it's samples - assuming they
*	are not already on the batch.
*
*
*******************************************************************************}

	DECLARE total                 ,
		include_batch_header  ,
		count                 ,
		test_number           ,
		include_entry         ,
		file_descriptor       ,
		message

	push_file_descriptor ( "BATCH_HEADER" , file_descriptor )

	create_row       = 0
	number_to_create = 0

	CREATE OBJECT STD_BATCH_HEADER_BASE, include_batch_header

	include_batch_header . read_for_display ( include_batch )

	total = 0
	count = 1

	WHILE count <= include_batch_header . size () DO

		include_entry = include_batch_header . get_entry ( count )
		test_number   = include_entry . get_test ()

		IF test_number <> EMPTY THEN

			test_number = self . valid_test ( test_number ,
						          EMPTY       ,
						          message     )
		ENDIF

		IF test_number <> EMPTY THEN

			IF self . add_test ( test_number      ,
					     row              ,
					     create_row       ,
					     number_to_create ) THEN

				count = count + 1
				total = total + 1

			ELSE

				count = include_batch_header . size () + 1

			ENDIF

		ELSE

			count = count + 1

		ENDIF

	ENDWHILE

	pop_file_descriptor ( file_descriptor )

	RETURN ( total )

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_header_base_action_select_samples (       self             ,
						      VALUE row              ,
							    create_row       ,
							    number_to_create )


{
*	Find all the matching samples from the database and put them
*	into the batch - use the template maximum number to restrict
*	how many are used.
*
*******************************************************************************}

	DECLARE max_number ,
		test       ,
		criteria   ,
		count      ,
		finished


	ARRAY criteria

	create_row       = 0
	number_to_create = 0
	count            = 0
        finished         = FALSE


	max_number = self . template_header . get_field ( "MAXIMUM_SAMPLES" )


	self . template_header . add_criteria ( criteria )
	self . alter_test_selection_criteria ( criteria )


	array_select_add ( criteria          ,
			   ARRAY_SELECT_PUSH ,
			   EMPTY             ,
			   EMPTY             )


	array_select_add ( criteria        ,
			   ARRAY_SELECT_EQ ,
			   "TEST_STATUS"   ,
			   "V"             )

	array_select_add ( criteria        ,
			   ARRAY_SELECT_OR ,
			   EMPTY           ,
			   EMPTY           )

	array_select_add ( criteria        ,
			   ARRAY_SELECT_EQ ,
			   "TEST_STATUS"   ,
			   "P"             )

	array_select_add ( criteria         ,
			   ARRAY_SELECT_POP ,
			   EMPTY            ,
			   EMPTY            )

	array_select_add ( criteria               ,
			   ARRAY_SELECT_ORDER     ,
			   "TEST_NUMBER"          ,
			   ARRAY_SELECT_ASCENDING )


	array_select ( "SAMP_TEST_VIEW" ,
			FALSE           ,
			criteria        )

	test = SELECT samp_test_view . test_number

	WHILE ( test <> EMPTY ) AND
	      ( NOT finished  )	DO

		count = count + 1

		IF max_number > 0 THEN

			IF count > max_number THEN

				finished = TRUE

			ENDIF

                ENDIF

		IF NOT finished THEN

			finished = NOT self . add_test ( test             ,
				                   	 row              ,
					                 create_row       ,
					                 number_to_create )

		ENDIF

		NEXT samp_test_view

		test = SELECT samp_test_view . test_number

	ENDWHILE

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_header_base_action_review ( self )

{
*	Review the entire batch.
*
*
*******************************************************************************}

	DECLARE count      ,
		entry      ,
		comparison ,
		answer

	answer = "P"
	count  = 1

	WHILE count <= self . size () DO

		entry = self . get_entry ( count )

		comparison = entry . review ()

		IF comparison = "F" THEN

			answer = "F"

		ELSEIF answer = "P" THEN

			answer = comparison

		ENDIF

		count = count + 1

	ENDWHILE

	self . review_status = answer

	ASSIGN batch_header . review_status = answer

	RETURN ( answer )

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_header_base_action_review_update ( self )

{
*	Update the entire batch after review.
*
*
*******************************************************************************}

	DECLARE count ,
		entry

	count  = 1

	WHILE count <= self . size () DO

		entry = self . get_entry ( count )

		entry . review_update ()

		count = count + 1

	ENDWHILE

	UPDATE batch_header

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_header_base_action_review_full ( self )

{
*	Review all tests on batch irrespective of batch type.
*
*
*******************************************************************************}

	DECLARE count      ,
		entry      ,
		comparison ,
		answer

	answer = "P"
	count  = 1

	WHILE count <= self . size () DO

		entry = self . get_entry ( count )

		comparison = entry . review_full ()

		IF comparison = "F" THEN

			answer = "F"

		ELSEIF answer = "P" THEN

			answer = comparison

		ENDIF

		count = count + 1

	ENDWHILE

	self . review_status = answer

	ASSIGN batch_header . review_status = answer

	RETURN ( answer )

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_header_base_action_get_review ( self )

{
*	Get the review flag
*
*
*******************************************************************************}

	RETURN ( self . review_status )

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_header_base_action_get_field (       self           ,
						 VALUE the_field_name )

{
*	Get a field from the batch
*
*
*******************************************************************************}

	DECLARE answer

	answer = SELECT batch_header . 'the_field_name'


	RETURN ( answer )

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_header_base_action_add_to_delete ( self  ,
						     entry )

{
*	Add element to the deleted list.
*
*
*******************************************************************************}

	DECLARE position

	position = size_of_array ( self . deleted_entries )

	self . deleted_entries [ position + 1 ] = entry

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_header_base_action_add_test_to_delete (       self        ,
							  VALUE test_number )

{
*	Add test number to the deleted list.
*
*
*******************************************************************************}

	DECLARE entry ,
		grid

	CREATE OBJECT STD_BATCH_ENTRY_SAMPLE, entry

	entry . set_test ( test_number ,
			   grid        ,
			   0           )

	self . add_to_delete ( entry )

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_header_base_action_remove_from_delete (       self        ,
						          VALUE test_number )

{
*	Remove the test number from the deleted list.
*
*
*******************************************************************************}

	DECLARE count

	count = 1

	WHILE count <= size_of_array ( self . deleted_entries ) DO

		IF self . deleted_entries [ count ] . get_test () = test_number THEN

			array_remove_slice ( self . deleted_entries ,
					     1                      ,
					     count                 )

		ELSE

			count = count + 1

		ENDIF

	ENDWHILE

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_header_base_action_find_in_delete (       self        ,
						      VALUE test_number )

{
*	Find the test in the deleted list - return the position if found
*
*
*******************************************************************************}

	DECLARE count ,
		entry

	count = 1

	WHILE count <= size_of_array ( self . deleted_entries ) DO

		entry = self . deleted_entries [ count ]

		IF entry . get_test () = test_number THEN

			RETURN ( count )

		ENDIF

		count = count + 1

	ENDWHILE

	RETURN ( 0 )

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_header_base_action_update_delete ( self )

{
*	Take the stuff off the batch.
*
*
*******************************************************************************}

	DECLARE count ,
		entry

	count = 1

	WHILE count <= size_of_array ( self . deleted_entries ) DO

		entry = self . deleted_entries [ count ]

		entry . delete ( self )

		count = count + 1

	ENDWHILE

	ARRAY self . deleted_entries ARRAYSIZE ( 0 )

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_header_base_action_download ( self  )

{
*	Down load the batch to a chromatography system.
*
*******************************************************************************}

	DECLARE analysis       ,
	        count          ,
	        entry          ,
	        message        ,
	        chrom_path     ,
	        cds_proj       ,
	        cds_anal       ,
	        cds_inst       ,
	        cds_tmpl       ,
	        proj_list      ,
	        inst_list      ,
	        project_path   ,
	        user_logical   ,
	        chrom_software ,
	        message_ptr

	chrom_path = EMPTY

	ARRAY proj_list
	ARRAY inst_list

	IF ( GLOBAL ( "PLATFORM" ) = "VMS" ) THEN

		user_logical = "smp$userfiles:"

	ELSE

		user_logical = "$smp_userfiles/"

	ENDIF

	{ Check to see which Chromatography system is connected }
	{ Currently either to XChrom or MultiChrom }

	IF ( GLOBAL ( "CHROMATOGRAPHY_SOFTWARE" ) = "XCHROM"    )
	OR ( GLOBAL ( "CHROMATOGRAPHY_SOFTWARE" ) = "XCHROMV21" )
	OR ( GLOBAL ( "CHROMATOGRAPHY_SOFTWARE" ) = "ATLAS"     ) THEN

		IF ( GLOBAL ( "CHROMATOGRAPHY_SOFTWARE" ) = "ATLAS" ) THEN

			chrom_software = "Atlas"

			chrom_path = client_get_app_path ( "atlas.exe" )

			chrom_path = chrom_path # "Atlas.exe"

		ELSE

			chrom_software = "XChrom"

			chrom_path = client_get_xchrom_path ()

		ENDIF

		IF ( chrom_path <> EMPTY ) THEN

			{ The target system is either XChrom or Atlas }

			cds_proj = self . get_batch_field ( "CDS_PROJECT" )
			cds_anal = self . get_batch_field ( "CDS_ANALYSIS_NAME" )
			cds_inst = self . get_batch_field ( "CDS_INSTRUMENT" )
			cds_tmpl = self . get_batch_field ( "CDS_METHOD_NAME" )

			project_path = SELECT phrase . phrase_text
				WHERE phrase_type = "MCPROJECT"
				AND   phrase_id   = TOLOWER ( STRIP ( cds_proj ) )

			project_path = STRIP ( project_path )

			IF BLANK ( project_path ) THEN

				project_path = chrom_path : "\projects"

			ENDIF

			CLIENT_GET_FILE_NAMES ( project_path : "\" :
						STRIP ( cds_proj ) ,
						proj_list          )

			CLIENT_GET_FILE_NAMES ( project_path : "\" :
						STRIP ( cds_proj ) : "\" :
						cds_inst                 ,
						inst_list                )

			IF  ( NOT BLANK ( cds_proj ) )
			AND ( size_of_array ( proj_list ) <> 0 )
                        AND ( NOT BLANK ( cds_anal ) )
			AND ( size_of_array ( inst_list ) <> 0 )
			AND ( NOT BLANK ( cds_inst ) ) THEN

				IF (( chrom_software = "Atlas" )
				AND ( BLANK ( cds_tmpl )       )) THEN

					message_fetch ( "STD_XCHROM_MUST_SPECIFY_TMPL" ,
					                 message_ptr                   )

					message_add_parameter ( message_ptr            ,
					                        strip ( chrom_software))

					message = message_get_text ( message_ptr , 1 )

				ELSE

					IF ( chrom_software = "Atlas" ) THEN

						CREATE OBJECT STD_BATCH_ATLAS_ANALYSIS , analysis

					ELSE

						CREATE OBJECT STD_BATCH_XCHROM_ANALYSIS , analysis

					ENDIF

					analysis . set_analysis ( self )

					message = analysis . download_header ( self         ,
					                                       user_logical )

					IF ( message = EMPTY ) THEN

						count = 1

						WHILE count <= self . size () DO

							entry = self . get_entry ( count )

			   				analysis . download_sample ( entry        ,
							                             count        ,
							                             user_logical )

							count = count + 1

						ENDWHILE

					ENDIF

					message = analysis . finish_download ()

				ENDIF

			ELSE

				message_fetch ( "STD_XCHROM_MUST_SPECIFY" ,
				                 message_ptr              )

				message_add_parameter ( message_ptr            ,
				                        strip ( chrom_software))

				message = message_get_text ( message_ptr , 1 )

			ENDIF

		ELSE

			message_fetch ( "STD_XCHROM_FAILED_LOCATE" ,
			                 message_ptr               )

			message_add_parameter ( message_ptr            ,
			                        strip ( chrom_software))

			message = message_get_text ( message_ptr , 1 )

		ENDIF

	ELSEIF GLOBAL ( "CHROMATOGRAPHY_SOFTWARE" ) = "MULTICHROM" THEN

		{ Assume MultiChrom is the target system }

		CREATE OBJECT STD_BATCH_CHROM_ANALYSIS , analysis

		message = analysis . create_download ( self  )

		IF message = EMPTY THEN

			count = 1

			WHILE count <= self . size () DO

				entry = self . get_entry ( count )

	   			analysis . download_sample ( entry ,
							     count )

				count = count + 1

			ENDWHILE

			analysis . finish_download ()

		ENDIF
	ENDIF

	RETURN ( message )

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_header_base_action_upload ( self    ,
					      results )

{
*	Upload a batch from chromatography system.
*
*******************************************************************************}

	DECLARE message     ,
	        message_ptr ,
	        entries     ,
	        chrom_path  ,
	        cds

	chrom_path = EMPTY

	{ Check to see which Chromatography system is connected }
	{ Currently either to XChrom, MultiChrom or Atlas       }

	cds = GLOBAL ( "CHROMATOGRAPHY_SOFTWARE" )

	IF ( cds != "MULTICHROM" ) THEN

		IF ( cds = "ATLAS" ) THEN

			chrom_path = client_get_app_path ( "Atlas.exe" )

		ELSE

			chrom_path = CLIENT_GET_XCHROM_PATH ()

		ENDIF

		IF ( chrom_path <> EMPTY ) THEN

			IF ( cds = "ATLAS" ) THEN

				{ Atlas is the target system }

				CREATE OBJECT STD_BATCH_ATLAS_ANALYSIS , results

			ELSE

				{ Xchrom is the target system }

				CREATE OBJECT STD_BATCH_XCHROM_ANALYSIS , results

			ENDIF

			entries = self . size ()

			results . set_analysis ( self )

			message = results . read_analysis ( entries ,
			                                    TRUE    )

		ELSE

			message_fetch ( "STD_XCHROM_FAILED_LOCATE" ,
			                 message_ptr               )

			message_add_parameter ( message_ptr  ,
			                        strip ( cds ))

			message = message_get_text ( message_ptr , 1 )

		ENDIF

	ELSEIF cds = "MULTICHROM" THEN

		CREATE OBJECT STD_BATCH_CHROM_ANALYSIS , results

		message = results . create_upload ( self )

		IF message = EMPTY THEN

			results . set_analysis ( self )

			message = results . read_analysis ( TRUE )

			results . finish_upload ()

		ENDIF

	ENDIF

	RETURN ( message )

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_header_base_action_valid_test (       self        ,
						  VALUE test_number ,
					    	  VALUE sample      ,
							message     )

{
*	Test to see if the given test is valid for the batch. The test
*	can be specified as either:
*		Test Number
*		Sample Id/Replicate
*		Sample ID ( Defaults to replicate 1 )
*
*
*******************************************************************************}

	DECLARE replicate       ,
		sample_id       ,
		slash_pos       ,
		mandatory_array ,
		message_ptr

	ARRAY mandatory_array

	self . template_header . add_criteria ( mandatory_array )
	self . alter_test_selection_criteria ( mandatory_array )

	IF ( test_number <> EMPTY     ) AND
	   ( test_number <> 0         ) AND
	   ( NOT blank ( test_number )) THEN

		array_select_add (  mandatory_array ,
				    ARRAY_SELECT_EQ ,
				   "TEST_NUMBER"    ,
				    test_number     )

	ELSE

		sample    = TOUPPER ( sample )
		slash_pos = INDEX ( sample , "/" )

		IF slash_pos <> 0 THEN

			replicate = substring ( sample                        ,
		        	                slash_pos + 1                 ,
		                	        string_length ( sample ) -
								    slash_pos )

			IF numtext ( replicate ) THEN

        	                replicate = numeric ( replicate )

			ELSE

				replicate = 1

			ENDIF

			sample_id = substring ( sample       ,
			                        1             ,
		        	                slash_pos - 1 )

 		ELSE

			sample_id = sample
			replicate = 1

		ENDIF

		IF ( length  ( sample_id ) < 10 ) AND
                   ( numtext ( sample_id )      ) THEN

			array_select_add (  mandatory_array ,
					    ARRAY_SELECT_EQ ,
					   "ID_NUMERIC"     ,
					    sample_id       )

		ELSE

			array_select_add (  mandatory_array ,
					    ARRAY_SELECT_EQ ,
					   "ID_TEXT"        ,
					    sample_id       )

		ENDIF

		array_select_add (  mandatory_array ,
			            ARRAY_SELECT_EQ ,
				   "TEST_COUNT"     ,
			            replicate       )

	ENDIF

        array_select ( "SAMP_TEST_VIEW" ,
		        FALSE           ,
			mandatory_array )

	IF SELECT samp_test_view . test_number = EMPTY	 THEN

		IF ( test_number <> EMPTY     ) AND
		   ( test_number <> 0         ) AND
		   ( NOT blank ( test_number )) THEN

			message_fetch ( "BATCH_HEADER_INVALID_TEST" ,
					 message_ptr                )

			message_add_parameter ( message_ptr ,
						test_number )

			message_add_parameter ( message_ptr ,
						sample      )

			message = message_get_text ( message_ptr ,1 )

		ELSE

			message_fetch ( "BATCH_HEADER_INVALID_SAMPLE" ,
					 message_ptr                  )

			message_add_parameter ( message_ptr ,
						sample      )

			message = message_get_text ( message_ptr ,1 )

		ENDIF

	ENDIF

	RETURN ( SELECT samp_test_view . test_number )

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_header_base_action_upload_rebuild ( self       ,
						      instrument ,
						      message    )

{
*	Look at what came back from the instrument and rebuild the batch
*	to conform.
*
*******************************************************************************}

	DECLARE count             ,
		batch_size        ,
		instrument_size   ,
		common_size       ,
		instrument_sample ,
		entry             ,
		class_name        ,
		grid              ,
		changed           ,
		template          ,
		test_number       ,
		change_entry      ,
		keep_going        ,
		original_classes

	ARRAY original_classes

	changed         = FALSE
	template        = EMPTY
	message         = EMPTY
	keep_going      = TRUE

	batch_size      = self . size ()
	instrument_size = instrument . get_number_of_samples ()
	common_size     = find_min_number ( batch_size      ,
					    instrument_size )

	count = 1

	WHILE ( count <= batch_size ) DO

		original_classes [ count , 1 ] =
				SELECT samp_test_view . id_numeric
					IN OBJECT self .entries [ count ]

		original_classes [ count , 2 ] =
				SELECT samp_test_view . test_number
					IN OBJECT self . entries [ count ]

		original_classes [ count , 3 ] = object_get_class_name (
						self . entries [ count ] )

		count = count + 1

	ENDWHILE

	count = 1

	WHILE ( count <= common_size ) AND
	      ( keep_going           ) DO

		entry             = self . get_entry ( count )
		instrument_sample = instrument . get_entry ( count )

		IF NOT entry . is_same_as ( instrument_sample ) THEN

			test_number = self . valid_test ( instrument_sample .
								get_test ()   ,
							  instrument_sample .
								get_sample () ,
							  message             )

			keep_going = test_number <> EMPTY

			instrument_sample . set_test ( test_number )

			change_entry = NOT entry . is_same_as ( instrument_sample )

			{ If invalid sample_id read from chrom system the }
			{ following select means the entry holds a        }
			{ samp_test_view record                           }

			IF test_number = EMPTY THEN

				test_number = SELECT samp_test_view .test_number
					IN OBJECT self . entries [ count ]

				instrument_sample . set_test ( test_number )

			ENDIF

		ELSE

			change_entry = FALSE

		ENDIF

		IF change_entry THEN

			self . delete_entry ( count )

			class_name = self . get_original_class (
							batch_size        ,
							count             ,
							instrument_sample ,
							original_classes  )


			IF class_name = EMPTY THEN

				class_name = instrument_sample .
							get_batch_class ()

                        ENDIF

			self . create_chrom_template_entry ( instrument_sample ,
							     class_name        ,
							     1                 ,
							     template          )

			self . create_entry ( class_name    ,
					      template      ,
					      count         ,
					      1             )

			entry = self . get_entry ( count )

			entry . set_test ( test_number ,
					   grid        ,
					   0           )

{			grid . set_position ( 2, count )}

			changed = TRUE

		ENDIF

		count = count + 1

	ENDWHILE

	IF common_size < batch_size THEN

		WHILE ( count <= batch_size ) AND
		      ( keep_going          ) DO

			self . delete_entry ( common_size + 1 )

			count = count + 1

			changed = TRUE

		ENDWHILE

	ELSEIF common_size < instrument_size THEN

		WHILE count <= instrument_size DO

			instrument_sample = instrument . get_sample ( count )

			test_number = self . valid_test ( instrument_sample . get_test ()   ,
							  instrument_sample . get_sample () ,
							  message                           )


			instrument_sample . set_test ( test_number )

			keep_going = test_number <> EMPTY

			class_name = instrument_sample . get_batch_class ()

			self . create_entry ( class_name    ,
					      template      ,
					      count         ,
					      1             )

			entry = self . get_entry ( count )

			entry . set_test ( test_number ,
					   grid        ,
					   0           )

			count = count + 1

			changed = TRUE

		ENDWHILE

	ENDIF

	RETURN ( changed )

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_header_base_action_create_chrom_template_entry ( self    ,
							      chrom_sample ,
							VALUE class_name   ,
							VALUE repeat_val   ,
							      template     )

{
*	Create a template entry to be used when creating a batch entry
*	from a sample upload from a chromatography system.
*
*******************************************************************************}

	DECLARE class_type ,
		sample_id  ,
		slash_pos

	IF class_name = "STDBATCHENTRYSAMPLE" THEN

		class_type = BATCH_ENTRY_SAMPLE

	ELSEIF class_name = "STDBATCHENTRYSTANDARD" THEN

		class_type = BATCH_ENTRY_STANDARD

	ELSEIF class_name = "STDBATCHENTRYCONTROL" THEN

		class_type = BATCH_ENTRY_CONTROL

	ELSEIF class_name = "STDBATCHENTRYBLANK" THEN

		class_type = BATCH_ENTRY_BLANK

	ENDIF

	CREATE OBJECT STD_BATCH_TEMPLATE_ENTRY, template

	template . initialise ( class_type                    ,
				BATCH_TEMPLATE_REPEAT_SECTION )

	slash_pos = INDEX ( chrom_sample . sample_name , "/" )

	IF slash_pos <> 0 THEN

		sample_id = LEFTSTRING ( chrom_sample . sample_name , slash_pos - 1 )

	ELSE

		sample_id = chrom_sample . sample_name

	ENDIF

	sample_id = PACKED_DECIMAL ( sample_id )

	template . standard  = SELECT samp_test_view . standard_id
		WHERE id_numeric  = sample_id
		AND   test_number = chrom_sample . lims_name

	template . comp_list = SELECT samp_test_view . comp_list
	template . limit     = SELECT samp_test_view . product

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_header_base_action_get_original_class ( self              ,
							  number_entries    ,
							  entry_number      ,
							  instrument_sample ,
							  original_classes  )

{
*	Get the class of the original entry (if it existed).
*
*******************************************************************************}

	DECLARE count          ,
		original_class ,
		sample_name    ,
		test_number    ,
		slash_pos

	original_class = EMPTY

	sample_name = instrument_sample . sample_name
	test_number = instrument_sample . lims_name

	slash_pos = INDEX ( sample_name , "/" )

	IF slash_pos <> 0 THEN

		sample_name = LEFTSTRING ( sample_name , slash_pos - 1 )

	ENDIF

	count = 1

	WHILE ( count <= number_entries )
	AND   ( original_class = EMPTY  ) DO

		IF  ( original_classes [ count , 1 ] = sample_name )
		AND ( original_classes [ count , 2 ] = test_number ) THEN

			original_class = original_classes [ count , 3 ]

		ENDIF

		count = count + 1

	ENDWHILE

	RETURN ( original_class )

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_header_base_action_is_complete ( self )

{
*	Check to see if the batch is complete.
*
*******************************************************************************}

	DECLARE count      ,
		components ,
		complete   ,
		entries

	self . template_header . get_components ( components )

	complete = TRUE
	count    = 1

	entries  = size_of_array ( self . entries )

	IF entries = 0 THEN

		complete = FALSE

	ENDIF

	WHILE count <= entries DO

		IF NOT self . entries [ count ] . is_complete ( components ) THEN

			complete = FALSE
			count    = size_of_array ( self . entries )

		ENDIF

		count = count + 1

	ENDWHILE

	RETURN ( complete )

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_header_base_action_set_available ( self )

{
*	Set the batch status to available.
*
*******************************************************************************}

	DECLARE count   ,
		status  ,
		rebuild ,
		orig_batch_status


	status = EMPTY
	orig_batch_status = SELECT batch_header . status

	rebuild = ( SELECT batch_header . status <> "V" ) AND
		  ( SELECT batch_header . status <> "C" )

	{ Set the fields needed }

	ASSIGN batch_header . status  = "V"

	{ Make sure other fields are not set }

	ASSIGN batch_header . date_completed  = date ( " " )
	ASSIGN batch_header . completer       = ""

	ASSIGN batch_header . date_authorised      = date ( " " )
	ASSIGN batch_header . authoriser           = ""
	ASSIGN batch_header . authorisation_notes  = ""

	IF rebuild THEN

		count = 1

		WHILE ( count <= size_of_array ( self . entries )) AND
	              ( status = EMPTY                           ) DO

			status = self . entries [ count ] . cancel ( self )
			status = self . entries [ count ] . update ()

			count =  count + 1

  		ENDWHILE

	ENDIF

	batch_user_set_available ( self, orig_batch_status )

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_header_base_action_set_complete ( self )

{
*	Set the batch status to complete.
*
*******************************************************************************}

	DECLARE count           ,
		entry           ,
		included_batch  ,
		included        ,
		pos             ,
		found           ,
		batch           ,
		file_descriptor ,
		orig_batch_status

	orig_batch_status = SELECT batch_header . status

	{ Set the fields needed }

	ASSIGN batch_header . status          = "C"

	ASSIGN batch_header . date_completed  = now
	ASSIGN batch_header . completer       = operator

	{ Make sure other fields are not set }

	ASSIGN batch_header . date_reviewed  = date ( " " )
	ASSIGN batch_header . reviewer       = ""

	ASSIGN batch_header . date_authorised      = date ( " " )
	ASSIGN batch_header . authoriser           = ""
	ASSIGN batch_header . authorisation_notes  = ""

	IF self . type_test_include_field <> EMPTY THEN

		ARRAY included

		count = 1

		WHILE count <= size_of_array ( self . entries )

			entry = self . entries [ count ]

			included_batch = entry . get_samp_test_field ( self . type_test_include_field )

			IF ( included_batch <> EMPTY     ) AND
			   ( NOT blank ( included_batch )) THEN

				pos   = 1
	                        found = FALSE

				WHILE pos <= size_of_array ( included ) DO

                                        IF included [ pos ] = included_batch THEN

						found = TRUE
						pos   = size_of_array ( included)

					ENDIF

					pos = pos + 1

				ENDWHILE

				IF NOT found THEN

					included [ pos ] = included_batch

				ENDIF

			ENDIF

			count =  count + 1

  		ENDWHILE

		count = 1

		WHILE count <= size_of_array ( included ) DO

			push_file_descriptor ( "BATCH_HEADER"   ,
						file_descriptor )

			CREATE OBJECT STD_BATCH_HEADER_BASE, batch

			batch . read_for_modify ( included [ count ] ,
						  FALSE              )

			IF batch . is_complete () THEN

				batch . set_complete ()

				UPDATE batch_header

			ENDIF

			pop_file_descriptor ( file_descriptor )

			count = count + 1

		ENDWHILE

	ENDIF

	batch_user_set_complete ( self, orig_batch_status )

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_header_base_action_set_inspected ( self )

{
*	Set the batch status to review.
*
*******************************************************************************}

	DECLARE count      ,
		components ,
		status     ,
		orig_batch_status

	status = EMPTY
	orig_batch_status = SELECT batch_header . status

	{ Set the fields needed }

	ASSIGN batch_header . status         = "I"

	ASSIGN batch_header . date_reviewed  = now
	ASSIGN batch_header . reviewer       = operator

	{ Make sure other fields are not set }

	ASSIGN batch_header . date_authorised      = date ( " " )
	ASSIGN batch_header . authoriser           = ""
	ASSIGN batch_header . authorisation_notes  = ""

	count = 1

	WHILE ( count <= size_of_array ( self . entries )) AND
              ( status = EMPTY                           ) DO

		status = self . entries [ count ] . inspect ( components ,
						              self       )

		IF status = EMPTY THEN
			status = self . entries [ count ] . update ()
		ENDIF

		count =  count + 1

	ENDWHILE

	batch_user_set_inspected ( self, orig_batch_status )

	RETURN ( status )

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_header_base_action_set_authorised ( self )

{
*	Set the batch status to authorised.
*
*******************************************************************************}

	DECLARE count      ,
		components ,
		status     ,
		orig_batch_status

	status = EMPTY
	orig_batch_status = SELECT batch_header . status
	self . template_header . get_components ( components )

	{ Set the fields needed }

	ASSIGN batch_header . status           = "A"

	ASSIGN batch_header . date_authorised  = now
	ASSIGN batch_header . authoriser       = operator

	count = 1

	WHILE ( count <= size_of_array ( self . entries )) AND
              ( status = EMPTY                           ) DO

		status = self . entries [ count ] . authorise ( components ,
								self       )

		IF status = EMPTY THEN
			status = self . entries [ count ] . update ()
		ENDIF

		count =  count + 1

	ENDWHILE

	batch_user_set_authorised ( self, orig_batch_status )

	RETURN ( status )

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_header_base_action_set_cancelled ( self )

{
*	Set the batch status to cancelled.
*
*******************************************************************************}

	DECLARE count  ,
		status ,
		orig_batch_status

	status = EMPTY
	orig_batch_status = SELECT batch_header . status

	{ Set the fields needed }

	ASSIGN batch_header . status           = "X"

	ASSIGN batch_header . date_cancelled  = now
	ASSIGN batch_header . canceller       = operator

	count = 1

	WHILE ( count <= size_of_array ( self . entries )) AND
              ( status = EMPTY                           ) DO

		status = self . entries [ count ] . cancel ( self )

		IF status = EMPTY THEN
			status = self . entries [ count ] . update ()
		ENDIF

		count =  count + 1

	ENDWHILE

	batch_user_set_cancelled ( self, orig_batch_status )

	RETURN ( status )

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_header_base_action_set_status (       self       ,
                                                  VALUE new_status )
{
*	Set the batch status to what is required.
*
*******************************************************************************}

	DECLARE status       ,
		message_ptr  ,
		local_commit

	status = EMPTY

	local_commit = NOT TRANSACTION_IS_WRITE ( )

	IF local_commit THEN
		START WRITE TRANSACTION get_user_message ( "BATCH_HEADER_STATUS_TRANSACTION", 1 )
	ENDIF

	IF new_status = "V" THEN

		self . set_available ()

	ELSEIF new_status = "C" THEN

		self . set_complete ()

	ELSEIF new_status = "I" THEN

		status = self . set_inspected ()

	ELSEIF new_status = "A" THEN

		status = self . set_authorised ()

	ELSEIF new_status = "X" THEN

		status = self . set_cancelled ()

	ELSE

		message_fetch ( "BATCH_HEADER_UNKNOWN_STATUS" , message_ptr )

		message_add_parameter ( message_ptr , new_status )

		status = message_get_text ( message_ptr , 1 )

	ENDIF

	IF status = EMPTY THEN

		UPDATE batch_header

		IF local_commit THEN
			COMMIT
		ENDIF

	ELSEIF local_commit THEN
		ROLLBACK

	ENDIF

	RETURN ( status )

ENDROUTINE

{******************************************************************************}

ROUTINE std_batch_header_base_action_commit ( self )

{
*	Commit the batch
*
*******************************************************************************}

	DECLARE count       ,
		entry       ,
		destination ,
		form        ,
		status


        CALL_ROUTINE "BATCH_DESTINATION"
                      USING destination
                      RETURNING status
                      IN LIBRARY "$COMMIT"

	IF status THEN

		status = EMPTY

		START WRITE TRANSACTION get_user_message ( "BATCH_HEADER_COMMIT_TRANS" , 1 )

		CONSIGN BATCH_HEADER TO destination , status

		IF status = EMPTY THEN

			form = EMPTY
			commit_audit_records ( form               ,
					       "BATCH_HEADER"     ,
						self . batch_name ,
						destination       ,
						status            ,
						""                )

		ENDIF

		count = 1

		WHILE ( count <= size_of_array ( self . entries )) AND
		      ( status = EMPTY                           ) DO

			entry = self . entries [ count ]

			status = entry . commit ( destination  )

			count =  count + 1

		ENDWHILE

		IF status = EMPTY THEN

			COMMIT

		ELSE

			ROLLBACK

    		ENDIF

	ENDIF

	RETURN ( status )

ENDROUTINE

