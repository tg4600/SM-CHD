{******************************************************************************
* Module Name   : EXPLORER_RMB
* Purpose       : Custom RMB functions for Explorer folders
*******************************************************************************}

SET NOTPROTECTED
SET NAME"DEFER/"
SET COMPILE_OPTION DECLARE
ENABLE WINDOWS

JOIN STANDARD_LIBRARY STD_ARRAY
JOIN STANDARD_LIBRARY STD_ARRAY_SELECT 
JOIN STANDARD_LIBRARY STD_PROMPT

JOIN LIBRARY $LIB_UTILS
JOIN LIBRARY TOOLBOX
JOIN LIBRARY $TABLE_LOAD_SAVE_LIB

GLOBAL ROUTINE prod_sched_label_rmb ( rmb_object, object , collection )
{*************************************************************************
* Purpose       : Explorer RMB callback routine for setting/adjusting
*                 label count for Login Schedule based on LOGIN_SCHEDULE_VIEW
* Parameters    : rmb_object, object , collection
* Return Value  : None

    rmb_object  EXPLORER_RMB        - E:\Program Files (x86)\Thermo\SampleManager\11.1\Report\$explorer_rmb.rpf
    object      STD_OBJECT_RECORD   - Programmers_Guide.chm
    collection  STD_OBJECT_DATABASE - Programmers_Guide.chm

*************************************************************************}
DECLARE records, table, ArrKey0, Key1, Key2, Key3, Key4, Key5, i, key, status
DECLARE prompt_title, msg_array, display_text, prompt_type, fld_name, do_browse, select_array, prompt_val, last_key_used

ARRAY msg_array
ARRAY select_array
ARRAY records 
ARRAY ArrKey0

    table = rmb_object.table
    GET_TABLE_DETAILS 'table', "KEY0_FIELD", ArrKey0

    Key1 = ArrKey0[1]
    Key2 = ArrKey0[2]
    Key3 = ArrKey0[3]
    Key4 = ArrKey0[4]
    Key5 = ArrKey0[5]
    
    collection.set_first()
    WHILE collection.current <> EMPTY DO
        i = size_of_array(records) + 1
        records[i, 1] = SELECT 'table'.'Key1' IN OBJECT collection.current
        records[i, 2] = SELECT 'table'.'Key2' IN OBJECT collection.current
        records[i, 3] = SELECT 'table'.'Key3' IN OBJECT collection.current
        records[i, 4] = SELECT 'table'.'Key4' IN OBJECT collection.current
        records[i, 5] = SELECT 'table'.'Key5' IN OBJECT collection.current
        collection.set_next()
    ENDWHILE

    IF size_of_array(records) > 0 THEN
    
        prompt_title = "Set label count ..."
        msg_array[1] = "Set label count to N for selected records"
        msg_array[2] = "   N: set to fixed number"
        msg_array[3] = "+N: increase with N"
        msg_array[4] = "- N: decrease with N"
        display_text = "Define N:"
        prompt_type  = "TEXT10"
        fld_name     = ""
        do_browse    = FALSE
        prompt_val   = ""

        key = prompt_user_msg (prompt_title, msg_array, display_text,
                         prompt_type , fld_name, do_browse, 
                         select_array, prompt_val, last_key_used)

        IF key AND NUMTEXT(prompt_val) THEN
            i = 1
            WHILE i <= size_of_array(records)
                status = SELECT prod_sched.product_name FOR UPDATE
                         WHERE product_name     = records[i, 1]
                           AND product_version  = records[i, 2]
                           AND inspection_type  = records[i, 3]
                           AND sampling_point   = records[i, 4]
                           AND group_id         = records[i, 5]
                IF status = records[i, 1] THEN
                    START WRITE TRANSACTION "Set label count"
                    IF INDEX("+-", LEFTSTRING(STRIP(prompt_val), 1)) > 0 THEN
                        ASSIGN prod_sched.label_count = SELECT prod_sched.label_count + NUMERIC(prompt_val)
                    ELSE
                        ASSIGN prod_sched.label_count = NUMERIC(prompt_val)
                    ENDIF
                    UPDATE prod_sched
                    COMMIT
                ELSE
                    ROLLBACK
                ENDIF
                i = i + 1
            ENDWHILE
        ENDIF
    ENDIF
    
ENDROUTINE

GLOBAL ROUTINE export_data ( rmb_object, object , collection )
{*************************************************************************
* Purpose       : Explorer RMB callback routine for exporting data
                  To be used for single-table entities, like sample_point...
                  For entities using more tables, i.e. job and sample templates
                  the code must be adjusted for:
                => ROUTINE ExportChildTable AND
                => ROUTINE ImportChildTable 
                
* Parameters    : rmb_object, object , collection
* Return Value  : None
    rmb_object  EXPLORER_RMB        - E:\Program Files (x86)\Thermo\SampleManager\11.1\Report\$explorer_rmb.rpf
    object      STD_OBJECT_RECORD   - Programmers_Guide.chm
    collection  STD_OBJECT_DATABASE - Programmers_Guide.chm
*************************************************************************}
DECLARE table, ArrKey0, mod_field, Key1, Key2, Key3, Key4, Key5, i, records, default_path, file_name, msg,
        r, select_array, list_of_fields, flash_status, return_message, id, status

ARRAY records 
ARRAY ArrKey0
ARRAY select_array
ARRAY list_of_fields

    table = rmb_object.table
    GET_TABLE_DETAILS 'table', "KEY0_FIELD", ArrKey0
    GET_TABLE_DETAILS 'table', "MODIFIED_ON_FIELD", mod_field

    Key1 = EMPTY
    Key2 = EMPTY
    Key3 = EMPTY
    Key4 = EMPTY
    Key5 = EMPTY
    
    Key1 = ArrKey0[1]
    IF size_of_array(ArrKey0) >= 2 THEN
        Key2 = ArrKey0[2]
    ENDIF    
    IF size_of_array(ArrKey0) >= 3 THEN
        Key3 = ArrKey0[3]
    ENDIF    
    IF size_of_array(ArrKey0) >= 4 THEN
        Key4 = ArrKey0[4]
    ENDIF    
    IF size_of_array(ArrKey0) >= 5 THEN
        Key5 = ArrKey0[5]
    ENDIF    

    collection.set_first()
    WHILE collection.current <> EMPTY DO
        i = size_of_array(records) + 1
        IF size_of_array(ArrKey0) >= 1 THEN
            records[i, 1] = SELECT 'table'.'Key1' IN OBJECT collection.current
        ENDIF    
        IF size_of_array(ArrKey0) >= 2 THEN
            records[i, 2] = SELECT 'table'.'Key2' IN OBJECT collection.current
        ENDIF    
        IF size_of_array(ArrKey0) >= 3 THEN
            records[i, 3] = SELECT 'table'.'Key3' IN OBJECT collection.current
        ENDIF    
        IF size_of_array(ArrKey0) >= 4 THEN
            records[i, 4] = SELECT 'table'.'Key4' IN OBJECT collection.current
        ENDIF    
        IF size_of_array(ArrKey0) >= 5 THEN
            records[i, 5] = SELECT 'table'.'Key5' IN OBJECT collection.current
        ENDIF    
        collection.set_next()
    ENDWHILE

    default_path = STRIP(SELECT destination_cpu.system_path WHERE identity = GLOBAL("AUTO_COMMIT_DEFAULT_DEST")):"\CSV"

    r = 1
    WHILE r <= size_of_array(records)
            IF r = 1 THEN
                array_select_add(select_array, ARRAY_SELECT_PUSH, EMPTY, EMPTY)
            ELSEIF r > 1 THEN
                array_select_add(select_array, ARRAY_SELECT_OR, EMPTY, EMPTY)
            ENDIF
            i = 1
            WHILE i <= size_of_array(ArrKey0)
                IF i = 1 THEN
                    array_select_add(select_array, ARRAY_SELECT_PUSH, EMPTY, EMPTY)
                ELSEIF i > 1 THEN
                    array_select_add(select_array, ARRAY_SELECT_AND, EMPTY, EMPTY)
                ENDIF
                    array_select_add(select_array, ARRAY_SELECT_EQ, ArrKey0[i], records[r,i])
                IF i = size_of_array(ArrKey0) THEN
                    array_select_add(select_array, ARRAY_SELECT_POP,  EMPTY, EMPTY)
                ENDIF
                i = i + 1
            ENDWHILE    
            IF r = size_of_array(records) THEN
                array_select_add(select_array, ARRAY_SELECT_POP,  EMPTY, EMPTY)
            ENDIF
        r = r + 1
    ENDWHILE

    SET DATE FORMAT "YYYY-MM-DZ H24.MI"
        file_name = NOW:" ":STRIP(OPERATOR):".csv"
    RESTORE DATE FORMAT
   
    get_field_names_without_aliases ( table, list_of_fields )
    flash_status    = FALSE
    spawn "md ":default_path:"\":table, status QUIETLY
    output_csv_file ( default_path:"\":table:"\":file_name, table, list_of_fields, select_array, flash_status, return_message )

    ExportChildTable(table, select_array, file_name)
    
    IF mod_field <> EMPTY THEN
        i = 1
        WHILE i <= size_of_array(records)
            id = SELECT 'table'.'key1' FOR UPDATE WHERE 'key1' = records[i, 1]
            IF id = records[i, 1]
                start write transaction "Export ":table
                ASSIGN 'table'.'mod_field' = NOW
                UPDATE 'table'
                COMMIT
            ENDIF
            i = i + 1
        ENDWHILE
    ENDIF

    msg =  (ASCII(10):
            "Exported '":TOUPPER(table):"'":ASCII(10):
            GetArray(records):ASCII(10):ASCII(10):
            "to ":file_name)
    fm(msg)
 
ENDROUTINE



ROUTINE ExportChildTable (VALUE table, select_array, VALUE file_name) 
{*************************************************************************
* Purpose       : Exporting child records for table
* Parameters    : VALUE table       - parent table
                  select_array      - select array from parent table
                  file_name         - filename used in this transaction
* Return Value  : None
*************************************************************************}
    DECLARE flash_status, default_path, list_of_fields, r, status, return_message
    
    flash_status = FALSE
    default_path = STRIP(SELECT destination_cpu.system_path WHERE identity = GLOBAL("AUTO_COMMIT_DEFAULT_DEST")):"\CSV\":table
    ARRAY list_of_fields
    
    IF (table = "SAMP_TMPL_HEADER") OR 
       (table = "JOB_TEMPLATE") THEN
        table = "TEMPLATE_FIELDS"
        get_field_names_without_aliases ( table, list_of_fields )
        r = 1
        WHILE r <= size_of_array(select_array)
            IF select_array[r, 2] = "IDENTITY" THEN
                select_array[r, 2] = "TEMPLATE_ID"
            ENDIF
            r = r + 1
        ENDWHILE
        IF (table = "SAMP_TMPL_HEADER") THEN
            array_select_add(select_array, ARRAY_SELECT_AND, EMPTY, EMPTY)
            array_select_add(select_array, ARRAY_SELECT_EQ, "TABLE_NAME", "SAMPLE")
        ELSEIF (table = "JOB_TEMPLATE") THEN
            array_select_add(select_array, ARRAY_SELECT_AND, EMPTY, EMPTY)
            array_select_add(select_array, ARRAY_SELECT_EQ, "TABLE_NAME", "JOB_HEADER")
        ENDIF
        spawn "md ":default_path:"\":table, status QUIETLY
        output_csv_file ( default_path:"\":table:"\":file_name, table, list_of_fields, select_array, flash_status, return_message )
    ELSEIF table = "TEST_SCHED_HEADER" THEN
        table = "TEST_SCHED_ENTRY"
        get_field_names_without_aliases ( table, list_of_fields )
        spawn "md ":default_path:"\":table, status QUIETLY
        output_csv_file ( default_path:"\":table:"\":file_name, table, list_of_fields, select_array, flash_status, return_message )
    ELSEIF table = "PHRASE_HEADER" THEN
        table = "PHRASE"
        get_field_names_without_aliases ( table, list_of_fields )
        r = 1
        WHILE r <= size_of_array(select_array)
            IF select_array[r, 2] = "IDENTITY" THEN
                select_array[r, 2] = "PHRASE_ID"
            ENDIF
            r = r + 1
        ENDWHILE
        spawn "md ":default_path:"\":table, status QUIETLY
        output_csv_file ( default_path:"\":table:"\":file_name, table, list_of_fields, select_array, flash_status, return_message )
    ENDIF
    
ENDROUTINE


GLOBAL ROUTINE import_data ( rmb_object, object , collection )
{*************************************************************************
* Purpose       : Explorer RMB callback routine for exporting data
* Parameters    : rmb_object, object , collection
* Return Value  : None
    rmb_object  EXPLORER_RMB        - E:\Program Files (x86)\Thermo\SampleManager\11.1\Report\$explorer_rmb.rpf
    object      STD_OBJECT_RECORD   - Programmers_Guide.chm
    collection  STD_OBJECT_DATABASE - Programmers_Guide.chm
*************************************************************************}
    DECLARE table, overwrite_mode, allowed_to_prompt, transaction_size, flash_status,
            start, id, identities, ArrKey0, id_field
            
    ARRAY identities        
    ARRAY ArrKey0
    
    table = rmb_object.table
    

    DECLARE form, file_prompt, csv_file {, csv_line, check_ok, trancheck }

    csv_file = ""

    CREATE OBJECT "STD_FORM", form

    form.header = "SELECT file to import  ..."
    form.width  = 50
    form.height = 5
    form.row    = 2
    form.column = 5

    PROMPT OBJECT file_prompt
        AT 10, 1
        BROWSE ON FILE
        WITH (file_extension = "csv",
              file_directory = LOGICAL("smp$install"):"\CSV\":table)

{
    CREATE OBJECT "STD_PROMPT_FILE", file_prompt

    file_prompt.row      = 1
    file_prompt.column   = 10
    file_prompt.client_file = TRUE
    file_prompt.file_extension = "csv"
    file_prompt.file_directory = default_path
}

    form.add_prompt( file_prompt )

    form.add_display ( "File:", 1, 1, PROMPT_RENDITION_BOLD )

    form.start_prompt( )
    form.wait_prompt( )
    form.end_prompt( )

    csv_file = file_prompt.value
    
    IF NOT(BLANK(csv_file)) THEN
        start               = NOW
        overwrite_mode      = OVERWRITE_TABLE
        allowed_to_prompt   = FALSE
        transaction_size    = 0
        flash_status        = FALSE
        input_csv_file(csv_file, overwrite_mode, allowed_to_prompt, transaction_size, flash_status)
        

        GET_TABLE_DETAILS 'table', "KEY0_FIELD", ArrKey0
        id_field = ArrKey0[1]
        id = SELECT 'table'.'id_field' WHERE modified_on >= start AND modified_by = OPERATOR ORDER ON 'id_field'
        WHILE id <> EMPTY
            identities[size_of_array(identities) + 1] = id
        NEXT 'table'
            id = SELECT 'table'.'id_field'
        ENDWHILE
        
        IF size_of_array(identities) > 0 THEN
            ImportChildTable(identities, csv_file, table)
            FILE DELETE csv_file
            fm("Updated ":table:ASCII(10):
               GetArray(identities))
        ELSE
            fm("No updates from":ASCII(10):ASCII(10):
               csv_file)        
        ENDIF
    ENDIF             
                      
                      
ENDROUTINE


ROUTINE ImportChildTable (identities, VALUE csv_file, VALUE table)
{*************************************************************************
* Purpose       : Exporting child records for table
* Parameters    : identities       - identities updated in parent table
                  VALUE csv_file    - used to import datat for table
                  VALUE table       - parent table
* Return Value  : None
*************************************************************************}

DECLARE parent_table, file_directory, overwrite_mode, allowed_to_prompt, transaction_size, flash_status , key, field, id, i, status

    IF size_of_array(identities) = 0 THEN
        RETURN
    ENDIF
    
    parent_table        = table
    file_directory      = LOGICAL("smp$install"):"\CSV\":table:"\"
    csv_file            = STRIP(SUBSTRING(csv_file, LENGTH(file_directory) + 1, LENGTH(csv_file)))
    overwrite_mode      = OVERWRITE_TABLE
    allowed_to_prompt   = FALSE
    transaction_size    = 0
    flash_status        = FALSE
    
    IF (parent_table = "SAMP_TMPL_HEADER") OR
        (parent_table = "JOB_TEMPLATE") THEN
        table = "TEMPLATE_FIELDS"
        key   = "TEMPLATE_ID"
        field = "FIELD_NAME"
    ELSEIF parent_table = "TEST_SCHED_HEADER" THEN
        table = "TEST_SCHED_ENTRY"
        key   = "IDENTITY"
        field = "ANALYSIS_ID"
    ELSEIF table = "PHRASE_HEADER" THEN
        table = "PHRASE"
        key   = "IDENTITY"
        field = "PHRASE_ID"
    ELSE 
        RETURN
    ENDIF

    i = 1
    WHILE i <= size_of_array(identities)
        IF parent_table = "JOB_TEMPLATE" THEN
            id = SELECT 'table'.'field' FOR UPDATE WHERE 'key' = identities[i] AND table_name = "JOB_HEADER"
        ELSEIF parent_table = "SAMP_TMPL_HEADER" THEN
            id = SELECT 'table'.'field' FOR UPDATE WHERE 'key' = identities[i] AND table_name = "SAMPLE"
        ELSE
            id = SELECT 'table'.'field' FOR UPDATE WHERE 'key' = identities[i]
        ENDIF
        
        IF id <> EMPTY THEN
            START WRITE TRANSACTION "Delete '":table:"' for ":identities[i]
            WHILE id <> EMPTY
                DELETE 'table', status
                IF status <> EMPTY THEN
                    ROLLBACK
                    fm("Error during deletion of '":table:"' for ":identities[i]:ASCII(10):
                       "Retry the import of ":csv_file:ASCII(10):ASCII(10):
                       "Error code: ":status)
                    EXIT
                ENDIF
            NEXT 'table'
                IF parent_table = "SAMP_TMPL_HEADER" THEN
                    id = SELECT 'table'.'field' FOR UPDATE WHERE 'key' = identities[i] AND table_name = "SAMPLE"
                ELSE
                    id = SELECT 'table'.'field' FOR UPDATE WHERE 'key' = identities[i]
                ENDIF
            ENDWHILE
            COMMIT
        ENDIF

        i = i + 1
    ENDWHILE

    input_csv_file(file_directory:table:"\":csv_file, overwrite_mode, allowed_to_prompt, transaction_size, flash_status)
    FILE DELETE file_directory:table:"\":csv_file
    
ENDROUTINE

{*************************************************************************}

{*************************************************************************
* Purpose      : Writes to predefined log,
*                using WriteLog in $lib_utils
* Parameters   : Msg - what to write in log
* Return Value : N/A
**************************************************************************}
ROUTINE WriteToLog(VALUE Msg)

    WriteLog(Msg, global("current_library"))

ENDROUTINE

{*************************************************************************}

