{******************************************************************************
* Module Name   : EXPLORER_RMB
* Purpose       : Custom RMB functions for Explorer folders
*******************************************************************************}

SET NOTPROTECTED
SET NAME"DEFER/"
SET COMPILE_OPTION DECLARE
ENABLE WINDOWS

JOIN STANDARD_LIBRARY STD_ARRAY
JOIN STANDARD_LIBRARY STD_ARRAY_SELECT 
JOIN STANDARD_LIBRARY STD_PROMPT

JOIN LIBRARY $LIB_UTILS
JOIN LIBRARY TOOLBOX
JOIN LIBRARY $TABLE_LOAD_SAVE_LIB

GLOBAL ROUTINE prod_sched_label_rmb ( rmb_object, object , collection )
{*************************************************************************
* Purpose       : Explorer RMB callback routine for setting/adjusting
*                 label count for Login Schedule based on LOGIN_SCHEDULE_VIEW
* Parameters    : rmb_object, object , collection
* Return Value  : None

    rmb_object  EXPLORER_RMB        - E:\Program Files (x86)\Thermo\SampleManager\11.1\Report\$explorer_rmb.rpf
    object      STD_OBJECT_RECORD   - Programmers_Guide.chm
    collection  STD_OBJECT_DATABASE - Programmers_Guide.chm

*************************************************************************}
DECLARE records, table, ArrKey0, Key1, Key2, Key3, Key4, Key5, i, key, status
DECLARE prompt_title, msg_array, display_text, prompt_type, fld_name, do_browse, select_array, prompt_val, key_last_used

ARRAY msg_array
ARRAY select_array
ARRAY records 
ARRAY ArrKey0

    table = rmb_object.table
    GET_TABLE_DETAILS 'table', "KEY0_FIELD", ArrKey0

    Key1 = ArrKey0[1]
    Key2 = ArrKey0[2]
    Key3 = ArrKey0[3]
    Key4 = ArrKey0[4]
    Key5 = ArrKey0[5]
    
    collection.set_first()
    WHILE collection.current <> EMPTY DO
        i = size_of_array(records) + 1
        records[i, 1] = SELECT 'table'.'Key1' IN OBJECT collection.current
        records[i, 2] = SELECT 'table'.'Key2' IN OBJECT collection.current
        records[i, 3] = SELECT 'table'.'Key3' IN OBJECT collection.current
        records[i, 4] = SELECT 'table'.'Key4' IN OBJECT collection.current
        records[i, 5] = SELECT 'table'.'Key5' IN OBJECT collection.current
        collection.set_next()
    ENDWHILE

    IF size_of_array(records) > 0 THEN
    
        prompt_title = "Set label count ..."
        msg_array[1] = "Set label count to N for selected records"
        msg_array[2] = "   N: set to fixed number"
        msg_array[3] = "+N: increase with N"
        msg_array[4] = "- N: decrease with N"
        display_text = "Define N:"
        prompt_type  = "TEXT10"
        fld_name     = ""
        do_browse    = FALSE
        prompt_val   = ""

        key = prompt_user_msg (prompt_title, msg_array, display_text,
                         prompt_type , fld_name, do_browse, 
                         select_array, prompt_val, key_last_used)

        IF key AND NUMTEXT(prompt_val) THEN
            i = 1
            WHILE i <= size_of_array(records)
                status = SELECT prod_sched.product_name FOR UPDATE
                         WHERE product_name     = records[i, 1]
                           AND product_version  = records[i, 2]
                           AND inspection_type  = records[i, 3]
                           AND sampling_point   = records[i, 4]
                           AND group_id         = records[i, 5]
                IF status = records[i, 1] THEN
                    START WRITE TRANSACTION "Set label count"
                    IF INDEX("+-", LEFTSTRING(STRIP(prompt_val), 1)) > 0 THEN
                        ASSIGN prod_sched.label_count = SELECT prod_sched.label_count + NUMERIC(prompt_val)
                    ELSE
                        ASSIGN prod_sched.label_count = NUMERIC(prompt_val)
                    ENDIF
                    UPDATE prod_sched
                    COMMIT
                ELSE
                    ROLLBACK
                ENDIF
                i = i + 1
            ENDWHILE
        ENDIF
    ENDIF
    
ENDROUTINE

GLOBAL ROUTINE backup_data ( rmb_object, object , collection )
{*************************************************************************
* Purpose       : Explorer RMB callback routine for exporting data
                  To be used for single-table entities, like sample_point...
                  For entities using more tables, i.e. job and sample templates
                  the code must be adjusted for:
                  => ROUTINE ExportChildTable AND
                  => ROUTINE ImportChildTable 
                  in the sections  *** include child records ***
                
* Parameters    : rmb_object, object , collection
* Return Value  : None
    rmb_object  EXPLORER_RMB        - E:\Program Files (x86)\Thermo\SampleManager\11.1\Report\$explorer_rmb.rpf
    object      STD_OBJECT_RECORD   - Programmers_Guide.chm
    collection  STD_OBJECT_DATABASE - Programmers_Guide.chm
*************************************************************************}
DECLARE default_path

    default_path = LOGICAL("smp$install"):"\CSV_BACKUP"
    export_entity ( rmb_object, object , collection, default_path)
    
ENDROUTINE

GLOBAL ROUTINE export_data ( rmb_object, object , collection )
{*************************************************************************
* Purpose       : Explorer RMB callback routine for exporting data
                  To be used for single-table entities, like sample_point...
                  For entities using more tables, i.e. job and sample templates
                  the code must be adjusted for:
                  => ROUTINE ExportChildTable AND
                  => ROUTINE ImportChildTable 
                  in the sections  *** include child records ***
                
* Parameters    : rmb_object, object , collection
* Return Value  : None
    rmb_object  EXPLORER_RMB        - E:\Program Files (x86)\Thermo\SampleManager\11.1\Report\$explorer_rmb.rpf
    object      STD_OBJECT_RECORD   - Programmers_Guide.chm
    collection  STD_OBJECT_DATABASE - Programmers_Guide.chm
*************************************************************************}
DECLARE default_path

    default_path = STRIP(SELECT destination_cpu.system_path WHERE identity = GLOBAL("AUTO_COMMIT_DEFAULT_DEST")):"\CSV"
    export_entity ( rmb_object, object , collection, default_path)
    
ENDROUTINE

ROUTINE export_entity ( rmb_object, object , collection, default_path)
{*************************************************************************
* Purpose       : Explorer RMB callback routine for exporting data
                  To be used for single-table entities, like sample_point...
                  For entities using more tables, i.e. job and sample templates
                  the code must be adjusted for:
                  => ROUTINE ExportChildTable AND
                  => ROUTINE ImportChildTable 
                  in the sections  *** include child records ***
                
* Parameters    : rmb_object, object , collection
* Return Value  : None
    rmb_object  EXPLORER_RMB        - E:\Program Files (x86)\Thermo\SampleManager\11.1\Report\$explorer_rmb.rpf
    object      STD_OBJECT_RECORD   - Programmers_Guide.chm
    collection  STD_OBJECT_DATABASE - Programmers_Guide.chm
*************************************************************************}
DECLARE table, ArrKey0, mod_field, Key1, Key2, Key3, Key4, Key5, key_first, keep_first, keep_last, key_last, i, records, file_name, msg,
        r, select_array, list_of_fields, flash_status, return_message, {id, } status

ARRAY records 
ARRAY ArrKey0
ARRAY select_array
ARRAY list_of_fields

    table = rmb_object.table
    GET_TABLE_DETAILS 'table', "KEY0_FIELD", ArrKey0
    GET_TABLE_DETAILS 'table', "MODIFIED_ON_FIELD", mod_field

    Key1 = EMPTY
    Key2 = EMPTY
    Key3 = EMPTY
    Key4 = EMPTY
    Key5 = EMPTY
    
    Key1 = ArrKey0[1]
    IF size_of_array(ArrKey0) >= 2 THEN
        Key2 = ArrKey0[2]
    ENDIF    
    IF size_of_array(ArrKey0) >= 3 THEN
        Key3 = ArrKey0[3]
    ENDIF    
    IF size_of_array(ArrKey0) >= 4 THEN
        Key4 = ArrKey0[4]
    ENDIF    
    IF size_of_array(ArrKey0) >= 5 THEN
        Key5 = ArrKey0[5]
    ENDIF    

    collection.set_first()
    WHILE collection.current <> EMPTY DO
        i = size_of_array(records) + 1
        IF size_of_array(ArrKey0) >= 1 THEN
            records[i, 1] = SELECT 'table'.'Key1' IN OBJECT collection.current
        ENDIF    
        IF size_of_array(ArrKey0) >= 2 THEN
            records[i, 2] = SELECT 'table'.'Key2' IN OBJECT collection.current
        ENDIF    
        IF size_of_array(ArrKey0) >= 3 THEN
            records[i, 3] = SELECT 'table'.'Key3' IN OBJECT collection.current
        ENDIF    
        IF size_of_array(ArrKey0) >= 4 THEN
            records[i, 4] = SELECT 'table'.'Key4' IN OBJECT collection.current
       ENDIF    
        IF size_of_array(ArrKey0) >= 5 THEN
            records[i, 5] = SELECT 'table'.'Key5' IN OBJECT collection.current
        ENDIF    
        collection.set_next()
    ENDWHILE
    
    key_first = ""
    i = 1
    WHILE i <= size_of_array(ArrKey0)
        key_first = key_first:" ":STRIP(records[1, i])
        i = i + 1
    ENDWHILE
    
    key_last  = ""
    i = 1
    WHILE i <= size_of_array(ArrKey0)
        key_last  = key_last :" ":STRIP(records[size_of_array(records), i])
        i = i + 1
    ENDWHILE

    keep_first = STRIP(key_first)
    keep_last  = STRIP(key_last)
    IF (key_first <> key_last) THEN
        WHILE SUBSTRING(key_first, 1, 1) = SUBSTRING(key_last, 1, 1)
            IF SUBSTRING(key_first, 1, 1) = " " THEN
                keep_first = STRIP(key_first)
                keep_last  = STRIP(key_last)
            ENDIF
            IF SUBSTRING(key_first, 1, 1) = "-" THEN
                keep_last  = STRIP(SUBSTRING(key_last, 2, LENGTH(key_last)))
            ENDIF
            key_first = (SUBSTRING(key_first, 2, LENGTH(key_first)))
            key_last  = (SUBSTRING(key_last,  2, LENGTH(key_last )))
        ENDWHILE
    ENDIF    
    key_first = keep_first
    key_last  = STRIP(keep_last)

    r = 1
    WHILE r <= size_of_array(records)
            IF r = 1 THEN
                array_select_add(select_array, ARRAY_SELECT_PUSH, EMPTY, EMPTY)
            ELSEIF r > 1 THEN
                array_select_add(select_array, ARRAY_SELECT_OR, EMPTY, EMPTY)
            ENDIF
            i = 1
            WHILE i <= size_of_array(ArrKey0)
                IF i = 1 THEN
                    array_select_add(select_array, ARRAY_SELECT_PUSH, EMPTY, EMPTY)
                ELSEIF i > 1 THEN
                    array_select_add(select_array, ARRAY_SELECT_AND, EMPTY, EMPTY)
                ENDIF
                    array_select_add(select_array, ARRAY_SELECT_EQ, ArrKey0[i], records[r,i])
                IF i = size_of_array(ArrKey0) THEN
                    array_select_add(select_array, ARRAY_SELECT_POP,  EMPTY, EMPTY)
                ENDIF
                i = i + 1
            ENDWHILE    
            IF r = size_of_array(records) THEN
                array_select_add(select_array, ARRAY_SELECT_POP,  EMPTY, EMPTY)
            ENDIF
        r = r + 1
    ENDWHILE

    SET DATE FORMAT "YYYY-MM-DZ H24.MI"
        IF size_of_array(records) = 1 THEN
            file_name = NOW:" ":STRIP(OPERATOR):" [":SUBSTITUTE(STRIP(key_first), "\/:*?<>|":ASCII(34), ""):"].csv"
        ELSEIF size_of_array(records) > 1 THEN
            file_name = NOW:" ":STRIP(OPERATOR):" [":SUBSTITUTE(STRIP(key_first), "\/:*?<>|":ASCII(34), ""):" - ":
                                                     SUBSTITUTE(STRIP(key_last) , "\/:*?<>|":ASCII(34), ""):"].csv"
        ENDIF
    RESTORE DATE FORMAT
   
    get_field_names_without_aliases ( table, list_of_fields )
    flash_status    = FALSE
    SPAWN "md ":default_path:"\":table, status QUIETLY
    output_csv_file ( default_path:"\":table:"\":file_name, table, list_of_fields, select_array, flash_status, return_message )

    ExportChildTable(default_path, table, select_array, file_name)
{    
    IF mod_field <> EMPTY THEN
        i = 1
        WHILE i <= size_of_array(records)
            id = SELECT 'table'.'key1' FOR UPDATE WHERE 'key1' = records[i, 1]
            IF id = records[i, 1]
                start write transaction "Export ":table
                ASSIGN 'table'.'mod_field' = NOW
                UPDATE 'table'
                COMMIT
            ENDIF
            i = i + 1
        ENDWHILE
    ENDIF
 }
    msg =  (ASCII(10):
            "Exported '":TOUPPER(table):"'":ASCII(10):ASCII(10):
            GetArray(records):ASCII(10):ASCII(10):
            "to ":file_name)
    fm(msg)
 
ENDROUTINE



ROUTINE ExportChildTable (VALUE default_path, VALUE table, select_array, VALUE file_name) 
{*************************************************************************
* Purpose       : Exporting child records for table
* Parameters    : VALUE table       - parent table
                  select_array      - select array from parent table
                  file_name         - filename used in this transaction
* Return Value  : None
*************************************************************************}
    DECLARE flash_status, list_of_fields, r, status, return_message
    
    flash_status = FALSE
    default_path = default_path:"\":table
    ARRAY list_of_fields
    
    {*** include child records ***}
    
    IF (table = "SAMP_TMPL_HEADER") OR 
       (table = "JOB_TEMPLATE") THEN
        ARRAY list_of_fields
        table = "TEMPLATE_FIELDS"
        get_field_names_without_aliases ( table, list_of_fields )
        r = 1
        WHILE r <= size_of_array(select_array)
            IF select_array[r, 2] = "IDENTITY" THEN
                select_array[r, 2] = "TEMPLATE_ID"
            ENDIF
            r = r + 1
        ENDWHILE
        IF (table = "SAMP_TMPL_HEADER") THEN
            array_select_add(select_array, ARRAY_SELECT_AND, EMPTY, EMPTY)
            array_select_add(select_array, ARRAY_SELECT_EQ, "TABLE_NAME", "SAMPLE")
        ELSEIF (table = "JOB_TEMPLATE") THEN
            array_select_add(select_array, ARRAY_SELECT_AND, EMPTY, EMPTY)
            array_select_add(select_array, ARRAY_SELECT_EQ, "TABLE_NAME", "JOB_HEADER")
        ENDIF
        SPAWN "md ":default_path:"\":table, status QUIETLY
        output_csv_file ( default_path:"\":table:"\":file_name, table, list_of_fields, select_array, flash_status, return_message )
    ELSEIF table = "TEST_SCHED_HEADER" THEN
        ARRAY list_of_fields
        table = "TEST_SCHED_ENTRY"
        get_field_names_without_aliases ( table, list_of_fields )
        SPAWN "md ":default_path:"\":table, status QUIETLY
        output_csv_file ( default_path:"\":table:"\":file_name, table, list_of_fields, select_array, flash_status, return_message )
    ELSEIF table = "PHRASE_HEADER" THEN
        ARRAY list_of_fields
        table = "PHRASE"
        get_field_names_without_aliases ( table, list_of_fields )
        r = 1
        WHILE r <= size_of_array(select_array)
            IF select_array[r, 2] = "IDENTITY" THEN
                select_array[r, 2] = "PHRASE_TYPE"
            ENDIF
            r = r + 1
        ENDWHILE
        SPAWN "md ":default_path:"\":table, status QUIETLY
        output_csv_file ( default_path:"\":table:"\":file_name, table, list_of_fields, select_array, flash_status, return_message )
    ELSEIF table = "CRITERIA_SAVED" THEN
        r = 1
        WHILE r <= size_of_array(select_array)
            IF select_array[r, 2] = "IDENTITY" THEN
                select_array[r, 2] = "CRITERIA_SAVED"
            ENDIF
            r = r + 1
        ENDWHILE

        ARRAY list_of_fields
        table = "CRITERIA_VARIABLE"
        get_field_names_without_aliases ( table, list_of_fields )
        SPAWN "md ":default_path:"\":table, status QUIETLY
        output_csv_file ( default_path:"\":table:"\":file_name, table, list_of_fields, select_array, flash_status, return_message )

        ARRAY list_of_fields
        table = "CRITERIA_CONDITION"
        get_field_names_without_aliases ( table, list_of_fields )
        SPAWN "md ":default_path:"\":table, status QUIETLY
        output_csv_file ( default_path:"\":table:"\":file_name, table, list_of_fields, select_array, flash_status, return_message )

        ARRAY list_of_fields
        table = "CRITERIA_ORDER"
        get_field_names_without_aliases ( table, list_of_fields )
        SPAWN "md ":default_path:"\":table, status QUIETLY
        output_csv_file ( default_path:"\":table:"\":file_name, table, list_of_fields, select_array, flash_status, return_message )
    ELSEIF table = "MASTER_MENU" THEN
        ARRAY list_of_fields
        table = "ROLE_ENTRY"
        get_field_names_without_aliases ( table, list_of_fields )
        SPAWN "md ":default_path:"\":table, status QUIETLY
        output_csv_file ( default_path:"\":table:"\":file_name, table, list_of_fields, select_array, flash_status, return_message )
    ELSEIF table = "PERSONNEL" THEN
        table = "PASSWORD"
        ARRAY list_of_fields
        get_field_names_without_aliases ( table, list_of_fields )
        SPAWN "md ":default_path:"\":table, status QUIETLY
        output_csv_file ( default_path:"\":table:"\":file_name, table, list_of_fields, select_array, flash_status, return_message )

        r = 1
        WHILE r <= size_of_array(select_array)
            IF select_array[r, 2] = "IDENTITY" THEN
                select_array[r, 2] = "OPERATOR_ID"
            ENDIF
            r = r + 1
        ENDWHILE

        table = "GROUPLINK"
        ARRAY list_of_fields
        get_field_names_without_aliases ( table, list_of_fields )
        SPAWN "md ":default_path:"\":table, status QUIETLY
        output_csv_file ( default_path:"\":table:"\":file_name, table, list_of_fields, select_array, flash_status, return_message )

        table = "ROLE_ASSIGNMENT"
        ARRAY list_of_fields
        get_field_names_without_aliases ( table, list_of_fields )
        SPAWN "md ":default_path:"\":table, status QUIETLY
        output_csv_file ( default_path:"\":table:"\":file_name, table, list_of_fields, select_array, flash_status, return_message )
    ENDIF
    
ENDROUTINE


GLOBAL ROUTINE import_data ( rmb_object, object , collection )
{*************************************************************************
* Purpose       : Explorer RMB callback routine for exporting data
* Parameters    : rmb_object, object , collection
* Return Value  : None
    rmb_object  EXPLORER_RMB        - E:\Program Files (x86)\Thermo\SampleManager\11.1\Report\$explorer_rmb.rpf
    object      STD_OBJECT_RECORD   - Programmers_Guide.chm
    collection  STD_OBJECT_DATABASE - Programmers_Guide.chm
*************************************************************************}
    DECLARE default_path

    default_path = LOGICAL("smp$install"):"\CSV"
    import_entity ( rmb_object, object , collection , default_path)
    
ENDROUTINE

GLOBAL ROUTINE restore_data ( rmb_object, object , collection )
{*************************************************************************
* Purpose       : Explorer RMB callback routine for exporting data
* Parameters    : rmb_object, object , collection
* Return Value  : None
    rmb_object  EXPLORER_RMB        - E:\Program Files (x86)\Thermo\SampleManager\11.1\Report\$explorer_rmb.rpf
    object      STD_OBJECT_RECORD   - Programmers_Guide.chm
    collection  STD_OBJECT_DATABASE - Programmers_Guide.chm
*************************************************************************}
    DECLARE default_path

    default_path = LOGICAL("smp$install"):"\CSV_BACKUP"
    import_entity ( rmb_object, object , collection , default_path)
    
ENDROUTINE

ROUTINE import_entity ( rmb_object, object , collection, default_path)
{*************************************************************************
* Purpose       : Explorer RMB callback routine for exporting data
* Parameters    : rmb_object, object , collection
* Return Value  : None
    rmb_object  EXPLORER_RMB        - E:\Program Files (x86)\Thermo\SampleManager\11.1\Report\$explorer_rmb.rpf
    object      STD_OBJECT_RECORD   - Programmers_Guide.chm
    collection  STD_OBJECT_DATABASE - Programmers_Guide.chm
*************************************************************************}
    DECLARE table, overwrite_mode, allowed_to_prompt, transaction_size, flash_status,
            start, id, k, i, identities, ArrKey0, id_field, form, file_prompt, csv_file, status
            
    ARRAY identities        
    ARRAY ArrKey0
    
    table = rmb_object.table
    
    csv_file = ""
    

    SPAWN "SUBST I: ":default_path, status QUIETLY
    WHILE status <> EMPTY
        SLEEP FOR INTERVAL("   0 00:00:01")
        SPAWN "SUBST I: ":default_path, status QUIETLY
    ENDWHILE

    CREATE OBJECT "STD_FORM", form

    form.header = "SELECT file to import  ..."
    form.width  = 50
    form.height = 5
    form.row    = 2
    form.column = 5

    PROMPT OBJECT file_prompt
        AT 10, 1
        BROWSE ON FILE
        WITH (file_extension = "csv",
              file_directory = "I:\":table)

    form.add_prompt( file_prompt )
    form.add_display ( "File:", 1, 1, PROMPT_RENDITION_BOLD )
    form.start_prompt( )
    form.wait_prompt( )
    form.end_prompt( )

    csv_file = file_prompt.value
    
    IF NOT(BLANK(csv_file)) THEN
        start               = NOW
        overwrite_mode      = OVERWRITE_TABLE
        allowed_to_prompt   = FALSE
        transaction_size    = 0
        flash_status        = FALSE
        WriteImport("Import: ":csv_file)
        input_csv_file(csv_file, overwrite_mode, allowed_to_prompt, transaction_size, flash_status)
        

        GET_TABLE_DETAILS 'table', "KEY0_FIELD", ArrKey0
        k = 1
        WHILE k <= size_of_array(ArrKey0)
            id_field = ArrKey0[k]
            i = 1
            id = SELECT 'table'.'id_field' WHERE modified_on >= start AND modified_by = OPERATOR ORDER ON 'id_field'
            WHILE id <> EMPTY
                identities[i, k] = id
            NEXT 'table'
                i = i + 1
                id = SELECT 'table'.'id_field'
            ENDWHILE
            k = k + 1
        ENDWHILE    
        
        IF size_of_array(identities) > 0 THEN
            ImportChildTable(identities, csv_file, table, default_path)
            fm("Imported to ":table:ASCII(10):ASCII(10):
                        GetArray(identities):ASCII(10):ASCII(10):
               "from: ":ASCII(10):
               SUBSTITUTE(SUBSTRING(csv_file, 3, LENGTH(csv_file)), "\", ASCII(10)))
            WriteImport("Updated:":ASCII(10):
                        GetArray(identities):ASCII(10))   
        ELSE
            fm("No updates from":ASCII(10):ASCII(10):
               csv_file)
            WriteImport("No updates.":ASCII(10))   
        ENDIF
        SPAWN "del ":ASCII(34):csv_file:ASCII(34):" /S", status QUIETLY
    ENDIF             
                      
    SPAWN "SUBST I: /D", status QUIETLY

ENDROUTINE


ROUTINE ImportChildTable (identities, VALUE csv_file, VALUE table, VALUE default_path)
{*************************************************************************
* Purpose       : Exporting child records for table
* Parameters    : identities       - identities updated in parent table
                  VALUE csv_file    - used to import datat for table
                  VALUE table       - parent table
* Return Value  : None
*************************************************************************}

DECLARE parent_table, file_directory, overwrite_mode, allowed_to_prompt, transaction_size, flash_status , key, field

    IF size_of_array(identities) = 0 THEN
        RETURN
    ENDIF
    
    parent_table        = table
    file_directory      = default_path:"\":parent_table:"\"
    csv_file            = STRIP(SUBSTRING(csv_file, INDEX(csv_file, parent_table) + LENGTH(parent_table) + 1, LENGTH(csv_file)))
    IF NOT FILE EXISTS (file_directory:csv_file) THEN
        fm("File not found: '":file_directory:csv_file:"'" )
        EXIT
    ENDIF
    overwrite_mode      = OVERWRITE_TABLE
    allowed_to_prompt   = FALSE
    transaction_size    = 0
    flash_status        = FALSE
    
    {*** include child records ***}
    
    IF (parent_table = "SAMP_TMPL_HEADER") OR
        (parent_table = "JOB_TEMPLATE") THEN

        table = "TEMPLATE_FIELDS"
        key   = "TEMPLATE_ID"
        field = "FIELD_NAME"
        WriteImport(file_directory:table:"\":csv_file)
        DeleteChildRecords(table, key, field, identities, parent_table, csv_file, default_path)
        input_csv_file(file_directory:table:"\":csv_file, overwrite_mode, allowed_to_prompt, transaction_size, flash_status)

    ELSEIF parent_table = "TEST_SCHED_HEADER" THEN

        table = "TEST_SCHED_ENTRY"
        key   = "IDENTITY"
        field = "ANALYSIS_ID"
        WriteImport(file_directory:table:"\":csv_file)
        DeleteChildRecords(table, key, field, identities, parent_table, csv_file, default_path)
        input_csv_file(file_directory:table:"\":csv_file, overwrite_mode, allowed_to_prompt, transaction_size, flash_status)

    ELSEIF table = "PHRASE_HEADER" THEN

        table = "PHRASE"
        key   = "PHRASE_TYPE"
        field = "PHRASE_ID"
        WriteImport(file_directory:table:"\":csv_file)
        DeleteChildRecords(table, key, field, identities, parent_table, csv_file, default_path)
        input_csv_file(file_directory:table:"\":csv_file, overwrite_mode, allowed_to_prompt, transaction_size, flash_status)

    ELSEIF table = "CRITERIA_SAVED" THEN
    
        table = "CRITERIA_VARIABLE"
        key   = "CRITERIA_SAVED"
        field = "NAME"
        WriteImport(file_directory:table:"\":csv_file)
        DeleteChildRecords(table, key, field, identities, parent_table, csv_file, default_path)
        input_csv_file(file_directory:table:"\":csv_file, overwrite_mode, allowed_to_prompt, transaction_size, flash_status)

        table = "CRITERIA_CONDITION"
        key   = "CRITERIA_SAVED"
        field = "CRITERIA_FIELD"
        WriteImport(file_directory:table:"\":csv_file)
        DeleteChildRecords(table, key, field, identities, parent_table, csv_file, default_path)
        input_csv_file(file_directory:table:"\":csv_file, overwrite_mode, allowed_to_prompt, transaction_size, flash_status)

        table = "CRITERIA_ORDER"
        key   = "CRITERIA_SAVED"
        field = "FIELD_NAME"
        WriteImport(file_directory:table:"\":csv_file)
        DeleteChildRecords(table, key, field, identities, parent_table, csv_file, default_path)
        input_csv_file(file_directory:table:"\":csv_file, overwrite_mode, allowed_to_prompt, transaction_size, flash_status)

    ELSEIF table = "MASTER_MENU" THEN

        table = "ROLE_ENTRY"
        key   = "PROCEDURE_NUM"
        field = "ROLE_ID"
        WriteImport(file_directory:table:"\":csv_file)
        DeleteChildRecords(table, key, field, identities, parent_table, csv_file, default_path)
        input_csv_file(file_directory:table:"\":csv_file, overwrite_mode, allowed_to_prompt, transaction_size, flash_status)

    ELSEIF table = "PERSONNEL" THEN
    
        table = "PASSWORD"
        key   = "IDENTITY"
        field = "IDENTITY"
        WriteImport(file_directory:table:"\":csv_file)
        DeleteChildRecords(table, key, field, identities, parent_table, csv_file, default_path)
        input_csv_file(file_directory:table:"\":csv_file, overwrite_mode, allowed_to_prompt, transaction_size, flash_status)

        table = "GROUPLINK"
        key   = "OPERATOR_ID"
        field = "GROUP_ID"
        WriteImport(file_directory:table:"\":csv_file)
        DeleteChildRecords(table, key, field, identities, parent_table, csv_file, default_path)
        input_csv_file(file_directory:table:"\":csv_file, overwrite_mode, allowed_to_prompt, transaction_size, flash_status)

        table = "ROLE_ASSIGNMENT"
        key   = "OPERATOR_ID"
        field = "ROLE_ID"
        WriteImport(file_directory:table:"\":csv_file)
        DeleteChildRecords(table, key, field, identities, parent_table, csv_file, default_path)
        input_csv_file(file_directory:table:"\":csv_file, overwrite_mode, allowed_to_prompt, transaction_size, flash_status)

    ELSE 
        RETURN
    ENDIF

    
ENDROUTINE

{*************************************************************************}

{*************************************************************************
* Purpose      : Writes to predefined log,
*                using WriteLog in $lib_utils
* Parameters   : Msg - what to write in log
* Return Value : N/A
**************************************************************************}
ROUTINE DeleteChildRecords(VALUE table, VALUE key, VALUE field, identities, VALUE parent_table, VALUE csv_file, VALUE default_path)

DECLARE id, i, status

    i = 1
    WHILE i <= size_of_array(identities)
        IF parent_table = "JOB_TEMPLATE" THEN
            id = SELECT 'table'.'field' FOR UPDATE WHERE 'key' = identities[i, 1] AND table_name = "JOB_HEADER"
        ELSEIF parent_table = "SAMP_TMPL_HEADER" THEN
            id = SELECT 'table'.'field' FOR UPDATE WHERE 'key' = identities[i, 1] AND table_name = "SAMPLE"
        ELSEIF parent_table = "CRITERIA_SAVED" THEN
            id = SELECT 'table'.'field' FOR UPDATE WHERE 'key' = identities[i, 2] AND table_name =  identities[i, 1]
        ELSE
            id = SELECT 'table'.'field' FOR UPDATE WHERE 'key' = identities[i, 1]
        ENDIF
        
        IF id <> EMPTY THEN
            START WRITE TRANSACTION "Delete '":table:"' for ":identities[i, 1]
            WHILE id <> EMPTY
                SET GLOBAL "AUDITPROMPTSUPPRESS" TO TRUE
                DELETE 'table', status
                IF status <> EMPTY THEN
                    ROLLBACK
                    fm("Error during deletion of '":table:"' for ":identities[i, 1]:ASCII(10):
                       "Retry the import of ":csv_file:ASCII(10):ASCII(10):
                       "Error code: ":status)
                    EXIT
                ENDIF
            NEXT 'table'
                IF parent_table = "SAMP_TMPL_HEADER" THEN
                    id = SELECT 'table'.'field' FOR UPDATE WHERE 'key' = identities[i, 1] AND table_name = "SAMPLE"
                ELSEIF parent_table = "JOB_TEMPLATE" THEN
                    id = SELECT 'table'.'field' FOR UPDATE WHERE 'key' = identities[i, 1] AND table_name = "JOB_HEADER"
                ELSEIF parent_table = "CRITERIA_SAVED" THEN
                    id = SELECT 'table'.'field' FOR UPDATE WHERE 'key' = identities[i, 2] AND table_name =  identities[i, 1]
                ELSE
                    id = SELECT 'table'.'field' FOR UPDATE WHERE 'key' = identities[i, 1]
                ENDIF
            ENDWHILE
            COMMIT
            SET GLOBAL "AUDITPROMPTSUPPRESS" TO FALSE
        ENDIF

        i = i + 1
    ENDWHILE
    
    RETURN (TRUE)

ENDROUTINE

{*************************************************************************}

{*************************************************************************
* Purpose      : Writes to predefined log,
*                using WriteLog in $lib_utils
* Parameters   : Msg - what to write in log
* Return Value : N/A
**************************************************************************}
ROUTINE WriteToLog(VALUE Msg)

    WriteLog(Msg, global("current_library"))

ENDROUTINE

{*************************************************************************
* Purpose      : Writes to predefined log,
*                using WriteLog in $lib_utils
* Parameters   : Msg - what to write in log
* Return Value : N/A
**************************************************************************}
ROUTINE WriteImport(VALUE Msg)

    WriteLog(Msg, "IMPORT")

ENDROUTINE

{*************************************************************************}

