SET NAME "DEFER/"
ENABLE WINDOWS
SET COMPILE_OPTION DECLARE


JOIN STANDARD_LIBRARY STD_ARRAY_SELECT
JOIN STANDARD_LIBRARY STD_BLOCK

JOIN LIBRARY $LIB_UTILS
JOIN STANDARD_LIBRARY STD_UTILS
JOIN LIBRARY TOOLBOX

DECLARE keys, OrgId, grid_is_started, parm_mode, parm_type, current_format
ARRAY empty_arr

grid_is_started  = FALSE
parm_mode = "MODIFY"

init()
parm_type = EMPTY

save_parm_setup (        23, "501303           111", "M")
{
WHILE prompt_user("parm_types", "Enter Parameter Type", EMPTY, 
                   TRUE, "Enter Parameter Type:", empty_arr, 
                   parm_type, the_key) DO
   handle_parm_type ( parm_type )
ENDWHILE
}
SET FORMAT current_format


ROUTINE  init
WriteToLog("init")

   ARRAY browse_sel_arr
   ARRAY parm_values
   ARRAY sub_key_arr
   ARRAY table_fields

   IsNewVersion = FALSE
   values = 10
   sub_key_count = 0

   browse_sel_arr[ 1, 1] = ARRAY_SELECT_EQ
   browse_sel_arr[ 1, 2] = "PARM_TYPE"

   IF   GLOBAL("TERMTYPE") = "GUI"
   THEN gui = TRUE
   ELSE gui = FALSE
   ENDIF

   id_format = "9999999999"

   current_format = GLOBAL ("FORMAT_TEXT")
   SET FORMAT id_format

   aut_lev = select personnel.authority
             where  identity = OPERATOR
             and    removeflag = FALSE
   IF     (BLANK(aut_lev)) OR (aut_lev=EMPTY)
   THEN   flash_message("User ":strip(OPERATOR):" not known", TRUE)
          aut_lev = 1
   ELSEIF NOT NUMTEXT(aut_lev)
   THEN   flash_message("Warning: Authority level not numeric. ":
                        "Lowest authority level set", TRUE)
          aut_lev = 1
   ELSE   aut_lev_str = strip(aut_lev)
          aut_lev = NUMERIC( aut_lev )
   ENDIF

ENDROUTINE


ROUTINE  load_parm_def ( VALUE parm_type )
WriteToLog("load_parm_def")

   ARRAY parm_def
   ARRAY table_fields

   parm_defs = 0
   parm_id = select parm_def_fields.parm_id
             where  parm_type = parm_type
             order  on parm_id, order_num


   WHILE parm_id <> EMPTY DO

      parm_defs = parm_defs + 1
      parm_def[ parm_defs, 1] = parm_id
      parm_def[ parm_defs, 2] = select parm_def_fields.field_type
      parm_def[ parm_defs, 3] = select parm_def_fields.browse_object
      parm_def[ parm_defs, 4] = strip(select parm_def_fields.description)

      parm_aut = strip(select parm_def_fields.authority)

      IF  (BLANK(parm_aut)) OR (parm_aut=EMPTY) OR (NOT NUMTEXT(parm_aut))
      THEN parm_aut = 1
      ELSE parm_aut = NUMERIC( parm_aut )
      ENDIF
      parm_def[ parm_defs, 5] = parm_aut
{***AS1226 HBe 15-9-99}
      parm_def[ parm_defs, 6] = select parm_def_fields.browse_field
{***AE1226}
      NEXT parm_def_fields
      parm_id = select parm_def_fields.parm_id
   ENDWHILE

   increment_fld = "PARAMETER_ID"
   increment_tab = "PARM_SETUP_HEADER"

ENDROUTINE


ROUTINE expand_key_setup ( VALUE tab_name, keys, the_key, VALUE sub_key, sub_key_arr, sub_key_count )
WriteToLog("expand_key_setup")

ARRAY  tab_key_arr

    get_table_details 'tab_name', "KEY0_FIELD", tab_key_arr

    IF size_of_array(tab_key_arr) <> keys THEN
        keys = size_of_array(tab_key_arr)
        the_sub_key = select 'tab_name'.'tab_key_arr[2]' where 'tab_key_arr[1]' = the_key

        WHILE the_sub_key <> EMPTY DO
            sub_key_count = sub_key_count + 1
            sub_key_arr[sub_key_count, 1] = the_sub_key
            sub_key_arr[sub_key_count, 2] = EMPTY

            NEXT 'tab_name'

            the_sub_key = select 'tab_name'.'tab_key_arr[2]'

        ENDWHILE
   ELSE
        sub_key_count = 1
        sub_key_arr[1, 1] = strip(sub_key)
        sub_key_arr[1, 2] = EMPTY
   ENDIF

ENDROUTINE


GLOBAL ROUTINE  ext_parm_setup ( VALUE parm_type, VALUE id_key, VALUE sub_key, VALUE old_id_key, VALUE old_sub_key, VALUE operation )

    WriteToLog("ext_parm_setup(":parm_type:", ":id_key:", ":sub_key:", ":old_id_key:", ":old_sub_key:", ":operation:")")

    DECLARE  file_desc
    ARRAY    copy_keys

    grid_is_started = TRUE
    parm_mode= operation
    field_val = id_key

    tab_name = select parm_types.table_name where parm_type = parm_type

    IF (operation="MODIFY") AND (sub_key <> EMPTY) THEN
        found_sub_key = FALSE
        n = 0

        WHILE n < sub_key_count DO
                n = n + 1
                IF sub_key_arr[n, 1] = sub_key THEN
                    found_sub_key = TRUE
                ENDIF
        ENDWHILE

        IF NOT found_sub_key THEN
                sub_key_count = sub_key_count+1
                sub_key_arr[sub_key_count, 1] = strip(sub_key)
                sub_key_arr[sub_key_count, 2] = EMPTY
        ENDIF
    ENDIF

    IF (operation = "READ_FOR_MODIFY")  OR
      (operation = "READ_FOR_DISPLAY") OR
      (operation = "ADD"             ) OR
      (operation = "COPY"           ) THEN

      init()
      load_parm_def ( parm_type )
      table_fields[1] = id_key

      IF sub_key <> EMPTY THEN
            table_fields[2] = sub_key
            keys = 2
            sub_key_arr[1, 1] = strip(sub_key)
      ELSE
            keys = 1
      ENDIF

      sub_key_count = 0

      parms = 0
      parm_id = EMPTY

      IF operation = "COPY" THEN
        expand_key_setup ( tab_name, keys, old_id_key, old_sub_key, sub_key_arr, sub_key_count )
        IsNewVersion = TRUE
      ELSE
        IF NOT IsNewVersion THEN
            expand_key_setup ( tab_name, keys, id_key, sub_key, sub_key_arr, sub_key_count )
        ENDIF
      ENDIF

      next_sub_key = 0

      WHILE next_sub_key < sub_key_count DO
         next_sub_key = next_sub_key+1

        IF operation = "COPY" THEN
            copy_keys[1] = old_id_key
            copy_keys[2] = sub_key_arr[next_sub_key, 1]
            IsNewVersion = TRUE

            IF (old_sub_key <> EMPTY) AND (sub_key <> EMPTY) THEN
                save_sub_key = strip(sub_key)
            ELSE
                save_sub_key = sub_key_arr[next_sub_key, 1]
            ENDIF

            sub_key_arr[1, 1] = strip(sub_key)

            load_parm_values ( old_id_key, parms, parm_values, sub_key_arr[next_sub_key, 1] )

         ELSEIF (operation <> "ADD") THEN

                table_fields[2] = sub_key_arr[next_sub_key, 1]
                save_sub_key = sub_key_arr[next_sub_key, 1]

                IF NOT IsNewVersion THEN
    {       IF-statment removed by CONSULT-02 to allow data to be showed regardless of status}
    {               IF   get_parm_id ( parm_type, keys, table_fields, parm_id ) THEN }
                    load_parm_values ( IDKEY, parms, parm_values, sub_key_arr[next_sub_key, 1] )
                    sub_key_arr[next_sub_key, 2] = IDKEY{parm_id}

    {               ENDIF}
                ENDIF
         ELSE

            save_sub_key = EMPTY

         ENDIF

        ENDWHILE

    ENDIF

    IF (operation="MODIFY" ) OR (operation="DISPLAY") THEN

        ARRAY table_fields
        IF NOT IsNewVersion THEN
            param_id = PAD(STRIP(id_key), " ", 10) : JUSTIFY(PAD(STRIP(sub_key_arr[next_sub_key, 1]), " ", 10), "RIGHT")
            table_fields[1] = id_key
            table_fields[2] = sub_key
            new_id_key      = id_key
            new_sub_key     =  sub_key
        ELSE
            param_id = PAD(STRIP(old_id_key), " ", 10) : JUSTIFY(PAD(STRIP(old_sub_key), " ", 10), "RIGHT")
            table_fields[1] = old_id_key
            table_fields[2] = old_sub_key
            new_id_key      = id_key
            new_sub_key     =  sub_key

        ENDIF
            handle_parm_values ( param_id, keys, table_fields, old_id_key, old_sub_key, new_id_key, new_sub_key)

    ELSEIF operation = "SAVE" THEN
        param_id = PAD(STRIP(id_key), " ", 10) : JUSTIFY(PAD(STRIP(sub_key), " ", 10), "RIGHT")
        save_parm_setup( parms, PAD(STRIP(id_key), " ", 10) : JUSTIFY(PAD(STRIP(sub_key), " ", 10), "RIGHT"), parm_type )

    ELSEIF operation = "QUIT" THEN
        SET FORMAT current_format
        IsNewVersion = EMPTY
    ENDIF

ENDROUTINE  { Ext Parm Setup }


ROUTINE unpack_key_fields ( VALUE key_string, VALUE tab_name, key_id, sub_key )
WriteToLog("unpack_key_fields")

   ARRAY key_fields

   key_id = EMPTY
   sub_key = EMPTY

   IF key_string = EMPTY THEN
    return ( TRUE )
   ENDIF

   get_table_details 'tab_name', "KEY0_FIELD", key_fields

   keys = size_of_array ( key_fields )
   IF keys > 2 THEN
        flash_message("ERROR: Can not handle more than 2 key fields", TRUE)
        return ( FALSE )
   ENDIF

   key_len = LENGTH( key_string )
   used_len = 0

   key = 0
   WHILE (key < keys) AND (key >= 0) DO
        key = key + 1
        field_name = key_fields[key]
        get_field_details 'tab_name'.'field_name', "FIELD_SIZE", f_size

        IF key = 1 THEN
            key_id   = strip(substring( key_string, used_len+1, f_size ))
        ELSE
            sub_key = strip(substring( key_string, used_len+1, f_size ))
        ENDIF

        used_len = used_len + f_size

        IF used_len > key_len THEN
            flash_message("ERROR: Length of Key String is to short", TRUE)
            return ( FALSE )
        ENDIF
   ENDWHILE

   IF used_len <> key_len THEN
        flash_message("ERROR: Used Key Length:":strip(used_len):" is different from the Actual Key Length:":strip(key_len), TRUE)
        return ( FALSE )
   ENDIF

   RETURN ( TRUE )

ENDROUTINE  { Unpack Key Fields }


GLOBAL
ROUTINE ext_parm_setup_anal( VALUE anal_key, VALUE old_anal_key, VALUE operation )
WriteToLog("ext_parm_setup_anal")

IF unpack_key_fields( anal_key, "VERSIONED_ANALYSIS", the_key, the_sub_key) AND unpack_key_fields( old_anal_key, "VERSIONED_ANALYSIS", the_old_key, the_old_sub_key) THEN
    ext_parm_setup( "A", the_key, the_sub_key, the_old_key, the_old_sub_key, operation )
ENDIF

ENDROUTINE  { Ext Parm Setup Anal }


GLOBAL
ROUTINE ext_parm_setup_std( VALUE std_key, VALUE old_std_key, VALUE operation )
    old_sub_key =   select max standard_versions.version
                    where identity = old_std_key
WriteToLog("ext_parm_setup_std")

    ext_parm_setup( "S", std_key, "         1", old_std_key, old_sub_key, operation )

ENDROUTINE  { Ext Parm Setup Std }


GLOBAL
ROUTINE ext_parm_setup_std_ver( VALUE std_key, VALUE old_std_key, VALUE operation )
WriteToLog("ext_parm_setup_std_ver")

IF unpack_key_fields( std_key, "STANDARD_VERSIONS", the_key, the_sub_key)   AND
      unpack_key_fields( old_std_key, "STANDARD_VERSIONS", the_old_key, the_old_sub_key)
THEN    ext_parm_setup( "S", the_key, the_sub_key, the_old_key, the_old_sub_key, operation )

{**AS 1271 JDy 31/8/2000 Copy MLP Parameter Setup as well   }
    ARRAY  mlp_keys
    if  (operation = "SAVE") AND (old_std_key <> EMPTY) then
        mlp_keys[1] = the_key
        mlp_keys[2] = the_sub_key
        if not get_parm_id("M", 2, mlp_keys, mlp_parm_id)
        then mlp_keys[2] = the_old_sub_key
             if   get_parm_id("M", 2, mlp_keys, mlp_parm_id)
             then ext_parm_setup( "M", the_key, the_sub_key, the_old_key, the_old_sub_key, "COPY" )
                  ext_parm_setup( "M", the_key, the_sub_key, the_old_key, the_old_sub_key, "SAVE" )
             endif
        endif
    endif
{**AE 1271 JDy 31/8/2000    }
ENDIF

ENDROUTINE  { Ext Parm Setup Std Ver }


GLOBAL
ROUTINE ext_parm_setup_mlp( VALUE mlp_key, VALUE old_mlp_key, VALUE operation )
    WriteToLog("ext_parm_setup_mlp")

    ARRAY table_fields

    {**AS 2003R1}
    IF unpack_key_fields( mlp_key, "MLP_HEADER", the_key, the_sub_key)  AND 
       unpack_key_fields( old_mlp_key, "MLP_HEADER", the_old_key, the_old_sub_key) THEN
        ext_parm_setup( "M", the_key, the_sub_key, the_old_key, the_old_sub_key, operation )
    ELSE
        FLASH_MESSAGE("Error unpacking key information", TRUE)
    ENDIF

ENDROUTINE  { Ext Parm Setup Mlp }


ROUTINE  handle_parm_id ( VALUE parm_type, keys, key_array )
WriteToLog("handle_parm_id")

   parms = 0
{IF-statment removed by CONSULT-02 to allow data to be showed regardless of status}
{   IF   get_parm_id ( parm_type, keys, table_fields, parm_id ) THEN }
        load_parm_values ( parm_id, parms, parm_values, EMPTY )
        sub_key_arr[1, 2] = parm_id
{   ENDIF }

   handle_parm_values ( parm_id, keys, key_array, old_id_key, old_sub_key, new_id_key, new_sub_key  )

ENDROUTINE


ROUTINE  create_parm_id ( VALUE keys, table_fields, parm_id )
WriteToLog("create_parm_id")

      return ( TRUE )

ENDROUTINE


ROUTINE handle_parm_values ( VALUE parm_id, VALUE keys, key_arr, VALUE old_id_key, VALUE old_sub_key, VALUE new_id_key, VALUE new_sub_key)
WriteToLog("handle_parm_values")

   SET FORMAT "999999.99999"

   browse_sel_arr[ 1, 3] = parm_type

   CREATE OBJECT PROMPT_CLASS_GRID, parm_grid

   ARRAY parm_grid.user_info

   k = 1
   hdr_str = strip(key_arr[1])
   WHILE k < keys DO
      k = k+1
      hdr_str = hdr_str : "/" : strip(key_arr[k])
   ENDWHILE

   parm_grid.title_size_top = 1
   parm_grid.title_text_top [ 1, 1 ] = "Parameter"
   parm_grid.column_size [ 1 ] = 10

   v = 0
   WHILE v < values DO
      v = v + 1
      parm_grid.title_text_top [ v+1, 1 ] = "Value":strip(v)
      parm_grid.column_size [ v+1 ] = 10
   ENDWHILE

   parm_grid.title_separator_top = GRID_SEPARATOR_BOTH

   CREATE   OBJECT PROMPT_CLASS_FORM, get_parms

   wh = 15
   wr =  5
   wc =  4

   get_parms.height = wh

   get_parms.column   =  wc
   get_parms.width    =  GLOBAL("SCREEN_WIDTH")*1.5 {Modified for 2003R1}
   get_parms.row      =  wr
   get_parms.border   =  TRUE
   {get_parms.header   =  hdr_str : " Parameter Values"}
   {get_parms.header   =  "Parameter Values"}
   get_parms.header   =  "Parameter Values (":STRIP(new_id_key) : "/": STRIP(new_sub_key):")"
   get_parms.footer   =  "Press Insert/Remove Row / DO to accept " :
                         "/ Exit to quit"
   get_parms.button_style = FORM_BUTTON_NONE

   parm_grid.height  = get_parms.height
   parm_grid.column  = 1
   parm_grid.cell_columns = 1 + values
   parm_grid.enabled = TRUE
   parm_grid.display_cell_routine = "display_parm"
   parm_grid.prompt_cell_routine  = "prompt_parm"
   parm_grid.remove_routine = "delete_parm_row"
   parm_grid.insert_routine = "insert_parm_row"
{  parm_grid.check_move_routine = "check_parm_row"    }
   parm_grid.width = get_parms.width
   parm_grid.fixed_columns_left = 1
   parm_grid.current_column = 1
   parm_grid.current_row    = 1

   r = 0
   pr = 0
       WHILE pr < parms DO
            pr = pr+1
            c = 0
            chkval = parm_values[pr, c+1]

            IF  (chkval <> EMPTY) AND (NOT BLANK(parm_values[pr, 1])) THEN

                r = r+1
{                IF NOT IsNewVersion THEN}
                    IF ((parm_values[pr, values+2] = EMPTY) OR (key_arr[2] = parm_values[pr, values+2])) AND (parm_values[pr, values+3]) THEN
                        WHILE c < values + 1 DO
                            c = c+1
                            IF NOT BLANK(parm_values [ pr, c ]) THEN
                                parm_grid.user_info [ r, c ] = parm_values [ pr, c ]
                            ENDIF
                        ENDWHILE
                    ENDIF
                ELSE
                    WHILE c < values + 1 DO
                        c = c+1
                        IF NOT BLANK(parm_values [ pr, c ]) THEN
                            parm_grid.user_info [ r, c ] = parm_values [ pr, c ]
                        ENDIF
                    ENDWHILE
                ENDIF
{           ENDIF}
       ENDWHILE

       IF   r = 0
       THEN parm_grid.cell_rows = 1
       ELSE parm_grid.cell_rows = r
       ENDIF

   get_parms.add_prompt ( parm_grid )

   IF gui THEN
      gui_adjustments(get_parms, 4)
      add_button(get_parms, "INSERT", 3, 4, "insert_parm_row", "PARM_SETUP_N", "Insert")
      add_button(get_parms, "REMOVE", 4, 4, "delete_parm_row", "PARM_SETUP_N", "Remove")
   ENDIF

   get_parms.add_frame ( "", 1, 1, wh, get_parms.width )
   get_parms.prompt_id = GLOBAL ("CURRENT_LIBRARY") : "_PARM"
   get_parms.start_prompt()

   REPEAT

      get_parms.wait_prompt()

   UNTIL ( get_parms.get_lastkey () = "EXIT" ) OR
         ( get_parms.get_lastkey () = "DO"   )

{  Save parameter setup }
   IF get_parms.get_lastkey() = "DO" THEN

      p = 0
     WHILE p < parms DO
        p = p+1

        IF parm_values[p, values+2] = key_arr[2] THEN
            parm_values[p, values+3] = FALSE
        ENDIF

     ENDWHILE

      p = 0
{    parms = 0  .........}
      parms = 0
      WHILE p < parm_grid.cell_rows DO
         p = p +1
         IF (parm_grid.user_info [ p, 1 ] <> EMPTY) AND (NOT BLANK(parm_grid.user_info [ p, 1 ])) THEN
             parms = parms + 1
             parm_values [ parms, 1 ] = parm_grid.user_info [ p, 1 ]
             parm_values [ parms, values + 2 ] = key_arr[2]
             parm_values [ parms, values + 3 ] = TRUE
             c = 1
             WHILE c < parm_grid.cell_columns DO
                c = c + 1
                IF NOT BLANK(parm_grid.user_info[p, c]) THEN
                   parm_values [ parms, c ] = parm_grid.user_info[p, c]
                ELSE
                    parm_values [ parms, c ] = " "
                ENDIF
             ENDWHILE
         ENDIF
      ENDWHILE
{
      IF (NOT grid_is_started) THEN
        IF NOT IsNewVersion THEN
            IF NOT save_parm_setup ( parms, parm_id, parm_type ) THEN
               return ( FALSE )
            ENDIF
         ELSE
            IF NOT save_parm_setup ( parms, PAD(STRIP(old_id_key), " ", 10) : JUSTIFY(PAD(STRIP(old_sub_key), " ", 10), "RIGHT"), parm_type ) THEN
               return ( FALSE )
            ENDIF
         ENDIF
      ENDIF
}

   ENDIF          {  End Save }

   SET FORMAT id_format

   get_parms.end_prompt()

ENDROUTINE

ROUTINE  load_parm_values ( VALUE load_parm_id, parms, parm_values, VALUE sub_key )
WriteToLog("load_parm_values")


IF IsNewVersion THEN
    sub_key = old_sub_key
ENDIF

   p_id = select parm_setup.parm_id
          where  identity = load_parm_id
          and identity_version = sub_key
          order  on order_num

  SET FORMAT "999999.99999"

{    parms = 0 }
   WHILE p_id <> EMPTY DO
      parms = parms + 1
      parm_values [ parms, 1 ] = p_id
      v = 0
      WHILE v < values DO
         v = v + 1
         fld = "VAL" : strip(v)
         parm_values [ parms, v+1 ] = select parm_setup.'fld'
      ENDWHILE
       parm_values[parms, values+2] = sub_key
       parm_values[parms, values+3] = TRUE
      NEXT parm_setup
      p_id = select parm_setup.parm_id
   ENDWHILE

   SET FORMAT id_format

ENDROUTINE

ROUTINE  save_parm_setup ( VALUE parm_count, VALUE dummy_parm_id, VALUE parm_type )
DECLARE counter, sel_arr, sub_key_no
WriteToLog("save_parm_setup (":parm_count:", ":dummy_parm_id:", ":parm_type:")")
   ARRAY sel_arr

      IF NOT grid_is_started THEN
         START WRITE TRANSACTION "Save Setup"
      ENDIF

  sub_key_no = 0

  WHILE sub_key_no < sub_key_count DO
      sub_key_no = sub_key_no+1
      parm_id = sub_key_arr[sub_key_no, 2]

      IF parm_id = EMPTY THEN
          table_fields[2] = sub_key_arr[sub_key_no, 1]
         IF   NOT create_parm_id ( keys, table_fields, parm_id ) THEN
            return ( FALSE )
         ELSE
            sub_key_arr[sub_key_no, 2] = parm_id
         ENDIF
      ENDIF

    IF parm_id = EMPTY THEN
    parm_id = STRIP(LEFTSTRING(dummy_parm_id, INDEX(dummy_parm_id, " ")))
    sub_key_arr[sub_key_no, 2] = parm_id

    i = LENGTH(dummy_parm_id) - 1
    WHILE i > 0
        IF SUBSTRING(dummy_parm_id, i, 1 ) = " " THEN
            tmpval = SUBSTRING(dummy_parm_id, i, LENGTH(dummy_parm_id))
            sub_key_arr[sub_key_no, 1] = JUSTIFY(PAD(STRIP(tmpval), " ", 10), "RIGHT")
            i = 0
        ENDIF

        i = i - 1
    ENDWHILE


    ENDIF

{     Delete current Value Setup for this Parameter Id }
      block_del_v = "Delete Values"

      IF NOT block_init( block_del_v, "PARM_SETUP" ) THEN
         ROLLBACK       {  Out of WRITE TRANSACTION mode        }
         return ( FALSE )
      ENDIF

      sel_arr[1, 1] = ARRAY_SELECT_EQ
      sel_arr[1, 2] = "IDENTITY"
      sel_arr[1, 3] = parm_id
      sel_arr[2, 1] = ARRAY_SELECT_EQ
      sel_arr[2, 2] = "IDENTITY_VERSION"
      sel_arr[2, 3] = sub_key_arr[sub_key_no, 1]
      delete_block ( block_del_v, sel_arr )
      rc = block_row_update ( block_del_v )
      rc = block_row_release( block_del_v )

{     Store new setup   }
      block_values = "Insert Values"

      IF NOT block_init( block_values, "PARM_SETUP" ) THEN
         ROLLBACK       {  Out of WRITE TRANSACTION mode        }
         flash_message("Error: Could not initiate Values table", TRUE)
         return ( FALSE )
      ENDIF

      SET FORMAT "999999.99999"

   get_field_details parm_setup.identity, "FIELD_SIZE", f_size
   key_str = PAD(parm_id, " ", f_size)
   p = 0
   pv = 0

  WHILE pv < parm_count DO
      pv = pv +1

{BLOCK edited by CONSULT-02 to allow data to be saved with version}
      IF (parm_values[pv, values+3]) THEN {AND (parm_values[pv, values+2] = strip(sub_key_arr[sub_key_no, 1]))  THEN}
         p = p+1
         f_key_str = PAD(STRIP(key_str), " ", 10) : JUSTIFY(PAD(STRIP(sub_key_arr[sub_key_no, 1]), " ", 10), "RIGHT") : PAD(STRIP(parm_type), " ", 10): JUSTIFY(PAD(STRIP(p), " ", 10), "RIGHT")
         f_key_str = dummy_parm_id : PAD(STRIP(parm_type), " ", 10): JUSTIFY(PAD(STRIP(p), " ", 10), "RIGHT")

       IF block_row_create_last( block_values, f_key_str ) THEN
            rc = block_row_last ( block_values )
            rc = block_row_field_assign ( block_values, "PARM_ID", parm_values[pv, 1] )
            c = 1

            IF NOT grid_is_started THEN
                counter = parm_grid.cell_columns
            ELSE
                counter = values + 1
            ENDIF

            {WHILE c <= values DO}

            WHILE c < counter DO
                c = c + 1
                IF parm_values[pv, c] <> EMPTY THEN
                    rc = block_row_field_assign( block_values, "VAL":strip(c-1), parm_values[pv, c] )
                    WriteToLog("VAL":strip(c-1):", ":parm_values[pv, c])
                ELSE
                    rc = block_row_field_assign( block_values, "VAL":strip(c-1), "-" )
                    WriteToLog("VAL":strip(c-1):", ":" ")
                ENDIF
            ENDWHILE
         ELSE flash_message("Error: Could not create parameter", TRUE)
              rc = block_row_release ( block_values )
              ROLLBACK
              return ( FALSE )
         ENDIF

      ENDIF
{END BLOCK edited by CONSULT-02}
    ENDWHILE    { Parameter Count }

     rc = block_row_update  ( block_values )
     rc = block_row_release ( block_values )

  ENDWHILE      { Sub Key Count }

      SET FORMAT id_format

      IF (NOT grid_is_started) THEN
         COMMIT
      ENDIF

      return ( TRUE )

ENDROUTINE  { Save Setup }



ROUTINE  display_parm( self, VALUE cell_col, VALUE cell_row, window, 
                       VALUE col, VALUE row, VALUE cell_w, VALUE cell_h )
{WriteToLog("display_parm") }
   generic_display ( self, cell_col, cell_row, window, col, 
                     row, cell_w, cell_h, FALSE )

ENDROUTINE

ROUTINE  generic_display ( self, VALUE cell_col, VALUE cell_row, window, 
                           VALUE col, VALUE row, VALUE cell_w, VALUE cell_h, 
                           VALUE bold_on )
{WriteToLog("generic_display") }

   val = self.user_info [ cell_row, cell_col ]
   IF   (val = EMPTY) OR (BLANK(val))
   THEN val = pad( "", " ", cell_w )
   ELSE IF NUMTEXT(val) AND (NOT(GUI)) THEN
           val = strip(val)
           cut_decimals( val, TRUE )
           IF length(val) < cell_w THEN
              val = pad("", " ", cell_w-length(val)):val
           ENDIF
        ENDIF
        val = substring( val, 1, cell_w )
   ENDIF

   DISPLAY  val
            AT col, row
            BOLD = bold_on
            INVERSE = FALSE
            IN WINDOW window

ENDROUTINE


ROUTINE  prompt_parm ( self, VALUE cell_col, VALUE cell_row, window, 
                       VALUE col, VALUE row, VALUE cell_w, VALUE cell_h )
WriteToLog("prompt_parm(cell_col, cell_row, col, row, cell_w, cell_h)")
WriteToLog("prompt_parm(":cell_col:", ":cell_row:", ":col:", ":row:", ":cell_w:", ":cell_h:")")


    DECLARE browse_table, select_field, key_fields, c, sel_arr,
            browse_field, order_field, link_table, i, ana, ver, comp

    ARRAY key_fields
    ARRAY sel_arr
    ARRAY opt_list
    ARRAY relevant_fields
    generic_display ( self, cell_col, cell_row, window, col, row, cell_w, cell_h, TRUE  )

    old_parm = self.user_info [ cell_row, 1 ]
    parm_aut = TRUE
    IF   (old_parm <> EMPTY) AND (NOT BLANK(old_parm)) THEN 
        parm_lev = select parm_def_headers.authority
        where  parm_type = parm_type
        and    parm_id   = old_parm
        head_desc = select parm_def_headers.description
        IF   (parm_lev <> EMPTY) AND (NOT BLANK(parm_lev)) THEN 
            IF   NUMTEXT(parm_lev) THEN 
                IF   NUMERIC(parm_lev) > aut_lev THEN 
                    parm_aut = FALSE
                ENDIF
            ENDIF
        ENDIF
    ELSE 
        head_desc = EMPTY
    ENDIF

    IF     parm_mode = "DISPLAY" THEN
        IF cell_col = 1 THEN
            show_desc ( head_desc )
        ENDIF

        IF cell_col > 1 THEN
            IF get_parm_def( self.user_info[cell_row, 1], cell_col-1, def_row ) THEN
                val_desc = parm_def[ def_row, 4 ]
            ELSE
                val_desc = " "
            ENDIF
            show_desc ( val_desc )
        ENDIF
        no_prompt()
        unshow_desc()

    ELSEIF NOT parm_aut THEN  
        no_prompt()
    ELSEIF cell_col = 1 THEN   
        new_parm = old_parm
        show_desc ( head_desc )
        aut_lev_le = aut_lev - 1
        browse_sel_arr[ 2, 1] = ARRAY_SELECT_PUSH
        browse_sel_arr[ 3, 1] = ARRAY_SELECT_EQ
        browse_sel_arr[ 3, 2] = "AUTHORITY"
        browse_sel_arr[ 3, 3] = "NULL"
        browse_sel_arr[ 4, 1] = ARRAY_SELECT_OR
        browse_sel_arr[ 5, 1] = ARRAY_SELECT_LE
        browse_sel_arr[ 5, 2] = "AUTHORITY"
        browse_sel_arr[ 5, 3] = STRIP(aut_lev_le)
        browse_sel_arr[ 6, 1] = ARRAY_SELECT_OR
        browse_sel_arr[ 7, 1] = ARRAY_SELECT_EQ
        browse_sel_arr[ 7, 2] = "AUTHORITY"
        browse_sel_arr[ 7, 3] = aut_lev_str
        browse_sel_arr[ 8, 1] = ARRAY_SELECT_POP
        prompt for new_parm
            AT col, row
            IN WINDOW window
            TO col + cell_w - 1
            BOLD = TRUE
            BROWSE ON PARM_DEF_HEADERS
            WITH ( select_array = browse_sel_arr )
        IF    (BLANK(old_parm)) OR (old_parm = EMPTY) THEN   
            self.user_info [ cell_row, cell_col ] = new_parm
        ELSEIF (new_parm = EMPTY) OR (BLANK(new_parm)) THEN   
            new_parm = old_parm
        ELSEIF old_parm <> new_parm THEN   
            self.user_info [ cell_row, cell_col ] = new_parm
            v = 1
            WHILE v < values DO
                v = v + 1
                self.user_info [ cell_row, v ] = EMPTY
            ENDWHILE
            self.redisplay_row ( cell_row )
        ENDIF
        unshow_desc()
    ELSEIF get_parm_def( self.user_info[cell_row, 1], cell_col-1, def_row ) THEN   
        val_type = parm_def[ def_row, 2 ]
        val_desc = parm_def[ def_row, 4 ]
        val_auth = parm_def[ def_row, 5 ]

        show_desc ( val_desc )

        IF     val_auth > aut_lev THEN   
            no_prompt()
        ELSEIF NOT parm_aut THEN   
            no_prompt()
        ELSEIF val_type = "B" THEN
            browse_table = parm_def[ def_row, 3 ]
            select_field = parm_def[ def_row, 6 ]
            IF (browse_table = EMPTY) OR BLANK(browse_table) THEN
                fm("Error in parameter definition.":ASCII(10):
                   "No table defined for browse.")
                no_prompt()   
            ENDIF
            IF (select_field = EMPTY) OR BLANK(select_field) THEN
                GET_TABLE_DETAILS 'browse_table', "BROWSE_FIELD", select_field
                IF (select_field = EMPTY) THEN
                    fm("Error in 'structure.txt'.":ASCII(10):
                       "No 'primary_browse' defined for table '":browse_table:"'")
                    no_prompt()
                ENDIF
            ENDIF

            GET_TABLE_DETAILS 'browse_table', "KEY0_FIELD", key_fields
            GET_TABLE_DETAILS 'browse_table', "ORDER_FIELD", order_field

            link_table = EMPTY
            i = 1
            WHILE (i <= size_of_array(key_fields)) AND (link_table = EMPTY)
                GET_FIELD_DETAILS 'browse_table'.'key_fields[i]', "LINK_TABLE", link_table
                i = i + 1
            ENDWHILE

            c = 2
            ver = EMPTY
            WHILE (c < cell_col) AND (ver = EMPTY)
                IF (link_table = "VERSIONED_ANALYSIS") OR
                   (link_table = "VERSIONED_C_L_HEADER")THEN
                    ana = self.user_info[cell_row, c]
                    ver = SELECT max_active_anal_ver.max_version WHERE identity = ana
                    IF ver <> EMPTY THEN
                        array_select_add(sel_arr, ARRAY_SELECT_EQ, "ANALYSIS", ana)
                        array_select_add(sel_arr, ARRAY_SELECT_AND, EMPTY, EMPTY)
                        array_select_add(sel_arr, ARRAY_SELECT_EQ, "ANALYSIS_VERSION", ver)
                    ENDIF
                ELSEIF link_table = "MLP_HEADER" THEN
                    ana = self.user_info[cell_row, c]
                    ver = SELECT max_active_mlp_ver.max_version WHERE identity = ana
                    IF ver <> EMPTY THEN
                        array_select_add(sel_arr, ARRAY_SELECT_EQ, "IDENTITY", ana)
                        array_select_add(sel_arr, ARRAY_SELECT_AND, EMPTY, EMPTY)
                        array_select_add(sel_arr, ARRAY_SELECT_EQ, "PRODUCT_VERSION", ver)
                    ENDIF
                ENDIF
                c = c + 1
            ENDWHILE

            IF (ver <> EMPTY) AND (select_field = "COMP_LIST") THEN
                c = 2
                comp = EMPTY
                WHILE (c < cell_col) AND (comp = EMPTY) 
                    comp = SELECT versioned_component.name
                           WHERE analysis = ana
                             AND analysis_version = ver
                             AND name = self.user_info[cell_row, c]
                    IF (self.user_info[cell_row, c] = comp) THEN
                        c = cell_col
                    ENDIF
                    c = c + 1
                ENDWHILE
                IF comp <> EMPTY THEN
                    IF size_of_array(sel_arr) > 0 THEN
                        array_select_add(sel_arr, ARRAY_SELECT_AND, EMPTY, EMPTY)
                    ENDIF
                    array_select_add(sel_arr, ARRAY_SELECT_EQ, "NAME", comp)
                ENDIF    
            ENDIF

            IF order_field <> EMPTY THEN
                array_select_add(sel_arr, ARRAY_SELECT_ORDER, order_field, ARRAY_SELECT_ASCENDING)
            ENDIF
            PROMPT FOR self.user_info[ cell_row, cell_col ]
                AT col, row
                IN WINDOW window
                TO col + cell_w - 1
                BOLD = TRUE
                BROWSE ON 'browse_table'.'select_field'
                WITH (select_array = sel_arr)

{**************************************************************************************************************
            IF NOT ((parm_def[ def_row, 6 ] = "" ) OR 
                    (parm_def[ def_row, 6 ] = EMPTY) OR
                    BLANK(parm_def[ def_row, 6 ])) THEN
                selected_rows_only (browse_table, select_field, relevant_fields, keys, key_arr) 
                IF  SIZE_OF_ARRAY (relevant_fields) = 0 THEN
                    FLASH_MESSAGE("Nothing to choose from!", TRUE)
                    no_prompt()
                ELSE
                    prompt for self.user_info[ cell_row, cell_col ]
                        AT col, row
                        IN WINDOW window
                        TO col + cell_w - 1
                        BOLD = TRUE
                        CHOOSE OUTOF relevant_fields
                ENDIF
            ELSE
                IF  (parm_def[ def_row, 3 ] = EMPTY) OR (BLANK(parm_def[ def_row, 3 ])) THEN 
                    flash_message("Error in Parameter Definition. No table to browse on", TRUE)
                    no_prompt()
                ELSE
                    prompt for self.user_info[ cell_row, cell_col ]
                        AT col, row
                        IN WINDOW window
                        TO col + cell_w - 1
                        BOLD = TRUE
                        BROWSE ON 'parm_def[ def_row, 3 ]'
                ENDIF
            ENDIF
***************************************************************************************************************}

        ELSEIF val_type = "O" THEN
            opt = select phrase.phrase_id
                    WHERE  phrase_type = parm_def[ def_row, 3 ]
                    order  on order_num
            opts = 0
            WHILE opt <> EMPTY DO
                opts = opts + 1
                txt = select phrase.phrase_text
                opt_list [ opts, 1 ] = opt
                opt_list [ opts, 2 ] = txt
                opt_list [ opts, 3 ] = opt
            NEXT phrase
                opt = select phrase.phrase_id
            ENDWHILE
            opt = self.user_info [ cell_row, cell_col ]
            option_switch ( opts, opt_list, 1, 2, opt )
            prompt for opt
                AT col, row
                IN WINDOW window
                TO col + cell_w - 1
                BOLD = TRUE
                CHOOSE OUTOF opt_list
            option_switch ( opts, opt_list, 2, 1, opt )
            self.user_info [ cell_row, cell_col ] = opt
        ELSEIF val_type = "N" THEN
            prompt for self.user_info[ cell_row, cell_col ]
                AT col, row
                IN WINDOW window
                TO col + cell_w - 1
                BOLD = TRUE
                FORMAT REAL
        ELSEIF val_type = "T" THEN
            prompt for self.user_info[ cell_row, cell_col ]
                AT col, row
                IN WINDOW window
                TO col + cell_w - 1
                BOLD = TRUE
                FORMAT TEXT
        ELSEIF val_type = "L" THEN
            prompt for self.user_info[ cell_row, cell_col ]
                AT col, row
                IN WINDOW window
                TO col + cell_w - 1
                BOLD = TRUE
                FORMAT BOOLEAN
        ELSEIF val_type = "D" THEN
            IF (self.user_info[ cell_row, cell_col ] = EMPTY) OR
               (BLANK(self.user_info[ cell_row, cell_col ]))  THEN
                self.user_info[ cell_row, cell_col ] = TODAY
            ENDIF
            self.user_info[ cell_row, cell_col ] =
            STRIP(substring(self.user_info[ cell_row, cell_col ], 1, 11))
            prompt for self.user_info[ cell_row, cell_col ]
                AT col, row
                IN WINDOW window
                TO col + cell_w - 1
                BOLD = TRUE
                FORMAT DATE
        ELSE 
            flash_message("Type of value:":val_type:" unknown", TRUE)
        ENDIF
        unshow_desc()

    ELSE { self.set_position ( cell_row, 1 ) }
        no_prompt()
    ENDIF

    generic_display ( self, cell_col, cell_row, window, col, 
    row, cell_w, cell_h, FALSE )

ENDROUTINE


{**MS2003R1: Versions on analysis}
{***AS1226 HBe 15-9-99}

ROUTINE  selected_rows_only (VALUE browse_table, VALUE select_field, relevant_fields, VALUE keys, key_arr )
WriteToLog("selected rows only, ":browse_table:", ":select_field:"")

ARRAY all_field_names

GET_FIELD_NAMES (browse_table, all_field_names)
total_browse_fields = SIZE_OF_ARRAY (all_field_names)

browse_field = 1
one_found = FALSE
two_found = FALSE

IF keys = 1 THEN

   WHILE ((browse_field <= total_browse_fields) AND (NOT one_found)) DO

      GET_FIELD_DETAILS 'browse_table'.'all_field_names[browse_field, 1]', "LINK_TABLE", master_table

      IF (master_table = tab_name)
      THEN
         one_found = TRUE
         relevant_field_count = 0

            link_detail = select  'browse_table'.'select_field'
                          WHERE 'all_field_names[browse_field, 1]' = key_arr[1]
                          order on  'all_field_names[browse_field, 1]'

         WHILE ((link_detail <> EMPTY) AND (NOT BLANK(link_detail))) DO
            relevant_field_count = relevant_field_count + 1
            relevant_fields[relevant_field_count, 1] = strip(link_detail)
            relevant_fields[relevant_field_count, 2] = strip(link_detail)
            NEXT 'browse_table'
            link_detail = select  'browse_table'.'select_field'
         ENDWHILE
      ENDIF
   browse_field = browse_field + 1
   ENDWHILE


ELSEIF keys = 2 THEN

   field_one = EMPTY

   WHILE (browse_field <= total_browse_fields) AND  NOT( (one_found) AND ( two_found)) DO

      GET_FIELD_DETAILS 'browse_table'.'all_field_names[browse_field, 1]', "LINK_TABLE", master_table
      GET_FIELD_DETAILS 'browse_table'.'all_field_names[browse_field, 1]', "LINK_FIELD", master_field
      GET_FIELD_DETAILS 'browse_table'.'all_field_names[browse_field, 1]', "KEY0_FIELD", is_key

      IF (master_table = tab_name) AND is_key AND (NOT one_found)
      THEN
         one_found = TRUE
         field_one = master_field
         key1_record = browse_field
      ENDIF

      IF (master_table = tab_name) AND is_key AND (master_field <> field_one)
      THEN
         two_found = TRUE
         key2_record = browse_field
      ENDIF

      IF (one_found) AND (two_found) THEN
         relevant_field_count = 0
         link_detail = select  'browse_table'.'select_field'
                       WHERE 'all_field_names[key1_record, 1]' = key_arr[1]
                       AND   'all_field_names[key2_record, 1]' = key_arr[2]
                       order on  'all_field_names[browse_field, 1]'

         WHILE ((link_detail <> EMPTY) AND (NOT BLANK(link_detail))) DO
            relevant_field_count = relevant_field_count + 1
            relevant_fields[relevant_field_count, 1] = strip(link_detail)
            relevant_fields[relevant_field_count, 2] = strip(link_detail)
            NEXT 'browse_table'
            link_detail = select  'browse_table'.'select_field'
         ENDWHILE
      ENDIF
   browse_field = browse_field + 1
   ENDWHILE

ELSE
   FLASH_MESSAGE("Too many keys: " : keys : ", more than 2 keys is not supported", TRUE)
   RETURN(FALSE)
ENDIF

ENDROUTINE
{***AE1226}
{**ME2003R1}

{**MS HBe 30-5-00
ROUTINE  unshow_desc
   IF NOT gui THEN
      UNPASTE TEXT WINDOW val_win
   ENDIF
ENDROUTINE
}

ROUTINE  unshow_desc
WriteToLog("unshow_desc")
   UNPASTE TEXT WINDOW val_win
ENDROUTINE

{**ME HBe 30-5-00}

{**MS HBe 30-5-00
ROUTINE  show_desc ( VALUE val_desc )

   IF gui THEN
      return
   ENDIF

   IF   val_desc = EMPTY
   THEN val_l = 1
   ELSE val_l = length( val_desc ) + 1
   ENDIF

   val_win = "VAL_DESC"
   create text window val_win
          HEIGHT 1 WIDTH val_l
   PASTE TEXT WINDOW val_win AT wc, wr-2
   IF val_desc <> EMPTY THEN
      DISPLAY val_desc ON LINE 1 FROM 1 TO val_l IN WINDOW val_win
   ENDIF

ENDROUTINE
}

ROUTINE  show_desc ( VALUE val_desc )
WriteToLog("show_desc")

   IF   val_desc = EMPTY
   THEN val_l = 1
   ELSE val_l = length( val_desc ) + 1
   ENDIF

   val_win = "VAL_DESC"
   create text window val_win
          HEIGHT 1 WIDTH val_l
   PASTE TEXT WINDOW val_win AT wc, wr-2
   IF val_desc <> EMPTY THEN
      DISPLAY val_desc ON LINE 1 FROM 1 TO val_l IN WINDOW val_win
   ENDIF
ENDROUTINE

{**ME HBe 30-5-00}


ROUTINE  get_parm_def ( VALUE parm_id, VALUE parm_no, the_row )
WriteToLog("get_parm_def(":parm_id:", ":parm_no:", the_row)")
   r = 0
   the_row   = 0
   dont_stop = TRUE
   WHILE (r < parm_defs) AND (the_row=0) AND (dont_stop) DO
      r = r + 1
      IF parm_def [ r, 1 ] = parm_id THEN
         dont_stop = FALSE
         IF (r+parm_no-1 <= parm_defs) AND
            (parm_def[r+parm_no-1, 1] = parm_id) THEN
            the_row = r+parm_no-1
         ENDIF
      ENDIF
   ENDWHILE

   IF   the_row > 0
   THEN 
{    fm("get_parm_def(":parm_id:", ":parm_no:", ":the_row:") TRUE")
    WriteToLog("get_parm_def(":parm_id:", ":parm_no:", ":the_row:")")}
    return ( TRUE  )
   ELSE 
{    fm("get_parm_def(":parm_id:", ":parm_no:", ":the_row:")")
    WriteToLog("get_parm_def(":parm_id:", ":parm_no:", ":the_row:") FALSE")}
    return ( FALSE )
   ENDIF
ENDROUTINE

ROUTINE  insert_parm_row ( self )
WriteToLog("insert_parm_row")

   DECLARE  r, c

   IF   parm_mode = "DISPLAY"
   THEN return
   ENDIF

   r = parm_grid.cell_rows
   WHILE r > parm_grid.current_row DO
      c = 0
      WHILE c < parm_grid.cell_columns DO
         c = c + 1
         parm_grid.user_info [ r+1, c ] = parm_grid.user_info [ r, c ]
         parm_grid.user_info [ r, c ] = " "
      ENDWHILE
      r = r - 1
   ENDWHILE

   c = 0
   WHILE c < parm_grid.cell_columns DO
      c = c + 1
      parm_grid.user_info [ parm_grid.current_row+1, c ] = " "
   ENDWHILE


   parm_grid.insert_row( parm_grid.current_row, 1, GRID_SEPARATOR_NONE )
   parm_grid.redisplay_row ( parm_grid.current_row )

ENDROUTINE


ROUTINE  delete_parm_row ( self )
WriteToLog("delete_parm_row")

   DECLARE  r, c

   IF   parm_mode = "DISPLAY"
   THEN return
   ENDIF

   IF   parm_grid.cell_rows > 1
   THEN
      r = parm_grid.current_row
      WHILE r < parm_grid.cell_rows DO
         c = 0
         WHILE c < parm_grid.cell_columns DO
            c = c + 1
            parm_grid.user_info [ r, c ] = parm_grid.user_info [ r+1, c ]
         ENDWHILE
         r = r + 1
      ENDWHILE
   ELSE c = 0
        WHILE c < parm_grid.cell_columns DO
           c = c + 1
           parm_grid.user_info [ 1, c ] = ""
        ENDWHILE
   ENDIF

   IF parm_grid.current_row > 0 THEN
      parm_grid.remove_row( parm_grid.current_row )
   ENDIF

   IF parm_grid.cell_rows = 0 THEN
      parm_grid.insert_row( parm_grid.current_row, 1, GRID_SEPARATOR_NONE )
      parm_grid.current_row = 1
   ENDIF

   parm_grid.redisplay_row ( parm_grid.current_row )

ENDROUTINE


ROUTINE  no_prompt
WriteToLog("no_prompt")
   IF   NOT(gui)
   THEN getkey
   ELSE PROMPT IN WINDOW window ON LINE cell_row FROM cell_col
   ENDIF
ENDROUTINE

ROUTINE copy_sub_key ( VALUE old_key, VALUE new_key )
WriteToLog("copy_sub_key")

   if   (old_key <> EMPTY)  AND
    (new_key <> EMPTY)
   then  pv = 0
              while pv < parms do
    pv = pv+1
    if (parm_values[pv, values+3]) AND (parm_values[pv, values+2]=strip(old_key)) then
        parms = parms+1
        c=0
        while c<=values do
            c = c+1
            parm_values[parms, c] = parm_values[pv, c]
        endwhile
        parm_values[parms, values+3] = TRUE
        parm_values[parms, values+2] = strip(new_key)
    endif
              endwhile
   endif

ENDROUTINE

ROUTINE WriteToLog(VALUE Msg)
{*************************************************************************
* Purpose      : Writes to predefined log, 
*                using WriteLog in $lib_utils
* Parameters   : Msg - what to write in log
* Return Value : N/A
**************************************************************************}

    WriteLog(Msg, global("current_library"))

ENDROUTINE
