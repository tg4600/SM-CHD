  SET NAME "DEFER/"
ENABLE WINDOWS

JOIN STANDARD_LIBRARY STD_UTILS
JOIN STANDARD_LIBRARY STD_ARRAY_SELECT
JOIN STANDARD_LIBRARY STD_BLOCK
JOIN STANDARD_LIBRARY STD_PROMPT

JOIN LIBRARY $LIB_UTILS
JOIN LIBRARY $LINE_EDITOR
JOIN LIBRARY $LIST_GRID
JOIN LIBRARY $INSTALL_WINDOW
JOIN LIBRARY TOOLBOX

do_the_setup()

ROUTINE  init

ARRAY empty_arr

ARRAY table_names
ARRAY tab_arr
ARRAY in_ex
ARRAY the_tables        {  Tables actually used when printing   }
ARRAY the_tab_cols

ARRAY rep_col_arr       {  Column information   }
ARRAY rep_tab_arr       {  Table information    }
ARRAY rep_ord_arr       {  Ordering information }
ARRAY rep_filter_arr    {  Filtering information}

{AS1171 4-2-99 HBe}
ARRAY rights_arr
{AS1171 4-2-99 HBe}

ARRAY yes_no
ARRAY just_arr
ARRAY cond_arr
ARRAY clause_arr
ARRAY asc_desc

CONSTANT TEXT_WIDTH  = 30
CONSTANT DUMMY_TABLE = "CONFIG_HEADER"
CONSTANT DUMMY_FIELD = "IDENTITY"

{...
CONSTANT button_width      = 10
CONSTANT GUI_HEIGHT_DIFF   = 4
CONSTANT GUI_WIDTH_DIFF    = button_width + 3
CONSTANT BUTTON_FROM_FRAME = button_width
..}

{ rtX_pos are positions in rep_tab_arr array    }
CONSTANT rtn_pos = 1    {  Table Name                                   }
CONSTANT rtr_pos = 2    {  Row in rep_tab_arr this table links to       }
CONSTANT rtb_pos = 3    {  Block Array Name                             }
CONSTANT rtd_pos = 4    {  Link Direction LINK_MAST, LINK_UP or LINK_DOWN }
CONSTANT rtu_pos = 5    {  If 'Linked Up'                               }
CONSTANT rtl_pos = 6    {  If 'Linked Down'                             }
CONSTANT rtv_pos = 7    {  Link Level when using Link Down              }
CONSTANT rtp_pos = 8    {  Break on Table level Yes or No               }
CONSTANT rti_pos = 9    {  Number of Characters to indent               }
CONSTANT rto_pos = 10   {  Only first record Yes or No                  }
{AS1171 HBe 18-1-99}
CONSTANT rts_pos = 11   { Number of skipped lines between header and contents   }
{AE1171 HBe 18-1-99}
CONSTANT rtf_pos = 12   {  Number of fields                             }
CONSTANT LINK_DOWN = "Down"
CONSTANT LINK_UP   = "Up"
CONSTANT LINK_MAST = "Master"

{ rcX_pos are positions in rep_col_arr array    }
CONSTANT rcr_pos = 1    {  Row in rep_tab_arr to where this field belongs }
CONSTANT rcn_pos = 2    {  Field Name                                   }
CONSTANT rcp_pos = 3    {  Not used                                     }
CONSTANT rcl_pos = 3    {  Field length to print                        }
CONSTANT rco_pos = 4    {  Field order to print in                      }
CONSTANT rcw_pos = 5    {  Wrap or not                                  }
CONSTANT rch_pos = 6    {  Header text for this field                   }
CONSTANT rcs_pos = 7    {  Number of lines to skip after printing this field }
CONSTANT rca_pos = 8    {  If header is to be printed above the field   }
CONSTANT rcj_pos = 9    {  Justification Left, Right or Center          }
CONSTANT rcm_pos = 10   {  Printing format                              }
CONSTANT rca_no  = 10   {  Number of columns in this array              }

{ roX_pos are positions in rep_ord_arr array    }
CONSTANT ror_pos = 1    {  Row in rep_tab_arr                           }
CONSTANT ron_pos = 2    {  Number of columns                            }
CONSTANT roc_pos = 1    {  Internal positions : Field Name              }
CONSTANT roo_pos = 2    {                       Order numbering         }
CONSTANT roa_pos = 3    {                       Ascending or Descending }

{ ttX_pos are positions in the_tables array     }
CONSTANT ttr_pos = 1    {  Row number in rep_tab_arr                    }
CONSTANT ttt_pos = 2    {  Not used                                     }
CONSTANT tts_pos = 3    {  TRUE/FALSE if any skipped lines on this table}
CONSTANT ttn_pos = 4    {  Number of linked tables to this table        }
                        {  Each linked table is row number in the_tables}

{ rfX_pos are positions in rep_filter_arr array   }
CONSTANT rfr_pos = 1    {  Row number in rep_tab_arr                    }
CONSTANT rfn_pos = 2    {  Number of fields having conditions           }
CONSTANT rfn_off = 4    {  Off-set for each field information           }
                        {  1: AND/OR Clause                             }
                        {  2: Field name                                }
                        {  3: Filter operator                           }
                        {  4: Value                                     }

CONSTANT PROP_MODE = "property"
CONSTANT FILT_MODE = "filter"

{ cgX_pos are positions in report column grid array   }
CONSTANT cgf_pos = 1    {  Field Name                                   }
CONSTANT cgt_pos = 2    {  Field Type                                   }
CONSTANT cgl_pos = 3    {  Field Length when printing                   }
CONSTANT cgo_pos = 4    {  Order to print fields in                     }
CONSTANT cgw_pos = 5    {  Wrap                                         }
CONSTANT cgh_pos = 6    {  Header text                                  }
CONSTANT cgs_pos = 7    {  Number of lines to skip                      }
CONSTANT cga_pos = 8    {  Header above or not                          }
CONSTANT cgj_pos = 9    {  Justification Left/Right/Center              }
CONSTANT cgm_pos = 10   {  Format to use when printing                  }
CONSTANT cgc_no  = 10   {  Number of attributes                         }

{ ogX_pos are positions in order grid array   }
CONSTANT ogf_pos = 1    {  Field Name                                   }
CONSTANT ogo_pos = 2    {  Order number                                 }
CONSTANT oga_pos = 3    {  Ascending/Descending                         }

{ fgX_pos are positions in filter grid array   }
CONSTANT fgo_pos = 1    {  AND/OR Clause                                }
CONSTANT fgf_pos = 2    {  Field Name                                   }
CONSTANT fgc_pos = 3    {  Filter Condition                             }
CONSTANT fgv_pos = 4    {  Filter Value                                 }

CONSTANT ori_pos = 1
CONSTANT new_pos = 2

CONSTANT WIDTH_TEXT = "Width"
CONSTANT ORDER_TEXT = "Order"
CONSTANT LEVEL_TEXT = "Level"
CONSTANT SKIP_TEXT  = "Skip"

DECLARE  got_main_table

yes_no [ 1, 1 ] = "Yes"
yes_no [ 1, 2 ] = "Yes"
yes_no [ 2, 1 ] = "No"
yes_no [ 2, 2 ] = "No"

just_arr[ 1, 1 ] = "L"
just_arr[ 1, 2 ] = "Left"
just_arr[ 2, 1 ] = "R"
just_arr[ 2, 2 ] = "Right"
just_arr[ 3, 1 ] = "C"
just_arr[ 3, 2 ] = "Center"

IF   GLOBAL("TERMTYPE") = "GUI"
THEN gui = TRUE
ELSE gui = FALSE
ENDIF

   cond_arr [ 1, 1 ] = "="
   cond_arr [ 1, 2 ] = "Equal"
   cond_arr [ 1, 3 ] = ARRAY_SELECT_EQ
   cond_arr [ 2, 1 ] = ">="
   cond_arr [ 2, 2 ] = "Greater or Equal"
   cond_arr [ 2, 3 ] = ARRAY_SELECT_GE
   cond_arr [ 3, 1 ] = "<="
   cond_arr [ 3, 2 ] = "Less or Equal"
   cond_arr [ 3, 3 ] = ARRAY_SELECT_LE
   cond_arr [ 4, 1 ] = "!="
   cond_arr [ 4, 2 ] = "Not Equal"
   cond_arr [ 4, 3 ] = ARRAY_SELECT_NE
   cond_arr [ 5, 1 ] = "<"
   cond_arr [ 5, 2 ] = "Less Than"
   cond_arr [ 5, 3 ] = ARRAY_SELECT_LT
   cond_arr [ 6, 1 ] = ">"
   cond_arr [ 6, 2 ] = "Greater Than"
   cond_arr [ 6, 3 ] = ARRAY_SELECT_GT
   cond_arr [ 7, 1 ] = "Like"
   cond_arr [ 7, 2 ] = "Remember % sign"
   cond_arr [ 7, 3 ] = ARRAY_SELECT_LIKE
   cond_arr [ 8, 1 ] = "("
   cond_arr [ 8, 2 ] = "Push"
   cond_arr [ 8, 3 ] = ARRAY_SELECT_PUSH
   cond_arr [ 9, 1 ] = ")"
   cond_arr [ 9, 2 ] = "Pop"
   cond_arr [ 9, 3 ] = ARRAY_SELECT_POP
   CONSTANT CONDITIONS = 9


   clause_arr [ 1, 1 ] = "AND"
   clause_arr [ 1, 2 ] = "AND"
   clause_arr [ 1, 3 ] = ARRAY_SELECT_AND
   clause_arr [ 2, 1 ] = "OR"
   clause_arr [ 2, 2 ] = "OR"
   clause_arr [ 2, 3 ] = ARRAY_SELECT_OR
   clause_arr [ 3, 1 ] = ""
   clause_arr [ 3, 2 ] = ""
   clause_arr [ 3, 3 ] = ""

   asc_desc [ 1, 1 ] = "Ascending"
   asc_desc [ 1, 2 ] = "Char:A,B,C... Number:1,2,3... Date..."
   asc_desc [ 1, 3 ] = ARRAY_SELECT_ASCENDING
   asc_desc [ 2, 1 ] = "Descending"
   asc_desc [ 2, 2 ] = "Char:Z,Y,X... Number:9,8,7... Date..."
   asc_desc [ 2, 3 ] = ARRAY_SELECT_DESCENDING

ENDROUTINE  { Init }


ROUTINE  do_the_setup

   init()

   get_table_names ( table_names )

   set_up_list_grid_class ( )

   CREATE OBJECT PROMPT_CLASS_FORM, get_tab

   ww = 40
   wr = 5
   wc = 5
   wh = GLOBAL("SCREEN_HEIGHT") - wr - 2
   IF gui THEN
      wh = wh - GUI_HEIGHT_DIFF
   ENDIF

   report_id = EMPTY

   get_tab . height   =  wh
   get_tab . width    =  ww
   get_tab . row      =  wr
   get_tab . column   =  wc
   get_tab . border   =  TRUE
   get_tab . header   =  "Enter Main Table"
   get_tab . footer   =  "Press DO to select / Exit to quit"

   IF gui THEN

      gui_adjustments    ( get_tab, 3 )
      add_button ( get_tab, "SELECT", 3, 3,
"load_setup_main","AD-HOC-REPORTS","Load setup")

   ENDIF

   CREATE OBJECT "STD_LIST_GRID" , table_list_grid
   table_list_grid . select_list [ 1 ] = TRUE
   table_list_grid . maximum_select = 1
   table_list_grid . title_text_top [ 1, 1 ] = "Table Names"
   table_list_grid . height  = get_tab . height
   table_list_grid . width   = ww
   table_list_grid . column  = 1
   table_list_grid . current_row    = 1
   table_list_grid . current_column = 1
   table_list_grid . remove_routine = "do_nothing"
{  table_list_grid . select_routine = "do_nothing" }
   table_list_grid . select_routine = "load_setup_main"

   get_tab . add_prompt ( table_list_grid )

   tabs = size_of_array ( table_names )
   tab_no = 0
   WHILE tab_no < tabs DO
      tab_no = tab_no + 1
      table_list_grid . display_list [ tab_no ] = table_names [ tab_no, 1 ]
      table_names [ tab_no, 2 ] = table_names [ tab_no, 1 ]
   ENDWHILE

   get_tab . add_frame ( "" , 1 , 1 , tabs , get_tab . width )

   get_tab . start_prompt()

   first_entrance = TRUE

   REPEAT

      IF   first_entrance
      THEN first_entrance = FALSE
           IF   load_setup()
           THEN handle_table ( rep_tab_arr [ 1, rtn_pos ], TRUE )
           ENDIF
      ENDIF

      got_main_table = FALSE
      get_tab . wait_prompt()
      IF     got_main_table
      THEN   handle_table ( rep_tab_arr [ 1, rtn_pos ], TRUE )
      ELSEIF get_tab . get_lastkey () = "DO"
      THEN   handle_table ( table_names[table_list_grid.current_row,1], FALSE )
      ENDIF

   UNTIL ( get_tab . get_lastkey () = "EXIT" )

   get_tab . end_prompt()

ENDROUTINE  { Do The Setup }

ROUTINE  run_option ( VALUE option )

   init()

   report_id = EMPTY

   WHILE load_setup () DO
      WriteToLog(report_id)
      create_report()
   ENDWHILE

ENDROUTINE

ROUTINE  setup_option ( option )
   do_the_setup()
ENDROUTINE

ROUTINE  do_nothing ( self )
ENDROUTINE


ROUTINE  array_switch ( choose_array, VALUE col_in, VALUE val_in )
   DECLARE  s, r

   s = size_of_array ( choose_array )
   r = 0
   WHILE r < s DO
      r = r + 1
      IF choose_array[ r, col_in ] = val_in THEN
         IF   col_in = 1
         THEN return( choose_array[ r, 2 ] )
         ELSE return( choose_array[ r, 1 ] )
         ENDIF
      ENDIF
   ENDWHILE

   flash_message("ERROR: Could not find array value:":val_in,TRUE)
   return( val_in )

ENDROUTINE


{....
ROUTINE  gui_adjustments ( self, VALUE buttons )
   self . button_style = FORM_BUTTON_NONE
   self . width  = self . width  + GUI_WIDTH_DIFF
   add_button ( self, "DO"  , 1, buttons, EMPTY )
   add_button ( self, "EXIT", 2, buttons, EMPTY )
ENDROUTINE

ROUTINE  add_button ( self, VALUE action,
                            VALUE button_no, VALUE buttons,
                            VALUE routine_to_call )

   IF     action = "DO"
   THEN   capt_text = get_user_message("SMP_PROMPT_BUTTON_OK",1)
   ELSEIF action = "EXIT"
   THEN   capt_text = get_user_message("SMP_PROMPT_BUTTON_CANCEL",1)
   ELSEIF action = "SELECT"
   THEN   capt_text = get_user_message("SMP_PROMPT_BUTTON_SELECT",1)
   ELSEIF action = "REMOVE"
   THEN   capt_text = get_user_message("SMP_PROMPT_BUTTON_REMOVE",1)
   ELSE   capt_text = action
          flash_message("Warning: Action:":action:" not recognized",TRUE)
   ENDIF

[  pos = round((self.height/(buttons+1))*button_no) ]
   from_top = 2
   button_space = trunc((self.height-from_top)/buttons)
   IF   button_space = 0
   THEN button_space = 1
        from_top     = 1
   ENDIF
   pos = (button_space * (button_no-1)) + from_top

   IF   routine_to_call <> EMPTY
   THEN PROMPT OBJECT get_tab_button
            CLASS PROMPT_CLASS_BUTTON
            WITH ( caption = capt_text,
                   row     = pos,
                   column  = self . width - BUTTON_FROM_FRAME,
                   width   = button_width,
                   enabled = TRUE,
                   send_lastkey = action,
                   mouse_click_routine = routine_to_call)
   ELSE PROMPT OBJECT get_tab_button
            CLASS PROMPT_CLASS_BUTTON
            WITH ( caption = capt_text,
                   row     = pos,
                   column  = self . width - BUTTON_FROM_FRAME,
                   width   = button_width,
                   enabled = TRUE,
                   send_lastkey = action)
   ENDIF

   self . add_prompt ( get_tab_button )

ENDROUTINE
......}

ROUTINE  handle_table ( master_tab_name, VALUE is_loaded )

   ARRAY tab_opt

   IF NOT ( is_loaded ) THEN
      cols       = 0
      order_rows = 0
      title_text = ""
      print_head = "Yes"
      print_crit = "Yes"
{AS1171 HBe 26-1-99}
      top_indent     = 1
      top_text       = ""
      foot_indent    = 1
      foot_text      = "                     ****** END OF REPORT ******"
      print_rep_name = "Yes"
      exec_level     = 4
      mod_level      = 4
{AE1171 HBe 26-1-99}

{     master_tab_name = table_names [ self . current_row, 1 ] }
      report_tables = 1
      rep_tab_arr [ 1, rtn_pos ] = master_tab_name
      rep_tab_arr [ 1, rtr_pos ] = 0
      rep_tab_arr [ 1, rtb_pos ] = rep_tab_arr [ 1, rtn_pos ] : strip(1)
      rep_tab_arr [ 1, rtd_pos ] = LINK_MAST
      rep_tab_arr [ 1, rtu_pos ] = FALSE
      rep_tab_arr [ 1, rtl_pos ] = FALSE
      rep_tab_arr [ 1, rtv_pos ] = 0
      rep_tab_arr [ 1, rtp_pos ] = "No"
      rep_tab_arr [ 1, rti_pos ] = 0
      rep_tab_arr [ 1, rto_pos ] = "No"
      rep_tab_arr [ 1, rtf_pos ] = 0
{AS1171 HBe 28-1-99}
      rep_tab_arr [ 1, rts_pos ] = 0
{AS1171 HBe 28-1-99}
{     get_link_tables ( table_names )  }

      field_mode = PROP_MODE
      filters = 0
   ENDIF

   actual_table_no = 1

   REPEAT

      tab_opt [ 1, 1 ] = "*"
      tab_opt [ 1, 2 ] = "- Table Options " :
                         rep_tab_arr[actual_table_no,rtn_pos] : " -"
      tab_opt [ 2, 1 ] = "T"
      tab_opt [ 2, 2 ] = "Set Actual Table"
      tab_opt [ 2, 3 ] = "set_actual_tab"
      tab_opt [ 3, 1 ] = "A"
      tab_opt [ 3, 2 ] = "Field Attribute Setup"
      tab_opt [ 3, 3 ] = "field_attributes"
      tab_opt [ 4, 1 ] = "F"
      tab_opt [ 4, 2 ] = "Field Filter Setup"
      tab_opt [ 4, 3 ] = "field_filters"
      tab_opt [ 5, 1 ] = "O"
      tab_opt [ 5, 2 ] = "Order by"
      tab_opt [ 5, 3 ] = "order_by"
      tab_opt [ 6, 1 ] = "U"
      tab_opt [ 6, 2 ] = "Link Tables Up"
      tab_opt [ 6, 3 ] = "expand_tab_up"
      tab_opt [ 7, 1 ] = "D"
      tab_opt [ 7, 2 ] = "Link Tables Down"
      tab_opt [ 7, 3 ] = "expand_tab_down"
      tab_opt [ 8, 1 ] = "M"
      tab_opt [ 8, 2 ] = "Manually Link Down"
      tab_opt [ 8, 3 ] = "manual_link_down"
      tab_opt [ 9, 1 ] = "M"
      tab_opt [ 9, 2 ] = "Manually Link Up"
      tab_opt [ 9, 3 ] = "manual_link_up"
      tab_opt [10, 1 ] = "T"
      tab_opt [10, 2 ] = "Table  Attribute Setup"
      tab_opt [10, 3 ] = "table_attributes"
      tab_opt [11, 1 ] = "I"
      tab_opt [11, 2 ] = "Report AttrIbute Setup"
      tab_opt [11, 3 ] = "report_attributes"
      tab_opt [12, 1 ] = "L"
      tab_opt [12, 2 ] = "Load Report Setup"
      tab_opt [12, 3 ] = "load"
      tab_opt [13, 1 ] = "S"
      tab_opt [13, 2 ] = "Save Report Setup"
      tab_opt [13, 3 ] = "save"
      tab_opt [14, 1 ] = "D"
      tab_opt [14, 2 ] = "Delete Report Setup"
      tab_opt [14, 3 ] = "delete"
      tab_opt [15, 1 ] = "R"
      tab_opt [15, 2 ] = "Run Report (Ctrl-C to stop)"
      tab_opt [15, 3 ] = "run"
      tab_opt [16, 1 ] = "T"
      tab_opt [16, 2 ] = "File Transfer to PC"
      tab_opt [16, 3 ] = "file_transfer"

      IF NOT(gui) THEN
         tab_opt [17, 1 ] = "E"
         tab_opt [17, 2 ] = "Exit"
         tab_opt [17, 3 ] = "exit"
      ENDIF

      CHOOSE opt OUTOF tab_opt AT 30, 6

      IF LASTKEY = "EXIT" THEN
         opt = "exit"
      ENDIF

      IF opt <> "exit" THEN
         IF     opt = "set_actual_tab"
         THEN   get_actual_table ()
         ELSEIF opt = "field_attributes"
         THEN   column_attributes()
         ELSEIF opt = "field_filters"
         THEN   column_filters()
         ELSEIF opt = "order_by"
         THEN   order_setup()
         ELSEIF opt = "expand_tab_up"
         THEN   link_upwards()
         ELSEIF opt = "expand_tab_down"
         THEN   link_downwards()
         ELSEIF opt = "manual_link_down"
         THEN   manual_link( EMPTY, LINK_DOWN )
         ELSEIF opt = "manual_link_up"
         THEN   manual_link( EMPTY, LINK_UP )
         ELSEIF opt = "table_attributes"
         THEN   table_attributes()
         ELSEIF opt = "report_attributes"
{        THEN   prompt_user ( "text60", "Enter Report Title", EMPTY,
                               FALSE, title_text )   }
         THEN   report_attributes()
         ELSEIF opt = "load"
         THEN   load_setup()
         ELSEIF opt = "save"
         THEN   save_setup()
         ELSEIF opt = "delete"
         THEN   delete_setup()
         ELSEIF opt = "run"
         THEN   create_report ()
         ELSEIF opt = "file_transfer"
         THEN   rep_cat = "smp$textreports"
                def_ext = "RPT"
                CALL_ROUTINE "file_to_pc" USING rep_cat, def_ext
                              IN LIBRARY "filetopc"
         ELSE   flash_message("ERROR: Unknown option:":opt,TRUE)
         ENDIF
      ENDIF

   UNTIL (opt = "exit")

ENDROUTINE

ROUTINE  load_setup_main ( self )
   got_main_table = load_setup()
ENDROUTINE

ROUTINE  load_setup

   ARRAY ref_arr
   ARRAY key_arr
{AS1171 4-2-99 HBe}
   ARRAY rights_arr
{AE1171 4-2-99 HBe}


{AS-1171 4-2-99 HBe: array name changed and contents defined
   IF NOT (prompt_user("ad_rep_header","Load Report Id", EMPTY,
                        TRUE, "Enter Report ID:", empty_arr, report_id, l_key )) }

      rights_arr[1,1] = ARRAY_SELECT_LE
      rights_arr[1,2] = "EXEC_LEVEL"
      rights_arr[1,3] = (GLOBAL ( "CURRAUTH" ))

{AE1171 4-2-99 HBe}

   IF NOT (prompt_user("ad_rep_header","Load Report Id", EMPTY,
                        TRUE, "Enter Report ID:", rights_arr, report_id, l_key ))
   THEN RETURN ( FALSE )
   ENDIF

   IF   (report_id = EMPTY) OR (BLANK(report_id))
   THEN RETURN ( FALSE )
   ENDIF

   title_text = select ad_rep_header.description
                where  report_id = report_id
   print_head = boolean_to_text(select ad_rep_header.print_header)
   print_crit = boolean_to_text(select ad_rep_header.print_criterias)

{AS1171 HBe 26-1-99}
   top_indent     = select ad_rep_header.top_indent
   top_text       = select ad_rep_header.top_text
   foot_indent    = select ad_rep_header.foot_indent
   foot_text      = select ad_rep_header.foot_text
   print_rep_name = boolean_to_text(select ad_rep_header.print_rep_name)
   exec_level     = select ad_rep_header.exec_level
   mod_level      = select ad_rep_header.mod_level
{AE1171 HBe 26-1-99}


   order_number = select ad_rep_tables.order_number
                  where  report_id = report_id
                  order  on order_number

   report_tables = 0
   refs = 0
   filters = 0
   order_rows = 0

   WHILE order_number <> EMPTY DO

      link_dir   = select ad_rep_tables.link_direction

      IF     link_dir = "M"
      THEN   report_tables = 1
             rep_tab_arr [ 1, rtn_pos ] = select ad_rep_tables.table_name
             rep_tab_arr [ 1, rtr_pos ] = 0
             rep_tab_arr [ 1, rtb_pos ] = rep_tab_arr [ 1, rtn_pos ] : strip(1)
             rep_tab_arr [ 1, rtd_pos ] = LINK_MAST
             rep_tab_arr [ 1, rtu_pos ] = FALSE
             rep_tab_arr [ 1, rtl_pos ] = FALSE
             rep_tab_arr [ 1, rtv_pos ] = 0
             rep_tab_arr [ 1, rtp_pos ] = boolean_to_text(
                                          select ad_rep_tables.break_on )
             rep_tab_arr [ 1, rti_pos ] = select ad_rep_tables.indent
             rep_tab_arr [ 1, rto_pos ] = boolean_to_text(
                                       select ad_rep_tables.only_first_record)
{AS1171 HBe 28-1-99}
             rep_tab_arr [ 1, rts_pos ] = select ad_rep_tables.blanks
{AE1171 HBe 28-1-99}
             rep_tab_arr [ 1, rtf_pos ] = 0
             rep_tab_row = 1
      ELSE
         link_row = select ad_rep_tables.link_number
         link_dir = select ad_rep_tables.link_direction
         tab_name = select ad_rep_tables.table_name
         actual_table_no = ref_arr[link_row,1]
         IF   link_dir = "D"
         THEN IF NOT ( rep_tab_arr[actual_table_no,rtl_pos] ) THEN
                 link_downwards()
              ENDIF
              link_dir = LINK_DOWN
         ELSE IF NOT ( rep_tab_arr[actual_table_no,rtu_pos] ) THEN
                 link_upwards()
              ENDIF
              link_dir = LINK_UP
         ENDIF

         keys = 0

         key_no = select ad_rep_link_fields.order_no
                  where  report_id    = report_id
                  and    order_number = order_number
         WHILE key_no <> EMPTY DO
            keys = keys + 1
            key_arr[keys,1] = select ad_rep_link_fields.master_field_name
            key_arr[keys,2] = select ad_rep_link_fields.child_field_name
            NEXT ad_rep_link_fields
            key_no = select ad_rep_link_fields.order_no
         ENDWHILE

         rep_tab_row = 0
         rep_tab = 0
         WHILE (rep_tab < report_tables) AND (rep_tab_row = 0) DO
            rep_tab = rep_tab + 1
            IF (rep_tab_arr[rep_tab,rtr_pos] = actual_table_no) AND
               (rep_tab_arr[rep_tab,rtn_pos] = tab_name)        THEN
               IF rep_tab_arr[rep_tab,rtf_pos] = keys THEN
                  k = 0
                  all_match = TRUE
                  WHILE (k < keys) AND (all_match) DO
                     k = k+1
                     pos = rtf_pos + ((k-1)*2)
                     IF (rep_tab_arr[rep_tab,pos+1] <> key_arr[k,1]) OR
                        (rep_tab_arr[rep_tab,pos+2] <> key_arr[k,2])
                     THEN all_match = FALSE
                     ENDIF
                     IF all_match THEN
                        rep_tab_row = rep_tab
                     ENDIF
                  ENDWHILE
               ENDIF
            ENDIF
         ENDWHILE
         IF rep_tab_row = 0 THEN

{           Manually specified link supposed                    }
{...        flash_message("Error: Could not find match for order:":
                           strip(order_number),TRUE)
            return ( FALSE )  ...}

            k = 0
            WHILE k<keys DO
               k = k+1
               add_link_field( tab_name, ref_arr[link_row,1], link_dir,
                               key_arr[k,2],
                               EMPTY, "M", key_arr[k,1] )
            ENDWHILE
            rep_tab_row = report_tables

         ENDIF

         rep_tab_arr [ rep_tab_row, rtp_pos ] =
            boolean_to_text( select ad_rep_tables.break_on )
         rep_tab_arr [ rep_tab_row, rti_pos ] =
                             select ad_rep_tables.indent
         rep_tab_arr [ rep_tab_row, rto_pos ] =
            boolean_to_text( select ad_rep_tables.only_first_record )
{AS1171 HBe 28-1-99}
         rep_tab_arr [ rep_tab_row, rts_pos ] =
                             select ad_rep_tables.blanks
{AS1171 HBe 28-1-99}
      ENDIF

      ref_no = select ad_rep_tables.order_number
      ref_arr[ref_no,1] = rep_tab_row

      NEXT ad_rep_tables
      order_number = select ad_rep_tables.order_number

   ENDWHILE

   cols = 0
   field_ord_num = select ad_rep_fields.order_number
                   where  report_id = report_id
   WHILE field_ord_num <> EMPTY DO
      cols = cols + 1
      rep_col_arr[cols,rcr_pos] = ref_arr[field_ord_num,1]
      rep_col_arr[cols,rcn_pos] = select ad_rep_fields.field_name
      rep_col_arr[cols,rcl_pos] = select ad_rep_fields.column_size
      rep_col_arr[cols,rco_pos] = select ad_rep_fields.column_order
      rep_col_arr[cols,rcw_pos] = boolean_to_text(
                                  select ad_rep_fields.do_wrap )
      rep_col_arr[cols,rca_pos] = boolean_to_text(
                                  select ad_rep_fields.header_above )
      rep_col_arr[cols,rcj_pos] = array_switch( just_arr, 1,
                                  select ad_rep_fields.justification )
      rep_col_arr[cols,rcm_pos] = select ad_rep_fields.print_format
      rep_col_arr[cols,rch_pos] = select ad_rep_fields.column_header
      rep_col_arr[cols,rcs_pos] = select ad_rep_fields.skip_lines
      NEXT ad_rep_fields
      field_ord_num = select ad_rep_fields.order_number
   ENDWHILE

   filter_ord_num = select ad_rep_filters.order_number
                    where  report_id = report_id
		              order  on order_number, order_no
   WHILE filter_ord_num <> EMPTY DO
      actual_table_no = ref_arr[filter_ord_num,1]
      IF   NOT ( find_filter_row ( actual_table_no, the_filter_row ) )
      THEN filters = filters + 1
           the_filter_row = filters
           rep_filter_arr[the_filter_row,rfr_pos] = actual_table_no
           rep_filter_arr[the_filter_row,rfn_pos] = 0
      ENDIF
      n_filter = rep_filter_arr[the_filter_row,rfn_pos]
   	n_filter = n_filter + 1
	   rep_filter_arr[the_filter_row,rfn_pos] = n_filter
	   pos = rfn_pos + ((n_filter-1)*rfn_off)
	   rep_filter_arr[the_filter_row,pos+1] =
			   select ad_rep_filters.clause_operator
	   rep_filter_arr[the_filter_row,pos+2] =
			   select ad_rep_filters.field_name
	   rep_filter_arr[the_filter_row,pos+3] =
			   select ad_rep_filters.filter_operator
	   rep_filter_arr[the_filter_row,pos+4] =
			   select ad_rep_filters.filter_value
      NEXT ad_rep_filters
      filter_ord_num = select ad_rep_filters.order_number
   ENDWHILE

   sort_ord_num = select ad_rep_sort.order_number
                  where  report_id = report_id
    		         order  on order_number, order_no
   WHILE sort_ord_num <> EMPTY DO
      actual_table_no = ref_arr[sort_ord_num,1]
      get_order_row ( actual_table_no, the_order_row )
      IF the_order_row < 0 THEN
         order_rows = order_rows + 1
         the_order_row = order_rows
         rep_ord_arr[the_order_row,ror_pos] = actual_table_no
         rep_ord_arr[the_order_row,ron_pos] = 0
      ENDIF
      n = rep_ord_arr[the_order_row,ron_pos]
      n = n + 1
      rep_ord_arr[the_order_row,ron_pos] = n
      pos = ron_pos + ((n-1)*3)
      rep_ord_arr[the_order_row,pos+1] = select ad_rep_sort.field_name
      rep_ord_arr[the_order_row,pos+2] = select ad_rep_sort.order_no
      rep_ord_arr[the_order_row,pos+3] = select ad_rep_sort.asc_desc
      NEXT ad_rep_sort
      sort_ord_num = select ad_rep_sort.order_number
   ENDWHILE

   actual_table_no = 1

{AS 1219 HBe 15-6-99: Next line removed.
   flash_message("Report:":report_id:" has been loaded",TRUE)
AE 1219}
   return ( TRUE )

ENDROUTINE

ROUTINE  boolean_to_text ( VALUE true_false_flag )
   IF    true_false_flag
   THEN  return ( "Yes" )
   ELSE  return ( "No"  )
   ENDIF
ENDROUTINE

ROUTINE  text_to_boolean ( VALUE yes_no_text )
   IF     yes_no_text = "Yes"
   THEN   return ( TRUE )
   ELSEIF yes_no_text = "No"
   THEN   return ( FALSE)
   ELSE   flash_message("Warning: Yes/No text supposed:":yes_no_text,TRUE)
          return ( FALSE)
   ENDIF
ENDROUTINE

ROUTINE  delete_setup

   old_report_id = report_id

   IF   prompt_user("AD_REP_HEADER","Delete Report Setup", EMPTY,
                     TRUE, "Enter Report ID:", empty_arr, report_id, l_k)
   THEN

{AS1171 HBe 3-2-99}
   cur_authority      = GLOBAL ( "CURRAUTH" )
   saved_mod_level = select ad_rep_header.mod_level
                    where  report_id = report_id
   IF (saved_mod_level <> EMPTY) AND
      (NOT(BLANK(saved_mod_level))) THEN
     IF  cur_authority  < saved_mod_level
       THEN
       flash_message("You do currently not have the authority to delete this report",TRUE)
       return
     ENDIF

   ENDIF
{AE1171 HBe 3-2-99}


        START WRITE TRANSACTION "Delete Setup"



        delete_report ( report_id )

        COMMIT

        IF report_id = old_report_id THEN
           report_id = EMPTY
        ENDIF

        flash_message("The Report Setup has been deleted",TRUE)
   ENDIF

ENDROUTINE

ROUTINE  delete_report ( VALUE report_id )

   ARRAY sel_arr

{  Delete current setup for this report }
   block_del_h = "Delete Header"
   block_del_t = "Delete Tables"
   block_del_l = "Delete Link Fields"
   block_del_f = "Delete Fields"
   block_del_i = "Delete Filters"
   block_del_o = "Delete Order"
   IF init_block( block_del_h, "ad_rep_header" ) AND
      init_block( block_del_t, "ad_rep_tables" ) AND
      init_block( block_del_l, "ad_rep_link_fields" ) AND
      init_block( block_del_f, "ad_rep_fields" ) AND
      init_block( block_del_i, "ad_rep_filters" ) AND
      init_block( block_del_o, "ad_rep_sort" )
   THEN
      sel_arr[1,1] = ARRAY_SELECT_EQ
      sel_arr[1,2] = "REPORT_ID"
      sel_arr[1,3] = report_id
      delete_block ( block_del_h, sel_arr )
      delete_block ( block_del_t, sel_arr )
      delete_block ( block_del_l, sel_arr )
      delete_block ( block_del_f, sel_arr )
      delete_block ( block_del_i, sel_arr )
      delete_block ( block_del_o, sel_arr )
   ENDIF
   rc = block_row_update ( block_del_h )
   rc = block_row_update ( block_del_t )
   rc = block_row_update ( block_del_l )
   rc = block_row_update ( block_del_f )
   rc = block_row_update ( block_del_i )
   rc = block_row_update ( block_del_o )
   rc = block_row_release( block_del_h )
   rc = block_row_release( block_del_t )
   rc = block_row_release( block_del_l )
   rc = block_row_release( block_del_f )
   rc = block_row_release( block_del_i )
   rc = block_row_release( block_del_o )

ENDROUTINE

ROUTINE  save_setup

   selected_tables = build_up_tables()

   IF   selected_tables <= 0
   THEN flash_message("No tables to save. Save process is stopped",TRUE)
        return
   ENDIF

   build_up_columns()

   get_field_details ad_rep_header.report_id, "FIELD_SIZE", rep_id_size
   IF   NOT (prompt_user("AD_REP_HEADER","Enter Report Id","REPORT_ID",
                          FALSE, "Enter Report ID:", empty_arr, report_id, l_k))
   THEN return
   ENDIF

{AS1171 HBe 3-2-99}

   cur_authority      = GLOBAL ( "CURRAUTH" )
   saved_mod_level = select ad_rep_header.mod_level
                    where  report_id = report_id
   IF (saved_mod_level <> EMPTY) AND
      (NOT(BLANK(saved_mod_level))) THEN

     IF  cur_authority  < saved_mod_level
       THEN
       flash_message("You do currently not have the authority to update this report",TRUE)
       return
     ENDIF

   ENDIF
{AE1171 HBe 3-2-99}

   START WRITE TRANSACTION "Save Setup"

   delete_report ( report_id )

   block_header = "Insert Header"
   block_tables = "Insert Tables"
   block_links  = "Insert Links"
   block_fields = "Insert Fields"
   block_filter = "Insert Filters"
   block_order  = "Insert Order"
   IF init_block( block_header, "ad_rep_header" ) AND
      init_block( block_tables, "ad_rep_tables" ) AND
      init_block( block_links , "ad_rep_link_fields" ) AND
      init_block( block_fields, "ad_rep_fields" ) AND
      init_block( block_filter, "ad_rep_filters") AND
      init_block( block_order , "ad_rep_sort"   )
   THEN
      report_id = pad(report_id," ",rep_id_size)
      get_field_details ad_rep_tables.order_number, "FIELD_SIZE", rep_num_size
      get_field_details ad_rep_link_fields.order_no, "FIELD_SIZE", ls
      get_field_details ad_rep_fields.field_name, "FIELD_SIZE", fs
      get_field_details ad_rep_filters.order_no, "FIELD_SIZE", flt_s
      get_field_details ad_rep_sort.field_name, "FIELD_SIZE", os

      rc = block_row_create_last  ( block_header, report_id )
      rc = block_row_field_assign ( block_header, "DESCRIPTION", title_text )
      rc = block_row_field_assign ( block_header, "PRINT_HEADER",
                                    text_to_boolean(print_head))
      rc = block_row_field_assign ( block_header, "PRINT_CRITERIAS",
                                    text_to_boolean(print_crit))

{AS1171 HBe 27-2-99}
      rc = block_row_field_assign ( block_header, "TOP_INDENT", top_indent )
      rc = block_row_field_assign ( block_header, "TOP_TEXT", top_text )
      rc = block_row_field_assign ( block_header, "FOOT_INDENT", foot_indent )
      rc = block_row_field_assign ( block_header, "FOOT_TEXT", foot_text )
      rc = block_row_field_assign ( block_header, "PRINT_REP_NAME",
                                    text_to_boolean(print_rep_name ))
      rc = block_row_field_assign ( block_header, "EXEC_LEVEL", exec_level )
      rc = block_row_field_assign ( block_header, "MOD_LEVEL", mod_level )
{AE1171 HBe 27-2-99}

      tab = 0
      WHILE tab < selected_tables DO
         tab = tab + 1
         tab_id=report_id:pad(strip(the_tables[tab,ttr_pos])," ",rep_num_size)
         rc = block_row_create_last ( block_tables, tab_id )
         rc = block_row_last( block_tables )
         rc = block_row_field_assign ( block_tables, "LINK_NUMBER",
                   rep_tab_arr[the_tables[tab,ttr_pos], rtr_pos] )
         rc = block_row_field_assign ( block_tables, "TABLE_NAME",
                   rep_tab_arr[the_tables[tab,ttr_pos], rtn_pos] )

         rc = block_row_field_assign ( block_tables, "INDENT"    ,
                   rep_tab_arr[the_tables[tab,ttr_pos], rti_pos] )
         break_on = text_to_boolean(
                    rep_tab_arr[ the_tables[tab,ttr_pos], rtp_pos ] )
         rc = block_row_field_assign ( block_tables, "BREAK_ON", break_on )

         only_first=text_to_boolean(
                    rep_tab_arr[ the_tables[tab,ttr_pos], rto_pos ] )
         rc = block_row_field_assign ( block_tables, "ONLY_FIRST_RECORD",
                                       only_first)
{AS1171 HBe 28-1-99}
         rc = block_row_field_assign ( block_tables, "BLANKS"    ,
                   rep_tab_arr[the_tables[tab,ttr_pos], rts_pos] )
{AS1171 HBe 28-1-99}
         link_dir = rep_tab_arr[the_tables[tab,ttr_pos], rtd_pos]
         IF     link_dir = LINK_MAST
         THEN   link_dir = "M"
         ELSEIF link_dir = LINK_UP
         THEN   link_dir = "U"
         ELSE   link_dir = "D"
         ENDIF
         rc = block_row_field_assign ( block_tables,"LINK_DIRECTION",link_dir )

         f = 0
         WHILE f < rep_tab_arr[the_tables[tab,ttr_pos], rtf_pos] DO
            f = f + 1
            fld_id = tab_id : pad( strip(f), " ", ls )
            rc = block_row_create_last ( block_links, fld_id )
            rc = block_row_last( block_links )
            pos = rtf_pos + ((f-1)*2)
            rc = block_row_field_assign ( block_links,"MASTER_FIELD_NAME",
                         rep_tab_arr[the_tables[tab,ttr_pos],pos+1])
            rc = block_row_field_assign ( block_links,"CHILD_FIELD_NAME",
                         rep_tab_arr[the_tables[tab,ttr_pos],pos+2])
         ENDWHILE


         f = 0
         WHILE f < cols DO
            f = f + 1
            IF rep_col_arr[f,rcr_pos] = the_tables[tab,ttr_pos] THEN
               fld_id = tab_id : pad( strip(rep_col_arr[f,rcn_pos]), " ", fs )
               rc = block_row_create_last ( block_fields, fld_id )
               rc = block_row_last( block_fields )
               rc = block_row_field_assign ( block_fields,"COLUMN_SIZE",
                         rep_col_arr[f,rcl_pos] )
               rc = block_row_field_assign ( block_fields,"COLUMN_ORDER",
                         rep_col_arr[f,rco_pos] )
               rc = block_row_field_assign ( block_fields,"HEADER_ABOVE",
                         text_to_boolean ( rep_col_arr[f,rca_pos] ) )
               rc = block_row_field_assign ( block_fields,"JUSTIFICATION",
                         array_switch( just_arr, 2, rep_col_arr[f,rcj_pos] ) )
               rc = block_row_field_assign ( block_fields,"PRINT_FORMAT",
                         rep_col_arr[f,rcm_pos] )
               rc = block_row_field_assign ( block_fields,"COLUMN_HEADER",
                         rep_col_arr[f,rch_pos] )
               rc = block_row_field_assign ( block_fields,"SKIP_LINES",
                         rep_col_arr[f,rcs_pos] )
               do_wrap = text_to_boolean ( rep_col_arr[f,rcw_pos] )
               rc = block_row_field_assign ( block_fields,"DO_WRAP",do_wrap)
            ENDIF
         ENDWHILE

         f = 0
         WHILE f < filters DO
            f = f + 1
            IF rep_filter_arr[f,rfr_pos] = the_tables[tab,ttr_pos] THEN
               n = 0
               WHILE n < rep_filter_arr[f,rfn_pos] DO
                  n = n + 1
                  flt_id = tab_id : pad( strip(n), " ", flt_s )
                  rc = block_row_create_last ( block_filter, flt_id )
                  rc = block_row_last( block_filter )
                  pos = rfn_pos + ((n-1)*rfn_off)
                  rc = block_row_field_assign ( block_filter,"CLAUSE_OPERATOR",
                         rep_filter_arr[f,pos+1] )
                  rc = block_row_field_assign ( block_filter,"FIELD_NAME",
                         rep_filter_arr[f,pos+2] )
                  rc = block_row_field_assign ( block_filter,"FILTER_OPERATOR",
                         rep_filter_arr[f,pos+3] )
                  rc = block_row_field_assign ( block_filter,"FILTER_VALUE",
                         rep_filter_arr[f,pos+4] )
               ENDWHILE
            ENDIF
         ENDWHILE

         o = 0
         WHILE o < order_rows DO
            o = o + 1
            IF rep_ord_arr[o,ror_pos] = the_tables[tab,ttr_pos] THEN
               n = 0
               WHILE n < rep_ord_arr[o,ron_pos] DO
                  n = n + 1
                  pos = ron_pos + ((n-1)*3)
                  ord_id = tab_id : pad( strip(rep_ord_arr[o,pos+1]), " ", os )
                  rc = block_row_create_last ( block_order, ord_id )
                  rc = block_row_last( block_order )
                  rc = block_row_field_assign ( block_order,"ORDER_NO",
                         rep_ord_arr[o,pos+2] )
                  rc = block_row_field_assign ( block_order,"ASC_DESC",
                         rep_ord_arr[o,pos+3] )
               ENDWHILE
            ENDIF
         ENDWHILE

      ENDWHILE

   ENDIF

   rc = block_row_update ( block_header )
   rc = block_row_update ( block_tables )
   rc = block_row_update ( block_links )
   rc = block_row_update ( block_fields )
   rc = block_row_update ( block_filter )
   rc = block_row_update ( block_order  )
   rc = block_row_release( block_header )
   rc = block_row_release( block_tables )
   rc = block_row_release( block_links )
   rc = block_row_release( block_fields )
   rc = block_row_release( block_filter )
   rc = block_row_release( block_order  )

   COMMIT

   flash_message("The Report Setup has been saved",TRUE)

ENDROUTINE

ROUTINE  init_block ( block_name, VALUE tab_name )
   rc = block_row_initialise ( block_name, tab_name )
   IF   rc = EMPTY
   THEN return ( TRUE )
   ELSE flash_message("Error in block initialisation - ":rc,TRUE)
        return ( FALSE )
   ENDIF
ENDROUTINE


ROUTINE  report_attributes

   CREATE   OBJECT PROMPT_CLASS_FORM, get_rep_att

{M-1171 HBe 26-1-99: height increased to 12
   get_rep_att . height = 5                     }

   get_rep_att . height = 12
   get_rep_att . row      =  wr + 5
   get_rep_att . column   =  wc + 10
   get_rep_att . border   =  TRUE
   get_rep_att . header   =  "Set Report Attributes"
   get_rep_att . footer   =  "Press DO to accept"
   get_rep_att . button_style = FORM_BUTTON_OK

   CREATE OBJECT PROMPT_CLASS_GRID , rep_att_grid

   ARRAY rep_att_grid . user_info

   rep_att_grid . height  = get_rep_att . height
   rep_att_grid . column  = 1
   rep_att_grid . cell_columns = 2
{M-1171 HBe 26-1-99: cell_rows increased to 10
   rep_att_grid . cell_rows = 3 }
   rep_att_grid . cell_rows = 10
   rep_att_grid . enabled = TRUE
   rep_att_grid . display_cell_routine = "display_cell"
   rep_att_grid . prompt_cell_routine = "rep_att_prompt"
   rep_att_grid . remove_routine = "do_nothing"
   rep_att_grid . select_routine = "do_nothing"
   rep_att_grid . column_size [ 1 ] = 20
   rep_att_grid . column_size [ 2 ] = 30
   rep_att_grid . title_size_top = 1
   rep_att_grid . title_text_top [ 1, 1 ] = "Attribute"
   rep_att_grid . title_text_top [ 2, 1 ] = "Value"
   rep_att_grid . title_separator_top = GRID_SEPARATOR_BOTH

   rep_att_grid . user_info [ 1, 1 ] = "Title"
   rep_att_grid . user_info [ 1, 2 ] = title_text
   rep_att_grid . user_info [ 2, 1 ] = "Header On"
   rep_att_grid . user_info [ 2, 2 ] = print_head
   rep_att_grid . user_info [ 3, 1 ] = "Print Criterias"
   rep_att_grid . user_info [ 3, 2 ] = print_crit

{AS1171 HBe 26-1-99}
   rep_att_grid . user_info [ 4, 1 ] = "Lines A/B Top Text"
   rep_att_grid . user_info [ 4, 2 ] = top_indent
   rep_att_grid . user_info [ 5, 1 ] = "Top Text"
   rep_att_grid . user_info [ 5, 2 ] = top_text
   rep_att_grid . user_info [ 6, 1 ] = "Lines A Footer Text"
   rep_att_grid . user_info [ 6, 2 ] = foot_indent
   rep_att_grid . user_info [ 7, 1 ] = "Footer Text"
   rep_att_grid . user_info [ 7, 2 ] = foot_text
   rep_att_grid . user_info [ 8, 1 ] = "Include Report Name"
   rep_att_grid . user_info [ 8, 2 ] = print_rep_name
   rep_att_grid . user_info [ 9, 1 ] = "Execution level"
   rep_att_grid . user_info [ 9, 2 ] = exec_level
   rep_att_grid . user_info [ 10, 1 ] = "Modification level"
   rep_att_grid . user_info [ 10, 2 ] = mod_level
{AE1171 HBe 26-1-99}

   get_rep_att  . width = rep_att_grid.column_size[1]+
                          rep_att_grid.column_size[2]+2
   rep_att_grid . width = get_rep_att . width

   get_rep_att . add_prompt ( rep_att_grid )

   get_rep_att . add_frame ( "" , 1 , 1 , 2 , get_rep_att . width )

   get_rep_att . start_prompt()

   rep_att_grid.set_position(1,1)

   REPEAT

      get_rep_att . wait_prompt()

      the_key = get_rep_att . get_lastkey()

   UNTIL ( the_key = "EXIT" ) OR ( the_key = "DO" )

   get_rep_att . end_prompt()

   IF the_key = "DO" THEN
      title_text = rep_att_grid.user_info[1,2]
      print_head = rep_att_grid.user_info[2,2]
      print_crit = rep_att_grid.user_info[3,2]

{AS1171 HBe 26-1-99}
      top_indent     = rep_att_grid.user_info[4,2]
      top_text       = rep_att_grid.user_info[5,2]
      foot_indent    = rep_att_grid.user_info[6,2]
      foot_text      = rep_att_grid.user_info[7,2]
      print_rep_name = rep_att_grid.user_info[8,2]
      exec_level     = rep_att_grid.user_info[9,2]
      mod_level      = rep_att_grid.user_info[10,2]
{AE1171 HBe 26-1-99}


   ENDIF

ENDROUTINE


ROUTINE  table_attributes

   CREATE   OBJECT PROMPT_CLASS_FORM, get_tab_att
{M-1171 HBe 28-1-99: Height increased to 6
   get_tab_att . height = 5                  }
   get_tab_att . height = 6
   get_tab_att . row      =  wr + 5
   get_tab_att . column   =  wc + 20
   get_tab_att . border   =  TRUE
   get_tab_att . header   =  "Set Record Attributes"
   get_tab_att . footer   =  "Press DO to accept"
   get_tab_att . button_style = FORM_BUTTON_OK

   CREATE OBJECT PROMPT_CLASS_GRID , tab_att_grid

   ARRAY tab_att_grid . user_info

   tab_att_grid . height  = get_tab_att . height
   tab_att_grid . column  = 1
   tab_att_grid . cell_columns = 2
{M-1171 HBe 28-1-99: cell_rows increased to 4
   tab_att_grid . cell_rows = 3                }
   tab_att_grid . cell_rows = 4
   tab_att_grid . enabled = TRUE
   tab_att_grid . display_cell_routine = "display_cell"
   tab_att_grid . prompt_cell_routine = "tab_att_prompt"
   tab_att_grid . remove_routine = "do_nothing"
   tab_att_grid . select_routine = "do_nothing"
   tab_att_grid . column_size [ 1 ] = 10
   tab_att_grid . column_size [ 2 ] = 10
   tab_att_grid . title_size_top = 1
   tab_att_grid . title_text_top [ 1, 1 ] = "Attribute"
   tab_att_grid . title_text_top [ 2, 1 ] = "Value"
   tab_att_grid . title_separator_top = GRID_SEPARATOR_BOTH

   tab_att_grid . user_info [ 1, 1 ] = "Page Break"
   tab_att_grid . user_info [ 1, 2 ] = rep_tab_arr[ actual_table_no, rtp_pos ]
   tab_att_grid . user_info [ 2, 1 ] = "Indent"
   tab_att_grid . user_info [ 2, 2 ] = rep_tab_arr[ actual_table_no, rti_pos ]
   tab_att_grid . user_info [ 3, 1 ] = "Only First"
   tab_att_grid . user_info [ 3, 2 ] = rep_tab_arr[ actual_table_no, rto_pos ]
{AS1171 HBe 28-1-99}
   tab_att_grid . user_info [ 4, 1 ] = "Skip lines"
   tab_att_grid . user_info [ 4, 2 ] = rep_tab_arr[ actual_table_no, rts_pos ]
{AE1171 HBe 28-1-99}

   get_tab_att  . width = tab_att_grid.column_size[1]+
                          tab_att_grid.column_size[2]+2
   tab_att_grid . width = get_tab_att . width

   get_tab_att . add_prompt ( tab_att_grid )

   get_tab_att . add_frame ( "" , 1 , 1 , 2 , get_tab_att . width )

   get_tab_att . start_prompt()

   tab_att_grid.set_position(1,1)

   REPEAT

      get_tab_att . wait_prompt()

      the_key = get_tab_att . get_lastkey()

   UNTIL ( the_key = "EXIT" ) OR ( the_key = "DO" )

   get_tab_att . end_prompt()

   IF the_key = "DO" THEN
      rep_tab_arr[ actual_table_no, rtp_pos ] = tab_att_grid.user_info [1,2]
      rep_tab_arr[ actual_table_no, rti_pos ] = tab_att_grid.user_info [2,2]
      rep_tab_arr[ actual_table_no, rto_pos ] = tab_att_grid.user_info [3,2]
{AS1171 HBe 28-1-99}
      rep_tab_arr[ actual_table_no, rts_pos ] = tab_att_grid.user_info [4,2]
{AE1171 HBe 28-1-99}
   ENDIF

ENDROUTINE


ROUTINE  link_upwards

   DECLARE  child_tab, size, f_name, f
   ARRAY    child_fields

   IF rep_tab_arr [ actual_table_no, rtu_pos ] THEN
      flash_message("This table has already been expanded upwards",TRUE)
      return
   ENDIF

   child_tab = rep_tab_arr [ actual_table_no, rtn_pos ]
   get_field_names ( child_tab, child_fields )
   size = size_of_array ( child_fields )
   f = 0
   WHILE f < size DO
      f = f + 1
      IF NOT(child_fields[f,2]) THEN
         f_name = child_fields[f,1]
         adhoc_field_details (child_tab,f_name,"LINK_TABLE",EMPTY,l)
         IF l<>EMPTY THEN
            add_link_field ( l, actual_table_no, LINK_UP,
                             f_name, l, "A", EMPTY )
         ENDIF
      ENDIF
   ENDWHILE

   rep_tab_arr [ actual_table_no, rtu_pos ] = TRUE

ENDROUTINE


ROUTINE  order_setup

   ARRAY    field_names
   DECLARE  tab_name, dummy_row

   IF rep_tab_arr [ actual_table_no, rtd_pos ] = LINK_UP THEN
      flash_message("No ordering can be set for upward linked tables",TRUE)
      return
   ENDIF

   tab_name = rep_tab_arr [ actual_table_no, rtn_pos ]

   CREATE OBJECT PROMPT_CLASS_GRID , order_grid
   in_ex_obj = order_grid

   ARRAY order_grid . user_info

   order_grid . title_size_top = 1
   order_grid . title_text_top [ ogf_pos, 1 ] = "Field"
   order_grid . title_text_top [ ogo_pos, 1 ] = ORDER_TEXT
   order_grid . title_text_top [ oga_pos, 1 ] = "Asc/Des"
   order_grid . title_separator_top = GRID_SEPARATOR_BOTH

   order_grid . column_size [ ogo_pos ] = 5
   order_grid . column_size [ oga_pos ] = 10

   get_order_row ( actual_table_no, ord_row )

   get_field_names ( tab_name, field_names )
   size = size_of_array( field_names )
   f = 0
   fields = 0
   f_l = LENGTH( order_grid . title_text_top [ ogf_pos, 1 ])
   WHILE f < size DO
      f = f + 1
      IF NOT ( field_names[ f, 2 ] ) THEN       { Exclude synonyms }
         fields = fields + 1
         order_grid . user_info [ fields, ogf_pos ] =
               strip(field_names[f,1])

         IF LENGTH( order_grid . user_info [ fields, ogf_pos ]) > f_l THEN
            f_l = LENGTH( order_grid . user_info [ fields, ogf_pos ])
         ENDIF

         order_grid . user_info [ fields, ogo_pos ] = fields
         order_grid . user_info [ fields, oga_pos ] = asc_desc[1,1]
         IF   ord_row > 0
         THEN c = 0
              not_found = TRUE
              WHILE (c < rep_ord_arr[ord_row,ron_pos]) AND (not_found) DO
                 c = c + 1
                 pos = ron_pos+((c-1)*3)
                 IF rep_ord_arr[ord_row,pos+roc_pos] = field_names[f,1] THEN
                    not_found = FALSE
                 ENDIF
              ENDWHILE
              IF   not_found
              THEN in_ex [ fields, ori_pos ] = FALSE
              ELSE in_ex [ fields, ori_pos ] = TRUE
                   order_grid . user_info [ fields, ogo_pos ] =
                        rep_ord_arr[ord_row,pos+roo_pos]
                   order_grid . user_info [ fields, oga_pos ] =
                        rep_ord_arr[ord_row,pos+roa_pos]
                   transform_order(order_grid.user_info[fields,oga_pos],
                                   3, dummy_row )
              ENDIF
         ELSE in_ex [ fields, ori_pos ] = FALSE
         ENDIF
         in_ex [ fields, new_pos ] = in_ex [ fields, ori_pos ]

      ENDIF
   ENDWHILE

   CREATE OBJECT PROMPT_CLASS_FORM, get_ord_col

   IF   fields+2 > wh
   THEN get_ord_col . height = wh
   ELSE get_ord_col . height = fields + 2
   ENDIF

   get_ord_col . column   =  wc + 2
   get_ord_col . width    =  GLOBAL("SCREEN_WIDTH")-(get_ord_col.column*2)
   get_ord_col . row      =  wr
   get_ord_col . border   =  TRUE
   get_ord_col . header   =  "Field Ordering for Table " : tab_name
   get_ord_col . footer   =  "Press Insert/Remove Column / DO to accept " :
                         "/ Exit to quit"
   get_ord_col . button_style = FORM_BUTTON_NONE

   order_grid . height  = get_ord_col . height
   order_grid . column  = 1
   order_grid . cell_columns = 3
   order_grid . cell_rows = fields
   order_grid . enabled = TRUE
   order_grid . display_cell_routine = "display_field"
   order_grid . prompt_cell_routine  = "prompt_order"
   order_grid . remove_routine = "exclude_field"
   order_grid . select_routine = "include_field"
   order_grid . insert_routine = "include_field"
   order_grid . width = get_ord_col . width
   order_grid . column_size [ ogf_pos ] = f_l
   order_grid . fixed_columns_left = 1

   get_ord_col . add_prompt ( order_grid )

   IF gui THEN

      gui_adjustments ( get_ord_col, 4 )
      add_button ( get_ord_col, "SELECT", 3, 4,
"include_field","AD-HOC-REPORTS","Include" )
      add_button ( get_ord_col, "REMOVE", 4, 4,
"exclude_field","AD-HOC-REPORTS","Remove" )

   ENDIF

   get_ord_col . add_frame ( "" , 1 , 1 , fields , get_ord_col . width )

   get_ord_col . start_prompt()

   REPEAT

      get_ord_col . wait_prompt()

   UNTIL ( get_ord_col . get_lastkey () = "EXIT"          ) OR
         ((get_ord_col . get_lastkey () = "DO")    AND
          (order_setup_ok( order_grid, fields, ord_row )) )

   get_ord_col . end_prompt()

ENDROUTINE


ROUTINE  get_order_row ( VALUE rep_tab, rep_ord_row )

   DECLARE  r

{  Find current setup for this table - if any   }
   rep_ord_row = -1
   r = 0
   WHILE (r < order_rows) AND (rep_ord_row < 0) DO
      r = r + 1
      IF rep_ord_arr[r,ror_pos] = rep_tab THEN
         rep_ord_row = r
      ENDIF
   ENDWHILE

ENDROUTINE


ROUTINE  order_setup_ok ( order_grid, VALUE grid_rows, rep_ord_row )

   DECLARE  r, o, p, f, a

   r = 0
   WHILE r < (grid_rows-1) DO
      r = r + 1
      IF in_ex [ r, new_pos ] THEN
         o = order_grid.user_info[r,ogo_pos]
         n = r
         WHILE n < grid_rows DO
            n = n + 1
            IF in_ex [ n, new_pos ] THEN
               IF o = order_grid.user_info[n,ogo_pos] THEN
                  order_grid.set_position(ogo_pos,n)
                  flash_message("ERROR " : order_grid.user_info[r,ogf_pos] :
                                " has same ordering",TRUE)
                  return ( FALSE )
               ENDIF
            ENDIF
         ENDWHILE
      ENDIF
   ENDWHILE

   IF rep_ord_row < 0 THEN
      order_rows  = order_rows + 1
      rep_ord_row = order_rows
      rep_ord_arr[rep_ord_row,ror_pos] = actual_table_no
   ENDIF
   rep_ord_arr[rep_ord_row,ron_pos] = 0
   r = 0
   WHILE r < grid_rows DO
      r = r + 1
      IF in_ex [ r, new_pos ] THEN
         n = rep_ord_arr[rep_ord_row,ron_pos]+1
         rep_ord_arr[rep_ord_row,ron_pos] = n
         p = ron_pos + ((n-1)*3)
         rep_ord_arr[rep_ord_row,p+roc_pos] = order_grid.user_info[r,ogf_pos]
         rep_ord_arr[rep_ord_row,p+roo_pos] = order_grid.user_info[r,ogo_pos]

         transform_order(order_grid.user_info[r,oga_pos],1,o)
         rep_ord_arr[rep_ord_row,p+roa_pos] = asc_desc[o,3]

      ENDIF
   ENDWHILE

{  Reorder the fields according to order number }
   r = 0
   WHILE r < (rep_ord_arr[rep_ord_row,ron_pos]-1) DO
      r = r + 1
      p = ron_pos + ((r-1)*3) + roo_pos
      IF rep_ord_arr[rep_ord_row,p] > rep_ord_arr[rep_ord_row,p+3] THEN
         f = rep_ord_arr[rep_ord_row,p-1]
         o = rep_ord_arr[rep_ord_row,p  ]
         a = rep_ord_arr[rep_ord_row,p+1]

         rep_ord_arr[rep_ord_row,p-1] = rep_ord_arr[rep_ord_row,p+2]
         rep_ord_arr[rep_ord_row,p  ] = rep_ord_arr[rep_ord_row,p+3]
         rep_ord_arr[rep_ord_row,p+1] = rep_ord_arr[rep_ord_row,p+4]

         rep_ord_arr[rep_ord_row,p+2] = f
         rep_ord_arr[rep_ord_row,p+3] = o
         rep_ord_arr[rep_ord_row,p+4] = a

      ENDIF
   ENDWHILE

   return ( TRUE )

ENDROUTINE


ROUTINE  column_filters

   ARRAY field_names
   ARRAY field_arr

   IF rep_tab_arr [ actual_table_no, rtd_pos ] = LINK_UP THEN
      flash_message("Filters can not be set for upward linked tables",TRUE)
      return
   ENDIF

   CREATE OBJECT PROMPT_CLASS_GRID , filter_grid

   ARRAY filter_grid . user_info

   filter_grid . title_size_top = 2
   filter_grid . title_text_top [ fgo_pos, 2 ] = "Clause"
   filter_grid . title_text_top [ fgf_pos, 2 ] = "Field"
   filter_grid . title_text_top [ fgc_pos, 1 ] = "Condi"
   filter_grid . title_text_top [ fgc_pos, 2 ] = "tion"
   filter_grid . title_text_top [ fgv_pos, 2 ] = "Value"
   filter_grid . title_separator_top = GRID_SEPARATOR_BOTH

   tab_name = rep_tab_arr[ actual_table_no, rtn_pos ]
   get_field_names ( tab_name, field_names )
   size = size_of_array ( field_names )

   fields = 1              {  Empty fieldname is allowed  }
   field_arr[fields,1] = ""
   field_arr[fields,2] = ""
   field_arr[fields,3] = ""

   f = 0
   f_l = length ( filter_grid.title_text_top[fgf_pos,2] )
   WHILE f < size DO
      f = f + 1
      IF (NOT(field_names[f,2])) THEN
         get_field_details 'tab_name'.'field_names[f,1]', "DATA_TYPE" , f_typ
         fields = fields + 1
         field_arr[fields,1] = field_names[f,1]
         field_arr[fields,2] = field_names[f,1]
         field_arr[fields,3] = f_typ
         l = length(field_names[f,1])
         IF l > f_l THEN
            f_l = l
         ENDIF
      ENDIF
   ENDWHILE

   filter_grid . column_size [ fgo_pos ] = 6
   filter_grid . column_size [ fgf_pos ] = f_l
   filter_grid . column_size [ fgc_pos ] = 5
   filter_grid . column_size [ fgv_pos ] = 30

   CREATE   OBJECT PROMPT_CLASS_FORM, get_flt

   get_flt . height = wh

   get_flt . column   =  wc + 2
   get_flt . width    =  GLOBAL("SCREEN_WIDTH")-(get_flt.column*2)
   get_flt . row      =  wr
   get_flt . border   =  TRUE
   get_flt . header   =  "Filters for Table " : tab_name
   get_flt . footer   =  "Press Insert/Remove Filter / DO to accept " :
                         "/ Exit to quit"
   get_flt . button_style = FORM_BUTTON_NONE

   filter_grid . height  = get_flt . height
   filter_grid . column  = 1
   filter_grid . cell_columns = 4
   filter_grid . enabled = TRUE
   filter_grid . display_cell_routine = "display_filter"
   filter_grid . prompt_cell_routine  = "prompt_filter"
   filter_grid . remove_routine = "delete_grid_row"
   filter_grid . select_routine = "insert_filter_row"
   filter_grid . insert_routine = "insert_filter_row"
   filter_grid . width = get_flt . width
{  filter_grid . fixed_columns_left = 1 }

   the_filter_row = 0                   { Load current setup into grid }
   IF   find_filter_row ( actual_table_no, the_filter_row )
   THEN flt_rows = rep_filter_arr [ the_filter_row, rfn_pos ]
        filter_grid . cell_rows = flt_rows
        flt_row = 0
        WHILE flt_row < flt_rows DO
           flt_row = flt_row + 1
           flt_pos = rfn_pos + (flt_row-1)*rfn_off
           grid_col = 0
           WHILE grid_col < rfn_off DO
              grid_col = grid_col + 1
              filter_grid . user_info [ flt_row, grid_col ] =
                     rep_filter_arr [ the_filter_row, flt_pos+grid_col ]
           ENDWHILE
        ENDWHILE
   ELSE filter_grid . cell_rows = 1
   ENDIF

   get_flt . add_prompt ( filter_grid )

   IF gui THEN

      gui_adjustments ( get_flt, 4 )
      add_button ( get_flt, "SELECT", 3, 4,
"insert_filter_row","AD-HOC-REPORTS","Insert" )
      add_button ( get_flt, "REMOVE", 4, 4,
"delete_grid_row","AD-HOC-REPORTS","Remove" )

   ENDIF

   get_flt . add_frame ( "" , 1 , 1 , wh, get_flt . width )

   get_flt . start_prompt()

   REPEAT

      get_flt . wait_prompt()

   UNTIL ( get_flt . get_lastkey () = "EXIT" ) OR
         ( get_flt . get_lastkey () = "DO"   )

   IF get_flt . get_lastkey() = "DO" THEN       { Save filter setup }
      IF   the_filter_row = 0
      THEN filters = filters + 1
           the_filter_row = filters
           rep_filter_arr [ the_filter_row, rfr_pos ] = actual_table_no
      ENDIF
      rep_filter_arr[ the_filter_row, rfn_pos ] = 0
      grid_row = 0
      WHILE grid_row < filter_grid . cell_rows DO
         grid_row = grid_row + 1
         grid_col = 0
         any_input = FALSE
         WHILE (grid_col < rfn_off) AND (NOT(any_input)) DO
            grid_col = grid_col + 1
            IF NOT(
               (( filter_grid.user_info [ grid_row, grid_col ] = EMPTY ) OR
                ( BLANK ( filter_grid.user_info [ grid_row, grid_col ] ))))
            THEN any_input = TRUE
            ENDIF
         ENDWHILE
         IF any_input THEN
            n = rep_filter_arr [ the_filter_row, rfn_pos ] + 1
            rep_filter_arr [ the_filter_row, rfn_pos ] = n
            pos = rfn_pos + (n-1)*rfn_off
            grid_col = 0
            WHILE grid_col < rfn_off DO
               grid_col = grid_col + 1
               rep_filter_arr [ the_filter_row, pos+grid_col ] =
                                filter_grid . user_info [ grid_row, grid_col ]
            ENDWHILE
         ENDIF
      ENDWHILE
   ENDIF

   get_flt . end_prompt()

ENDROUTINE


ROUTINE  column_attributes

   ARRAY field_names

   tab_name = rep_tab_arr[ actual_table_no, rtn_pos ]

{  CREATE OBJECT "STD_LIST_GRID" , rep_col_list_grid }
   PROMPT OBJECT rep_col_list_grid
      CLASS PROMPT_CLASS_GRID
   in_ex_obj = rep_col_list_grid

   ARRAY rep_col_list_grid . user_info

   rep_col_list_grid . title_size_top = 1
   rep_col_list_grid . title_text_top [ cgf_pos, 1 ] = "Field"
   rep_col_list_grid . title_text_top [ cgt_pos, 1 ] = "Type"
   rep_col_list_grid . title_text_top [ cgl_pos, 1 ] = WIDTH_TEXT
   rep_col_list_grid . title_text_top [ cgo_pos, 1 ] = ORDER_TEXT
   rep_col_list_grid . title_text_top [ cgw_pos, 1 ] = "Wrap"
   rep_col_list_grid . title_text_top [ cgh_pos, 1 ] = "Header"
   rep_col_list_grid . title_text_top [ cgs_pos, 1 ] = SKIP_TEXT
   rep_col_list_grid . title_text_top [ cga_pos, 1 ] = "Above"
   rep_col_list_grid . title_text_top [ cgj_pos, 1 ] = "Just"
   rep_col_list_grid . title_text_top [ cgm_pos, 1 ] = "Format"
   rep_col_list_grid . title_separator_top = GRID_SEPARATOR_BOTH

   rep_col_list_grid . column_size [ cgt_pos ] = 7
   rep_col_list_grid . column_size [ cgl_pos ] = 5
   rep_col_list_grid . column_size [ cgo_pos ] = 5
   rep_col_list_grid . column_size [ cgw_pos ] = 4
   rep_col_list_grid . column_size [ cgh_pos ] = 15
   rep_col_list_grid . column_size [ cgs_pos ] = 4
   rep_col_list_grid . column_size [ cga_pos ] = 5
   rep_col_list_grid . column_size [ cgj_pos ] = 6
   rep_col_list_grid . column_size [ cgm_pos ] = 10

   get_field_names ( tab_name, field_names )
   size = size_of_array( field_names )
   f = 0
   fields = 0
   f_l = LENGTH(rep_col_list_grid . title_text_top [ cgf_pos, 1 ])
   WHILE f < size DO
      f = f + 1
      IF NOT ( field_names[ f, 2 ] ) THEN       { Exclude synonyms }
         fields = fields + 1
         rep_col_list_grid . user_info [ fields, cgf_pos ] =
               strip(field_names[f,1])
         IF LENGTH(rep_col_list_grid . user_info [ fields, cgf_pos ]) > f_l THEN
            f_l = LENGTH(rep_col_list_grid . user_info [ fields, cgf_pos ])
         ENDIF
         get_field_details 'tab_name'.'field_names[f,1]', "DATA_TYPE" , f_typ
         IF   f_typ = "Packed decimal"
         THEN f_typ = "Real"
         ENDIF
         rep_col_list_grid . user_info [ fields, cgt_pos ] = f_typ
         get_field_details 'tab_name'.'field_names[f,1]', "FIELD_SIZE", f_size
         f_size = trunc ( numeric( f_size ) )

         IF   field_in_list ( field_names[f,1], list_row )
         THEN in_ex [ fields, ori_pos ] = TRUE
              rep_col_list_grid . user_info [ fields  , cgl_pos ] =
                                 rep_col_arr[ list_row, rcl_pos ]
              rep_col_list_grid . user_info [ fields  , cgo_pos ] =
                                 rep_col_arr[ list_row, rco_pos ]
              rep_col_list_grid . user_info [ fields  , cgw_pos ] =
                                 rep_col_arr[ list_row, rcw_pos ]
              rep_col_list_grid . user_info [ fields  , cgh_pos ] =
                                 rep_col_arr[ list_row, rch_pos ]
              rep_col_list_grid . user_info [ fields  , cgs_pos ] =
                                 rep_col_arr[ list_row, rcs_pos ]
              rep_col_list_grid . user_info [ fields  , cga_pos ] =
                                 rep_col_arr[ list_row, rca_pos ]
              rep_col_list_grid . user_info [ fields  , cgj_pos ] =
                                 rep_col_arr[ list_row, rcj_pos ]
              rep_col_list_grid . user_info [ fields  , cgm_pos ] =
                                 rep_col_arr[ list_row, rcm_pos ]
         ELSE in_ex [ fields, ori_pos ] = FALSE
              rep_col_list_grid . user_info [ fields, cgl_pos ]=f_size
              rep_col_list_grid . user_info [ fields, cgo_pos ]=fields
              rep_col_list_grid . user_info [ fields, cgw_pos ]="Yes"
              rep_col_list_grid . user_info [ fields, cgh_pos ]=field_names[f,1]
              rep_col_list_grid . user_info [ fields, cgs_pos ]=0
              rep_col_list_grid . user_info [ fields, cga_pos ]="Yes"
              rep_col_list_grid . user_info [ fields, cgj_pos ]="Left"
              IF     f_typ = "Date"
              THEN rep_col_list_grid . user_info [ fields, cgm_pos ]="DDMMYY"
              ELSEIF f_typ = "Real"
              THEN rep_col_list_grid . user_info [ fields, cgm_pos ]= 0
              ELSE rep_col_list_grid . user_info [ fields, cgm_pos ]= ""
              ENDIF
         ENDIF
         in_ex [ fields, new_pos ] = in_ex [ fields, ori_pos ]

      ENDIF
   ENDWHILE

   CREATE OBJECT PROMPT_CLASS_FORM, get_col

   IF   fields+2 > wh
   THEN get_col . height = wh
   ELSE get_col . height = fields + 2
   ENDIF

   get_col . column   =  wc + 2
   get_col . width    =  GLOBAL("SCREEN_WIDTH")-(get_col.column*2)
   get_col . row      =  wr
   get_col . border   =  TRUE
   get_col . header   =  "Field Properties for Table " : tab_name
   get_col . footer   =  "Press Insert/Remove Column / DO to accept " :
                         "/ Exit to quit"
   rep_col_list_grid . column  = 1
   rep_col_list_grid . cell_columns = cgc_no
   rep_col_list_grid . cell_rows = fields
   rep_col_list_grid . enabled = TRUE
   rep_col_list_grid . display_cell_routine = "display_field"
   rep_col_list_grid . prompt_cell_routine  = "prompt_field"
   rep_col_list_grid . remove_routine = "exclude_field"
{  rep_col_list_grid . select_routine = "do_nothing" }
   rep_col_list_grid . select_routine = "include_field"
   rep_col_list_grid . insert_routine = "include_field"
   rep_col_list_grid . height = get_col . height
   rep_col_list_grid . width  = get_col . width
   rep_col_list_grid . column_size [ cgf_pos ] = f_l
   rep_col_list_grid . fixed_columns_left = 1
   rep_col_list_grid . current_column = 1
   rep_col_list_grid . current_row    = 1

   get_col . add_prompt ( rep_col_list_grid )

   IF gui THEN

      gui_adjustments    ( get_col, 4 )
      add_button ( get_col, "SELECT", 3, 4,
"include_field","AD-HOC-REPORTS","Include" )
      add_button ( get_col, "REMOVE", 4, 4,
"exclude_field","AD-HOC-REPORTS","Remove" )

   ENDIF

   get_col . add_frame ( "" , 1 , 1 , fields , get_col . width )

   get_col . start_prompt()

   REPEAT

      get_col . wait_prompt()

   UNTIL ( get_col . get_lastkey () = "EXIT" ) OR
         ( get_col . get_lastkey () = "DO"   )

   IF get_col . get_lastkey () = "DO" THEN

      col_row = 0                {  Remove old setup for actual table  }
      WHILE col_row < cols DO
         col_row = col_row + 1
         IF rep_col_arr[ col_row, rcr_pos ] = actual_table_no THEN
            r = col_row
            WHILE r < cols DO
               c = 0
               WHILE c < rca_no DO
                  c = c + 1
                  rep_col_arr[r,c] = rep_col_arr[r+1,c]
               ENDWHILE
               r = r + 1
            ENDWHILE
            cols = cols - 1
            col_row = col_row - 1
         ENDIF
      ENDWHILE

      f = 0                      {  Save new setup for actual table  }
      WHILE f < fields DO
         f = f + 1
         IF in_ex [ f, new_pos ] THEN
            cols = cols + 1
            rep_col_arr [ cols, rcr_pos ] = actual_table_no
            rep_col_arr [ cols, rcn_pos ] =
                        rep_col_list_grid.user_info[ f, cgf_pos ]
            rep_col_arr [ cols, rcl_pos ] =
                        rep_col_list_grid.user_info[ f, cgl_pos ]
            rep_col_arr [ cols, rco_pos ] =
                        rep_col_list_grid.user_info[ f, cgo_pos ]
            rep_col_arr [ cols, rcw_pos ] =
                        rep_col_list_grid.user_info[ f, cgw_pos ]
            rep_col_arr [ cols, rch_pos ] =
                        rep_col_list_grid.user_info[ f, cgh_pos ]
            rep_col_arr [ cols, rcs_pos ] =
                        rep_col_list_grid.user_info[ f, cgs_pos ]
            rep_col_arr [ cols, rca_pos ] =
                        rep_col_list_grid.user_info[ f, cga_pos ]
            rep_col_arr [ cols, rcj_pos ] =
                        rep_col_list_grid.user_info[ f, cgj_pos ]
            rep_col_arr [ cols, rcm_pos ] =
                        rep_col_list_grid.user_info[ f, cgm_pos ]
         ENDIF
      ENDWHILE

   ENDIF

   get_col . end_prompt()


ENDROUTINE


ROUTINE  include_field ( self )
   in_ex [ in_ex_obj.current_row, new_pos ] = TRUE
   in_ex_obj.redisplay_cell ( cgf_pos, in_ex_obj.current_row )
ENDROUTINE


ROUTINE  exclude_field ( self )
   in_ex [ in_ex_obj.current_row, new_pos ] = FALSE
   in_ex_obj.redisplay_cell ( cgf_pos, in_ex_obj.current_row )
ENDROUTINE


ROUTINE  get_actual_table

ARRAY link_tab_arr

   IF   report_tables = 1
   THEN chosen_table = 1
        RETURN ( TRUE )
   ENDIF

   selected_tables = build_up_tables()

{  CREATE OBJECT "STD_LIST_GRID" , rep_tab_list_grid }
   CREATE OBJECT PROMPT_CLASS_GRID , rep_tab_list_grid

   ARRAY rep_tab_list_grid . user_info

   rep_tab_list_grid . title_size_top = 2
   rep_tab_list_grid . title_text_top [ 1, 2 ] = "Table"
   rep_tab_list_grid . title_text_top [ 2, 1 ] = "Link"
   rep_tab_list_grid . title_text_top [ 2, 2 ] = "Table"
   rep_tab_list_grid . title_text_top [ 3, 1 ] = "Link"
   rep_tab_list_grid . title_text_top [ 3, 2 ] = "Direction"
   rep_tab_list_grid . title_text_top [ 4, 2 ] = LEVEL_TEXT

   t = 0
   col_1_w = LENGTH(rep_tab_list_grid . title_text_top [ 1, 2 ])
   col_2_w = LENGTH(rep_tab_list_grid . title_text_top [ 2, 2 ])
   col_3_w = LENGTH(rep_tab_list_grid . title_text_top [ 3, 2 ])
   col_4_w = LENGTH(rep_tab_list_grid . title_text_top [ 4, 2 ])

   WHILE t < report_tables DO
      t = t + 1
      rep_tab_list_grid.user_info[ t, 1 ] = rep_tab_arr [ t, rtn_pos ]
      rep_tab_list_grid.user_info[ t, 2 ] = " "
      rep_tab_list_grid.user_info[ t, 3 ] = rep_tab_arr [ t, rtd_pos ]
      rep_tab_list_grid.user_info[ t, 4 ] = rep_tab_arr [ t, rtv_pos ]
      IF   rep_tab_arr[ t, rtr_pos ] > 0
      THEN rep_tab_list_grid . user_info[ t, 2 ] =
               rep_tab_arr[ rep_tab_arr[ t, rtr_pos ], rtn_pos ]
      ENDIF
      l_1 = LENGTH(rep_tab_list_grid.user_info[ t, 1 ])
      l_2 = LENGTH(rep_tab_list_grid.user_info[ t, 2 ])
      IF col_1_w < l_1 THEN
         col_1_w = l_1
      ENDIF
      IF col_2_w < l_2 THEN
         col_2_w = l_2
      ENDIF
   ENDWHILE

   CREATE OBJECT PROMPT_CLASS_FORM, get_rep_tab
	in_ex_obj = rep_tab_list_grid

   IF   report_tables+3 > wh
   THEN get_rep_tab . height = wh
   ELSE get_rep_tab . height = report_tables + 3
   ENDIF

   get_rep_tab . width    =  col_1_w + col_2_w + col_3_w + col_4_w + 3
   get_rep_tab . row      =  wr
   get_rep_tab . column   =  wc + 2
   get_rep_tab . border   =  TRUE
   get_rep_tab . header   =  "Select Actual Table"
   get_rep_tab . footer   =  "Press DO:Select SELECT:Links EXIT:Quit"
   get_rep_tab . button_style = FORM_BUTTON_OK

{  rep_tab_list_grid . maximum_select = 0 }
   rep_tab_list_grid . height  = get_rep_tab . height
   rep_tab_list_grid . column  = 1
   rep_tab_list_grid . cell_columns = 4
   rep_tab_list_grid . cell_rows = report_tables
   rep_tab_list_grid . enabled = TRUE
   rep_tab_list_grid . display_cell_routine = "display_tab_cell"
   rep_tab_list_grid . prompt_cell_routine = "wait_key"
   rep_tab_list_grid . remove_routine = "do_nothing"
   rep_tab_list_grid . select_routine = "table_link_fields"
   rep_tab_list_grid . width = get_rep_tab . width
   rep_tab_list_grid . column_size [ 1 ] = col_1_w
   rep_tab_list_grid . column_size [ 2 ] = col_2_w
   rep_tab_list_grid . column_size [ 3 ] = col_3_w
   rep_tab_list_grid . column_size [ 4 ] = col_4_w
   rep_tab_list_grid . title_separator_top = GRID_SEPARATOR_BOTH
   rep_tab_list_grid . current_row    = 1

   get_rep_tab . add_prompt ( rep_tab_list_grid )

   IF gui THEN

      gui_adjustments ( get_rep_tab, 4 )
          add_button ( get_rep_tab, "SELECT", 3, 4,
"include_field","AD-HOC-REPORTS","Links" )
      add_button ( get_rep_tab, "REMOVE", 4, 4,
"exclude_field","AD-HOC-REPORTS","Remove" )
   ENDIF

   get_rep_tab . add_frame ( "" , 1 , 1 , report_tables , get_rep_tab . width )

   get_rep_tab . start_prompt()

   rep_tab_list_grid.set_position(1,actual_table_no)

   REPEAT

      get_rep_tab . wait_prompt()

      the_key = get_rep_tab . get_lastkey()
      chosen_table = rep_tab_list_grid . current_row

   UNTIL ( the_key = "EXIT" ) OR ( the_key = "DO" )

   get_rep_tab . end_prompt()

   IF   the_key <> "EXIT"
   THEN actual_table_no = chosen_table
   ENDIF

ENDROUTINE


ROUTINE  generic_display_cell ( self, VALUE cell_col, VALUE cell_row, window,
                                VALUE col, VALUE row, VALUE cell_w,
                                VALUE cell_h, VALUE bold_on, VALUE blink_on )
   DECLARE  val, l, t

   val = substring(strip(self . user_info [ cell_row, cell_col ]), 1, cell_w )

   t = self . title_text_top [ cell_col, 1 ]
   IF (t = EMPTY) OR (BLANK(t)) THEN
      t = self . title_text_top [ cell_col, 2 ]
   ENDIF

   IF ((t = WIDTH_TEXT) OR (t = ORDER_TEXT) OR
       (t = LEVEL_TEXT) OR (t = SKIP_TEXT)) AND
      (NOT(gui)) THEN
{     val = strip(val) }
      l = length(val)
      val = pad(""," ",cell_w-l) : substring(val,1,l)
   ENDIF

   DISPLAY  val
            AT col, row
            BOLD = bold_on
            INVERSE = blink_on
            IN WINDOW window

ENDROUTINE


ROUTINE  insert_filter_row ( self )

   DECLARE  r, c

   r = filter_grid . cell_rows
   WHILE r > filter_grid.current_row DO
      c = 0
      WHILE c < filter_grid.cell_columns DO
         c = c + 1
         filter_grid . user_info [ r+1, c ] = filter_grid . user_info [ r, c ]
      ENDWHILE
      r = r - 1
   ENDWHILE

   filter_grid . user_info [ filter_grid.current_row+1, 1 ] = EMPTY
   filter_grid . user_info [ filter_grid.current_row+1, 2 ] = EMPTY
   filter_grid . user_info [ filter_grid.current_row+1, 3 ] = EMPTY

   filter_grid.insert_row( filter_grid.current_row, 1, GRID_SEPARATOR_NONE )
   IF filter_grid.current_row > 0 THEN
      filter_grid.redisplay_row ( filter_grid.current_row )
   ENDIF

ENDROUTINE


ROUTINE  delete_grid_row ( self )

   DECLARE  r, c

   r = filter_grid . current_row
   WHILE r < filter_grid . cell_rows DO
      c = 0
      WHILE c < filter_grid.cell_columns DO
         c = c + 1
         filter_grid . user_info [ r, c ] = filter_grid . user_info [ r+1, c ]
      ENDWHILE
      r = r + 1
   ENDWHILE

   IF filter_grid.current_row > 0 THEN
      filter_grid.remove_row( filter_grid.current_row )
   ENDIF

ENDROUTINE


ROUTINE  prompt_filter ( self, VALUE cell_col, VALUE cell_row, window,
                         VALUE col, VALUE row, VALUE cell_w, VALUE cell_h )
   ARRAY key_arr

   IF (cell_col = fgf_pos)
   THEN
      prompt for filter_grid.user_info[ cell_row, cell_col ]
             AT col, row
             IN window window
             TO col + cell_w - 1
             BOLD = TRUE
             CHOOSE OUTOF field_arr
   ELSEIF (cell_col = fgo_pos)
   THEN
      prompt for filter_grid.user_info[ cell_row, cell_col ]
             AT col, row
             IN window window
             TO col + cell_w - 1
             BOLD = TRUE
             CHOOSE OUTOF clause_arr
   ELSEIF (cell_col = fgc_pos)
   THEN
      transform_condition ( filter_grid.user_info[cell_row, cell_col], TRUE )
      prompt for filter_grid.user_info[ cell_row, cell_col ]
             AT col, row
             IN window window
             TO col + cell_w - 1
             BOLD = TRUE
             CHOOSE OUTOF cond_arr
      transform_condition ( filter_grid.user_info[cell_row, cell_col], FALSE )
   ELSE

{     Browse on key in actual or linked table ?      }
      the_field = self.user_info[cell_row,fgf_pos]
      the_cond  = self.user_info[cell_row,fgc_pos]
      the_table = rep_tab_arr[actual_table_no,rtn_pos]
      get_field_filter_info( the_field, the_cond, the_table,
                             the_format, browse_tab, browse_fld )
      IF   the_format = "B"
      THEN
         prompt for self.user_info[ cell_row, cell_col ]
                AT col, row
                IN WINDOW window
                TO col + cell_w - 1
                BOLD = TRUE
                BROWSE ON 'browse_tab'.'browse_fld'
      ELSEIF the_format = "F"
      THEN
         prompt for filter_grid.user_info[ cell_row, cell_col ]
                AT col, row
                IN WINDOW window
                TO col + cell_w - 1
                BOLD = TRUE
                FORMAT 'browse_tab'.'browse_fld'
      ELSE
         prompt for self.user_info[ cell_row, cell_col ]
                AT col, row
                IN WINDOW window
                TO col + cell_w - 1
                BOLD = TRUE
                FORMAT TEXT
      ENDIF
   ENDIF

   display_filter ( filter_grid, cell_col, cell_row, window,
                          col, row, cell_w, cell_h )

ENDROUTINE

ROUTINE  get_field_filter_info ( VALUE the_field, VALUE the_cond,
                                 VALUE the_table,
                                 the_format, browse_tab, browse_fld )
      browse_tab = EMPTY
      browse_fld = EMPTY
      the_format = "T"

      IF (the_field <> EMPTY) AND
         (NOT(BLANK(the_field))) AND
         (the_cond <> EMPTY) AND
         (NOT(BLANK(the_cond))) THEN
         IF (the_cond = "=")
         THEN
            get_table_details 'the_table', "KEY0_FIELD", key_arr
            IF size_of_array( key_arr ) > 0 THEN
               IF key_arr[1] = the_field THEN
                  the_format = "B"
                  browse_tab = the_table
                  browse_fld = the_field
               ENDIF
            ENDIF
            IF ( the_format <> "B" ) THEN
               browse_tab = EMPTY
               browse_fld = EMPTY
               get_field_details 'the_table'.'the_field',
                                 "LINK_TABLE", browse_tab
               get_field_details 'the_table'.'the_field',
                                 "LINK_FIELD", browse_fld
               IF (browse_tab <> EMPTY) AND (browse_fld <> EMPTY) THEN
                  the_format = "B"
               ENDIF
            ENDIF
         ENDIF
      ENDIF

      IF the_format = "T" THEN
         IF INDEX( ">=<=", strip(the_cond) ) > 0 THEN
            the_format = "F"
            browse_tab = the_table
            browse_fld = the_field
         ENDIF
      ENDIF

ENDROUTINE


ROUTINE  transform_order ( val, VALUE col_from, ord_row )

   DECLARE col_to

   IF     col_from = 1
   THEN   col_to   = 2
   ELSE   col_to   = 1
   ENDIF

   IF   asc_desc[1,col_from]=val
   THEN ord_row = 1
   ELSE ord_row = 2
   ENDIF

   val = asc_desc[ord_row,col_to]

ENDROUTINE


ROUTINE  prompt_order  ( self, VALUE cell_col, VALUE cell_row, window,
                         VALUE col, VALUE row, VALUE cell_w, VALUE cell_h )

   DECLARE  r

   IF (cell_col = ogf_pos)
   THEN
      generic_display_cell ( order_grid, cell_col, cell_row, window,
                             col, row, cell_w, cell_h, TRUE ,
                             get_blink_flag(self, cell_col, cell_row) )
      no_prompt()
   ELSEIF (cell_col = ogo_pos)
   THEN
      prompt for order_grid.user_info[ cell_row, cell_col ]
             AT col, row
             IN WINDOW window
             TO col + cell_w - 1
             BOLD = TRUE
             FORMAT INTEGER
   ELSE
      transform_order( order_grid.user_info[ cell_row, cell_col ], 1, r)
      prompt for order_grid.user_info[ cell_row, cell_col ]
             AT col, row
             IN window window
             TO col + cell_w - 1
             BOLD = TRUE
             CHOOSE OUTOF asc_desc
      transform_order( order_grid.user_info[ cell_row, cell_col ], 2, r)
   ENDIF

   generic_display_cell ( order_grid, cell_col, cell_row, window,
                          col, row, cell_w, cell_h, FALSE,
                          get_blink_flag(self, cell_col, cell_row) )
ENDROUTINE


ROUTINE  no_prompt
   IF   NOT(gui)
   THEN getkey
   ELSE PROMPT IN WINDOW window ON LINE cell_row FROM cell_col
   ENDIF
ENDROUTINE

ROUTINE  prompt_link   ( self, VALUE cell_col, VALUE cell_row, window,
                         VALUE col, VALUE row, VALUE cell_w, VALUE cell_h )
   IF cell_col = mnf_pos
   THEN
      generic_display_cell ( rep_col_list_grid, cell_col, cell_row, window,
                             col, row, cell_w, cell_h, TRUE, FALSE )

      no_prompt()


   ELSEIF cell_col = mnl_pos
   THEN
      prompt for rep_col_list_grid.user_info[ cell_row, cell_col ]
             AT col, row
             IN window window
             TO col + cell_w - 1
             BOLD = TRUE
             CHOOSE OUTOF link_arr
   ELSE flash_message("Unknown column:":cell_col,TRUE)
      no_prompt()
   ENDIF

   generic_display_cell ( rep_col_list_grid, cell_col, cell_row, window,
                          col, row, cell_w, cell_h, FALSE, FALSE )

ENDROUTINE


ROUTINE  prompt_field  ( self, VALUE cell_col, VALUE cell_row, window,
                         VALUE col, VALUE row, VALUE cell_w, VALUE cell_h )
   IF (cell_col = cgf_pos) OR (cell_col = cgt_pos )
   THEN
      generic_display_cell ( self, cell_col, cell_row, window,
                             col, row, cell_w, cell_h, TRUE ,
                             get_blink_flag(self, cell_col, cell_row) )
      no_prompt()
   ELSEIF ( cell_col = cgw_pos ) OR ( cell_col = cga_pos )
   THEN
      prompt for self.user_info[ cell_row, cell_col ]
             AT col, row
             IN window window
             TO col + cell_w - 1
             BOLD = TRUE
             CHOOSE OUTOF yes_no
   ELSEIF ( cell_col = cgh_pos )
   THEN
      prompt for self.user_info[ cell_row, cell_col ]
             AT col, row
             IN window window
             TO col + cell_w - 1
             BOLD = TRUE
             FORMAT TEXT
   ELSEIF ( cell_col = cgj_pos )
   THEN
      prompt for self.user_info[ cell_row, cell_col ]
             AT col, row
             IN window window
             TO col + cell_w - 1
             BOLD = TRUE
             CHOOSE OUTOF just_arr
   ELSEIF ( cell_col = cgm_pos )
   THEN
      IF   self . user_info [ cell_row, cgt_pos ] = "Date"
      THEN
         local_var = self.user_info[ cell_row, cell_col ]
         prompt for local_var
                AT col, row
                IN window window
                TO col + cell_w - 1
                BOLD = TRUE
                FORMAT TEXT
         IF   date_handler("FORMAT",local_var,today,local_res,local_err)
         THEN self.user_info[cell_row,cell_col] = local_var
         ELSE flash_message(local_err,TRUE)
         ENDIF
      ELSEIF self . user_info [ cell_row, cgt_pos ] = "Real"
      THEN
         prompt for self.user_info[ cell_row, cell_col ]
                AT col, row
                IN window window
                TO col + cell_w - 1
                BOLD = TRUE
                FORMAT INTEGER
                WITH   ( minimum = 0 )
      ELSE
         generic_display_cell ( self, cell_col, cell_row, window,
                                col, row, cell_w, cell_h, TRUE ,
                                get_blink_flag(self, cell_col, cell_row) )
         no_prompt()
      ENDIF
   ELSE
      prompt for self.user_info[ cell_row, cell_col ]
             AT col, row
             IN WINDOW window
             TO col + cell_w - 1
             BOLD = TRUE
             FORMAT INTEGER
   ENDIF

   generic_display_cell ( self, cell_col, cell_row, window,
                          col, row, cell_w, cell_h, FALSE,
                          get_blink_flag(self, cell_col, cell_row) )
ENDROUTINE


ROUTINE  get_blink_flag ( self, VALUE cell_col, VALUE cell_row )

   DECLARE  blink_flag, disp_field_name, r

   blink_flag = FALSE

   IF   cell_col = cgf_pos
   THEN disp_field_name = self.user_info[ cell_row, cgf_pos ]
        IF   in_ex [ cell_row, new_pos ]
        THEN blink_flag = TRUE
        ENDIF
   ENDIF
   RETURN ( blink_flag )

ENDROUTINE


ROUTINE  display_field ( self, VALUE cell_col, VALUE cell_row, window,
                         VALUE col, VALUE row, VALUE cell_w, VALUE cell_h )

   generic_display_cell ( self, cell_col, cell_row, window,
                          col, row, cell_w, cell_h, FALSE,
                          get_blink_flag(self, cell_col, cell_row) )
ENDROUTINE


ROUTINE  display_link  ( self, VALUE cell_col, VALUE cell_row, window,
                         VALUE col, VALUE row, VALUE cell_w, VALUE cell_h )

   generic_display_cell ( self, cell_col, cell_row, window,
                          col, row, cell_w, cell_h, FALSE, FALSE )
ENDROUTINE


ROUTINE  get_cond_row ( VALUE the_value, VALUE the_column, row_found )

   DECLARE  found, c

   IF (the_value = EMPTY) OR BLANK(the_value) THEN
      return ( FALSE )
   ENDIF

   found = FALSE
   c = 0
   WHILE (c<CONDITIONS) AND (NOT(found))
      c = c + 1
      IF cond_arr [ c, the_column ] = the_value THEN
         found = TRUE
         row_found = c
      ENDIF
   ENDWHILE

   IF NOT(found) THEN
      flash_message("Could not find condition:":the_value:
                    " in column:":the_column,TRUE)
   ENDIF

   return ( found )

ENDROUTINE


ROUTINE  transform_condition ( the_value, VALUE got_mnemonic )

   DECLARE  cond_row

   IF   got_mnemonic
   THEN from_col = 1
        to_col   = 2
   ELSE from_col = 2
        to_col   = 1
   ENDIF
   IF get_cond_row ( the_value, from_col, cond_row ) THEN
      the_value = cond_arr [ cond_row, to_col ]
   ENDIF

ENDROUTINE


ROUTINE  display_filter( self, VALUE cell_col, VALUE cell_row, window,
                         VALUE col, VALUE row, VALUE cell_w, VALUE cell_h )

   val = self . user_info [ cell_row, cell_col ]
   IF   val = EMPTY
   THEN val = pad( "", " ", cell_w )
   ELSE val = substring( val, 1, cell_w )
   ENDIF

   DISPLAY  val
            AT col, row
            BOLD = FALSE
            INVERSE = FALSE
            IN WINDOW window

ENDROUTINE


ROUTINE  display_cell ( self, VALUE cell_col, VALUE cell_row, window,
                        VALUE col, VALUE row, VALUE cell_w, VALUE cell_h )
   generic_display_cell ( self, cell_col, cell_row, window,
                          col, row, cell_w, cell_h, FALSE, FALSE )
ENDROUTINE


ROUTINE  table_used ( self, VALUE cell_row, VALUE cell_col )

   IF   cell_col <> 1
   THEN return ( FALSE )
   ELSE t_name = self.user_info[cell_row,cell_col]
        t = 0
        WHILE t<selected_tables DO
           t = t+1
           IF rep_tab_arr[the_tables[t,ttr_pos],rtn_pos] = t_name THEN
              return ( TRUE )
           ENDIF
        ENDWHILE
   ENDIF
   return ( FALSE )

ENDROUTINE


ROUTINE  display_tab_cell ( self, VALUE cell_col, VALUE cell_row, window,
                            VALUE col, VALUE row, VALUE cell_w, VALUE cell_h )
   generic_display_cell ( self, cell_col, cell_row, window,
                          col, row, cell_w, cell_h, FALSE,
                          table_used( self, cell_row, cell_col ) )
ENDROUTINE


ROUTINE  wait_key     ( self, VALUE cell_col, VALUE cell_row, window,
                        VALUE col, VALUE row, VALUE cell_w, VALUE cell_h )

   generic_display_cell ( self, cell_col, cell_row, window,
                          col, row, cell_w, cell_h, TRUE ,
                          table_used( self, cell_row, cell_col ) )
   no_prompt()

   generic_display_cell ( self, cell_col, cell_row, window,
                          col, row, cell_w, cell_h, FALSE,
                          table_used( self, cell_row, cell_col ) )
ENDROUTINE


ROUTINE  rep_att_prompt ( self, VALUE cell_col, VALUE cell_row, window,
                        VALUE col, VALUE row, VALUE cell_w, VALUE cell_h )

   generic_display_cell ( self, cell_col, cell_row, window,
                          col, row, cell_w, cell_h, TRUE , FALSE )
   IF  (cell_col = 2 ) THEN

{M-1171 HBe 26-1-99: cell_row=5 and cell_row = 7 included below}

      IF  (cell_row = 1) OR (cell_row = 5) OR (cell_row = 7)
      THEN
{        prompt_user ( "text60", "Enter Report Title", EMPTY,
                               FALSE, self.user_info[ cell_row, cell_col ] ) }
         prompt for self.user_info[ cell_row, cell_col ]
                AT col, row
                IN window window
                TO col + cell_w - 1
                BOLD = TRUE
                FORMAT TEXT60

{M-1171 HBe 26-1-99: cell_row=8 included below}

      ELSEIF (cell_row=2) OR (cell_row=3) OR (cell_row=8)
      THEN
         prompt for self.user_info[ cell_row, cell_col ]
                AT col, row
                IN window window
                TO col + cell_w - 1
                BOLD = TRUE
                CHOOSE OUTOF yes_no

{AS 1171 HBe 26-1-99}

      ELSEIF (cell_row=4)
      THEN
         prompt for self.user_info[ cell_row, cell_col ]
                AT col, row
                IN WINDOW window
                TO col + cell_w - 1
                BOLD = TRUE
                FORMAT INTEGER
                WITH   ( minimum = 0 )
                WITH   ( maximum = 15 )


{AS 1233 HBe 8-10-99}

      ELSEIF (cell_row=6)
      THEN
         prompt for self.user_info[ cell_row, cell_col ]
                AT col, row
                IN WINDOW window
                TO col + cell_w - 1
                BOLD = TRUE
                FORMAT INTEGER
                WITH   ( minimum = 0 )
                WITH   ( maximum = 25 )

{AE 1233 HBe 8-10-99}


      ELSEIF (cell_row=9) OR (cell_row=10)
      THEN
         prompt for self.user_info[ cell_row, cell_col ]
                AT col, row
                IN WINDOW window
                TO col + cell_w - 1
                BOLD = TRUE
                FORMAT INTEGER
                WITH   ( minimum = 1 )
                WITH   ( maximum = 10 )


{AE 1171 HBe 26-1-99}



      ELSE flash_message("ERROR: Last row recognized is 10",TRUE)
      ENDIF
   ELSE no_prompt()
   ENDIF

   generic_display_cell ( self, cell_col, cell_row, window,
                          col, row, cell_w, cell_h, FALSE, FALSE )
ENDROUTINE


ROUTINE  tab_att_prompt ( self, VALUE cell_col, VALUE cell_row, window,
                        VALUE col, VALUE row, VALUE cell_w, VALUE cell_h )

   generic_display_cell ( self, cell_col, cell_row, window,
                          col, row, cell_w, cell_h, TRUE , FALSE )
   IF  (cell_col = 2 ) THEN
      IF  (cell_row = 1) OR (cell_row = 3)
      THEN
         prompt for self.user_info[ cell_row, cell_col ]
                AT col, row
                IN window window
                TO col + cell_w - 1
                BOLD = TRUE
                CHOOSE OUTOF yes_no
         IF (rep_tab_arr [ actual_table_no, rtd_pos ] = LINK_UP) AND
            (self.user_info[cell_row,cell_col] = "Yes")          AND
            (cell_row = 1)
         THEN
            flash_message(
            "No page break can be set for upward linked tables",TRUE)
            self.user_info[cell_row,cell_col] = "No"
         ENDIF
      ELSEIF (cell_row = 2)
      THEN
         prompt for self.user_info[ cell_row, cell_col ]
                AT col, row
                IN window window
                TO col + cell_w - 1
                BOLD = TRUE
                FORMAT INTEGER
                WITH   ( minimum = 0 )
{AS1171 28-1-99 HBe}
      ELSEIF (cell_row = 4)
      THEN
         prompt for self.user_info[ cell_row, cell_col ]
                AT col, row
                IN window window
                TO col + cell_w - 1
                BOLD = TRUE
                FORMAT INTEGER
                WITH   ( minimum = 0 )
                WITH   ( maximum = 9 )
{AE1171 28-1-99 HBe}
      ELSE flash_message("ERROR: Last row recognized is 4",TRUE)
      ENDIF
   ELSE no_prompt()
   ENDIF

   generic_display_cell ( self, cell_col, cell_row, window,
                          col, row, cell_w, cell_h, FALSE, FALSE )
ENDROUTINE


ROUTINE  add_filter ( VALUE rep_tab_row, VALUE field_name )

   PROMPT   OBJECT  filter_cond
            ON LINE pr_row
            FROM    pr_col
            CHOOSE  OUTOF cond_arr
   col_pro . add_prompt ( filter_cond )

   PROMPT   OBJECT  filter_val
            ON LINE pr_row + 1
            FROM    pr_col
            FORMAT  'rep_tab_arr[ rep_tab_row, rtn_pos ]'.'field_name'
   col_pro . add_prompt ( filter_val )

   col_pro . start_prompt ()

   DISPLAY "Condition"
         ON LINE pr_row     FROM dis_col in window col_pro . window
   DISPLAY "Value"
         ON LINE pr_row + 1 FROM dis_col in window col_pro . window

   REPEAT

      col_pro . wait_prompt ()

      pro_key = col_pro . get_lastkey()

      IF pro_key = "DO" THEN

         IF filter_cond . value = ARRAY_SELECT_LIKE THEN
            filter_val  . value = "%" : filter_val . value : "%"
         ENDIF

         IF   NOT (find_filter_row ( rep_tab_row, rep_fil_row ))
         THEN filters = filters + 1
              rep_fil_row = filters
              rep_filter_arr[rep_fil_row,rfr_pos] = rep_tab_row
              rep_filter_arr[rep_fil_row,rfn_pos] = 0
         ENDIF

         n_fil = rep_filter_arr[rep_fil_row,rfn_pos] + 1
         rep_filter_arr[rep_fil_row,rfn_pos] = n_fil
         first_pos = rfn_pos+((n_fil-1)*rfn_off) + 1
         rep_filter_arr[rep_fil_row,first_pos  ] = field_name
         rep_filter_arr[rep_fil_row,first_pos+1] = filter_cond.value
         rep_filter_arr[rep_fil_row,first_pos+2] = filter_val .value

      ENDIF

   UNTIL ( pro_key = "EXIT" ) OR ( pro_key = "DO" )

   col_pro . end_prompt ()

ENDROUTINE


ROUTINE  find_filter_row ( VALUE rep_tab_row, rep_filter_row )

   rep_filter_row = 0
   r = 0
   WHILE r < filters DO
      r = r + 1
      IF rep_filter_arr [ r, rfr_pos ] = rep_tab_row THEN
         rep_filter_row = r
         return ( TRUE )
      ENDIF
   ENDWHILE

   RETURN ( FALSE )

ENDROUTINE


ROUTINE  del_filter ( VALUE rep_tab_row, VALUE field_name )

   IF   NOT ( find_filter_row ( rep_tab_row, f_row ) )
   THEN return
   ENDIF

   next_fil = 0
   WHILE next_fil < rep_filter_arr[ f_row, rfn_pos ] DO
      next_fil = next_fil + 1
      name_pos = rfn_pos+((next_fil-1)*rfn_off)+1
      IF   rep_filter_arr[f_row,name_pos] = field_name
      THEN tab_fils = rep_filter_arr[f_row,rfn_pos]
           n = next_fil
           WHILE n < tab_fils DO
              np = rfn_pos+((n-1)*rfn_off)+1
              rep_filter_arr[f_row,np  ]=rep_filter_arr[f_row,np  +rfn_off]
              rep_filter_arr[f_row,np+1]=rep_filter_arr[f_row,np+1+rfn_off]
              rep_filter_arr[f_row,np+2]=rep_filter_arr[f_row,np+2+rfn_off]
              n = n + 1
           ENDWHILE
           rep_filter_arr[f_row,rfn_pos] = tab_fils-1
           next_fil = next_fil - 1
      ENDIF
   ENDWHILE

ENDROUTINE


ROUTINE  show_filter ( VALUE rep_tab_row, VALUE field_name )
   flash_message("Show filter ":rep_tab_row:"/":field_name,TRUE)
ENDROUTINE


ROUTINE  field_in_list ( VALUE field_name, row_found )

   DECLARE r

   row_found = 0
   r = 0
   WHILE (r < cols) AND (row_found=0) DO
      r = r + 1
      IF  (rep_col_arr[ r, rcr_pos ] = actual_table_no) AND
          (rep_col_arr[ r, rcn_pos ] = field_name )
      THEN row_found = r
      ENDIF
   ENDWHILE

   IF   row_found > 0
   THEN return ( TRUE )
   ELSE return ( FALSE )
   ENDIF

ENDROUTINE

{ROUTINE  prompt_user1 ( VALUE prompt_type, VALUE prompt_title, VALUE fld_name,
                       VALUE do_browse  ,       prompt_val )

NB: ERSTATTET AF PROMPT_USER I TOOLBOX!!

   DECLARE  rc

   CREATE OBJECT PROMPT_CLASS_FORM, the_prompt

   the_prompt . height   =  5
   the_prompt . width    =  60
   the_prompt . row      =  10
   the_prompt . column   =  10
   the_prompt . border   =  TRUE
   the_prompt . header   =  prompt_title
   the_prompt . footer   =  "Press DO to accept / Exit to quit"
   the_prompt . button_style = FORM_BUTTON_OK

   IF   do_browse
   THEN
      PROMPT   OBJECT get_object
               BROWSE ON 'prompt_type'
               ON LINE 3
               FROM    3
               IN    WINDOW the_prompt . window
   ELSE
      IF (BLANK(fld_name) OR (fld_name=EMPTY))
      THEN
         PROMPT   OBJECT  get_object
                  ON LINE 3
                  FROM    3
                  FORMAT  'prompt_type'
      ELSE
         PROMPT   OBJECT  get_object
                  ON LINE 3
                  FROM    3
                  FORMAT  'prompt_type'.'fld_name'
      ENDIF
   ENDIF

   the_prompt . add_prompt ( get_object )

   get_object . value = prompt_val

   the_prompt . add_frame ( "" , 1 , 1 , the_prompt.height , the_prompt.width )

   the_prompt . start_prompt()

   REPEAT

      the_prompt . wait_prompt()

   UNTIL ( ( the_prompt . get_lastkey () = "EXIT" ) OR
           ( the_prompt . get_lastkey () = "DO"   ) )

   IF   the_prompt . get_lastkey() = "DO"
   THEN prompt_val = get_object . value
        rc = TRUE
   ELSE rc = FALSE
   ENDIF

   the_prompt . end_prompt()

   return ( rc )

ENDROUTINE}


ROUTINE  create_report

   CONSTANT tlh_pos = 1
   CONSTANT tlt_pos = 2
   CONSTANT tli_pos = 3
   CONSTANT tln_pos = 4
   CONSTANT tlr_pos = 1
   CONSTANT tlv_pos = 2
   CONSTANT tln_off = 2

   CONSTANT tcn_pos = 1
   CONSTANT tcr_pos = 1
   CONSTANT tch_pos = 2
   CONSTANT tcn_off = 2

   ARRAY sel_arr
   ARRAY dummy_arr
   ARRAY the_lines
   ARRAY local_line_arr

   DECLARE rep_name_output

   selected_tables = build_up_tables()

   IF selected_tables = 0 THEN
      flash_message("No Fields Specified",TRUE)
      return
   ENDIF

   build_up_columns()

   IF   NOT prompt_for_missing_filters()
   THEN return
   ENDIF

   pct_done = 0
   ON CONTROL_C
      control_c_pressed = TRUE
      flash_message("Selecting Data Interrupted. " :
                    strip(pct_done) : " % done", TRUE)
   ENDON

   indent_level  = 0
   master_row    = 0
   total_line_no = 0
   control_c_pressed = FALSE

   set_up_install_window_class ( )
   CREATE OBJECT INSTALL_WINDOW_CLASS, install_bar
   install_bar . header = "Getting Data from the Database"
   install_bar . row    = 16
   install_bar . counter_message =
                GET_USER_MESSAGE("SMP_CREATEMENU_PARSE_MENU_COUNTER_MESSAGE",1)
   install_bar . step   = 10
   install_bar . start_value = 0
   install_bar . end_value   = 0

   install_bar . start_install ( )

   print_table ( 1, dummy_arr, 0, report_lines, 0 )

   install_bar . end_install ( )

   IF report_lines > 0 THEN

      set_up_install_window_class ( )
      CREATE OBJECT INSTALL_WINDOW_CLASS, install_bar
      install_bar . header = "Printing the Report"
      install_bar . row    = 16
      install_bar . counter_message =
                GET_USER_MESSAGE("SMP_CREATEMENU_PARSE_MENU_COUNTER_MESSAGE",1)
      install_bar . step   = 10
      install_bar . start_value = 0
      install_bar . end_value   = report_lines

      install_bar . start_install ( )

      IF print_head = "Yes"
      THEN
         pc     = 0
         the_op = OPERATOR
         the_tm = NOW
         print_header()
         last_col_head_printed = EMPTY
         set length 62
         ON NEW PAGE
            print_header()
         ENDON
      ENDIF
{AS1171 HBe 27-1-99}
      IF print_rep_name = "Yes" THEN
         rep_name_output = "Report: ":report_id
         rep_name_id (rep_name_output)
         last_col_head_printed = EMPTY
         set length 62
         ON NEW PAGE
           rep_name_id (rep_name_output)
         ENDON
      ENDIF

      IF strip(top_text) <> ""
      THEN
         make_blank_lines(top_indent)
         print_top_text(top_text)
         make_blank_lines(top_indent)
         last_col_head_printed = EMPTY
         set length 62
         ON NEW PAGE
           make_blank_lines(top_indent)
           print_top_text(top_text)
           make_blank_lines(top_indent)
         ENDON
      ENDIF

      IF (strip(top_text) = "") AND (print_head = "No") AND (print_rep_name = "No")
         THEN
         set length 9999999
         ON NEW PAGE
         ENDON
      ENDIF


{AE1171 HBe 27-1-99}


      IF print_crit = "Yes" THEN

LITERAL

Selection Filters
$ENDLITERAL

         tab_no = 0
         WHILE tab_no < selected_tables DO
            tab_no = tab_no + 1
            rep_tab_row = the_tables[tab_no,ttr_pos]
            IF find_filter_row ( rep_tab_row, rep_filter_row ) THEN
               tab_name = rep_tab_arr[rep_tab_row,rtn_pos]
LITERAL

Table: $tab_name____________________________________________
       Clause Field               Cond  Value
$ENDLITERAL
               f = 0
               WHILE f < rep_filter_arr[ rep_filter_row, rfn_pos ] DO
                  f = f + 1
                  pos = rfn_pos + (f-1)*rfn_off
                  IF   f=1
                  THEN cla = ""
                  ELSE cla   = rep_filter_arr[rep_filter_row,pos+1]
                  ENDIF
                  field_name = strip(rep_filter_arr[rep_filter_row,pos+2])
                  cond       = strip(rep_filter_arr[rep_filter_row,pos+3])
                  val        = strip(rep_filter_arr[rep_filter_row,pos+4])
LITERAL
       $cla__ $field_name________ $cond $val________________________________________
$ENDLITERAL
               ENDWHILE
            ENDIF
         ENDWHILE

         NEW PAGE

      ENDIF

      l = 0
      ON CONTROL_C
         control_c_pressed = TRUE
         flash_message("Printing Lines Interrupted at line ":strip(l):
                       " out of ":strip(report_lines):" lines",TRUE)
      ENDON

      control_c_pressed = FALSE
      WHILE (l < report_lines) AND (NOT(control_c_pressed)) DO
         l = l + 1
         install_bar . increase_one ( )

{        Build up next line   }
         local_lines = 1
         local_line_arr[1] = ""
         local_line_arr[2] = ""
         char_pos = 0

         col_row  = the_lines [ l, tlt_pos ]            { Row no in the_tables }
         tab_cols = the_tab_cols [ col_row, tcn_pos ]   { No of columns }

{        Check if skip page      }
         IF   rep_tab_arr[the_tables[col_row,ttr_pos],rtp_pos] = "Yes"
         THEN IF l > 1 THEN
                 NEW PAGE
              ENDIF
         ELSE IF the_lines[l,tlh_pos] THEN
                 make_blank_lines ( 1 )
              ENDIF
         ENDIF
{**LPE-S}
         header_line = FALSE
{**LPE-E}
         c = 0
         WHILE c < tab_cols
            c = c + 1
            pos = tcn_pos+((c-1)*tcn_off)       { Set header space or not }
            IF   (the_tab_cols[ col_row, pos+tch_pos ]) AND
                 (the_lines[l,tlh_pos])
            THEN header_line = TRUE
                 IF local_lines = 1 THEN
                    local_lines = 2
                 ENDIF
            ELSE header_line = FALSE
            ENDIF

            IF char_pos > 0 THEN       { One space between columns }
               char_pos = char_pos + 1
               pad_local_lines( 1, 0 )
            ENDIF

            the_field = the_tab_cols [col_row,pos+tcr_pos] { rep_col_arr Row }
            lf = 0
            not_found = TRUE
            val = ""
            WHILE (lf < the_lines [ l, tln_pos ]) AND (not_found) DO
               lf = lf + 1
               IF   the_field = the_lines[l,tln_pos+(tln_off*(lf-1))+tlr_pos]
               THEN not_found = FALSE
                    val = the_lines [ l, tln_pos+(tln_off*(lf-1))+tlv_pos ]
               ENDIF
            ENDWHILE
            IF (NOT(BLANK(strip(val)))) AND (val <> EMPTY) THEN

{              Formatting - Dates and Numbers                   }
               f = rep_col_arr[the_field,rcm_pos]
               IF NOT(BLANK(f)) THEN
                  IF   NUMTEXT(f)
                  THEN IF   NUMTEXT(val)
                       THEN f1 = NUMERIC(f) * 10
                            val1 = NUMERIC(val) * f1
                            IF  (f1 > 0) AND (INDEX(string(val1),"E")=0)
                            THEN
                                 val = STRIP(ROUND(NUMERIC(val) * f1) / f1)
                                 le = length(val)
                                 p = le
                                 WHILE p > 0 DO
                                    IF SUBSTRING(val,p,1) = "." THEN
                                       IF   (le-p) < f
                                       THEN val = val : PAD("","0",f-le+p)
                                       ELSE val = SUBSTRING(val,1,p+f)
                                       ENDIF
                                       p = 0
                                    ENDIF
                                    p = p - 1
                                 ENDWHILE
                            ELSEIF (INDEX(STRING(val),"E")=0) AND
                                   (NUMERIC(val) < 100000000)
                            THEN    val = STRING(ROUND(NUMERIC(val)))
                            ENDIF
                       ENDIF
                  ELSE IF   date_handler("FORMAT",f,val,form_val,local_err)
                       THEN val = form_val
                       ENDIF
{ Set Date Format is better performing but offers less functionality    }
{....             ELSE form_val = date(val)
                       SET DATE FORMAT f
                       val = strip(form_val)
                       RESTORE DATE FORMAT
.....}
                  ENDIF
               ENDIF
            ENDIF

            field_length = rep_col_arr[ the_field, rcl_pos ]
            justification= rep_col_arr[ the_field, rcj_pos ]

            IF   header_line
            THEN data_l = 2
            ELSE data_l = 1
            ENDIF

            col_header = rep_col_arr[the_field,rch_pos]
            IF   rep_col_arr[the_field,rca_pos] = "Yes"  { Header above ? }
            THEN IF header_line THEN
                    local_line_arr[1] = local_line_arr[1] :
                    fixed_length( col_header, field_length, justification )
                 ENDIF
            ELSE hl = length(col_header)
                 col_header = substring(col_header,1,hl) : " "
                 IF header_line THEN            { Header line spaces }
                    local_line_arr[1] = local_line_arr[1] :
                    fixed_length("", hl+field_length, "Left")
                 ENDIF
                 local_line_arr[data_l] = local_line_arr[data_l] : col_header
                 pad_local_lines( hl+1, data_l )
                 char_pos = char_pos + hl + 1
            ENDIF

            val_length = length ( val )
            ll = data_l
            IF   val_length > field_length
            THEN IF   rep_col_arr[ the_field, rcw_pos ] = "No"
                 THEN val = substring(val,1,field_length)       { No Wrap }
                      local_line_arr[data_l] = local_line_arr[data_l]:val
                 ELSE ll = data_l-1
                      p = 1
                      WHILE p <= val_length DO
                         ll = ll + 1
                         IF ll > local_lines THEN
                            local_lines = ll
                            local_line_arr[ll] = pad(""," ",char_pos)
                         ENDIF
                         local_line_arr[ll] = local_line_arr[ll] :
                                              substring(val,p,field_length)
                         p = p + field_length
                      ENDWHILE
                 ENDIF
            ELSE {adjust_field( val, field_length )}
                 local_line_arr[data_l] = local_line_arr[data_l]:
                 fixed_length( val, field_length, justification )
            ENDIF
            char_pos = char_pos + field_length
            pad_local_lines ( field_length, ll )


            IF rep_col_arr[ the_field, rcs_pos ] > 0 THEN
               next_local_line = 1
               WHILE next_local_line < rep_col_arr[the_field, rcs_pos] DO
                  local_line_arr[next_local_line+local_lines] = ""
                  next_local_line = next_local_line + 1
               ENDWHILE
               local_lines = local_lines + rep_col_arr[the_field,rcs_pos] - 1
               print_local_lines()
               local_lines = 1
               char_pos = 0
            ENDIF

         ENDWHILE

         print_local_lines()

      ENDWHILE

      install_bar . end_install ( )

      flash_message("Report Created. Data Lines Included:":
                     STRIP(report_lines):" Printed Lines:":strip(l), TRUE )

{MS1171 HBe 27-1-99: "End of report" changed to footer text.
LITERAL

                        ****** END OF REPORT ******
$ENDLITERAL                                                 }

make_blank_lines (foot_indent)

LITERAL
$foot_text__________________________________________________________
$ENDLITERAL


{ME1171 HBe 27-1-99}

      FLUSH_LITERAL

   ELSE  flash_message("No lines printed",TRUE)
   ENDIF

ENDROUTINE


ROUTINE  prompt_for_missing_filters

   DECLARE ok

   tab_no = 0
   ok = TRUE
   WHILE (tab_no < selected_tables) AND (ok) DO
      tab_no = tab_no + 1
      rep_tab_row = the_tables[tab_no,ttr_pos]
      IF find_filter_row ( rep_tab_row, rep_filter_row ) THEN
         tab_name = rep_tab_arr[rep_tab_row,rtn_pos]
         f = 0
         WHILE (f < rep_filter_arr[ rep_filter_row, rfn_pos ]) AND (ok) DO
            f = f + 1
            pos = rfn_pos + (f-1)*rfn_off
            field_name = strip(rep_filter_arr[rep_filter_row,pos+2])
            the_cond   = strip(rep_filter_arr[rep_filter_row,pos+3])
            val        = strip(rep_filter_arr[rep_filter_row,pos+4])
            IF (BLANK(val)) AND (INDEX("()",the_cond)=0) THEN
               get_field_filter_info( field_name, the_cond, tab_name,
                                      the_format, browse_tab, browse_fld )
               the_filter = EMPTY
               head_txt   = "Enter Missing Filters on " : tab_name
               prompt_txt = strip(field_name) : " " : strip(the_cond)
               IF     the_format = "B"
               THEN   ok = prompt_user ( browse_tab, head_txt,
                                         browse_fld, TRUE, prompt_txt,
                                         empty_arr, the_filter, l_key )
               ELSEIF the_format = "F"
               THEN   ok = prompt_user ( browse_tab, head_txt,
                                         browse_fld, FALSE, prompt_txt,
                                         empty_arr, the_filter, l_key )
               ELSE   ok = prompt_user ( "TEXT"    , head_txt,
                                         EMPTY     , FALSE, prompt_txt,
                                         empty_arr, the_filter, l_key )
               ENDIF
               IF ok THEN
                  rep_filter_arr[rep_filter_row,pos+4] = the_filter
               ENDIF
            ENDIF
         ENDWHILE
      ENDIF
   ENDWHILE

   RETURN ( ok )

ENDROUTINE


ROUTINE  make_blank_lines ( VALUE lines_to_skip )
   DECLARE  i
   i = 0
   WHILE i < lines_to_skip DO
      i = i + 1
LITERAL

$ENDLITERAL
   ENDWHILE
ENDROUTINE


ROUTINE  print_local_lines

         IF header_line THEN
            last_col_head_printed = local_line_arr[1]
            indent_line( last_col_head_printed, the_lines[l,tli_pos] )
         ENDIF

{        Print the line    }
         ll = 0
         WHILE ll < local_lines DO
            ll = ll + 1
            line = local_line_arr[ll]
            local_line_arr[ll] = ""
            indent_line ( line, the_lines[l,tli_pos] )
LITERAL
$line________________________________________________________________________________
$ENDLITERAL
         IF (header_line) AND (ll=1) THEN
            header_skip = rep_tab_arr[the_tables[col_row,ttr_pos],rts_pos]
            hs = 0
            WHILE hs<header_skip DO
               hs=hs+1
LITERAL

$ENDLITERAL
            ENDWHILE
         ENDIF

         ENDWHILE

ENDROUTINE


ROUTINE  fixed_length ( VALUE text, VALUE return_length, VALUE just )
   DECLARE l, ls, rs
   l = length( text )
   IF   l >= return_length
   THEN return(substring(text,1,return_length))
   ELSE IF   l=0
        THEN return(pad(""," ",return_length))
        ELSE IF     just = "Left"
             THEN   return(substring(text,1,l):pad(""," ",return_length-l))
             ELSEIF just = "Right"
             THEN   return(pad(""," ",return_length-l):substring(text,1,l))
             ELSE   ls = trunc((return_length-l)/2)
                    rs = return_length-l-ls
                    return(pad(""," ",ls):substring(text,1,l):pad(""," ",rs))
             ENDIF
        ENDIF
   ENDIF
ENDROUTINE


ROUTINE  pad_local_lines ( VALUE pad_length, VALUE start_line )

   DECLARE  r

   r = start_line
   WHILE r < local_lines DO
      r = r + 1
      local_line_arr[r] = local_line_arr[r] : pad(""," ",pad_length)
   ENDWHILE

ENDROUTINE


ROUTINE  build_up_tables

{  Find tables actually to select from  }
   selected_tables = 0
   tab_no = 0
   WHILE tab_no < report_tables DO
      tab_no = tab_no + 1
      IF in_report ( tab_no ) THEN
         selected_tables = selected_tables + 1
         the_tables [ selected_tables, ttr_pos ] = tab_no
         the_tables [ selected_tables, ttn_pos ] = 0
         the_tables [ selected_tables, tts_pos ] = FALSE
         the_tab_cols [ selected_tables, tcn_pos ] = 0

{        Maintain hierarchi of linked tables  }
         link_row = rep_tab_arr[ tab_no, rtr_pos ]
         IF link_row > 0 THEN
            t_no = selected_tables
            not_found = TRUE
            WHILE (t_no > 1) AND (not_found)  DO
               t_no = t_no - 1
               IF the_tables [ t_no, ttr_pos ] = link_row THEN
                  not_found = FALSE
                  link_tabs = the_tables[t_no,ttn_pos] + 1
                  the_tables[t_no,ttn_pos] = link_tabs
                  the_tables[t_no,ttn_pos+link_tabs] = selected_tables
               ENDIF
            ENDWHILE
            IF not_found THEN
               flash_message("ERROR: Could not find master table to:":
                              rep_tab_arr[ tab_no, rtn_pos ],TRUE)
               return
            ENDIF
         ENDIF

      ENDIF
   ENDWHILE

   return(selected_tables)

ENDROUTINE


ROUTINE  build_up_columns

   DECLARE  the_tab, col_row, pos, c, tab_cols, f_order, next_pos, tc

   the_tab = 0
   WHILE the_tab < selected_tables DO

      the_tab = the_tab + 1
      col_row = link_up_row ( the_tab )

      tab_cols = the_tab_cols [ col_row, tcn_pos ]

      c = 0
      WHILE c < cols DO
         c = c + 1
         IF rep_col_arr[c,rcr_pos] = the_tables[the_tab,ttr_pos] THEN

            f_order = rep_col_arr[c,rco_pos]
            next_pos = -1
            pos = 0
            WHILE (pos < tab_cols) AND (next_pos < 0) DO
               pos = pos + 1
               IF rep_col_arr[
                     the_tab_cols[col_row,tcn_pos+tcr_pos+((pos-1)*tcn_off)],
                              rco_pos] > f_order THEN
                  next_pos = pos
                  tc = tab_cols
                  WHILE tc >= pos DO
                    pos_int = tcn_pos + ((tc-1)*tcn_off)
                    tc1 = 0
                    WHILE tc1 < tcn_off DO
                     tc1 = tc1 + 1
                     the_tab_cols[col_row,pos_int+tc1+tcn_off] =
                     the_tab_cols[col_row,pos_int+tc1]
                    ENDWHILE
                    tc = tc - 1
                  ENDWHILE
               ENDIF
            ENDWHILE

            tab_cols = tab_cols + 1

            IF next_pos < 0 THEN
               next_pos = tab_cols
            ENDIF

            the_tab_cols [ col_row,tcn_pos+((next_pos-1)*tcn_off)+tcr_pos ] = c

         ENDIF
      ENDWHILE

      the_tab_cols [ col_row, tcn_pos ] = tab_cols

   ENDWHILE

{  Set Column Header Flag for each column }
   the_tab = 0
   WHILE the_tab < selected_tables DO

      the_tab = the_tab + 1
      c1 = 0
      last_start = 1
      header_on = FALSE
      WHILE c1 < the_tab_cols[the_tab,tcn_pos] DO
         c1 = c1 + 1
         pos = tcn_pos + ((c1-1)*tcn_off)
         IF   rep_col_arr[the_tab_cols[the_tab,pos+tcr_pos],rca_pos]="Yes"
         THEN header_on = TRUE
         ENDIF
         IF   rep_col_arr[the_tab_cols[the_tab,pos+tcr_pos],rcs_pos]>0
         THEN set_column_headers( header_on, the_tab, last_start, c1 )
              the_tables[the_tab,tts_pos] = TRUE
              last_start = c1 + 1
              header_on = FALSE
         ENDIF
      ENDWHILE
      set_column_headers( header_on, the_tab,
                          last_start, the_tab_cols[the_tab,tcn_pos] )
   ENDWHILE

{  Build up column header lines  }
   the_tab = 0
   WHILE the_tab < selected_tables DO

      the_tab = the_tab + 1
      header_text = ""
      c = 0
      WHILE c < the_tab_cols[the_tab,tcn_pos] DO
         c = c + 1
         IF c > 1 THEN
            header_text = header_text : " "
         ENDIF
         pos = tcn_pos + ((c-1)*tcn_off) + tcr_pos
         t = rep_col_arr[the_tab_cols[the_tab,pos],rch_pos]
         l = rep_col_arr[the_tab_cols[the_tab,pos],rcl_pos]
         adjust_field(t,l)
         header_text = header_text : t
      ENDWHILE

   ENDWHILE

ENDROUTINE

ROUTINE  set_column_headers( VALUE header_flag, VALUE tab_row,
                             VALUE start_col  , VALUE end_col )
   DECLARE  col, pos

   col = start_col-1
   WHILE col < end_col DO
      col = col + 1
      pos = tcn_pos + ((col-1)*tcn_off) + tch_pos
      the_tab_cols[ tab_row, pos ] = header_flag
   ENDWHILE

ENDROUTINE

ROUTINE  adjust_field ( the_text, VALUE the_length )

   DECLARE  l

   the_text = strip(the_text)
   l = length(the_text)
   IF     l > the_length
   THEN   the_text = substring(the_text,1,the_length)
   ELSEIF l < the_length
   THEN   the_text = the_text : pad(""," ", the_length-l )
   ENDIF

ENDROUTINE


ROUTINE  link_up_row ( VALUE the_table )

   DECLARE  the_dir, col_row, next_table, rep_row, next_rep_table, t

   rep_row = the_tables [ the_table, ttr_pos]
   the_dir = rep_tab_arr [ rep_row, rtd_pos ]
   IF   (the_dir = LINK_DOWN) OR (the_dir = LINK_MAST)
   THEN col_row = the_table
   ELSE next_rep_table = rep_tab_arr [ rep_row, rtr_pos ]
        t = 0
        next_table = -1
        WHILE (t < selected_tables) AND (next_table<0) DO
           t = t + 1
           IF the_tables[t,ttr_pos] = next_rep_table THEN
              next_table = t
           ENDIF
        ENDWHILE
        col_row = link_up_row ( next_table )
   ENDIF

   return ( col_row )

ENDROUTINE


ROUTINE  indent_line ( text_to_indent, VALUE line_level )
   ind = rep_tab_arr[the_tables[col_row,ttr_pos],rti_pos]
   IF ind > 0 THEN
      text_to_indent = pad(""," ",ind) : text_to_indent
   ENDIF
ENDROUTINE


ROUTINE  print_header

   pc = pc + 1
   pcp = STRIP(pc)

LITERAL
$the_op__  $the_tm____  $title_text_______________________________  Page:$pcp
$ENDLITERAL

ENDROUTINE


{AS1171 HBe 27-1-99}


ROUTINE  print_top_text (VALUE top_text)


LITERAL
         $top_text___________________________________________________
$ENDLITERAL
ENDROUTINE


ROUTINE rep_name_id (VALUE rep_name_output)

LITERAL
$rep_name_output___________________________________________________
$ENDLITERAL

ENDROUTINE

{AE1171 HBe 27-1-99}


ROUTINE  print_table ( VALUE selected_row, start_key_arr, VALUE no_of_keys,
                             lines_printed, VALUE master_line      )

   ARRAY    sel_arr
   ARRAY    linked_tab_arr

   DECLARE  the_block, the_table, fld_row, the_row, line
   DECLARE  first_fld, local_keys, linked_tables, l_tab, rep_row, rows
   DECLARE  local_lines_printed, local_lines_link, line_row, pos, n, next_line
   DECLARE  this_row

   DECLARE  local_key_arr, key_no
   ARRAY    local_key_arr
   key_no = 0
   WHILE key_no < no_of_keys DO
      key_no = key_no + 1
      local_key_arr [ key_no, 1 ] = start_key_arr [ key_no, 1 ]
      local_key_arr [ key_no, 2 ] = start_key_arr [ key_no, 2 ]
      local_key_arr [ key_no, 3 ] = start_key_arr [ key_no, 3 ]
   ENDWHILE

   the_row   = the_tables  [ selected_row, ttr_pos ]
   the_table = rep_tab_arr [ the_row, rtn_pos ]
   the_block = rep_tab_arr [ the_row, rtb_pos ]

   lines_printed    =  0
   local_lines_link = -1

   IF ((rep_tab_arr [ the_row, rtd_pos ] = LINK_MAST)  OR
       (rep_tab_arr [ the_row, rtd_pos ] = LINK_DOWN))
   THEN next_line = TRUE
   ELSE next_line = FALSE
   ENDIF

   rc = block_row_initialise( the_block, the_table )
   IF rc <> EMPTY THEN
      flash_message("ERROR:":rc,TRUE)
      return
   ENDIF

   filter_setup ( the_row, local_key_arr, no_of_keys )

   rc = block_row_select( the_block, local_key_arr, FALSE )

   rows = block_row_size( the_block )
   IF rows <= 0 THEN
      rc = block_row_release ( the_block )
      return
   ENDIF

   IF next_line THEN
      indent_level = indent_level + 1
   ENDIF

   rc = block_row_first ( the_block )

   REPEAT

      IF (rep_tab_arr [ the_row, rtd_pos ] = LINK_MAST) THEN
         master_row = master_row + 1
         pct_done = round ( 100 * master_row / rows )
         install_bar . end_value   = rows
         install_bar . increase_one ( )
      ENDIF

      IF next_line THEN
         total_line_no = total_line_no + 1
         lines_printed = lines_printed + 1
         line_row = total_line_no
         the_lines [ line_row, tln_pos ] = 0
         the_lines [ line_row, tlt_pos ] = selected_row
         the_lines [ line_row, tli_pos ] = indent_level
         IF   (local_lines_link <> 0) OR (the_tables[selected_row,tts_pos])
         THEN the_lines [ line_row, tlh_pos ] = TRUE
         ELSE the_lines [ line_row, tlh_pos ] = FALSE
         ENDIF
      ELSE
         line_row = master_line
      ENDIF

      line = ""
      first_fld = TRUE
      fld_row = 0
      WHILE fld_row < cols DO
         fld_row = fld_row + 1
         IF rep_col_arr[ fld_row, rcr_pos ] = the_row THEN
            IF   first_fld
            THEN first_fld = FALSE
            ELSE line = line : " "
            ENDIF
            val = block_row_field_select( the_block,
                                          rep_col_arr[ fld_row, rcn_pos ] )

            n = the_lines [ line_row, tln_pos ] + 1
            the_lines [ line_row, tln_pos ] = n
            pos = tln_pos+((n-1)*tln_off)
            the_lines [ line_row, pos+tlr_pos ] = fld_row
            the_lines [ line_row, pos+tlv_pos ] = strip(val)
            line = line : val
         ENDIF
      ENDWHILE


{     Print child table content  }
      l_tab = 0
      local_lines_link = 0
      WHILE (l_tab < the_tables[ selected_row, ttn_pos]) AND
            (NOT(control_c_pressed)) DO

         l_tab = l_tab + 1

         rep_row = the_tables[the_tables[selected_row,ttn_pos+l_tab],ttr_pos]

           local_keys = rep_tab_arr[ rep_row, rtf_pos ]
           l_k = 0
           n = 0
           WHILE l_k < local_keys DO
            l_k = l_k + 1
            IF n > 0 THEN
               n = n + 1
               local_key_arr[n,1] = ARRAY_SELECT_AND
            ENDIF
            n = n + 1
            local_key_arr[n,1] = ARRAY_SELECT_EQ

            IF   rep_tab_arr [ rep_row, rtd_pos ] = LINK_DOWN
            THEN local_key_arr[n,2] = rep_tab_arr[rep_row,rtf_pos+(l_k*2)  ]
                 master_field       = rep_tab_arr[rep_row,rtf_pos+(l_k*2)-1]
            ELSE local_key_arr[n,2] = rep_tab_arr[rep_row,rtf_pos+(l_k*2)-1]
                 master_field       = rep_tab_arr[rep_row,rtf_pos+(l_k*2)  ]
            ENDIF
            local_key_arr[n,3] = block_row_field_select(the_block,master_field)
           ENDWHILE

           print_table( the_tables[ selected_row, ttn_pos+l_tab ],
                        local_key_arr, n, local_lines_printed, line_row )
           local_lines_link = local_lines_link + local_lines_printed
      ENDWHILE
      lines_printed = lines_printed + local_lines_link

   UNTIL ( ( rep_tab_arr[ the_row, rto_pos ] = "Yes" ) OR
           ( NOT( block_row_next ( the_block ) ) )     OR
           ( control_c_pressed ) )

   rc = block_row_release ( the_block )

   IF next_line THEN
      indent_level = indent_level - 1
   ENDIF

ENDROUTINE


ROUTINE  filter_setup ( VALUE rep_tab_row, local_key_arr, VALUE no_of_keys )

   DECLARE  f_size, rep_fil_row, f_row, empty_not_found, rep_ord_row
   DECLARE  filter_flag, pos, o_row

   filter_flag = find_filter_row ( rep_tab_row, rep_fil_row )
   get_order_row ( rep_tab_row, rep_ord_row )

   IF  (NOT( filter_flag )) AND (rep_ord_row<=0)
   THEN return
   ENDIF

   f_row = no_of_keys + 1

   IF filter_flag THEN
      n_fil = 0
      WHILE n_fil < rep_filter_arr[ rep_fil_row, rfn_pos ] DO
         n_fil = n_fil + 1
         n_pos = rfn_pos + (n_fil-1)*rfn_off + 1
         IF f_row > 1 THEN
            IF     rep_filter_arr[rep_fil_row,n_pos] = "OR"
            THEN   local_key_arr[f_row,1] = ARRAY_SELECT_OR
            ELSEIF rep_filter_arr[rep_fil_row,n_pos] = "AND"
            THEN   local_key_arr[f_row,1] = ARRAY_SELECT_AND
            ELSE   f_row = f_row - 1
            ENDIF
            f_row = f_row + 1
         ENDIF

         IF   get_cond_row(rep_filter_arr[rep_fil_row,n_pos+2],1,cond_row)
         THEN cond = cond_arr [ cond_row, 3 ]
         ELSE return
         ENDIF

         local_key_arr[f_row,1] = cond
         IF (rep_filter_arr[rep_fil_row,n_pos+1] <> EMPTY) AND
            (NOT(BLANK(rep_filter_arr[rep_fil_row,n_pos+1])))
         THEN local_key_arr[f_row,2] = rep_filter_arr[rep_fil_row,n_pos+1]
         ENDIF
         IF (rep_filter_arr[rep_fil_row,n_pos+3] <> EMPTY) AND
            (NOT(BLANK(rep_filter_arr[rep_fil_row,n_pos+3])))
         THEN local_key_arr[f_row,3] = rep_filter_arr[rep_fil_row,n_pos+3]
         ENDIF

         f_row = f_row + 1

      ENDWHILE
   ENDIF

{  Apply order by clauses  }
   IF rep_ord_row > 0 THEN
      o_row = 0
      WHILE o_row < rep_ord_arr[rep_ord_row,ron_pos] DO
         o_row = o_row + 1
         pos = ron_pos + ((o_row-1)*3)

         local_key_arr[f_row,1] = ARRAY_SELECT_ORDER
         local_key_arr[f_row,2] = rep_ord_arr[rep_ord_row,pos+roc_pos]
         local_key_arr[f_row,3] = rep_ord_arr[rep_ord_row,pos+roa_pos]

         f_row = f_row + 1

      ENDWHILE
   ENDIF

ENDROUTINE


ROUTINE  in_report ( VALUE table_row )

   DECLARE  r, c

   c = 0
   WHILE c < cols DO
      c = c + 1
      IF rep_col_arr [ c, rcr_pos ] = table_row THEN
         return ( TRUE )
      ENDIF
   ENDWHILE

   r = table_row
   WHILE r < report_tables DO
      r = r + 1
      IF (rep_tab_arr [ r, rtr_pos ] = table_row)
      THEN
         IF in_report ( r ) THEN
            RETURN ( TRUE )
         ENDIF
      ENDIF
   ENDWHILE

   RETURN ( FALSE )

ENDROUTINE


ROUTINE  column_heading_text( VALUE tab_row )

   column_header = ""
   col = 0
   first_col = TRUE
   WHILE col < cols DO
      col = col + 1
      IF rep_col_arr[ col, rcr_pos ] = tab_row THEN
         IF   NOT(first_col)
         THEN column_header = column_header : " "
         ELSE first_col = FALSE
         ENDIF
         t_name = rep_tab_arr [ rep_col_arr [ col, rcr_pos ], rtn_pos ]
         get_field_details 't_name'.'rep_col_arr[col,rcn_pos]',"FIELD_SIZE",s
         column_header = column_header : pad(rep_col_arr[col,rcn_pos]," ",s)
      ENDIF
   ENDWHILE

   RETURN ( column_header )

ENDROUTINE

ROUTINE  table_link_fields ( self )
   manual_link ( self . current_row, EMPTY )
ENDROUTINE

ROUTINE  manual_link ( VALUE the_tab_row, VALUE link_dir )

   DECLARE  tab_name
   ARRAY    field_names
   ARRAY    link_arr
   ARRAY    master_tab_fields

   IF the_tab_row = EMPTY
   THEN

      tab_name = EMPTY

      IF   NOT prompt_user ( EMPTY, "Enter Table to Link To", EMPTY, TRUE,
                            "Table Name", table_names, tab_name, the_last_key )
      THEN return
      ENDIF

      master_tab_row = actual_table_no

   ELSEIF rep_tab_arr[ the_tab_row, rtd_pos ] = LINK_MAST
   THEN   flash_message("Link fields can not be displayed for the master table",
                         TRUE )
          return
   ELSE
      master_tab_row = rep_tab_arr[ the_tab_row, rtr_pos ]
      tab_name       = rep_tab_arr[ the_tab_row, rtn_pos ]
{     link_dir       = rep_tab_arr[ the_tab_row, rtd_pos ]      }
   ENDIF

   master_tab_name = rep_tab_arr[ master_tab_row, rtn_pos ]
   get_field_names ( master_tab_name, master_tab_fields )
   s = size_of_array ( master_tab_fields )
   f = 0
   l = 1
   link_arr[l,1] = " "
   link_arr[l,2] = " "
   link_arr[l,3] = " "
   max_len = 0
   WHILE f < s DO
      f = f+1
      IF NOT(master_tab_fields[f,2]) THEN
         l = l+1
         link_arr[l,1] = master_tab_fields[f,1]
         link_arr[l,2] = master_tab_fields[f,1]
         link_arr[l,3] = master_tab_fields[f,1]
         len = length(strip(master_tab_fields[f,1]))
         IF len > max_len THEN
            max_len = len
         ENDIF
      ENDIF
   ENDWHILE

{  CREATE OBJECT "STD_LIST_GRID" , rep_col_list_grid }
   PROMPT OBJECT rep_col_list_grid
      CLASS PROMPT_CLASS_GRID

   ARRAY rep_col_list_grid . user_info

   mnf_pos = 1
   mnl_pos = 2

   rep_col_list_grid . title_size_top = 2
   rep_col_list_grid . title_text_top [ mnf_pos, 1 ] = tab_name
   rep_col_list_grid . title_text_top [ mnl_pos, 1 ] = master_tab_name
   rep_col_list_grid . title_separator_top = GRID_SEPARATOR_BOTH

   IF   link_dir = LINK_DOWN
   THEN rep_col_list_grid . title_text_top [ mnf_pos, 2 ] = "Child"
        rep_col_list_grid . title_text_top [ mnl_pos, 2 ] = "Master"
   ELSE rep_col_list_grid . title_text_top [ mnf_pos, 2 ] = "Master"
        rep_col_list_grid . title_text_top [ mnl_pos, 2 ] = "Child"
   ENDIF

   rep_col_list_grid . column_size [ mnl_pos ] = max_len

   get_field_names ( tab_name, field_names )
   size = size_of_array( field_names )
   f = 0
   fields = 0
   f_l = LENGTH(rep_col_list_grid . title_text_top [ mnf_pos, 1 ])
   WHILE f < size DO
      f = f + 1
      IF NOT ( field_names[ f, 2 ] ) THEN       { Exclude synonyms }
         fields = fields + 1
         rep_col_list_grid . user_info [ fields, mnf_pos ] =
               strip(field_names[f,1])
         IF LENGTH(rep_col_list_grid . user_info [ fields, mnf_pos ]) > f_l THEN
            f_l = LENGTH(rep_col_list_grid . user_info [ fields, mnf_pos ])
         ENDIF
         rep_col_list_grid . user_info [ fields, mnl_pos ] = " "

         IF the_tab_row <> EMPTY THEN
            n = 0
            found = FALSE
            WHILE (n < rep_tab_arr[ the_tab_row, rtf_pos ]) AND (NOT found) DO
               n = n+1
               pos = rtf_pos + (n-1)*2
               IF   rep_tab_arr[ the_tab_row, pos+2 ] = strip(field_names[f,1])
               THEN rep_col_list_grid . user_info [ fields, mnl_pos ] =
                    rep_tab_arr[ the_tab_row, pos+1 ]
                    found = TRUE
               ENDIF
            ENDWHILE
         ENDIF

      ENDIF
   ENDWHILE

   CREATE   OBJECT PROMPT_CLASS_FORM, get_col

   IF   fields+3 > wh
   THEN get_col . height = wh
   ELSE get_col . height = fields + 3
   ENDIF

   get_col . column   =  wc + 2
   get_col . column   =  (GLOBAL("SCREEN_WIDTH")-max_len-f_l-2)/2
   get_col . width    =  GLOBAL("SCREEN_WIDTH")-(get_col.column*2)
   get_col . width    =  f_l + max_len + 2
   get_col . row      =  wr
   get_col . border   =  TRUE
   get_col . header   =  "Link Table Fields"
   get_col . footer   =  "Press DO to accept / Exit to quit"
   rep_col_list_grid . column  = 1
   rep_col_list_grid . cell_columns = 2
   rep_col_list_grid . cell_rows = fields
   rep_col_list_grid . enabled = TRUE
   rep_col_list_grid . display_cell_routine = "display_link"
   rep_col_list_grid . prompt_cell_routine  = "prompt_link"
{  rep_col_list_grid . remove_routine = "exclude_field" }
   rep_col_list_grid . select_routine = "do_nothing"
{  rep_col_list_grid . select_routine = "include_field" }
{  rep_col_list_grid . insert_routine = "include_field" }
   rep_col_list_grid . height = get_col . height
   rep_col_list_grid . width  = get_col . width
   rep_col_list_grid . column_size [ mnf_pos ] = f_l
   rep_col_list_grid . fixed_columns_left = 1
   rep_col_list_grid . current_column = 1
   rep_col_list_grid . current_row    = 1

   get_col . add_prompt ( rep_col_list_grid )

{......
   IF gui THEN

      gui_adjustments    ( get_col, 4 )
      add_button ( get_col, "SELECT", 3, 4,
"include_field","AD-HOC-REPORTS","Include" )
      add_button ( get_col, "REMOVE", 4, 4,
"exclude_field","AD-HOC-REPORTS","Exclude" )

   ENDIF
...}

   get_col . add_frame ( "" , 1 , 1 , fields , get_col . width )

   get_col . start_prompt()

   REPEAT

      get_col . wait_prompt()

   UNTIL ( get_col . get_lastkey () = "EXIT" ) OR
         ( get_col . get_lastkey () = "DO"   )

   IF get_col . get_lastkey () = "DO" THEN

      f = 0                      {  Save new link to actual table  }
      l_used = 0
      WHILE f < fields DO
         f = f + 1
         l_fld = strip(rep_col_list_grid.user_info[f,mnl_pos])
         IF (l_fld <> EMPTY) AND (NOT BLANK(l_fld)) THEN
            l_used = l_used + 1
            IF   link_dir = LINK_DOWN
            THEN m_fld = l_fld
                 c_fld = rep_col_list_grid.user_info[f,mnf_pos]
            ELSE c_fld = l_fld
                 m_fld = rep_col_list_grid.user_info[f,mnf_pos]
            ENDIF
            add_link_field( tab_name, actual_table_no, link_dir,
                            c_fld, EMPTY, "M", m_fld )
         ENDIF
      ENDWHILE

      IF l_used = 0 THEN
         flash_message("Warning: No link fields - No information saved",TRUE)
      ENDIF

   ENDIF

   get_col . end_prompt()

ENDROUTINE

ROUTINE  link_downwards

   DECLARE  tab_name, size, tables, tab, tab_link, f_no, f_nam, l
   ARRAY    link_field_names

   IF rep_tab_arr [ actual_table_no, rtl_pos ] THEN
      flash_message("This table has already been expanded downwards",TRUE)
      return
   ENDIF

   IF rep_tab_arr [ actual_table_no, rtd_pos ] = LINK_UP THEN
      flash_message("Tables linked Upwards can not be linked downwards",TRUE)
      return
   ENDIF

   tab_name = rep_tab_arr [ actual_table_no, rtn_pos ]

   tables = size_of_array ( table_names )

   tab = 0
   WHILE tab < tables DO
      tab = tab + 1
      tab_link = table_names [ tab, 1 ]
      IF tab_link <> tab_name THEN
         get_field_names ( tab_link, link_field_names )
         size = size_of_array ( link_field_names )
         f_no = 0
         WHILE f_no < size DO
            f_no = f_no + 1
            IF NOT link_field_names[ f_no, 2 ] THEN
               f_nam = link_field_names [ f_no, 1 ]
               adhoc_field_details (tab_link,f_nam,"LINK_TABLE",tab_name,l)
               IF  (l <> EMPTY) AND (NOT(BLANK(l))) AND (l=tab_name)
               THEN
                  add_link_field ( tab_link, actual_table_no, LINK_DOWN,
                                   f_nam, tab_name, "A", EMPTY )
               ENDIF
            ENDIF
         ENDWHILE
      ENDIF
   ENDWHILE

   rep_tab_arr [ actual_table_no, rtl_pos ] = TRUE

ENDROUTINE


ROUTINE  get_link_tables ( table_names )

   tab_limit = 100

   tabs = size_of_array ( table_names )

   rep_tab = 0
   WHILE (rep_tab < report_tables) AND (report_tables < tab_limit) DO
      rep_tab  = rep_tab + 1
      rep_name = rep_tab_arr[ rep_tab, rtn_pos ]

      tab = 0
      WHILE tab < tabs DO
         tab = tab + 1
         tab_link = table_names [ tab, 1 ]
         IF tab_link <> rep_name THEN
            get_field_names ( tab_link, field_names )
            size = size_of_array ( field_names )
            f_no = 0
            WHILE f_no < size DO
               f_no = f_no + 1
               IF NOT field_names[ f_no, 2 ] THEN
                 f_nam = field_names [ f_no, 1 ]
          {      get_field_details 'tab_link'.'f_nam',"LINK_TABLE",l  }
                 adhoc_field_details(tab_link,f_nam,"LINK_TABLE",rep_name,l)
                 IF  (l <> EMPTY) AND (NOT(BLANK(l))) AND (l=rep_name)
                 THEN

                   add_link_field ( tab_link, rep_tab, LINK_DOWN,
                                    f_nam, rep_name, "A", EMPTY )

                 ENDIF
               ENDIF
            ENDWHILE
         ENDIF
      ENDWHILE
   ENDWHILE

   IF report_tables >= tab_limit THEN
      flash_message("Error in finding linked tables. " :
                    "Number of tables reduced to one - the main table",TRUE)
      report_tables = 1
   ENDIF

ENDROUTINE


ROUTINE  add_link_field ( VALUE tab_link, VALUE rep_tab, VALUE link_dir,
                          VALUE field_name, VALUE rep_name, VALUE mode,
                          VALUE the_link_field )

   DECLARE  rt, rep_row, link_fields, l_fld

{....
flash_message("Add link field. Child table:":tab_link:
" Master table:":rep_tab_arr[rep_tab,rtn_pos]:
" Child field name:":field_name:
" Master field name:":the_link_field,TRUE)
...}
   IF   mode = "A"
   THEN IF   link_dir = LINK_DOWN
        THEN adhoc_field_details(tab_link,
                                 field_name,"LINK_FIELD",rep_name,l_fld)
        ELSE adhoc_field_details(rep_tab_arr[rep_tab,rtn_pos],
                                 field_name,"LINK_FIELD",rep_name,l_fld)
        ENDIF
   ELSE l_fld = the_link_field
   ENDIF

   rt = 0
   rep_row = -1
   WHILE (rt < report_tables) AND (rep_row < 0) DO
      rt = rt + 1
      IF   (rep_tab_arr[rt,rtn_pos] = tab_link) AND
           (rep_tab_arr[rt,rtr_pos] = rep_tab )
      THEN lf = 0
           already_there = FALSE
           WHILE (lf < rep_tab_arr[rt,rtf_pos]) AND (NOT(already_there))
              lf = lf + 1
              IF rep_tab_arr[rt,rtf_pos+lf] = l_fld THEN
                 already_there = TRUE
              ENDIF
           ENDWHILE
           IF NOT(already_there) THEN
              rep_row = rt
           ENDIF
      ENDIF
   ENDWHILE

   IF rep_row < 0 THEN
      report_tables = report_tables + 1
      rep_row = report_tables
      rep_tab_arr[ rep_row, rtn_pos ] = tab_link
      rep_tab_arr[ rep_row, rtr_pos ] = rep_tab
      rep_tab_arr[ rep_row, rtb_pos ] = tab_link:strip(rep_row)
      rep_tab_arr[ rep_row, rtd_pos ] = link_dir
      rep_tab_arr[ rep_row, rtu_pos ] = FALSE
      rep_tab_arr[ rep_row, rtl_pos ] = FALSE
      rep_tab_arr[ rep_row, rtv_pos ] = rep_tab_arr[rep_tab,rtv_pos]+1
      rep_tab_arr[ rep_row, rtp_pos ] = "No"
      rep_tab_arr[ rep_row, rti_pos ] = 0
      rep_tab_arr[ rep_row, rto_pos ] = "No"
{AS1171 HBe 28-1-99}
      rep_tab_arr[ rep_row, rts_pos ] = 0
{AS1171 HBe 28-1-99}
      rep_tab_arr[ rep_row, rtf_pos ] = 0
   ENDIF

   link_fields = rep_tab_arr[rep_row,rtf_pos] + 1
   rep_tab_arr[rep_row,rtf_pos] = link_fields
   rep_tab_arr[rep_row,rtf_pos+(link_fields*2)-1] = l_fld
   rep_tab_arr[rep_row,rtf_pos+(link_fields*2)  ] = field_name

ENDROUTINE


ROUTINE  adhoc_field_details ( VALUE link_tab, VALUE link_fld, VALUE option,
                               VALUE comp_name, link_result)

   link_result = EMPTY
   get_field_details 'link_tab'.'link_fld', option, link_result

{  Special datamodel link handling }
   IF   option = "LINK_TABLE"
   THEN IF (link_tab  = "MLP_VALUES") AND
           (link_fld  = "ENTRY_CODE")
        THEN IF ((comp_name = "MLP_HEADER") OR (comp_name="MLP_COMPONENTS"))
             THEN link_result = comp_name
             ELSEIF comp_name = EMPTY THEN
                link_result = "MLP_HEADER"
                add_link_field ( "MLP_COMPONENTS", actual_table_no,
                                 LINK_UP, "ENTRY_CODE", "MLP_COMPONENTS",
                                 "A", EMPTY )
             ENDIF
        ELSEIF (link_tab = "STANDARD_VERSIONS") AND
               (link_fld = "IDENTITY")
        THEN
             IF (comp_name = "STANDARD")
             THEN link_result = "STANDARD"
             ELSEIF comp_name = EMPTY THEN
                link_result = "STANDARD"
             ENDIF
        ENDIF
   ELSE IF (link_tab  = "MLP_VALUES") AND
           (link_fld  = "ENTRY_CODE")
        THEN IF ((comp_name = "MLP_HEADER") OR (comp_name="MLP_COMPONENTS") OR
                 (comp_name = EMPTY) )
             THEN link_result = "ENTRY_CODE"
             ENDIF
        ELSEIF (link_tab = "STANDARD_VERSIONS") AND
               (link_fld = "IDENTITY")
        THEN IF (comp_name = "STANDARD") OR (comp_name = EMPTY)
             THEN link_result = "IDENTITY"
             ENDIF
        ENDIF
   ENDIF

ENDROUTINE

{*************************************************************************
* Purpose      : Writes to predefined log,
*                using WriteLog in $lib_utils
* Parameters   : Msg - what to write in log
* Return Value : N/A
**************************************************************************}
ROUTINE WriteToLog(VALUE Msg)

    WriteLog(Msg, global("current_library"))

ENDROUTINE
