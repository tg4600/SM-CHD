{******************************************************************************
*
* Module Name   : $BATCH_SCREEN.RPF
*
* Purpose       : Contains the class for putting a batch on screen.
*
* Document Ref. :
*
* Specification : SE/T/VGSM320-WORK-BATCH
*
* Portability   : Not Checked
*
* Re-entrant    :
*
*******************************************************************************}

ENABLE WINDOWS
SET NOTPROTECTED
SET NAME "DEFER/"
SET COMPILE_OPTION DECLARE

JOIN STANDARD_LIBRARY STD_ARRAY
JOIN STANDARD_LIBRARY STD_ARRAY_SELECT
JOIN STANDARD_LIBRARY STD_CLASS
JOIN STANDARD_LIBRARY STD_GENERAL
JOIN STANDARD_LIBRARY STD_PROMPT
JOIN STANDARD_LIBRARY STD_WINDOW
JOIN STANDARD_LIBRARY STD_MESSAGE

JOIN LIBRARY $LIB_UTILS
JOIN LIBRARY $LIB_GRID
JOIN LIBRARY $LIB_COMP
JOIN LIBRARY $LINE_EDITOR
JOIN LIBRARY $LIB_TEMP
JOIN LIBRARY $BATCH_UTILS
JOIN LIBRARY $BATCH_SQC
JOIN LIBRARY $BATCH_USER
JOIN LIBRARY $BATCH_TEMPLATE_LIST
JOIN LIBRARY $LIST_BOX
JOIN LIBRARY $MLPS_CONST
JOIN LIBRARY $LIB_RE_MLP
JOIN LIBRARY $PROMPT_TAB

JOIN LIBRARY $CRITERIA_CACHE
JOIN LIBRARY $BROWSE_FIELD

{* CONSTANTS ******************************************************************}


{* VARIABLES ******************************************************************}

DECLARE batch_screen_message_window

{******************************************************************************}

GLOBAL

ROUTINE batch_screen_initialise

{
*	Initialise all the batch modules
*
*******************************************************************************}

	IF NOT global ( "LIBRARY_INITIALISED" ) THEN

		lib_grid_initialise ()
		setup_list_box_class ()
		line_editor_initialise_new ()
		set_up_std_prompt_tab_class ()

		batch_screen_define_class ()


		CREATE TEXT WINDOW batch_screen_message_window
		       HEIGHT 3
		       WIDTH  50
		       BORDER	


		SET GLOBAL "LIBRARY_INITIALISED" TO TRUE

	ENDIF

ENDROUTINE

{******************************************************************************}

ROUTINE batch_screen_define_class

{
*	Define the classes the screen representation of a batch
*
*******************************************************************************}

	DEFINE CLASS STD_BATCH_SCREEN_SUBGRID

		PROPERTIES "GRID_OBJECT"   ,
			   "CLASS_NAME"    ,	
			   "VISIBLE"       ,
			   "ENABLED"       ,
			   "TAB_ORDER"     ,
			   "BUTTON_TEXT"   ,
			   "INSERT_BUTTON" ,
			   "REMOVE_BUTTON" ,
			   "SELECT_BUTTON" ,
			   "OWN_BUTTON"

		INITIALISATION

	END CLASS
		
	DEFINE CLASS STD_BATCH_SCREEN_LIST

		INHERIT PROMPT_CLASS_GRID

		PROPERTIES "BATCH"                ,
			   "PROMPT_DETAILS"	  ,
			   "DISPLAY_FIELDS"	  ,
			   "USER_FIELDS"          ,
			   "HEADER"	          ,
			   "GRID_NUMBER"

		ACTIONS    "MODIFY_FIELDS_SHOWN"   ,
			   "CREATE_FIELD_LIST"     ,	
			   "UPDATE_FIELD_LIST"     ,
			   "UPDATE_DISPLAY_FIELDS" ,		
			   "REMOVE_TEST"           ,
			   "INCLUDE_BATCH"         ,
			   "CALL_REVIEW"           ,	
			
			   "GET_TEMPLATE_HEADER"   ,	

			   "CREATE_NEW_ROWS"       ,	
                           "CHECK_MOVE"            ,
                           "START_PROMPT"          ,
                           "ENTER_PROMPT"          ,
			   "DISPLAY_CELL"          ,
			   "PROMPT_CELL"           ,		
			   "REMOVE"                ,
			   "INSERT"                ,
			   "SELECT"                ,
			   "LEAVE_PROMPT"          ,
				

			   "RESERVE"               ,	
			   "CREATE_BATCH"          ,
			   "MODIFY_BATCH"          ,
			   "DISPLAY_BATCH"   		

		INITIALISATION

	END CLASS

	DEFINE CLASS STD_BATCH_SCREEN_HEADER

		INHERIT PROMPT_CLASS_FORM

		PROPERTIES "GRID_BUTTON"         ,
			   "INSERT_BUTTON"       ,
			   "REMOVE_BUTTON"       ,
			   "SELECT_BUTTON"       ,
			   "OWN_BUTTON"          ,
			   "FORM_TYPE"           ,	
			   "DO_BUTTON"           ,
			   "CHART_BUTTON"        ,

			   "LIMITS_BOX_ON"       ,
			   "MLP_FORM" 	         ,
			   "TAB"                 ,
			   "HEADER_GRID"         ,
			   "LIST_GRID"           ,	
			   "UPLOAD_GRID"         ,
			   "CURRENT_GRID"        ,
			   "GRIDS"               ,

			   "REVIEW_PROMPT"       ,
			   "STATUS_PROMPT"       ,
			   "STATUS_LIST"         ,		
			
			   "IS_DISPLAY"          ,		
			   "WANT_REVIEW_FLAG"    ,
			   "WANT_STATUS_FLAG"    ,
			   "WANT_OLD_IDENTITY"   ,
			   "LIST_DISPLAY_ONLY"   ,
			   "FIELDS_DISPLAY_ONLY" ,
			   "EXPAND_BATCH"        ,
			   "INSERT_CALLS_REVIEW" ,		

			   "GRID_COLUMN"         ,
			   "GRID_ROW"            ,
			   "GRID_HEIGHT"         ,
			   "GRID_WIDTH"         		

		ACTIONS    "FIND_GRID"           ,
			   "FIND_GRID_OBJECT"    ,
			   "ENABLE_GRID"         ,
			   "DISABLE_GRID"        ,
			   "ADD_GRID"            ,
			   "TAB_GRID"            ,
			   "GOTO_GRID"           ,

			   "SET_IS_DISPLAY"      ,
			   "IS_DISPLAY"          ,				
   			
			   "SET_GRID_POSITION"        ,
			   "CALCULATE_GRID_POSITIONS" ,	

			   "CREATE_IDENTITY"          ,
			   "CREATE_TAB"               ,
			   "CREATE_LIST_GRID"         ,
			   "CREATE_HEADER_GRID"       ,
			   "CREATE_UPLOAD_GRID"       ,
			   "CREATE_STANDARD"          ,

			   "SELECT_SAMPLES"           ,
			   "COPY_DEFAULT_VALUES"      ,
			   "BUILD_TEMPLATE"           ,	
			   "SET_TEMPLATE"             ,
			   "SET_BATCH"                ,
			   "EDIT_CRITERIA"            ,

			   "ADD_GRID_BUTTONS"         ,
			   "SET_GRID_BUTTON"          ,				
			   "ADD_BUTTONS"              ,	

			   "ASSIGN_SELECTED_RESULTS"  ,	
			   "UPDATE_RESULTS"           ,
			   "UPDATE_BATCH"             ,
			   "BUILD_BATCH"              ,
			   "VALID_BATCH"	      ,
			   "SET_VALID_STATUS"         ,	
			   "SET_STATUS"	


		INITIALISATION

	END CLASS

	DEFINE CLASS STD_BATCH_SCREEN_RESULT

		INHERIT PROMPT_CLASS_GRID

		PROPERTIES "RESULTS"              ,
			   "FORMATTED"            ,
			   "PROMPT_DETAILS"	  ,
			   "MLP_IDENTITY"         ,
			   "MLP_VERSION"	  ,
			   "HEADER"	          ,
			   "GRID_NUMBER"

                ACTIONS    "START_PROMPT"         ,
			   "DISPLAY_CELL"         ,
			   "PROMPT_CELL"

	END CLASS

	DEFINE CLASS STD_BATCH_SCREEN_UPLOAD

		INHERIT PROMPT_CLASS_GRID

		PROPERTIES "RESULTS"                 ,
			   "COMPONENTS"              ,
			   "SAMPLES"	             ,
			   "RESULT_CONTEXTS"         ,
			   "RESULT_OBJECTS"          ,	
			   "RESULT_TEXT"             ,
			   "FAILED"                  ,		
			   "SCREEN_ORDER"            ,
			   "TEST_ORDER"              ,
			   "SELECTED"                ,
		           "HEADER"                  ,
			   "GRID_NUMBER"
				

		ACTIONS    "DISPLAY_CELL"            ,
			   "PROMPT_CELL"             ,
			   "FIND_RESULT"             ,			
			   "REMOVE"                  ,
			   "INSERT"                  ,
			   "SELECT"                  ,	
                           "START_PROMPT"            ,
			   "LEAVE_PROMPT"            ,
				
			
			   "BUILD_SAMPLE_LIST"       ,
			   "READ_IN_ANALYSIS"        ,
			   "SET_SELECTED"            ,
			   "UPLOAD_RESULTS"          ,
			   "REBUILD"                 ,	
			   "ASSIGN_SELECTED_RESULTS"      	

		INITIALISATION
				
	END CLASS

	DEFINE CLASS STD_BATCH_SCREEN_FIELDS

		INHERIT "STD_LINE_EDITOR"

		PROPERTIES "HEADER"       ,
			   "GRID_NUMBER"

	END CLASS


ENDROUTINE

{*****************************************************************************}

ROUTINE batch_screen_display_message ( VALUE message )

{
*	Display a message on the screen
*
*******************************************************************************}

	DECLARE temp

	temp = get_user_message ( message , 1 )

	IF temp = ERROR THEN

		temp = message

	ENDIF

	IF ( GLOBAL ( "TERMTYPE" ) = "GUI" ) THEN

		window_set_status ( temp )

	ELSE

		CLEAR LINE 2
		      FROM 1
		      IN WINDOW batch_screen_message_window
	
		DISPLAY centre_text ( temp , 50 - 4 )
			FROM    2
                        ON LINE 2
			IN WINDOW batch_screen_message_window
			
		PASTE TEXT WINDOW batch_screen_message_window
		      ON LINE 10
		      FROM    20				

	ENDIF

ENDROUTINE

{*****************************************************************************}

ROUTINE batch_screen_clear_message

{
*	Clear a message from the screen
*
*******************************************************************************}

	IF ( GLOBAL ( "TERMTYPE" ) = "GUI" ) THEN

		window_set_status ( "" )

	ELSE


		UNPASTE TEXT WINDOW batch_screen_message_window

		CLEAR LINE 2
		      FROM 1
		      IN WINDOW batch_screen_message_window


	ENDIF

ENDROUTINE

{*****************************************************************************}

ROUTINE std_batch_screen_subgrid_class_initialisation ( self )

{
*	Initialise the object
*
*******************************************************************************}

	self . grid_object   = EMPTY
	self . class_name    = ""
	self . visible       = FALSE
	self . enabled       = TRUE
	self . tab_order     = 0
	self . button_text   = ""
	self . insert_button = EMPTY
	self . remove_button = EMPTY
	self . select_button = EMPTY
	self . own_button    = EMPTY
	
ENDROUTINE

{*****************************************************************************}

ROUTINE std_batch_screen_list_class_initialisation ( self )

{
*	Initialise the object
*
*******************************************************************************}

        DECLARE count       ,
		field_names ,
		titles      ,
		widths
	
	CREATE OBJECT STD_BATCH_HEADER_BASE , self . batch

	ARRAY self . display_fields
        ARRAY field_names
        ARRAY titles
        ARRAY widths

	browse_field_details ( "SAMP_TEST_VIEW" ,
                               ""               ,
                                0               ,
                                field_names     ,
                                titles          ,
                                widths          )

	
        count = 1

        WHILE count <= size_of_array ( field_names ) DO

		self . display_fields [ count , 1 ] = field_names [ count     ]
		self . display_fields [ count , 2 ] = titles      [ count , 1 ]
		self . display_fields [ count , 3 ] = widths      [ count     ]

                count = count + 1

        ENDWHILE

ENDROUTINE

{******************************************************************************}

ROUTINE batch_screen_list_prompt_type (       self           ,
    			    	              grid           ,
                                        VALUE cell_column    ,
		                        VALUE cell_row       ,
		                        VALUE column         ,
		                        VALUE row            ,
			                VALUE cell_width     ,
			                      screen         ,
			                VALUE is_display     )

{
*	Prompt/Display the type.
*
*
*****************************************************************************}

	DECLARE type

	IF is_display THEN

		DISPLAY self . get_type ()
			ON LINE   row
			FROM      column
			TO        column + cell_width -1
			IN WINDOW screen

	ELSE

		type = self . get_type ()

		PROMPT FOR       type
		       ON LINE   row
		       FROM      column
		       IN WINDOW screen		
		       TO        column + cell_width -1
                       WITH ( inverse      = TRUE ,
			      display_only = TRUE )	
			
		CLEAR LINE row
		      FROM column
		      TO   column + cell_width - 1
		      IN WINDOW screen		 	

		DISPLAY type
			ON LINE   row
			FROM      column
			TO        column + cell_width -1
			IN WINDOW screen

	ENDIF

ENDROUTINE

{******************************************************************************}

ROUTINE batch_screen_list_prompt_identity (       self           ,
    				                  grid           ,
                                            VALUE cell_column    ,
		                            VALUE cell_row       ,
		                            VALUE column         ,
		                            VALUE row            ,
			                    VALUE cell_width     ,
			                          screen         ,
			                    VALUE is_display     )

{
*	Prompt/Display the identity.
*
*
*****************************************************************************}

	self . prompt_identity ( grid          ,
				 cell_column   ,
				 cell_row      ,
				 column        ,
				 row           ,
				 cell_width    ,
				 screen        ,
				 is_display    )

ENDROUTINE

{******************************************************************************}

ROUTINE batch_screen_list_prompt_review (       self           ,
    				                grid           ,
                                          VALUE cell_column    ,
		                          VALUE cell_row       ,
		                          VALUE column         ,
		                          VALUE row            ,
			                  VALUE cell_width     ,
			                        screen         ,
			                  VALUE is_display     )

{
*	Prompt/Display the review.
*
*
*****************************************************************************}

	DECLARE comparison

	comparison = self . get_review ()

	IF is_display THEN

		DISPLAY comparison
			ON LINE   row
			FROM      column
			TO        column + cell_width -1
			IN WINDOW screen
			BLINKING = ( comparison <> MLP_CONST_PASS )

	ELSE

		PROMPT FOR comparison
		       ON LINE   row
		       FROM      column
		       TO        column + cell_width - 1	
		       IN WINDOW screen		
		       WITH ( inverse      = TRUE ,
			      display_only = TRUE )		

		DISPLAY comparison
			ON LINE   row
			FROM      column
			TO        column + cell_width -1
			IN WINDOW screen
			BLINKING = ( comparison <> MLP_CONST_PASS )

	ENDIF

ENDROUTINE


{******************************************************************************}

ROUTINE batch_screen_list_prompt_parent (       self           ,
    				                grid           ,
                                          VALUE cell_column    ,
		                          VALUE cell_row       ,
		                          VALUE column         ,
		                          VALUE row            ,
			                  VALUE cell_width     ,
			                        screen         ,
			                  VALUE is_display     )

{
*	Prompt/Display the parent.
*
*
*****************************************************************************}

	IF self . want_parent () THEN

		self . base_prompt_parent ( grid        ,
				            cell_column ,
				            cell_row    ,
				            column      ,
				            row         ,
				            cell_width  ,
				            screen 	,
				            is_display  ,
					    TRUE        )  	
					

	ELSE

		IF is_display THEN

			CLEAR LINE row
			      FROM column
			      TO   column + cell_width - 1	
			      IN WINDOW screen		

		ELSE

			PROMPT
			       ON LINE   row
   			       FROM      column
			       IN WINDOW screen		

		ENDIF

	ENDIF

ENDROUTINE

{******************************************************************************}

ROUTINE batch_screen_list_prompt_field (       self           ,
    			    	               grid           ,
                                         VALUE cell_column    ,
		                         VALUE cell_row       ,
		                         VALUE column         ,
		                         VALUE row            ,
			                 VALUE cell_width     ,
			                       screen         ,
			                 VALUE is_display     )

{
*	Prompt/Display a field from the database.
*
*
*****************************************************************************}

	DECLARE field_value  ,
		field_name   ,
		field_number

	field_number = cell_column - grid . user_fields + 1

	field_name =  grid . display_fields [ field_number , 1 ]

	field_value = self . get_samp_test_field ( field_name )

	IF field_value = EMPTY THEN

		field_value = " "

	ENDIF

	IF is_display THEN

		DISPLAY field_value
			ON LINE   row
			FROM      column
			TO        column + cell_width -1
			IN WINDOW screen

	ELSE

		PROMPT FOR       field_value
		       ON LINE   row
		       FROM      column
		       TO        column + cell_width -1
		       IN WINDOW screen		
		       WITH ( display_only = TRUE ,
			      inverse      = TRUE )
	
		DISPLAY field_value
			ON LINE   row
			FROM      column
			TO        column + cell_width -1
			IN WINDOW screen
	
	ENDIF

ENDROUTINE

{******************************************************************************}

ROUTINE batch_screen_list_preparation_batch (       self           ,
    			    	                    grid           ,
                                              VALUE cell_column    ,
		                              VALUE cell_row       ,
		                              VALUE column         ,
		                              VALUE row            ,
			                      VALUE cell_width     ,
			                            screen         ,
			                      VALUE is_display     )

{
*	Prompt/Display the batch from the database.
*	If the sample doesn't have a batch then allow the user to prompt
*	for the batch and include the samples from that batch.
*
*
*****************************************************************************}

	DECLARE field_value    ,
		field_name     ,
		include_batch  ,
		include_prompt ,
		batch


	batch = grid . batch

	field_name  = batch . type_test_include_field

	field_value = self . get_samp_test_field ( field_name )

	IF is_display THEN

		IF field_value = EMPTY THEN

			field_value = " "

		ENDIF


		DISPLAY field_value
			ON LINE   row
			FROM      column
			TO        column + cell_width -1
			IN WINDOW screen
			FORMAT samp_test_view . 'field_name'


	ELSEIF ( NOT self . should_create ()) AND
	       (     self . is_sample     ()) THEN

		SET BATCH_STATUS "VCIA"

		PROMPT OBJECT    include_prompt
		       ON LINE   row
		       FROM      column
		       TO        column + cell_width - 1	
		       IN WINDOW screen
		       BROWSE ON batch_header

		batch . include_selection_criteria ( include_prompt . mandatory_array )

		include_prompt . start_prompt ()
		include_prompt . wait_prompt  ()
                include_prompt . end_prompt   ()
		
		include_prompt . set_globals ()
		include_batch = include_prompt . value
		
		IF ( NOT blank ( include_batch )               )  AND
		   ( include_prompt . get_lastkey () <> "EXIT" )  THEN

			grid . include_batch ( include_batch ,
					       cell_row      )
		 				
		ENDIF

	ELSE

		
		PROMPT FOR       field_value
		       ON LINE   row
		       FROM      column
		       IN WINDOW screen		
                       BROWSE ON samp_test_view . 'field_name'
		       WITH ( display_only = TRUE )
	
	ENDIF

ENDROUTINE


{******************************************************************************}

{*****************************************************************************}

ROUTINE std_batch_screen_list_action_create_new_rows (       grid             ,
						       VALUE create_row       ,
						       VALUE number_to_create )

{
*
*
******************************************************************************}

	DECLARE count

	SET FORMAT "999"

	IF create_row > 0 THEN

		count = 1

		WHILE count <= number_to_create DO

			grid . insert_row ( create_row          ,
					    1                   ,
					    GRID_SEPARATOR_NONE )		

			grid . title_text_left [ create_row , 1 ] = create_row
        		grid . redisplay_title_left ( create_row )	
	
			count      = count      + 1
			create_row = create_row + 1

		ENDWHILE

		WHILE create_row <= grid . cell_rows DO

			grid . title_text_left [ create_row , 1 ] = create_row
        		grid . redisplay_title_left ( create_row )	
	
			create_row = create_row + 1

		ENDWHILE

	ENDIF

ENDROUTINE

{*****************************************************************************}

ROUTINE std_batch_screen_list_action_check_move (       grid        ,
						  VALUE old_column  ,
						  VALUE old_row     ,
							new_column  ,
							new_row     )

{
*
*
******************************************************************************}

	DECLARE create_row       ,
		number_to_create

	IF new_row <> grid . cell_rows THEN

		grid . batch . set_prompt_position ( new_row          ,
						     create_row       ,
						     number_to_create )	
		IF create_row > 0 THEN

			grid . create_new_rows ( create_row       ,
						 number_to_create )

     		ENDIF

	ENDIF

ENDROUTINE

{*****************************************************************************}

ROUTINE std_batch_screen_list_action_display_cell (       grid        ,
				                    VALUE cell_column ,	
				                    VALUE cell_row    ,
					                  screen      ,
				                    VALUE column      ,
				                    VALUE row         ,
				                    VALUE cell_width  ,
				                    VALUE cell_height )

{
*	Display an entry from the batch.
*
******************************************************************************}

	DECLARE entry

	IF cell_row = grid . cell_rows THEN

		CLEAR LINE row
		      FROM column
		      TO   column + cell_width - 1
		      IN WINDOW screen		 	

	ELSE

		entry = grid . batch . get_entry ( cell_row )

		lib_grid_display_array ( grid                  ,
					 cell_column           ,
					 cell_row              ,
					 screen                ,
					 column                ,
					 row                   ,
					 cell_width            ,
					 entry                 ,
					 grid . prompt_details ,
					 "SAMP_TEST_VIEW"      ,
					 FALSE                 ,
					 PROMPT_DETAILS_310    )	
	
	ENDIF

ENDROUTINE	

{*****************************************************************************}

ROUTINE std_batch_screen_list_action_prompt_cell (       grid        ,
				                   VALUE cell_column ,	
				                   VALUE cell_row    ,
					                 screen      ,
				                   VALUE column      ,
				                   VALUE row         ,
				                   VALUE cell_width  ,
				                   VALUE cell_height )

{
*	Prompt for an entry in the batch.
*
******************************************************************************}

	DECLARE entry

	IF cell_row = grid . cell_rows THEN

		DISPLAY pad ( " ", " ", cell_width )
		        ON LINE row
		        FROM    column
		        TO      column + cell_width - 1
		        IN WINDOW screen INVERSE

		PROMPT ON LINE row
		       FROM    column
		       TO      column + cell_width - 1
		       IN WINDOW screen

		CLEAR LINE row
		      FROM column
		      TO   column + cell_width - 1
		      IN WINDOW screen		 	

	ELSE

		entry = grid . batch . get_entry ( cell_row )

		lib_grid_prompt_array ( grid                  ,
					cell_column           ,
					cell_row              ,
					screen                ,
					column                ,
					row                   ,
					cell_width            ,
					entry                 ,
					grid . prompt_details ,
					"SAMP_TEST_VIEW"      ,
					FALSE                 ,
					PROMPT_DETAILS_310    )	

	ENDIF

ENDROUTINE	

{*****************************************************************************}

ROUTINE std_batch_screen_list_action_insert (  grid )

{
*	 Do an insert
*
******************************************************************************}

	DECLARE current_row    ,
		template_entry ,
		repeat_section

	current_row    = grid . current_row

	IF grid . header . insert_calls_review THEN

		IF current_row <> grid . cell_rows THEN

			grid . call_review ()

		ENDIF

	ELSEIF NOT grid . display_only THEN

		IF current_row = grid . cell_rows THEN

			IF current_row = 1 THEN

				repeat_section = 1

			ELSE

				repeat_section = grid . batch . get_entry ( current_row - 1 ) . get_repeat ()		

			ENDIF

		ELSE

			repeat_section = grid . batch . get_entry ( current_row ) . get_repeat ()		

		ENDIF

		IF batch_template_list_create_single ( template_entry ,
						       grid . batch   ) THEN

			grid . batch . create_entry ( template_entry . get_class () ,
						      template_entry                ,
						      current_row                   ,
						      repeat_section                )
	
   			grid . create_new_rows ( current_row ,
					         1           )

			grid . set_position ( grid . current_column ,
					      current_row           )	

		ENDIF

	ENDIF

ENDROUTINE

{*****************************************************************************}

ROUTINE std_batch_screen_list_action_remove (  grid )

{
*	Remove the current element if possible
*
******************************************************************************}

	DECLARE count

	IF NOT grid . display_only THEN
	
		IF grid . current_row <> grid . cell_rows THEN

			grid . batch . delete_entry ( grid . current_row )		

			grid . remove_row ( grid . current_row )

			count = grid . current_row

			WHILE count <= grid . cell_rows DO

				grid . title_text_left [ count , 1 ] = count
        			grid . redisplay_title_left ( count )	
	
				count = count + 1
             	
			ENDWHILE

		ENDIF

	ENDIF

ENDROUTINE

{*****************************************************************************}

ROUTINE std_batch_screen_list_action_call_review (  grid )

{
*	Call the review screen
*
******************************************************************************}

	DECLARE form        ,
		result_grid ,
		entry       ,
		result_size ,
		message

	entry = grid . batch . get_entry ( grid . current_row )

	CREATE OBJECT STD_BATCH_SCREEN_RESULT , result_grid	

	result_grid . row    = 4
	result_grid . column = 2
	result_grid . height = 13
	result_grid . width  = 73

	result_grid . mlp_identity = entry . get_samp_test_field ( "PRODUCT" )
	result_grid . mlp_version  = entry . get_samp_test_field ( "PRODUCT_VERSION" )	

	result_grid . results = entry . get_results ( FALSE )	

	IF result_grid . results <> EMPTY THEN

		result_grid . results . do_compare           = TRUE
		result_grid . results . convert_to_mlp_units = TRUE
	
		result_grid . results . mlp_format (  result_grid . mlp_identity ,
						      result_grid . mlp_version  ,
						      EMPTY    	                 ,
						      result_grid . formatted    )	

		result_size  = size_of_array ( result_grid . formatted )

		result_grid . height  = find_min_number ( result_size + 2          ,
							  global ( "screen_height" ) -
                        	                          13                         )

		PROMPT OBJECT form
		       CLASS PROMPT_CLASS_FORM
		       ON LINE 9 FROM 4
		       WITH ( header       = "Review screen"          ,
	  		      width        = result_grid . width  + 2 ,
			      height       = result_grid . height + 3 ,
			      button_style = FORM_BUTTON_CLOSE        )	

		message = get_user_message ( "BATCH_SCREEN_REVIEW_SAMPLE_ID"  , 1 )
		message = pad ( message , " " , 19 )

		form . add_display ( message                   ,
				     2                         ,
				     1 	                       ,
				     PROMPT_RENDITION_BOLD +
	       			     PROMPT_RENDITION_RAISED   )		

		IF global ( "SAMP_BROWSE" ) = "T" THEN

			message = entry . get_samp_test_field ( "ID_TEXT" )

		ELSE

			message = entry . get_samp_test_field ( "ID_NUMERIC" )

		ENDIF
		form . add_display ( message                   ,
				     22                        ,
				     1 	                       ,
				     PROMPT_RENDITION_LOWERED  )

		message = get_user_message ( "BATCH_SCREEN_REVIEW_BATCH_TYPE"  , 1 )
		message = pad ( message , " " , 19 )

		form . add_display ( message                     ,
				     2                           ,
				     2 	                         ,
				     PROMPT_RENDITION_BOLD +
	       			     PROMPT_RENDITION_RAISED     )		


		message = entry . get_type ()

		form . add_display ( message                  ,
				     22                       ,
				     2 	                      ,
				     PROMPT_RENDITION_LOWERED )

		form . add_frame ( ""            ,
				   1             ,
				   1             ,
				   2             ,
				   form . width  )

		form . add_prompt ( result_grid )


		form . add_frame ( ""                   ,
			           1                    ,
				   4                    ,
				   result_grid . height ,
				   form . width         )
				
		form . start_prompt ()
  		form . wait_prompt  ()
		form . end_prompt   ()

	ELSE

		flash_message ( get_user_message ( "BATCH_SCREEN_REVIEW_NO_RESULTS",1),
				TRUE                                          )


	ENDIF

ENDROUTINE

{*****************************************************************************}

ROUTINE std_batch_screen_list_action_select (  grid )

{
*	Options screen
*
******************************************************************************}

	grid . modify_fields_shown ()

ENDROUTINE

{*****************************************************************************}

ROUTINE std_batch_screen_list_action_leave_prompt ( self )

{
*
*
******************************************************************************}

	DECLARE form

	IF self . get_lastkey () = "TAB" THEN

		self . set_lastkey ( "CONTINUE" )

		form = self . header

		form . tab_grid ()

	ENDIF

ENDROUTINE

{*****************************************************************************}

ROUTINE std_batch_screen_list_action_remove_test (      grid        ,
						  VALUE	test_number )

{
*	Remove given test from the batch.
*
******************************************************************************}

	grid . batch . add_test_to_delete ( test_number )

ENDROUTINE

{*****************************************************************************}

ROUTINE std_batch_screen_list_action_include_batch (       grid          ,
						     VALUE include_batch ,
						     VALUE cell_row      )

{
*	Include the batch and then redisplay the grid.
*
*
******************************************************************************}

	DECLARE count            ,
		total            ,
		create_row       ,
		number_to_create

	total = grid . batch . include_batch ( cell_row         ,
					       include_batch    ,
					       create_row       ,
					       number_to_create )

	IF create_row > 0 THEN

		grid . create_new_rows ( create_row       ,
					 number_to_create )

	ENDIF				

	count = 1

	WHILE count <= total DO

		grid . redisplay_row ( cell_row + count - 1 )

		count = count + 1

	ENDWHILE

	IF total <> 0 THEN

		grid . set_position ( grid . current_column ,
				      cell_row + total - 1  )	

	ELSE

		SET GLOBAL "LASTKEY" TO "CONTINUE"
		grid . set_position ( grid . current_column ,
				      cell_row              )	

	ENDIF

ENDROUTINE

{*****************************************************************************}

ROUTINE std_batch_screen_list_action_update_display_fields ( self )

{
*	Look at the display fields array and remove anything that is
*	already there.
*
*******************************************************************************}
	
	DECLARE count        ,
		field_name   ,
		delete_field

	count = 1

	WHILE count <= size_of_array ( self . display_fields ) DO

		field_name = strip ( self . display_fields [ count , 1 ] )
		field_name = toupper ( field_name )

		delete_field = FALSE		

		IF ( field_name = "ID_TEXT"         ) AND
		   ( global ( "SAMP_BROWSE" ) = "T" ) THEN

			delete_field = TRUE

		ELSEIF field_name = "ID_NUMERIC" THEN

			delete_field = TRUE

		ELSEIF field_name = "TEST_COUNT" THEN

			delete_field = TRUE		

		ELSEIF field_name = "PARENT_TEST" THEN

			self . display_fields [ count , 3 ] =  35
			self . display_fields [ count , 4 ] = "batch_screen_list_prompt_parent"

		ELSE

			self . display_fields [ count , 4 ] =  "batch_screen_list_prompt_field"

		ENDIF

		IF delete_field THEN

			array_remove_slice ( self . display_fields ,
					     1                     ,
					     count                 )		

		ELSE

			count = count + 1

		ENDIF


	ENDWHILE

ENDROUTINE
{*****************************************************************************}

ROUTINE std_batch_screen_list_action_start_prompt ( self )

{
*	Start the batch prompt grid.
*
*******************************************************************************}

	DECLARE count     ,
		old_width ,
		next_pos

	old_width = self . width

	ARRAY self . prompt_details

	self . prompt_details [1 , 2 ] = "ROUTINE"
	self . prompt_details [1 , 3 ] = global ( "current_library" )
	self . prompt_details [1 , 4 ] = "batch_screen_list_prompt_type"
	self . prompt_details [1 , 5 ] = get_user_message ( "BATCH_SCREEN_TYPE_TITLE" , 1)
	self . prompt_details [1 , 6 ] = 10

	self . prompt_details [2 , 2 ] = "ROUTINE"
	self . prompt_details [2 , 3 ] = global ( "current_library" )
	self . prompt_details [2 , 4 ] = "batch_screen_list_prompt_identity"
	self . prompt_details [2 , 5 ] = get_user_message ( "BATCH_SCREEN_SAMPLE_TITLE" , 1)
	self . prompt_details [2 , 6 ] = 35

	IF self . header . want_review_flag THEN

		self . prompt_details [3 , 2 ] = "ROUTINE"
		self . prompt_details [3 , 3 ] = global ( "current_library" )
		self . prompt_details [3 , 4 ] = "batch_screen_list_prompt_review"
		self . prompt_details [3 , 5 ] = get_user_message ( "BATCH_SCREEN_REVIEW_TITLE" , 1)
		self . prompt_details [3 , 6 ] = 20

		next_pos = 4

	ELSEIF  ( variable_is_assigned ( self . batch . type_test_include_field )) AND
		( self . batch . type_test_include_field <> EMPTY                ) THEN

		self . prompt_details [3 , 2 ] = "ROUTINE"
		self . prompt_details [3 , 3 ] = global ( "current_library" )
		self . prompt_details [3 , 4 ] = "batch_screen_list_preparation_batch"
		self . prompt_details [3 , 5 ] = get_user_message ( "BATCH_SCREEN_INCLUDE_TITLE" , 1)

		get_field_details batch_header . identity
				  "FIELD_SIZE"             ,
		                  self . prompt_details [3 , 6 ]

		next_pos = 4

	ELSE

		next_pos = 3

	ENDIF

	self . user_fields = next_pos

	self . update_display_fields ()

	count = 1

	
	WHILE count <= size_of_array ( self . display_fields ) DO

		self . prompt_details [ next_pos , 2 ] = "ROUTINE"
		self . prompt_details [ next_pos , 3 ] = global ( "current_library" )
		self . prompt_details [ next_pos , 4 ] = self . display_fields [ count , 4 ]
		self . prompt_details [ next_pos , 5 ] = self . display_fields [ count , 2 ]
		self . prompt_details [ next_pos , 6 ] = self . display_fields [ count , 3 ]

		next_pos = next_pos + 1
		count    = count    + 1

	ENDWHILE

	lib_grid_setup_columns (  self . prompt_details ,
				  self                  ,
				 "SAMP_TEST_VIEW"       )	

	self . cell_columns       = size_of_array ( self . prompt_details )
	self . cell_rows          = self . batch . size () + 1
	self . fixed_columns_left = 1	

	self . title_separator_top  = GRID_SEPARATOR_BOTH
	self . title_rendition_top  = PROMPT_RENDITION_BOLD
	self . title_size_top       = 1

	self . title_separator_left  = GRID_SEPARATOR_BOTH
	self . title_rendition_left  = PROMPT_RENDITION_BOLD
	self . title_size_left       = 4

	self . width  = self . width + self . title_size_left + 1

        self . width  = find_min_number ( self . width  ,	
					  old_width     )	
	
	self . vgl_library            = global ( "current_library" )

	SET FORMAT "999"

	count = 1

	WHILE count <= self . cell_rows DO

		self . title_text_left [ count , 1 ] = count
		count = count + 1

	ENDWHILE

	object_invoke_class (  self              ,
		               PROMPT_CLASS_GRID ,
		              "START_PROMPT"     )		

ENDROUTINE

{*****************************************************************************}

ROUTINE std_batch_screen_list_action_enter_prompt ( self )

{
*	Enter the prompt grid
*
*******************************************************************************}

	self . return_behaviour = GRID_RETURN_DOWN

	object_invoke_class (  self              ,
		               PROMPT_CLASS_GRID ,
		              "ENTER_PROMPT"     )		

	IF self . current_column = 1 THEN

		self . set_position ( 2, 1  )	

	ENDIF

ENDROUTINE

{*****************************************************************************}

ROUTINE std_batch_screen_list_action_create_field_list ( self       ,
							 list_box   )

{
*	Build a list of all the fields to show
*
*******************************************************************************}

	DECLARE count      ,
		field_list ,
		temp       ,
		name

	criteria_cache_fields ( "SAMP_TEST_VIEW" ,
	                         field_list      )

	count = 1

	WHILE count <= size_of_array ( field_list ) DO

		name = field_list [ count , 2 ]

		list_box . display_list [ count ] = field_list [ count ,1 ]
		list_box . select_list  [ count ] = FALSE

		temp = 1

		WHILE temp <= size_of_array ( self . display_fields ) DO

			IF name = self . display_fields [ temp , 1 ] THEN

				list_box . select_list [ count ] = TRUE
				temp = size_of_array  ( self . display_fields )

			ENDIF

			temp = temp + 1
		
		ENDWHILE

		count = count + 1

	ENDWHILE


ENDROUTINE

{*****************************************************************************}

ROUTINE std_batch_screen_list_action_update_field_list ( self       ,
							 list_box   )

{
*	Update to show the new fields
*
*******************************************************************************}

	DECLARE count       ,
		field_list  ,
		next_pos    ,
		field_name  ,
		field_width
		

	ARRAY self . display_fields

	criteria_cache_fields ( "SAMP_TEST_VIEW" ,
	                         field_list      )

	next_pos = 1
	count    = 1

	WHILE count <= size_of_array ( field_list ) DO

		IF list_box . select_list [ count ] THEN

			field_name  = field_list [ count , 2 ]
			field_width = criteria_cache_field_width ( "SAMP_TEST_VIEW" ,
							            field_name      )

			self . display_fields [ next_pos , 1 ] =
					field_name
			self . display_fields [ next_pos , 2 ] =
					field_list [ count , 1 ]
			self . display_fields [ next_pos , 3 ] =
					field_width

			next_pos = next_pos + 1

		ENDIF

		count = count + 1

	ENDWHILE

	self . stop_prompt  ()
	self . start_prompt ()

ENDROUTINE

{*****************************************************************************}

ROUTINE std_batch_screen_list_action_modify_fields_shown ( self )

{
*	Change the fields shown on the grid.
*
*******************************************************************************}

	DECLARE list_box

	CREATE OBJECT LIST_BOX_CLASS, list_box

	ARRAY list_box . display_list

	list_box . list_title = get_user_message ( "BATCH_SCREEN_FIELDS_TITLE" ,1 )
	list_box . header     = get_user_message ( "BATCH_SCREEN_FIELDS_HEADER" ,1 )

	self . create_field_list ( list_box )

	list_box . start_prompt ()
	list_box . wait_prompt  ()
	list_box . end_prompt   ()

	IF list_box . get_lastkey () = "DO" THEN

		self . update_field_list ( list_box )

	ENDIF

ENDROUTINE

{*****************************************************************************}

ROUTINE std_batch_screen_list_action_get_template_header ( self )

{
*	get the template header
*
******************************************************************************}
	
	RETURN ( self . batch . get_template_header ())

ENDROUTINE

{*****************************************************************************}

ROUTINE std_batch_screen_list_action_create_batch (        self           ,
						     VALUE batch_template )	

{
*	Set the screen up to create a batch.
*
*******************************************************************************}

	CREATE OBJECT STD_BATCH_HEADER_BASE , self . batch

	self . batch . create ( batch_template )

ENDROUTINE

{*****************************************************************************}

ROUTINE std_batch_screen_list_action_modify_batch (       self         ,
						    VALUE batch_name   ,
						    VALUE expand_batch )

{
*	Set the screen up to modify a batch.
*
*******************************************************************************}

	self . batch . read_for_modify ( batch_name   ,
					 expand_batch )

	IF self . header . want_review_flag THEN

		self . batch . review ()

	ENDIF

	self . end_prompt ()
	self . start_prompt ()

ENDROUTINE

{*****************************************************************************}

ROUTINE std_batch_screen_list_action_display_batch (       self       ,
						     VALUE batch_name )	

{
*	Set the screen up to display a batch.
*
*******************************************************************************}

	IF ( self . batch . read_for_display ( batch_name )) THEN
		
		IF self . header . want_review_flag THEN

			self . batch . review ()

		ENDIF
			
		self . end_prompt ()
		self . start_prompt ()
	
	ENDIF

ENDROUTINE

{*****************************************************************************}

ROUTINE std_batch_screen_list_action_reserve (       self     ,
					       VALUE identity )		

{
*	
*
******************************************************************************}

	DECLARE status

	status = self . batch . reserve ( identity )

	IF status <> EMPTY THEN

		flash_message ( status , TRUE )

	ENDIF

	RETURN ( status )

ENDROUTINE

{*****************************************************************************}
{*****************************************************************************}
{									      }		
{                                                                             }
{		Batch Header Class					      }
{									      }		
{*****************************************************************************}
{*****************************************************************************}

ROUTINE std_batch_screen_header_class_initialisation ( self )

{
*
*
******************************************************************************}

	ARRAY self . grids ARRAY_SIZE ( 0 )

	self . current_grid      = 1

	self . grid_row          = 0
	self . grid_column       = 0
	self . grid_height       = 0
	self . grid_width        = 0

	self . button_style      = FORM_BUTTON_NONE
	self . height            = global ( "SCREEN_HEIGHT" ) - 9
	self . width             = global ( "SCREEN_WIDTH"  ) - 4
        self . is_display        = FALSE
	
	self . status_list         = EMPTY	
	self . want_review_flag    = FALSE
	self . want_status_flag    = TRUE
	self . want_old_identity   = TRUE
	self . list_display_only   = FALSE
	self . fields_display_only = FALSE
	self . expand_batch        = FALSE
	self . insert_calls_review = FALSE
	self . do_button           = EMPTY
        self . insert_button       = EMPTY
	self . remove_button       = EMPTY
	self . select_button       = EMPTY
	self . own_button          = EMPTY
	
ENDROUTINE

{*****************************************************************************}

ROUTINE std_batch_screen_header_action_add_grid ( self            ,
						  grid_definition )

{
*
*
******************************************************************************}

	DECLARE position ,
		form     ,
		grid

	position = size_of_array ( self . grids ) + 1
	grid     = grid_definition . grid_object

	self . grids [ position ]     = grid_definition
	grid . grid_number = position

	object_assign_uncounted ( grid . header , self )

	IF global ( "TERMTYPE" ) = "GUI" THEN

		grid_definition . button_text = 
			substitute ( grid_definition . button_text , "." , "" ) 

		grid . visible = TRUE

		IF object_check_property ( grid , "user_enter_prompt_routine" ) THEN

			grid . user_enter_prompt_routine = "batch_screen_grid_enter_prompt"

		ELSE

			grid . enter_prompt_routine = "batch_screen_grid_enter_prompt"

		ENDIF	
	
		CREATE OBJECT "STD_FORM" , form

		self . tab . set_size ( form )

		form . add_prompt ( grid  )

		form . header = grid_definition . button_text         

		self . tab . add_form ( form )

	ELSE

		self . add_prompt ( grid_definition . grid_object )


	ENDIF

ENDROUTINE

{*****************************************************************************}

ROUTINE std_batch_screen_header_action_find_grid (       self      ,
						   VALUE grid_name )

{
*
*
******************************************************************************}

	DECLARE count           ,
		grid_definition

	count = 1

	WHILE count <= size_of_array ( self . grids ) DO

		grid_definition = self . grids [ count ]

		IF grid_definition . class_name = grid_name THEN

			RETURN ( count )

		ENDIF

		count = count + 1

	ENDWHILE

	RETURN ( 0 )

ENDROUTINE

{*****************************************************************************}

ROUTINE std_batch_screen_header_action_find_grid_object (       self      ,
						          VALUE grid_name )

{
*
*
******************************************************************************}

	DECLARE grid_number

	grid_number = self . find_grid ( grid_name )

	RETURN ( self . grids [ grid_number ] . grid_object )

ENDROUTINE
{*****************************************************************************}

ROUTINE std_batch_screen_header_action_enable_grid (       self      ,
						     VALUE grid_name )

{
*
*
******************************************************************************}

	DECLARE grid

	grid = self . find_grid ( grid_name )

	IF grid <> 0 THEN

		self . grids [ grid ] . enabled = TRUE

	ENDIF

ENDROUTINE

{*****************************************************************************}

ROUTINE std_batch_screen_header_action_disable_grid (       self      ,
						      VALUE grid_name )

{
*
*
******************************************************************************}

	DECLARE grid

	grid = self . find_grid ( grid_name )

	IF grid <> 0 THEN

		self . grids [ grid ] . enabled = FALSE

	ENDIF

ENDROUTINE

{*****************************************************************************}

ROUTINE std_batch_screen_header_action_tab_grid ( self )


{
*
*
******************************************************************************}

	DECLARE new_grid     ,
		keep_looking

	new_grid     = self . current_grid + 1
	keep_looking = TRUE

	WHILE keep_looking DO

		IF new_grid <= size_of_array ( self . grids ) THEN

			IF self . grids [ new_grid ] . enabled THEN

				keep_looking = FALSE

			ELSE

				new_grid = new_grid + 1

			ENDIF

		ELSE

			new_grid = 1
		
		ENDIF

	ENDWHILE

	IF new_grid <> self . current_grid THEN

		self . goto_grid ( new_grid )

	ENDIF

ENDROUTINE

{*****************************************************************************}

ROUTINE std_batch_screen_header_action_goto_grid (       self     ,
						   VALUE new_grid )


{
*
*
******************************************************************************}

	DECLARE insert_text ,
		remove_text ,
		select_text ,
		grid 

	grid = self . grids [ self . current_grid ] . grid_object
	grid . parent_prompt . set_position ( grid . tag )


	IF new_grid <> self . current_grid THEN


		IF global ( "TERMTYPE" ) = "GUI" THEN

			insert_text = self . grids [ new_grid ] . insert_button
			remove_text = self . grids [ new_grid ] . remove_button
			select_text = self . grids [ new_grid ] . select_button

			IF ( insert_text <> EMPTY ) AND
			   (( self . form_type <> BATCH_SCREEN_CREATE ) OR
			    ( NOT self . grids [ new_grid ] . grid_object . display_only )) THEN

				self . insert_button . caption = insert_text
				self . insert_button . set_enabled ( TRUE )
				self . insert_button . repaste ()

			ELSEIF self . insert_button <> EMPTY THEN

				self . insert_button . set_enabled ( FALSE )

			ENDIF

			IF ( remove_text <> EMPTY ) AND
			   (( self . form_type <> BATCH_SCREEN_CREATE ) OR
			    ( NOT self . grids [ new_grid ] . grid_object . display_only )) THEN

				self . remove_button . caption = remove_text
				self . remove_button . set_enabled ( TRUE )
				self . remove_button . repaste ()

			ELSEIF self . remove_button <> EMPTY

				self . remove_button . set_enabled ( FALSE )

			ENDIF

			IF select_text <> EMPTY THEN

				self . select_button . caption = select_text
				self . select_button . set_enabled ( TRUE )
				self . select_button . repaste ()

			ELSEIF self . select_button <> EMPTY THEN

				self . select_button . set_enabled ( FALSE )

			ENDIF


		ELSE

			self . grids [ self . current_grid ] . grid_object . set_visible ( FALSE )
			self . grids [ new_grid            ] . grid_object . set_visible ( TRUE  )
			self . set_position ( self . grids [ new_grid ] . grid_object . tag )


		ENDIF

		self . current_grid = new_grid

	ENDIF

ENDROUTINE

{*****************************************************************************}

ROUTINE std_batch_screen_header_action_set_is_display ( self )


{
*
*
******************************************************************************}
	
	self . is_display = TRUE

ENDROUTINE

{*****************************************************************************}

ROUTINE std_batch_screen_header_action_is_display ( self )


{
*
*
******************************************************************************}
	
	RETURN ( self . is_display )

ENDROUTINE

{*****************************************************************************}

ROUTINE std_batch_screen_header_action_set_grid_position (       self        ,
							   VALUE grid_column ,
							   VALUE grid_row    ,
							   VALUE grid_width  ,
							   VALUE grid_height )	

{
*
*
******************************************************************************}

	self . grid_column = grid_column
	self . grid_row    = grid_row
	self . grid_width  = grid_width
	self . grid_height = grid_height

ENDROUTINE

{*****************************************************************************}

ROUTINE std_batch_screen_header_action_calculate_grid_positions ( self )

{
*
*
******************************************************************************}


	IF self . grid_column = 0 THEN

		self . grid_column = 2

	ENDIF

	IF self . grid_row = 0 THEN

		IF self . want_review_flag THEN

			self . grid_row = 4
	
		ELSE

			self . grid_row = 3

		ENDIF

	ENDIF

	IF self . grid_height = 0 THEN

		self . grid_height = self . height - self . grid_row + 1

	ENDIF

	IF self . grid_width = 0 THEN

		self . grid_width = self . width - self . grid_column - 1

	ENDIF

	self . add_frame ( ""                     ,
			   self . grid_column - 1 ,
			   self . grid_row        ,
			   self . grid_height     ,
			   self . grid_width + 2  )	

ENDROUTINE

{*****************************************************************************}

ROUTINE batch_screen_header_leave_new_identity ( self )

{
*
*
******************************************************************************}

	DECLARE form

	IF self . get_lastkey () <> "EXIT" THEN

                form = self . parent_prompt

		IF form . list_grid . reserve ( self . value ) = EMPTY THEN

                        form . header_grid . redisplay_contents ()
			

			IF global ( "TERMTYPE" ) = "GUI" THEN

		
				self . set_lastkey ( "CONTINUE" )

				form . set_position ( form . tab . forms [ form . current_grid ] . tag )

			ELSE

				self . set_lastkey ( "RETURN" )

			ENDIF


		ELSE


			self . set_lastkey ( "CONTINUE" )

		ENDIF

	ENDIF

ENDROUTINE

{*****************************************************************************}

ROUTINE batch_screen_header_leave_old_identity ( self )

{
*
*
******************************************************************************}

	DECLARE form          ,
	        batch         ,
	        status        ,
	        review_status ,
	        keep_going    ,
	        batch_header

	batch_header = self . parent_prompt . list_grid . batch

	{ If changing from one batch to another, update the original batch }

	IF ( self . text <> self . original_text   ) THEN

		IF  ( NOT self . parent_prompt . is_display )
		AND ( NOT blank ( self . original_text )    )
		AND confirm_with_message ( "LABTABLIB_CONFIRM_CHANGE" ) THEN

			batch_header . set_will_update ( )
	
			self . parent_prompt . update_batch () 
		
		ENDIF		

		IF ( self . get_lastkey ( ) <> "EXIT" ) THEN

			batch_header . initialise ()

	                form = self . parent_prompt

			object_set_current_table ( self , "BATCH_HEADER" )

			status = SELECT batch_header . status

			IF form . want_status_flag THEN

				form . status_prompt . set_text ( status)

			ENDIF

                
			IF form . is_display THEN

				form . list_grid . display_batch ( self . value )

			ELSE
		
				form . list_grid . modify_batch ( self . value        ,
								  form . expand_batch )	
	
			ENDIF
                                   
			batch = form . list_grid . batch

			keep_going = batch_user_batch_allowed ( batch            ,
				                                form . form_type )

		ELSE
			keep_going = FALSE
		ENDIF

	ELSE
                
		keep_going = FALSE

	ENDIF

	IF keep_going
                          
		form . list_grid . stop_prompt ()
		form . list_grid . start_prompt ()

 		IF form . form_type = BATCH_SCREEN_UPLOAD THEN
				
			status = form . upload_grid . upload_results ( batch )

			IF status THEN

				status = form . upload_grid . rebuild ( batch )

			ENDIF

		
			IF status THEN

				CREATE OBJECT STD_BATCH_HEADER_BASE , form . list_grid . batch
                	  
				form . list_grid . modify_batch ( self . value        ,
							          form . expand_batch )	


				form . upload_grid . build_sample_list ()


			ELSE

				CREATE OBJECT STD_BATCH_HEADER_BASE , form . list_grid . batch
                	
				form . list_grid . display_batch ( self . value )

			ENDIF

		ENDIF
		
		IF form . want_review_flag THEN

			review_status = batch . get_review ()
			form . review_prompt . set_text ( review_status )

		ELSE

			review_status = "P"

		ENDIF


                form . build_template ( SELECT batch_header . template_id ,
					status                            ,
					review_status                     )

 		IF form . form_type = BATCH_SCREEN_MODIFY THEN
	
			form . edit_criteria ()
					
		ENDIF

                form . header_grid . redisplay_contents ()

 		IF form . form_type = BATCH_SCREEN_UPLOAD THEN

			batch_screen_display_message (  get_user_message ( "BATCH_SCREEN_UPLOAD_FORMAT" ,1 ))

			form . upload_grid . end_prompt   ()
			form . upload_grid . start_prompt ()
                
			batch_screen_clear_message (  )

		ENDIF

		IF global ( "TERMTYPE" ) = "GUI" THEN
                          
		
			self . set_lastkey ( "CONTINUE" )

			form . set_position ( form . tab . forms [ form . current_grid ] . tag )

		ELSE

			self . set_lastkey ( "RETURN" )

		ENDIF

	ENDIF

ENDROUTINE

{*****************************************************************************}

ROUTINE std_batch_screen_header_action_create_identity ( self )

{
*
*
******************************************************************************}

	DECLARE message         ,
		prompt_object   ,
		position        ,
		right_offset    ,
		field_size

	IF self . status_list  <> EMPTY THEN

		SET BATCH_STATUS  self . status_list

	ELSE

		SET BATCH_STATUS "VCIAX"

	ENDIF

	message  = get_user_message ( "BATCH_SCREEN_BATCH_NAME_PROMPT" , 1 )
	position = string_length ( message ) + 3


	get_field_details  batch_header . identity ,
			  "FIELD_SIZE"	           ,
			   field_size

	right_offset = position + field_size + 5

	self . add_display ( message                    ,
			     2                          ,
			     1 	                   	,
			     PROMPT_RENDITION_BOLD +
			     PROMPT_RENDITION_RAISED   )		
	
	IF NOT self . want_old_identity THEN

		PROMPT OBJECT prompt_object
		       ON LINE 1
		       FROM    position
		       FORMAT  batch_header
		       WITH ( vgl_library          = global ( "current_library" ) ,
			      leave_prompt_routine = "batch_screen_header_leave_new_identity" )		


	ELSEIF self . is_display THEN

		PROMPT OBJECT prompt_object
		       ON LINE 1
		       FROM      position
		       BROWSE ON batch_header
		       THEN SELECT 	
		       WITH ( vgl_library          = global ( "current_library" ) ,
			      leave_prompt_routine = "batch_screen_header_leave_old_identity" )		


	ELSE


		PROMPT OBJECT prompt_object
		       ON LINE 1
		       FROM      position
		       BROWSE ON batch_header
		       THEN SELECT FOR UPDATE 	
		       WITH ( vgl_library          = global ( "current_library" ) ,
			      leave_prompt_routine = "batch_screen_header_leave_old_identity" )		


	ENDIF

	self . add_prompt ( prompt_object )			

	IF self . want_status_flag THEN

		message  = get_user_message ( "BATCH_SCREEN_STATUS_PROMPT" , 1 )

		position = string_length ( message ) + 3 + right_offset

      		self . add_display ( message                    ,
				     2 + right_offset           ,
				     1 	                   	,
				     PROMPT_RENDITION_BOLD +
				     PROMPT_RENDITION_RAISED   )		

		PROMPT OBJECT prompt_object
		       ON LINE 1
		       FROM    position
 		       TO      position + 15 	
		       FORMAT  batch_header . status
		       WITH  ( lowered = TRUE )

		
		self . add_display ( prompt_object )
	
		self . status_prompt = prompt_object

	ENDIF

	IF self . want_review_flag THEN

		message  = get_user_message ( "BATCH_SCREEN_REVIEW_PROMPT" , 1 )

		position = string_length ( message ) + 3 + right_offset

      		self . add_display ( message                    ,
				     2 + right_offset           ,
				     2 	                   	,
				     PROMPT_RENDITION_BOLD +
				     PROMPT_RENDITION_RAISED   )		

		PROMPT OBJECT prompt_object
		       ON LINE 2
		       FROM    position 	
		       TO      position + 15	
		       FORMAT  batch_header . review_status
		       WITH  ( lowered = TRUE )

		self . add_display ( prompt_object )
	
		self . review_prompt = prompt_object

	ENDIF

	IF self . want_review_flag THEN
	
		self . add_frame ( ""                     ,
				   self . grid_column - 1 ,
				   1                      ,
				   2                      ,
		     		   self . grid_width + 2  )	

        ELSE

		self . add_frame ( ""                     ,
				   self . grid_column - 1 ,
				   1                      ,
				   1                      ,
		     		   self . grid_width + 2  )	

	ENDIF
	
ENDROUTINE

{*****************************************************************************}

ROUTINE std_batch_screen_header_action_create_list_grid ( self )

{
*
*
******************************************************************************}

	DECLARE grid_info   ,	
		list_grid

	CREATE OBJECT STD_BATCH_SCREEN_SUBGRID , grid_info

	CREATE OBJECT "STD_BATCH_SCREEN_LIST"  , list_grid

	list_grid . row          = self . grid_row
	list_grid . column       = self . grid_column
	list_grid . height       = self . grid_height
	list_grid . width        = self . grid_width
	list_grid . visible      = FALSE
	list_grid . display_only = self . list_display_only

	grid_info . grid_object = list_grid
	grid_info . class_name  = "STD_BATCH_SCREEN_LIST"
	grid_info . button_text = get_user_message ( "BATCH_SCREEN_LIST_BUTTON"  , 1)

	IF NOT self . list_display_only THEN

		grid_info . insert_button = get_user_message ( "BATCH_SCREEN_INSERT_BUTTON" , 1  )
		grid_info . remove_button = get_user_message ( "BATCH_SCREEN_REMOVE_BUTTON" , 1  )
		grid_info . select_button = get_user_message ( "BATCH_SCREEN_CONFIGURE_BUTTON", 1)

	ELSEIF self . insert_calls_review THEN

		grid_info . insert_button = get_user_message ( "BATCH_SCREEN_RESULTS_BUTTON"  , 1  )
		grid_info . select_button = get_user_message ( "BATCH_SCREEN_CONFIGURE_BUTTON", 1)

	ELSE

		grid_info . select_button = get_user_message ( "BATCH_SCREEN_CONFIGURE_BUTTON", 1)

	ENDIF


	self . list_grid = list_grid

	self . add_grid ( grid_info )

ENDROUTINE

{*****************************************************************************}

ROUTINE std_batch_screen_header_action_create_upload_grid ( self )

{
*
*
******************************************************************************}

	DECLARE grid_info   ,	
		list_grid

	CREATE OBJECT STD_BATCH_SCREEN_SUBGRID , grid_info
	CREATE OBJECT STD_BATCH_SCREEN_UPLOAD  , list_grid

	list_grid . row     = self . grid_row
	list_grid . column  = self . grid_column
	list_grid . height  = self . grid_height
	list_grid . width   = self . grid_width
	list_grid . visible = FALSE

	grid_info . grid_object = list_grid
	grid_info . class_name  = STD_BATCH_SCREEN_UPLOAD
	grid_info . button_text = get_user_message ( "BATCH_SCREEN_UPLOAD_BUTTON"  , 1)

	grid_info . insert_button = get_user_message ( "BATCH_SCREEN_ACCEPT_BUTTON" , 1  )
	grid_info . remove_button = get_user_message ( "BATCH_SCREEN_REMOVE_BUTTON" , 1  )

	self . limits_box_on = global ( "RES_LIMITS_BOX_ON" )

	IF self . limits_box_on THEN

		grid_info . select_button = get_user_message ( "BATCH_SCREEN_MLP_BUTTON" , 1  )

	ELSE

		grid_info . select_button = get_user_message ( "BATCH_SCREEN_MLP_BUTTON" , 2  )

	ENDIF

	self . upload_grid = list_grid

	self . add_grid ( grid_info )

	IF global ( "TERMTYPE" ) = "GUI" THEN

		lib_re_mlp_create_mlp_form ( self )
		
		self . mlp_form . visible = FALSE
                self . add_prompt ( self . mlp_form )

	ELSE

		self . mlp_form = EMPTY
		
	ENDIF

ENDROUTINE

{*****************************************************************************}

ROUTINE batch_screen_header_select ( self )

{
*
*
******************************************************************************}

        DECLARE max_grid_height ,
                max_grid_width  ,
                batch_fields    ,
                the_line_editor ,
		count           ,
                form

	ARRAY batch_fields  ARRAY_SIZE ( 0 , 7 )

	batch_fields [ 1 , 1 ] = get_user_message ( "BATCH_SCREEN_DATE_CREATED_TITLE" ,1)
	batch_fields [ 1 , 4 ] = "DATE_CREATED"

	batch_fields [ 2 , 1 ] = get_user_message ( "BATCH_SCREEN_CREATOR_TITLE" ,1)
	batch_fields [ 2 , 4 ] = "CREATOR"

	batch_fields [ 3 , 1 ] = get_user_message ( "BATCH_SCREEN_DATE_COMPLETED_TITLE" ,1)
	batch_fields [ 3 , 4 ] = "DATE_COMPLETED"

	batch_fields [ 4 , 1 ] = get_user_message ( "BATCH_SCREEN_COMPLETER_TITLE" ,1)
	batch_fields [ 4 , 4 ] = "COMPLETER"

	batch_fields [ 5 , 1 ] = get_user_message ( "BATCH_SCREEN_DATE_INSPECTED_TITLE" ,1)
	batch_fields [ 5 , 4 ] = "DATE_REVIEWED"

	batch_fields [ 6 , 1 ] = get_user_message ( "BATCH_SCREEN_INSPECTED_TITLE" ,1)
	batch_fields [ 6 , 4 ] = "REVIEWER"

	batch_fields [ 7 , 1 ] = get_user_message ( "BATCH_SCREEN_DATE_AUTHORISED_TITLE" ,1)
	batch_fields [ 7 , 4 ] = "DATE_AUTHORISED"

	batch_fields [ 8 , 1 ] = get_user_message ( "BATCH_SCREEN_AUTHORISER_TITLE" ,1)
	batch_fields [ 8 , 4 ] = "AUTHORISER"

	batch_fields [ 9 , 1 ] = get_user_message ( "BATCH_SCREEN_DATE_CANCELLED_TITLE" ,1)
	batch_fields [ 9 , 4 ] = "DATE_CANCELLED"

	batch_fields [ 10 , 1 ] = get_user_message ( "BATCH_SCREEN_CANCELLER_TITLE" ,1)
	batch_fields [ 10 , 4 ] = "CANCELLER"

	batch_fields [ 11 , 1 ] = get_user_message ( "BATCH_SCREEN_TEMPLATE_TITLE" ,1)
	batch_fields [ 11 , 4 ] = "TEMPLATE_ID"

	batch_fields [ 12 , 1 ] = get_user_message ( "BATCH_SCREEN_BATCH_CLASS_TITLE" ,1)
	batch_fields [ 12 , 4 ] = "BATCH_CLASS"


	count = 1

	WHILE count <= size_of_array ( batch_fields ) DO

		batch_fields [ count , 2 ] = "DISPLAY"
		batch_fields [ count , 3 ] = "BATCH_HEADER"

		count = count + 1	

	ENDWHILE


        max_grid_width  = global ( "SCREEN_WIDTH"  ) - 8
        max_grid_height = global ( "SCREEN_HEIGHT" ) - 9

	max_grid_height = find_min_number ( max_grid_height               ,
					    size_of_array ( batch_fields ))

        PROMPT OBJECT the_line_editor
                      ON LINE 1
                      FROM    2
                      CLASS "STD_LINE_EDITOR"
                      WITH ( title_width = 32              ,
                             height = max_grid_height      ,
                             width  = max_grid_width       ,
                             prompt_details = batch_fields )

        PROMPT OBJECT form
               CLASS PROMPT_CLASS_FORM
               ON LINE 9 FROM 4
               WITH ( header       = get_user_MESSAGE ( "BATCH_SCREEN_INTERNAL_HEADER" ,1),
                      footer       = get_user_MESSAGE ( "BATCH_SCREEN_INTERNAL_FOOTER" ,1),
                      width        = max_grid_width + 2  ,
                      height       = max_grid_height     ,
                      proportional = TRUE                )

        form . add_prompt ( the_line_editor )

        form . add_frame ( ""                  ,
                           1                   ,
                           1                   ,
                           max_grid_height     ,
                           max_grid_width + 2  )

        form . start_prompt ()
        form . wait_prompt  ()
        form . end_prompt   ()


ENDROUTINE

{*****************************************************************************}

ROUTINE batch_screen_header_leave_prompt ( self )

{
*
*
******************************************************************************}

	DECLARE form

	IF self . get_lastkey () = "TAB" THEN

		self . set_lastkey ( "CONTINUE" )
		form = self . header
		form . tab_grid ()

	ENDIF

ENDROUTINE

{*****************************************************************************}

ROUTINE std_batch_screen_header_action_create_tab ( self )

{
*
*
******************************************************************************}

	DECLARE tab

	IF global ( "TERMTYPE" ) = "GUI" THEN

		CREATE OBJECT PROMPT_TAB_CLASS , tab

		tab . height = self . grid_height   
		tab . width  = self . grid_width   		
		tab . row    = self . grid_row
		tab . column = self . grid_column

		self . grid_height = self . grid_height - 3
		self . grid_width  = self . grid_width  - 4
		
		self . grid_row    = 1
		self . grid_column = 1

		self . tab = tab
	
		self . add_prompt ( tab )

	ENDIF

ENDROUTINE

{*****************************************************************************}

ROUTINE std_batch_screen_header_action_create_header_grid ( self )

{
*
*
******************************************************************************}
	
	DECLARE prompt_details ,
		header_grid    ,
		grid_info

	ARRAY prompt_details

	PROMPT OBJECT header_grid
	       ON LINE self . grid_row
	       FROM    self . grid_column
               CLASS STD_BATCH_SCREEN_FIELDS
	       WITH ( height                    = self . grid_height         ,
		      width                     = self . grid_width          ,	
		      title_width               = 32                         ,
		      user_callback_library     = global ( "current_library" )   ,
		      user_select_routine       ="batch_screen_header_select" ,	
		      user_leave_prompt_routine ="batch_screen_header_leave_prompt" ,	
		      prompt_details            = prompt_details             ,
		      display_only              = self . fields_display_only )	

	CREATE OBJECT STD_BATCH_SCREEN_SUBGRID , grid_info
	grid_info . grid_object = header_grid
	grid_info . class_name  = STD_BATCH_SCREEN_FIELDS
	grid_info . button_text = get_user_message ( "BATCH_SCREEN_HEADER_BUTTON"  , 1)

	grid_info . select_button = get_user_message ( "BATCH_SCREEN_DETAILS_BUTTON" , 1  )

	self . header_grid = header_grid
	
	self . add_grid ( grid_info )

ENDROUTINE

{*****************************************************************************}

ROUTINE std_batch_screen_header_action_create_standard (       self        ,
							 VALUE screen_type )

{
*
*
******************************************************************************}

	self . form_type = screen_type

	self . chart_button = ( screen_type <> BATCH_SCREEN_CREATE ) 

	self . calculate_grid_positions ()
	self . create_identity ()
	self . create_tab ()
	self . create_header_grid ()
	self . create_list_grid ()

	self . confirm_required = ( global ( "TERMTYPE" ) <> "GUI" ) AND
				  ( NOT self . is_display          )


ENDROUTINE

{*****************************************************************************}

ROUTINE std_batch_screen_header_action_edit_criteria ( self )

{
*
*
******************************************************************************}

	self . list_grid . batch . get_template_header () . edit_criteria ()

ENDROUTINE

{*****************************************************************************}

ROUTINE std_batch_screen_header_action_build_template (       self          ,
						        VALUE template      ,
						        VALUE status        ,
							VALUE review_status )	

{
*
*
******************************************************************************}

	DECLARE template_fields ,
		prompt_details  ,
		the_table_name  ,
		include_copy    ,
		field_top       ,
		display_mode

	include_copy   =  TRUE
	display_mode   =  FALSE
	the_table_name = "BATCH_HEADER"

	read_in_template_fields ( template        ,
				  the_table_name  ,
				  template_fields ,
				  TRUE            ,
				  TRUE            )		

	IF ( self . form_type = BATCH_SCREEN_AUTHORISE ) OR
	   ( status           = "A"  	               ) THEN

		set_fields_to_display ( template_fields )

		array_insert_slice ( template_fields ,
				     1               ,
				     1               )

		template_fields [ 1 , 1  ] = "AUTHORISATION_NOTES"
		template_fields [ 1 , 2  ] =  TRUE
		template_fields [ 1 , 3  ] =  FALSE
		template_fields [ 1 , 4  ] =  TRUE
		template_fields [ 1 , 5  ] =  review_status <> "P"
		template_fields [ 1 , 6  ] = "V"
		template_fields [ 1 , 7  ] = ""
		template_fields [ 1 , 8  ] =  get_user_message ( "BATCH_SCREEN_AUTH_FIELD" ,1 )
		template_fields [ 1 , 9  ] = ""
		template_fields [ 1 , 10 ] = ""
		template_fields [ 1 , 11 ] = ""

	ENDIF

	create_prompt_array ( template_fields   ,
			      the_table_name    ,
			      prompt_details    ,
			      display_mode      ,
     			      field_top         ,
			      include_copy      )

	
	IF field_top = 0 THEN

		prompt_details [ 1 , 1 ] = get_user_message ( "BATCH_SCREEN_NO_FIELDS", 1)
		prompt_details [ 1 , 2 ] = "DISPLAY"
		prompt_details [ 1 , 3 ] = "BATCH_HEADER"
		prompt_details [ 1 , 4 ] = "DESCRIPTION"


	ENDIF

	self . header_grid . user_info = template_fields
	self . header_grid . change_prompt_details ( prompt_details )

ENDROUTINE

{*****************************************************************************}

ROUTINE std_batch_screen_header_action_select_samples ( self )

{
*	Get all the samples for the batch.
*
******************************************************************************}

	DECLARE batch            ,
		create_row       ,
		number_to_create

	batch = self . list_grid . batch

	IF batch . template_header . get_field ( "AUTOMATIC_SELECT" ) THEN

		batch . select_samples ( 1                ,
					 create_row       ,
					 number_to_create )

	ENDIF

ENDROUTINE

{*****************************************************************************}

ROUTINE std_batch_screen_header_action_copy_default_values (       self ,
					  		     VALUE type )

{
*
*
******************************************************************************}

	DECLARE table

	table = "BATCH_HEADER"

        copy_default_values ( type                           ,
                              table                          ,
                              self . header_grid . user_info )
ENDROUTINE

{*****************************************************************************}

ROUTINE std_batch_screen_header_action_set_template (       self     ,
						      VALUE template )	

{
*
*
******************************************************************************}

	DECLARE syntax    ,
		edit_list

	self . build_template ( template ,
				""       ,
				""       )

	self . list_grid . create_batch ( template )

	syntax    = self . list_grid . batch . get_template_header () . get_syntax ()
	edit_list = self . list_grid . batch . get_template_header () . get_field ( "EDIT_LIST" )

	IF NOT Blank ( syntax ) THEN

		self . prompt_objects [ 1 ] . value = "To be generated"
		self . prompt_objects [ 1 ] . set_enabled ( FALSE )

	ENDIF

        self . list_grid . display_only = NOT edit_list

	RETURN ( blank ( syntax ))
	
ENDROUTINE

{*****************************************************************************}

ROUTINE std_batch_screen_header_action_set_batch ( self )

{
*
*
******************************************************************************}

ENDROUTINE

{*****************************************************************************}

ROUTINE batch_screen_grid_button ( self )

{
*
*
******************************************************************************}

	DECLARE form        ,
		wanted_grid

	form        = self . header
	wanted_grid = self . user_info

	form . goto_grid ( wanted_grid )

ENDROUTINE

{*****************************************************************************}

ROUTINE batch_screen_grid_enter_prompt ( self )

{
*
*
******************************************************************************}

	DECLARE form        

	form        = self . header

	form . goto_grid ( self . grid_number )

ENDROUTINE

{*****************************************************************************}

ROUTINE std_batch_screen_header_action_add_grid_buttons ( self        ,	
						          button_list ,
						          position    )	

{
*
*
******************************************************************************}

	DECLARE count       ,
		grid_info   ,
		want_insert ,
		want_remove ,
		want_select ,
		insert_text ,
		remove_text ,
		select_text 

	position = 1

	IF self . is_display THEN
	
		lib_grid_lastkey_button (  button_list              ,
					   position                 ,
					  "EXIT"	            ,
					   get_user_message ( "SMP_PROMPT_BUTTON_CLOSE",1 ))

	ELSEIF self . do_button <> EMPTY THEN

		lib_grid_lastkey_button (  button_list       ,
					   position          ,
					  "DO"	             ,
					   self . do_button  )

	ELSE

		lib_grid_lastkey_button (  button_list ,
					   position    ,
					  "DO"	       ,
					   EMPTY       )

	ENDIF
	
	want_insert = FALSE
	want_remove = FALSE
	want_select = FALSE

	count = 1

	WHILE count <= size_of_array ( self . grids ) DO

		grid_info = self . grids [ count ]

		IF grid_info . insert_button <> EMPTY THEN

			IF NOT want_insert THEN

				want_insert = TRUE
				insert_text = grid_info . insert_button

                        ENDIF
			
		ENDIF

		IF grid_info . remove_button <> EMPTY THEN
		
			IF NOT want_remove THEN

				want_remove = TRUE
				remove_text = grid_info . remove_button

                        ENDIF
			
		ENDIF

		IF grid_info . select_button <> EMPTY THEN
		
			IF NOT want_select THEN

				want_select = TRUE
				select_text = grid_info . select_button

                        ENDIF
			
		ENDIF

		count = count + 1

	ENDWHILE

	grid_info = self . grids [ 1 ]

	IF want_insert THEN

		lib_grid_lastkey_button (  button_list  ,
					   position     ,
				          "INSERT HERE" ,
					   insert_text  )

	ENDIF

	IF want_remove THEN	
	
		lib_grid_lastkey_button (  button_list ,
					   position    ,
				          "REMOVE"     ,
					   remove_text )

	ENDIF

	IF want_select THEN

		lib_grid_lastkey_button (  button_list ,
					   position    ,
				          "SELECT"     ,
					   select_text )

	ENDIF

	IF self . chart_button THEN

		lib_grid_action_button ( button_list                                          ,
					 position                                             ,
					 get_user_message ( "BATCH_SCREEN_CHART_BUTTON" , 1 ) ,
					 "batch_screen_chart_button"                          ,
					 global ( "current_library" )                         ,
					 count                                                )

	ENDIF

	IF NOT self . is_display THEN
	
		lib_grid_lastkey_button (  button_list  ,
					   position     ,
					  "EXIT"	,
					   EMPTY        )

	ENDIF

	IF global ( "TERMTYPE" ) = "GUI" THEN

		grid_info = self . grids [ 1 ]

		lib_form_add_vertical_buttons ( self        ,
					        button_list )	

		count = 2

		IF want_insert THEN

			self . insert_button = button_list [ count ] . prompt_object
			self . insert_button . enabled =
				( grid_info . insert_button <> EMPTY )

		        count = count + 1

		ENDIF

		IF want_remove THEN

			self . remove_button = button_list [ count ] . prompt_object
			self . remove_button . enabled =
				( grid_info . remove_button <> EMPTY )
		        count = count + 1

		ENDIF

		IF want_select THEN

			self . select_button = button_list [ count ] . prompt_object
			self . select_button . enabled =
				( grid_info . select_button <> EMPTY )
		        count = count + 1

		ENDIF

	ENDIF

ENDROUTINE

{*****************************************************************************}

ROUTINE std_batch_screen_header_action_set_grid_button ( self          ,
							 grid_button )		

{
*
*
******************************************************************************}

	IF global ( "TERMTYPE" ) = "GUI" THEN

		self . grid_button = grid_button . tag

	ENDIF

ENDROUTINE

{*****************************************************************************}

ROUTINE std_batch_screen_header_action_add_buttons ( self        ,
				                     button_list )		

{
*
*
******************************************************************************}


ENDROUTINE


{*****************************************************************************}

ROUTINE std_batch_screen_header_action_valid_batch ( self )

{
*
*
******************************************************************************}

	DECLARE valid                ,
                count                ,
                fields_not_filled    ,
		editor               ,
		message              ,
		table                ,
		invalid_row

	table = "BATCH_HEADER"

	editor = self . header_grid

        IF NOT mandatory_fields_filled ( table              ,
                                         editor . user_info ,
                                         fields_not_filled  ) THEN

                count  = 1

                WHILE fields_not_filled [ count ] <> EMPTY DO

                        editor . set_position ( 1                         ,
                                                fields_not_filled [ count])

                        count = count + 1

                ENDWHILE

		valid = FALSE

                flash_message ( GET_USER_MESSAGE("SAMP_JOB_CONST_7" ,1) ,
                                TRUE                                   )

        ELSE

                valid = self . list_grid . batch . validate ( message     ,
							      invalid_row )	

		IF invalid_row <> 0 THEN

			self . list_grid . set_position ( 2           ,
							  invalid_row )

		ENDIF

		IF NOT valid THEN

			flash_message ( message , TRUE )

		ENDIF

        ENDIF
	
	RETURN ( valid )

ENDROUTINE

{*****************************************************************************}

ROUTINE std_batch_screen_header_action_build_batch ( self )

{
*
*
******************************************************************************}

	DECLARE message     ,
		ok          ,
		message_ptr

	ok = self . list_grid . batch . build ( message )

	IF ok <> EMPTY THEN

		flash_message ( message , TRUE )

	ELSE

		message_fetch ( "BATCH_SCREEN_CREATED_BATCH" , message_ptr )
		message_add_parameter (  message_ptr                          ,
					 self . list_grid . batch . batch_name)
		message = message_get_text ( message_ptr ,1 )

		flash_message ( message , TRUE )


	ENDIF

	RETURN ( ok )

ENDROUTINE

{*****************************************************************************}

ROUTINE std_batch_screen_header_action_update_batch ( self )

{
*
*
******************************************************************************}

	DECLARE ok      ,
		message

	ok = self . list_grid . batch . update ( message )

	IF ok <> EMPTY THEN

		flash_message ( message , TRUE )

	ENDIF

	RETURN ( ok )

ENDROUTINE

{*****************************************************************************}

ROUTINE std_batch_screen_header_action_update_results ( self )

{
*
*
******************************************************************************}

	self . list_grid . batch . update_results ()

ENDROUTINE

{*****************************************************************************}

ROUTINE std_batch_screen_header_action_assign_selected_results ( self )

{
*
*
******************************************************************************}

	self . upload_grid . assign_selected_results ( self . list_grid . batch )

ENDROUTINE

{*****************************************************************************}

ROUTINE std_batch_screen_header_action_set_valid_status (       self   ,
					                  VALUE status )

{
*
*
******************************************************************************}

	self . status_list = status

ENDROUTINE

{*****************************************************************************}

ROUTINE std_batch_screen_header_action_set_status (       self       ,
					            VALUE new_status )

{
*
*
******************************************************************************}

	DECLARE status

	status = self .  list_grid . batch . set_status ( new_status )

	IF status <> EMPTY THEN

		IF ( status = LOCKED ) THEN
			flash_message ( "BATCH_SCREEN_FAIL_LOCKED", TRUE )

		ELSEIF ( status = ERROR ) THEN
			flash_message ( "BATCH_SCREEN_FAIL_ERROR", TRUE )

		ELSE
			flash_message ( status , TRUE )
		ENDIF

	ELSE

		output_message ( "BATCH_SCREEN_SUCCEED_" : new_status )

	ENDIF

ENDROUTINE

{*****************************************************************************}
{******************************************************************************}

ROUTINE batch_screen_result_component (       self           ,
    			    	              grid           ,
                                        VALUE cell_column    ,
		                        VALUE cell_row       ,
		                        VALUE column         ,
		                        VALUE row            ,
			                VALUE cell_width     ,
			                      screen         ,
			                VALUE is_display     )

{
*	Prompt/Display the component name.
*
*
*****************************************************************************}

	DECLARE name

	name  = grid . formatted [ cell_row ] . name

	IF is_display THEN

		DISPLAY name
			ON LINE   row
			FROM      column
			TO        column + cell_width -1
			IN WINDOW screen

	ELSE

		PROMPT FOR       name
		       ON LINE   row
		       FROM      column
		       TO        column + cell_width - 1	
		       IN WINDOW screen		        	
		       WITH    ( display_only = TRUE )	

	ENDIF

ENDROUTINE

{******************************************************************************}

ROUTINE batch_screen_result_value (       self           ,
    			    	          grid           ,
                                    VALUE cell_column    ,
		                    VALUE cell_row       ,
		                    VALUE column         ,
		                    VALUE row            ,
			            VALUE cell_width     ,
			                  screen         ,
			            VALUE is_display     )

{
*	Prompt/Display the result value.
*
*
*****************************************************************************}

	DECLARE text

	text  = grid . formatted [ cell_row ] . text
	
	IF is_display THEN
		
		DISPLAY text
			ON LINE row
			FROM    column
			TO      column + cell_width - 1
			IN WINDOW screen


	ELSE

		PROMPT  FOR       text
			ON LINE   row
			FROM      column
			TO        column + cell_width - 1
			IN WINDOW screen
			WITH    ( display_only = TRUE )

	ENDIF

ENDROUTINE

{******************************************************************************}

ROUTINE batch_screen_result_units (       self           ,
    			    	          grid           ,
                                    VALUE cell_column    ,
		                    VALUE cell_row       ,
		                    VALUE column         ,
		                    VALUE row            ,
			            VALUE cell_width     ,
			                  screen         ,
			            VALUE is_display     )

{
*	Prompt/Display the units.
*
*
*****************************************************************************}

	DECLARE units

	units  = grid . formatted [ cell_row ] . mlp_units

	IF units = EMPTY THEN

		units  = grid . formatted [ cell_row ] .  result_units

	ENDIF

	IF is_display THEN

		DISPLAY           units
			ON LINE   row
			FROM      column
			TO        column + cell_width -1
			IN WINDOW screen

	ELSE

		PROMPT FOR       units
		       ON LINE   row
		       FROM      column
		       TO        column + cell_width - 1	
		       IN WINDOW screen		
		       WITH    ( display_only = TRUE )	

	ENDIF

ENDROUTINE

{******************************************************************************}

ROUTINE batch_screen_result_review (       self           ,
    			    	           grid           ,
                                     VALUE cell_column    ,
		                     VALUE cell_row       ,
		                     VALUE column         ,
		                     VALUE row            ,
			             VALUE cell_width     ,
			                   screen         ,
			             VALUE is_display     )

{
*	Prompt/Display the units.
*
*
*****************************************************************************}

	DECLARE passes

	passes  = grid . formatted [ cell_row ] . pass_fail

	IF is_display THEN

		DISPLAY passes
			ON LINE   row
			FROM      column
			TO        column + cell_width -1
			IN WINDOW screen
			FORMAT    batch_entry . review_status
			BLINKING = ( passes <> MLP_CONST_PASS )

	ELSE

		PROMPT  FOR       passes
			ON LINE   row
			FROM      column
			TO        column + cell_width -1
			IN WINDOW screen
			FORMAT    batch_entry . review_status
			BLINKING = ( passes <> MLP_CONST_PASS )
			WITH     ( display_only = TRUE )

		DISPLAY passes
			ON LINE   row
			FROM      column
			TO        column + cell_width -1
			IN WINDOW screen
			FORMAT    batch_entry . review_status
			BLINKING = ( passes <> MLP_CONST_PASS )

	ENDIF

ENDROUTINE

{******************************************************************************}

ROUTINE batch_screen_result_level (       self           ,
    			    	          grid           ,
                                    VALUE cell_column    ,
		                    VALUE cell_row       ,
		                    VALUE column         ,
		                    VALUE row            ,
			            VALUE cell_width     ,
			                  screen         ,
			            VALUE is_display     )

{
*	Prompt/Display the level.
*
*
*****************************************************************************}

	DECLARE level

	level  = grid . formatted [ cell_row ] . level
	
	IF is_display THEN
		
		DISPLAY level
			ON LINE row
			FROM    column
			TO      column + cell_width - 1
			IN WINDOW screen


	ELSE

		PROMPT  FOR       level
			ON LINE   row
			FROM      column
			TO        column + cell_width - 1
			IN WINDOW screen
			WITH    ( display_only = TRUE )

	ENDIF

ENDROUTINE

{******************************************************************************}

ROUTINE batch_screen_result_lower (       self           ,
    			    	          grid           ,
                                    VALUE cell_column    ,
		                    VALUE cell_row       ,
		                    VALUE column         ,
		                    VALUE row            ,
			            VALUE cell_width     ,
			                  screen         ,
			            VALUE is_display     )

{
*	Prompt/Display the lower value.
*
*
*****************************************************************************}

	DECLARE lower

	lower  = grid . formatted [ cell_row ] . lower
	
	IF is_display THEN
		
		DISPLAY lower
			ON LINE row
			FROM    column
			TO      column + cell_width - 1
			IN WINDOW screen


	ELSE

		PROMPT  FOR       lower
			ON LINE   row
			FROM      column
			TO        column + cell_width - 1
			IN WINDOW screen
			WITH    ( display_only = TRUE )

	ENDIF

ENDROUTINE

{******************************************************************************}

ROUTINE batch_screen_result_upper (       self           ,
    			    	          grid           ,
                                    VALUE cell_column    ,
		                    VALUE cell_row       ,
		                    VALUE column         ,
		                    VALUE row            ,
			            VALUE cell_width     ,
			                  screen         ,
			            VALUE is_display     )

{
*	Prompt/Display the result value.
*
*
*****************************************************************************}

	DECLARE upper

	upper  = grid . formatted [ cell_row ] . upper
	
	IF is_display THEN
		
		DISPLAY upper
			ON LINE row
			FROM    column
			TO      column + cell_width - 1
			IN WINDOW screen


	ELSE

		PROMPT  FOR       upper
			ON LINE   row
			FROM      column
			TO        column + cell_width - 1
			IN WINDOW screen
			WITH    ( display_only = TRUE )

	ENDIF

ENDROUTINE


{*****************************************************************************}

ROUTINE std_batch_screen_result_action_start_prompt ( self )

{
*
*
******************************************************************************}

	DECLARE old_width

	old_width = self . width

	ARRAY self . prompt_details

	self . prompt_details [1 , 2 ] = "ROUTINE"
	self . prompt_details [1 , 3 ] = global ( "current_library" )
	self . prompt_details [1 , 4 ] = "batch_screen_result_component"
	self . prompt_details [1 , 5 ] = get_user_message ( "BATCH_SCREEN_COMPONENT_TITLE" , 1)
	self . prompt_details [1 , 6 ] = 25

	self . prompt_details [2 , 2 ] = "ROUTINE"
	self . prompt_details [2 , 3 ] = global ( "current_library" )
	self . prompt_details [2 , 4 ] = "batch_screen_result_value"
	self . prompt_details [2 , 5 ] = get_user_message ( "BATCH_SCREEN_VALUE_TITLE" , 1)
	self . prompt_details [2 , 6 ] = 15

	self . prompt_details [3 , 2 ] = "ROUTINE"
	self . prompt_details [3 , 3 ] = global ( "current_library" )
	self . prompt_details [3 , 4 ] = "batch_screen_result_units"
	self . prompt_details [3 , 5 ] = get_user_message ( "BATCH_SCREEN_UNITS_TITLE" , 1)
	self . prompt_details [3 , 6 ] = 10

	self . prompt_details [4 , 2 ] = "ROUTINE"
	self . prompt_details [4 , 3 ] = global ( "current_library" )
	self . prompt_details [4 , 4 ] = "batch_screen_result_review"
	self . prompt_details [4 , 5 ] = get_user_message ( "BATCH_SCREEN_REVIEW_TITLE" , 1)
	self . prompt_details [4 , 6 ] = 10
	
	self . prompt_details [5 , 2 ] = "ROUTINE"
	self . prompt_details [5 , 3 ] = global ( "current_library" )
	self . prompt_details [5 , 4 ] = "batch_screen_result_level"
	self . prompt_details [5 , 5 ] = get_user_message ( "BATCH_SCREEN_LEVEL_TITLE" , 1)
	self . prompt_details [5 , 6 ] = 10

	self . prompt_details [6 , 2 ] = "ROUTINE"
	self . prompt_details [6 , 3 ] = global ( "current_library" )
	self . prompt_details [6 , 4 ] = "batch_screen_result_lower"
	self . prompt_details [6 , 5 ] = get_user_message ( "BATCH_SCREEN_LOWER_TITLE" , 1)
	self . prompt_details [6 , 6 ] = 10

	self . prompt_details [7 , 2 ] = "ROUTINE"
	self . prompt_details [7 , 3 ] = global ( "current_library" )
	self . prompt_details [7 , 4 ] = "batch_screen_result_upper"
	self . prompt_details [7 , 5 ] = get_user_message ( "BATCH_SCREEN_UPPER_TITLE" , 1)
	self . prompt_details [7 , 6 ] = 10


	
	lib_grid_setup_columns (  self . prompt_details ,
				  self                  ,
				 "RESULT"               )	

	self . fixed_columns_left = 1

	self . cell_columns = size_of_array ( self . prompt_details )
	self . cell_rows    = size_of_array ( self .  formatted )
	
	self . title_separator_top  = GRID_SEPARATOR_BOTH
	self . title_rendition_top  = PROMPT_RENDITION_BOLD
	self . title_size_top       = 1

        self . width  = find_min_number ( self . width  ,	
					  old_width     )	
	
	self . vgl_library            = global ( "current_library" )

	object_invoke_class (  self              ,
		               PROMPT_CLASS_GRID ,
		              "START_PROMPT"     )		

ENDROUTINE

{*****************************************************************************}

ROUTINE std_batch_screen_result_action_display_cell (       grid        ,
				                      VALUE cell_column ,	
				                      VALUE cell_row    ,
					                    screen      ,
				                      VALUE column      ,
				                      VALUE row         ,
				                      VALUE cell_width  ,
				                      VALUE cell_height )

{
*	Display an entry from the result list.
*
******************************************************************************}

	lib_grid_display_array ( grid                  ,
				 cell_column           ,
				 cell_row              ,
				 screen                ,
				 column                ,
				 row                   ,
				 cell_width            ,
				 grid . results        ,
				 grid . prompt_details ,
				 "SAMP_TEST_VIEW"      ,
				 FALSE                 ,
				 PROMPT_DETAILS_310    )	
	

ENDROUTINE	

{*****************************************************************************}

ROUTINE std_batch_screen_result_action_prompt_cell (       grid        ,
				                     VALUE cell_column ,	
				                     VALUE cell_row    ,
					                   screen      ,
				                     VALUE column      ,
				                     VALUE row         ,
				                     VALUE cell_width  ,
				                     VALUE cell_height )

{
*	Prompt for an entry in the result.
*
******************************************************************************}

	lib_grid_prompt_array ( grid                  ,
				cell_column           ,
				cell_row              ,
				screen                ,
				column                ,
				row                   ,
				cell_width            ,
				grid . results        ,
				grid . prompt_details ,
				"SAMP_TEST_VIEW"      ,
				FALSE                 ,
				PROMPT_DETAILS_310    )	

ENDROUTINE	

{*****************************************************************************}
{*****************************************************************************}

ROUTINE std_batch_screen_upload_class_initialisation ( self )

{
*	Initialise the object
*
*******************************************************************************}

	self . height            = global ( "SCREEN_HEIGHT" ) - 9
	self . width             = global ( "SCREEN_WIDTH"  ) - 4

	ARRAY self . samples
	ARRAY self . components
	ARRAY self . selected = FALSE
	ARRAY self . screen_order
	ARRAY self . test_order
	ARRAY self . result_contexts
	ARRAY self . result_objects
	ARRAY self . result_text
	ARRAY self . failed


ENDROUTINE

{*****************************************************************************}

ROUTINE std_batch_screen_upload_action_read_in_analysis (       self     ,
							  VALUE analysis )

{
*
*
******************************************************************************}

	DECLARE name   ,
		count

	name = SELECT component . name
	       WHERE  ( analysis = analysis ) AND
		      ( result_type = "N"   )
	       ORDER ON order_number		


	count = 1

	WHILE name <> EMPTY DO

		self . components [ count ] = name

		NEXT component

		name = SELECT component . name

		count = count + 1

	ENDWHILE

ENDROUTINE

{*****************************************************************************}

ROUTINE std_batch_screen_upload_action_build_sample_list ( self )

{
*
*
******************************************************************************}

	DECLARE count      ,
		screen_pos ,
		test       ,
		found

	count = 1
	
	WHILE count <= self . results . sample_size () DO

		self . samples [ count ] = self . results . get_sample ( count )
		test                     = self . results . get_test   ( count )

		found      = FALSE
		screen_pos = 1

		WHILE ( screen_pos <= size_of_array ( self . test_order )) AND
		      ( NOT found                                        )	

			IF self . test_order [ screen_pos ] = test THEN

				found = TRUE			

			ENDIF

			screen_pos = screen_pos + 1

		ENDWHILE

		IF  ( found                                             )
		AND ( screen_pos <= size_of_array ( self . test_order ) ) THEN

			found = self . test_order [ screen_pos ] = test

			WHILE ( screen_pos <= size_of_array ( self . test_order )) AND
			      ( found                                            ) DO

				screen_pos = screen_pos + 1

				found = self . test_order [ screen_pos ] = test


			ENDWHILE
		
			array_insert_slice ( self . test_order ,
					     1                 ,
					     screen_pos        )	

			array_insert_slice ( self . screen_order ,
					     1                   ,
					     screen_pos          )	
			
		ENDIF

		self . screen_order [ screen_pos ] = count
		self . test_order   [ screen_pos ] = test

		count = count + 1

	ENDWHILE

ENDROUTINE

{*****************************************************************************}

ROUTINE std_batch_screen_upload_action_upload_results ( self         ,
							batch_header )

{
*
*
******************************************************************************}

	DECLARE message

	batch_screen_display_message ( get_user_message ( "BATCH_SCREEN_UPLOAD" ,1 ))

	self . read_in_analysis ( batch_header . get_analysis () )

	message = batch_header . upload ( self . results )

	IF message <> EMPTY THEN

		flash_message ( message , TRUE )

	ENDIF	

	batch_screen_clear_message (  )

	RETURN ( message = EMPTY )

ENDROUTINE

{*****************************************************************************}

ROUTINE std_batch_screen_upload_action_rebuild ( self         ,
					         batch_header )

{
*
*
******************************************************************************}

	DECLARE message ,
		worked

	batch_screen_display_message ( get_user_message ( "BATCH_SCREEN_UPLOAD_CHECK" ,1 ))

	IF batch_header . upload_rebuild ( self . results ,
					   message        ) THEN

		batch_screen_display_message ( get_user_message ( "BATCH_SCREEN_UPLOAD_REBUILD" ,1 ))

		batch_header . set_will_update ()

       		batch_header . update ( message )

	ENDIF

	batch_screen_clear_message ()

	IF message <> EMPTY THEN

		worked = FALSE
		flash_message ( message , TRUE )


	ELSE

		worked = TRUE

	ENDIF

	RETURN ( worked )

ENDROUTINE

{*****************************************************************************}

ROUTINE std_batch_screen_upload_action_find_result (       self          ,
                                                     VALUE cell_column   ,
						     VALUE cell_row      )

{
*	Find the result for a given cell
*
******************************************************************************}

	DECLARE result        ,
		detected      ,
		name          ,
        	sample        ,
		test          ,
		pos           ,
		batch         ,
		temp          ,
		failed        ,
		results       ,
		result_object ,
		copy_text     ,
		copy_value

	failed  = FALSE
	sample  = self . screen_order [ cell_row ]
	batch   = self . header . list_grid . batch
	test    = self . test_order [ cell_row ]

	IF self . result_contexts [ cell_row ] = EMPTY THEN

		pos     = batch . find_test ( test )

		IF pos <> 0 THEN

			results = batch . get_entry ( pos ) . get_results ( TRUE )

			self . result_contexts [ cell_row ] = results

		ELSE

			results = EMPTY

		ENDIF

	ELSE

		results = self . result_contexts [ cell_row ]

	ENDIF


	name   = self . components [ cell_column -1 ]
	temp   = lib_comp_add_replicate ( name , 1 )

	IF results <> EMPTY THEN

		result_object =  results . get_result ( EMPTY , temp  )

	ELSE

		result_object = EMPTY

	ENDIF

	IF result_object <> EMPTY THEN	

		self . results . get_result ( sample   ,
					      name     ,
					      result   ,
					      detected )		

		copy_text  = result_object . result_str
		copy_value = result_object . result_val


      		IF NOT detected THEN

			result_object . set_less_than_pql ( results )
			result = result_object . result_str

			IF blank ( result ) THEN

				result = get_user_message ( "BATCH_SCREEN_LESS_DETECT" , 1 )

			ENDIF

		ELSE                	

			result_object . enter_for_type ( result  ,
							 results )

			result = result_object . result_str


	   	ENDIF                                                        	
        	
		failed = result_object . mlp_compare ( results ,
						       EMPTY   ,
						       EMPTY   ,
						       EMPTY   ,
						       FALSE   ) <> "P"				

		result_object . result_str = copy_text
		result_object . result_val = copy_value	

		object_assign_uncounted ( self . result_objects [ cell_column ,
					  			  cell_row ]  ,
					  result_object                       )

	ELSE

		result = " --- "

	ENDIF		


	self . result_text    [ cell_column , cell_row ] = result
	self . failed         [ cell_column , cell_row ] = failed

	RETURN ( result )

ENDROUTINE

{*****************************************************************************}

ROUTINE std_batch_screen_upload_action_display_cell (       self        ,
				                      VALUE cell_column ,	
				                      VALUE cell_row    ,
					                    screen      ,
				                      VALUE column      ,
				                      VALUE row         ,
				                      VALUE cell_width  ,
				                      VALUE cell_height )

{
*	Display a choose element
*
******************************************************************************}

	DECLARE result ,
		output ,
		sample ,
		colour
	
	IF cell_column = 1 THEN

		sample = self . screen_order [ cell_row ]

		output = self . samples [ sample ]

		IF output = EMPTY THEN

			output = ""

		ENDIF

		DISPLAY          output
		       ON LINE   row
		       FROM      column
		       TO        column + cell_width - 1
		       IN WINDOW screen	       	
		       INVERSE = self . selected [ cell_column , cell_row ]			
		       WITH ( display_only = TRUE )
			     	

	ELSE	

		result = self . find_result ( cell_column    ,
					      cell_row       )	


		result         = self . result_text     [ cell_column , cell_row ]

		IF self . failed [ cell_column , cell_row ] THEN

			colour = PROMPT_COLOUR_RED

		ELSE

			colour = PROMPT_COLOUR_BLACK

		ENDIF


		DISPLAY          result
		       ON LINE   row
		       FROM      column
		       TO        column + cell_width - 1
		       IN WINDOW screen			
 		       INVERSE  = self . selected [ cell_column , cell_row ]			
 		       BLINKING = self . failed   [ cell_column , cell_row ]			
 		       WITH ( display_only      = TRUE   ,
			      foreground_colour = colour )	

	ENDIF


ENDROUTINE

{*****************************************************************************}

ROUTINE std_batch_screen_upload_action_prompt_cell (       self        ,
				                     VALUE cell_column ,	
				                     VALUE cell_row    ,
					                   screen      ,
				                     VALUE column      ,
				                     VALUE row         ,
				                     VALUE cell_width  ,
				                     VALUE cell_height )

{
*	Prompt on a choose element
*
******************************************************************************}

	DECLARE result         ,
		sample         ,
		output         ,
		result_object  ,
		result_context ,
		colour

	IF self . header . limits_box_on THEN

		IF global ( "TERMTYPE" ) = "GUI" THEN

	                self . header . mlp_form . prompt_objects [1] .
        	                                                  set_visible ( TRUE )
  			self . header . mlp_form . set_visible ( TRUE )

		ENDIF
        	
	ENDIF

	IF cell_column = 1 THEN

		sample = self . screen_order [ cell_row ]

		output = self . samples [ sample ]

		IF output = EMPTY THEN

			output = ""

		ENDIF

		PROMPT FOR       output
		       ON LINE   row
		       FROM      column
		       TO        column + cell_width - 1
		       IN WINDOW screen			
		       WITH ( display_only = TRUE                               ,
		              inverse = self . selected [ cell_column , cell_row ]	)		

	ELSE	

		result         = self . result_text     [ cell_column , cell_row ]
		result_object  = self . result_objects  [ cell_column , cell_row ]
		result_context = self . result_contexts [ cell_row ]
		result_context . limits_box_on = TRUE

		IF result_object <> EMPTY THEN

			result_context . mlp_form = self . header . mlp_form
			result_object  . mlp_paste ( result_context )

		ENDIF

		IF self . failed [ cell_column , cell_row ] THEN

			colour = PROMPT_COLOUR_RED

		ELSE

			colour = PROMPT_COLOUR_BLACK

		ENDIF

		PROMPT FOR       result
		       ON LINE   row
		       FROM      column
		       TO        column + cell_width - 1
		       IN WINDOW screen			
		       WITH ( display_only = TRUE                                   ,
		              inverse  = self . selected [ cell_column , cell_row ] ,		
 		              blinking = self . failed   [ cell_column , cell_row ] ,			
			      foreground_colour = colour                            )	

		DISPLAY          result
		       ON LINE   row
		       FROM      column
		       TO        column + cell_width - 1
		       IN WINDOW screen			
 		       INVERSE  = self . selected [ cell_column , cell_row ]			
 		       BLINKING = self . failed   [ cell_column , cell_row ]			
 		       WITH ( display_only      = TRUE   ,
			      foreground_colour = colour )	


		IF result_object <> EMPTY THEN

			result_object . mlp_unpaste ( )

		ENDIF

	ENDIF

ENDROUTINE

{*****************************************************************************}

ROUTINE std_batch_screen_upload_action_set_selected (       self     ,
						      VALUE column   ,
						      VALUE row	     )		

{
*	Set the selected flag
*
*******************************************************************************}

	DECLARE count ,
		test

	test = self . test_order [ self . current_row ]

	self . selected [ column , row ] = TRUE

	count = row - 1

	WHILE count > 0 DO


		IF self . test_order [ count ] = test THEN

			IF self . selected [ column , count ] THEN

				self . selected [ column , count ] = FALSE
				self . redisplay_cell ( column ,
							count  )

			ENDIF

		ELSE

			count = 0

		ENDIF

		count = count - 1

	ENDWHILE

	count = row + 1

	WHILE count <= size_of_array ( self. test_order ) DO


		IF self . test_order [ count ] = test THEN

			IF self . selected [ column , count ] THEN

				self . selected [ column , count ] = FALSE
				self . redisplay_cell ( column ,
							count  )

			ENDIF

		ELSE

			count = size_of_array ( self . test_order )

		ENDIF

		count = count + 1

	ENDWHILE

ENDROUTINE
{*****************************************************************************}

ROUTINE std_batch_screen_upload_action_insert ( self )

{
*	Set the insert flag
*
*******************************************************************************}

	DECLARE count          ,
		current_column ,	
		current_row

	current_column = self . current_column
	current_row    = self . current_row

	IF current_row = 0 THEN

	ELSEIF self . current_column = 1 THEN

		count = 1

		WHILE count <= self . cell_columns DO

			self . set_selected ( count , current_row )

        		count = count + 1

		ENDWHILE

		self . redisplay_row ( current_row )	

	ELSE


		self . set_selected ( current_column , current_row )
		self . redisplay_cell ( current_column , current_row )

	ENDIF

ENDROUTINE

{*****************************************************************************}

ROUTINE std_batch_screen_upload_action_remove ( self )

{
*	Set the insert flag
*
*******************************************************************************}

	DECLARE count          ,
		current_column ,	
		current_row

	current_column = self . current_column
	current_row    = self . current_row

	IF current_row = 0 THEN

	ELSEIF self . current_column = 1 THEN

		count = 1

		WHILE count <= self . cell_columns DO

			self . selected [ count , current_row ] = FALSE
        		count = count + 1

		ENDWHILE

		self . redisplay_row ( current_row )	

	ELSE

		self . selected [ current_column , current_row ] = FALSE
		self . redisplay_cell ( current_column , current_row )

	ENDIF

ENDROUTINE

{*****************************************************************************}

ROUTINE std_batch_screen_upload_action_select ( self )

{
*	Toggle the MLP display box
*
*******************************************************************************}

	DECLARE form      ,
		grid_info

	form = self . header

	form . limits_box_on = NOT form . limits_box_on

	IF global ( "TERMTYPE" ) = "GUI" THEN

		grid_info = form . grids [ form . current_grid ]

		IF form . limits_box_on THEN

			grid_info . select_button = get_user_message ( "BATCH_SCREEN_MLP_BUTTON" , 1  )

			form . mlp_form . prompt_objects [1] .
                                                          set_visible ( TRUE )
			form . mlp_form . set_visible ( TRUE )

		ELSE

			grid_info . select_button = get_user_message ( "BATCH_SCREEN_MLP_BUTTON" , 2  )

			form . mlp_form . set_visible ( FALSE )

		ENDIF

		form . select_button . caption = grid_info . select_button
                form . select_button . repaste ()

	ENDIF

ENDROUTINE

{*****************************************************************************}

ROUTINE std_batch_screen_upload_action_start_prompt ( self )

{
*	Start the batch choose grid.
*
*******************************************************************************}

	DECLARE count

	self . cell_columns = size_of_array ( self . components ) + 1
	self . cell_rows    = size_of_array ( self . samples )
	
	self . title_separator_top  = GRID_SEPARATOR_BOTH
	self . title_rendition_top  = PROMPT_RENDITION_BOLD
	self . title_size_top       = 1

	IF self . cell_columns > 1 THEN

		self . fixed_columns_left   = 1

	ENDIF

	self . width  = ( self . cell_columns * 10 ) + 30

        self . width  = find_min_number ( self . width               ,	
					  self . header . grid_width )	

	
	self . column_size [ 1 ] = 30
	self . title_text_top [ 1 , 1 ] = get_user_message ("BATCH_SCREEN_SAMPLE_TITLE" ,1 )

	count = 2

	WHILE count <= self . cell_columns DO
		
		self . title_text_top [ count , 1 ] = self . components [ count- 1 ]
		self . column_size [ count ] = 10
		count = count + 1

	ENDWHILE		

	self . vgl_library            = global ( "current_library" )

	object_invoke_class (  self              ,
		               PROMPT_CLASS_GRID ,
		              "START_PROMPT"     )		

ENDROUTINE

{*****************************************************************************}

ROUTINE std_batch_screen_upload_action_leave_prompt ( self )

{
*
*
******************************************************************************}

	IF self . header . limits_box_on AND
	   ( global ( "TERMTYPE" ) = "GUI" )  THEN

		IF self . header . mlp_form . visible THEN

			self . header . mlp_form . set_visible ( FALSE )

		ENDIF

	ENDIF

	IF self . get_lastkey () = "TAB" THEN

		self . set_lastkey ( "CONTINUE" )

		self . header . tab_grid ()

	ENDIF

ENDROUTINE

{*****************************************************************************}

ROUTINE std_batch_screen_upload_action_assign_selected_results ( self  ,
							         batch )

{
*
*
******************************************************************************}

	DECLARE row_count    ,
		column_count ,
		entry        ,
		name         ,
		sample       ,
		test         ,
		pos

	row_count = 1
	
	WHILE row_count <= self . cell_rows DO

		sample  = self . screen_order [ row_count ]
		test    = self . test_order [ row_count ]

		pos     = batch . find_test ( test )
		entry   = batch . get_entry ( pos  )

		column_count = 2

		WHILE column_count <= self . cell_columns DO

			IF self . selected [ column_count ,
					     row_count    ] THEN

				name   = self . components [ column_count - 1 ]

				self . results . assign ( entry   ,
							  sample  ,
							  name    )

			ENDIF	

			column_count = column_count + 1

		ENDWHILE

		row_count = row_count + 1

	ENDWHILE

ENDROUTINE

{****************************************************************************************}

ROUTINE batch_screen_chart_button ( self )

{
*
*
****************************************************************************************}
	

	DECLARE identity
	
	identity = SELECT batch_header . identity

	batch_sqc_charts_for_given ( identity )
	
ENDROUTINE











