{******************************************************************************
*
* Module Name   : LIT_PACKAGER
*
* Purpose       : Utility to create and install packages
*
* Document Ref. :
*
* Specification :
*
*******************************************************************************
*
* Modification History ________________________________________________________
*
* Date___________  By________    Reason__________________________________________
* Nov 04, 2007     LIT           Created
* Feb 19, 2008     LIT001        Delivery of *.arc use FILE COPY and check retval
*******************************************************************************}

ENABLE WINDOWS

SET NAME "DEFER/"
SET NOTPROTECTED
SET COMPILE_OPTION DECLARE

{ **************************************************************************** }

JOIN STANDARD_LIBRARY STD_ARRAY         { size_of_array                        }
JOIN STANDARD_LIBRARY STD_ARRAY_SELECT  { array_select_add                     }
JOIN STANDARD_LIBRARY STD_CLASS         { object_set_current_table/add_table   }
JOIN STANDARD_LIBRARY STD_CLIENT        { client_registry_get_values           }
JOIN STANDARD_LIBRARY STD_DATABASE      { lock_upgrade                         }
JOIN STANDARD_LIBRARY STD_GENERAL       { variable_get_type, var_is_assigned   }
JOIN STANDARD_LIBRARY STD_GLOBAL        { global_exists                        }
JOIN STANDARD_LIBRARY STD_MESSAGE       { message_fetch, message_get_text      }
JOIN STANDARD_LIBRARY STD_OUTPUT        { output_to_editor                     }
JOIN STANDARD_LIBRARY STD_PROMPT        { prompt_class_form                    }
JOIN STANDARD_LIBRARY STD_STRUCTURE     { valid_table                          }
JOIN STANDARD_LIBRARY STD_TRANSFER      { transfer_binary_to_server            }
JOIN STANDARD_LIBRARY STD_USER_LOGIN    { user_login_reconnect                 }
JOIN STANDARD_LIBRARY STD_VGL           { vgl_validate_routine                 }
JOIN STANDARD_LIBRARY STD_WINDOW        { window_set_status                    }

JOIN LIBRARY $CRITERIA_SAVED            { criteria_saved_load_squirrel         }
JOIN LIBRARY $INSTALL_WINDOW            { Table loader low level setup         }
JOIN LIBRARY $LABTABLIB                 { old fashioned LTE's                  }
JOIN LIBRARY $LIB_MENU                  { lib_menu_get_new_proc_num            }
JOIN LIBRARY $LIB_UTILS                 { flash_message                        }
JOIN LIBRARY $LIST_EDITOR               { old fashioned LTE's                  }
JOIN LIBRARY $LIB_LIST_VIEWER           { list shown on veto of record load    }
JOIN LIBRARY $MENU_EDIT                 { smw menu edit to import .menu        }
JOIN LIBRARY $PROMPT_LIST               { old fashioned LTE's                  }
JOIN LIBRARY $PROMPT_WINDOW             { get_identity_using_criteria          }
JOIN LIBRARY $TABLE_LOAD_SAVE_LIB       { output_csv_file                      }


{ ********************************** CLASSES ********************************* }


CONSTANT CLASS_PACKAGER_CLASS            = "PACKAGER"                   { class for package/install  }
CONSTANT CLASS_STD_NET_SERVER            = "STD_NET_SERVER"             { class NET for 7zip         }
CONSTANT CLASS_MESSAGES                  = "msg"                        { main class for messages    }
CONSTANT CLASS_STD_OLE_AUTOMATION_SERVER = "STD_OLE_AUTOMATION_SERVER"  { class COM for FSO          }

{ *****************************   GLOBAL CONSTANTS *************************** }


{ ********************************** CONSTANTS ******************************* }
CONSTANT C_SMP_VERSIONS                 = "#2004R2#92#921"
CONSTANT C_STD_OBJECT_DATABASE          = "STD_OBJECT_DATABASE"  { object databases           }
CONSTANT C_BASEDATE                     = "1-JAN-1990 00:00:00"  { fso object file dates      }
CONSTANT C_BASEDATENUM                  = 32874                  { fso object file dates      }

CONSTANT C_MESSAGE_POINTERS             = "LIT_MESSAGE_POINTERS" { global if messages decoded }
CONSTANT C_UNINSTALL_DIR                = "UNINSTALL"
CONSTANT C_VERSION_0_NO_FILE            = "Version 0 file does not exist"

CONSTANT C_STRUCTURE_PREFIX             = "STRUCTURE_"
CONSTANT C_SMW_MENU_PREFIX              = "MENU_"
CONSTANT C_MESSAGES_PREFIX              = "MESSAGES_"
CONSTANT C_DEFAULT_LAB_FILE             = "SMP$USERFILES\DEFAULT.LAB"
CONSTANT C_PROCEDURE_CONTEXT            = "IMPLEMENTATION"
CONSTANT C_PROCEDURE_OK                 = "Ok"
CONSTANT C_MAKE_VERSION_0               = FALSE                         { must be false.... future use }
CONSTANT C_PKG_INSTALL_VETO             = "PKG_INSTALL_VETO"            { config item verbosity        }
CONSTANT C_PKG_INSTALL_VETO_MSG         = "Packager/Installer Veto"     { config item description      }

CONSTANT C_MESSAGE_FILE_ID              = "SMP$MESSAGES\LIT_MESSAGES_PACKAGER.TXT"
CONSTANT C_MESSAGE_FILE_ID_NO_DIR       = "LIT_MESSAGES_PACKAGER.TXT"

CONSTANT C_7ZIP_USE_DOT_NET             = FALSE
CONSTANT C_7_ZIP                        = "7-Zip"
CONSTANT C_7ZA_EXE                      = "7za.exe"
CONSTANT C_THERMO_7_ZIP                 = "Thermo.Informatics.SRD._7Zip"
CONSTANT C_7ZIP_SELF_EXTRACT_CMD        = " a -sfx "
CONSTANT C_7ZIP_ZIP_EXTRACT_CMD         = " x "
CONSTANT C_7ZIP_UNZIP_OVERWRITE         = " -aoa"
CONSTANT C_7ZIP_ZIP_CREATE_CMD          = " a "

CONSTANT C_SECTION_LINE                 = "= = = = = = = = = = = = = = = = = = = = "
CONSTANT C_INSTALL_SET_EXT              = "SMP"
CONSTANT C_PACKAGER_WRITE_TRANS         = "PACKAGER_UPDATE"

CONSTANT C_DEFAULT_PACKAGE_ID           = "PACKAGER_SELF_EXTRACT_INSTALL_KIT"
CONSTANT C_DEFAULT_PACKAGE_ID2          = "921_PACKAGER_1"

CONSTANT C_TRIGGER_LIBRARY              = "LIT_PACKAGER_USER"
CONSTANT C_TRIGGER_BASE_ROUTINE         = "packager_"
CONSTANT C_TRIGGER_BUILD_COMPLETE       = "COMPLETED_BUILD"
CONSTANT C_TRIGGER_INSTALL_COMPLETE     = "COMPLETED_INSTALL"
CONSTANT C_TRIGGER_BEFORE_MAKE_DATA     = "BEFORE_MAKE_DATA"
CONSTANT C_TRIGGER_BEFORE_SAVE          = "BEFORE_SAVE"
CONSTANT C_TRIGGER_BEFORE_INSTALL_COMMIT= "BEFORE_INSTALL_COMMIT"
CONSTANT C_TRIGGER_BEFORE_BUILD_COMMIT  = "BEFORE_BUILD_COMMIT"
CONSTANT C_TRIGGER_LOAD_COMPLETE        = "LOAD_COMPLETE"
CONSTANT C_TRIGGER_MOVE_ZIP_COMPLETE    = "MOVE_ZIP_COMPLETE"

CONSTANT C_MSG_POINTER_DESCRIPTION      = "Boolean TRUE messages displayed, FALSE message id's"
CONSTANT C_CLIENT_DIR                   = "\client_dll"     { must be lower case and \ }
CONSTANT C_SERVER_DIR                   = "\server_dll"     { must be lower case and \ }
CONSTANT C_TAB                          = ASCII(11)

CONSTANT C_MODULE_PREFIX                = "M_"
CONSTANT C_STRUCTURE_TXT                = "STRUCTURE.TXT"
CONSTANT C_COMPILE_VGSM                 = "COMPILE.VGSM"
CONSTANT C_MESSAGE_TXT                  = "MESSAGE.TXT"
CONSTANT C_SMW_MENU                     = "SMW.MENU"
CONSTANT C_MTB_MENU                     = "MENU.MTB"
CONSTANT C_DOCUMENT_DOC                 = "DOCUMENT.DOC"
CONSTANT C_HELP_FILE                    = "HELP.CHM"
CONSTANT C_PRESENTATION_PPT             = "PRESENTATION.PPT"
CONSTANT C_CRITERIA_CRT                 = "CRITERIA.CRT"
CONSTANT C_DEFAULT_LAB                  = "DEFAULT.LAB"
CONSTANT C_PHRASE_CRITERIA_TABLE        = "PKG_TYPES"
CONSTANT C_PHRASE_LOGICALS              = "PKGLOGICAL"

CONSTANT C_STRUCTURE_TXT_FULL           = "SMP$DATAFILES\STRUCTURE.TXT"
CONSTANT C_MESSAGE_TXT_FULL             = "SMP$MESSAGES\MESSAGE.TXT"
CONSTANT C_MESSAGE_INCLUDE_PREFIX       = "INCLUDE     "
CONSTANT C_LIT_DATABASE                 = "LIT_DATABASE"
CONSTANT C_LIT_DATABASE_WRITE_STRUCTURE = "DONOTUSE_MENU_create_file_structure_txt"

CONSTANT C_CRITERIA_SAVED_ADD           = 831
CONSTANT C_CRITERIA_SAVED_COPY          = 832
CONSTANT C_CRITERIA_SAVED_MODIFY        = 833

CONSTANT C_REG_SERVER_LOGICALS          = TRUE                      { MUST BE FALSE on > 2004R2 SMP versions }
CONSTANT C_REG_HKEY_LOCAL_MACHINE       = "HKEY_LOCAL_MACHINE"
CONSTANT C_REG_THERMO_INSTANCE          = "Software\LabSystems\SampleManager Server\"
CONSTANT C_REG_KEY_ADD_INSTALL          = "reg add "

CONSTANT C_OK_SUFFIX                    = "_ok"                      { must be lower case }
CONSTANT C_FAIL_SUFFIX                  = "_errors"                  { must be lower case }

CONSTANT C_REAL_FORMAT                  = "99.9999999999999999E9999" { Allow maximum resolution   }
CONSTANT C_DATE_FORMAT                  = "DD-MM-YYYY H24:MI:SS.CC"  { for reals and dates        }

CONSTANT C_SMP_MODULE_INSTALL_SET_DIR   = "SMP$INSTALL"
CONSTANT C_SMP_MODULE_INSTALL_DIR_VALUE = "INSTALL"
CONSTANT C_SMP_MODULE_INSTALL_SET_EXT   = "SMP"
CONSTANT C_SMP_MODULE                   = "SMP_MODULE"

CONSTANT C_SMP_MODULE_CRITERIA          = "SMP_MODULE_CRITERIA"
CONSTANT C_SMP_MODULE_PROGRAM           = "SMP_MODULE_PROGRAM"
CONSTANT C_SMP_MODULE_MENU              = "SMP_MODULE_MENU"
CONSTANT C_SMP_STRUCTURE                = "SMP_STRUCTURE"

CONSTANT C_SMP_KEY1_LEN                 = 10
CONSTANT C_SMP_KEY2_LEN                 = 40

CONSTANT C_DELIMIT_CHAR                 = ASCII(34)
CONSTANT C_CSV_LOAD_LOCK_RETRY          = 100
CONSTANT C_CSV_INTERVAL_SLEEP           = INTERVAL ( "0 00:00:05" )
CONSTANT C_VETO_PREFIX                  = "                                                       DATA_VETO_SKIP "
CONSTANT C_SKIP_PREFIX                  = "                                                       DATA_EXISTS    "
CONSTANT C_SHOW_PREFIX                  = "   "

{ *****************************  GLOBAL VARIABLES   ************************** }

DECLARE retval                 ,
        GLBL_id                ,
        status                 ,
        a_msg                  ,
        array_structure_lines  ,
        array_message_lines    ,
        tables_ok

{******************************************************************************}
{  OLD FASHIONED LTE VARIABLES                                                 }
{******************************************************************************}

DECLARE name_of_table            ,
    directory               ,
    extn                    ,
    help_context            ,
    default_value           ,
    input_mess              ,
    header_mess             ,
    footer_mess             ,
    display_footer_mess     ,
    displayed_name_of_table ,
    fields_to_output        ,
    special_actions_report  ,
    labtable_messages       ,
    prompt_details          ,
    the_list_editor

{ **************************************************************************** }
{                                                                              }
{                                                                              }
{                                                                              }
{   DEFAULT PROGRAM - check if packager is installed and if not then install   }
{                                                                              }
{                                                                              }
{                                                                              }
{ **************************************************************************** }

internal_install_packager()      {Program installs/validates itself }
EXIT

{ **************************************************************************** }

ROUTINE internal_install_packager

    DECLARE a_dir  ,
            a_mode

    { --------------------------------------------------------------- }
    { Very first time ran on the install of packager itself           }
    { --------------------------------------------------------------- }

    IF NOT ( internal_validate_server ( a_dir, tables_ok ) ) THEN

        FLASH_MESSAGE ( "LIT_LAB_SMP_MODULE_ERROR_SMPINSTALL", FALSE )

    { --------------------------------------------------------------- }
    { 2nd stage of packager installing itself                         }
    { --------------------------------------------------------------- }

    ELSEIF ( NOT tables_ok ) THEN

        IF ( internal_first_time()  ) THEN

            MENU_move_zip_package ( "EXE_FIRST" )  { must be this param... }

            FLASH_MESSAGE ( "Self-install completed, you must restart the client", FALSE )
            EXIT

        ENDIF

    { --------------------------------------------------------------- }
    { 3rd stage of packager install itself (user re-signed on)        }
    { --------------------------------------------------------------- }

    ELSEIF ( internal_create_record ( C_DEFAULT_PACKAGE_ID, C_DEFAULT_PACKAGE_ID2, TRUE, TRUE, FALSE ) ) THEN

        Menu_install_package ( "FIRST" )

    { --------------------------------------------------------------- }
    { Option 1 - packager installed, but moving a new kit (no menu)   }
    { --------------------------------------------------------------- }

    ELSEIF GLOBAL ( "PARAM_ACTIVE" ) THEN

        PROMPT FOR a_mode

        IF ( INDEX ( "#ZIP#EXE#", a_mode ) = 0 ) THEN

            a_mode = "EXE"

        ENDIF

        Menu_move_zip_package ( a_mode )

    { --------------------------------------------------------------- }
    { Option n - packager installed, new kit moved, now install new 1 }
    { --------------------------------------------------------------- }

    ELSEIF ( CONFIRM_WITH_TEXT ( "Install kit" ) ) THEN

        Menu_install_package ( "Default_Install_Mode" )

    ELSEIF ( CONFIRM_WITH_TEXT ( "Create a new package ?" ) ) THEN    { or maybe even create one to install somewhere else ? }

        Menu_create_package ( "Default_Create_Mode" )

    ENDIF

    EXIT

ENDROUTINE  { internal_install_packager }

{ **************************************************************************** }

ROUTINE internal_first_time

    DECLARE a_file,
                 status,
            a_cnt

    retval = FALSE
    a_file = C_STRUCTURE_TXT_FULL

    ARRAY array_structure_lines
    ARRAY array_message_lines

    internal_set_structure_lines ( array_structure_lines )
    internal_set_message_lines   ( array_message_lines   )

    { ------------------------------------------------------------------------------------ }
    { This caption cannot be a message because it is part of the self install of packager  }
    { ------------------------------------------------------------------------------------ }

    IF ( CONFIRM_WITH_TEXT ( "Append structure.txt with SMP Module tables and fields ? " ) ) THEN

        FILE EXTEND a_file, status

        { ------------------------------------------------------------------------- }
        { Write the default lines of the structure for the module                   }
        { ------------------------------------------------------------------------- }

        a_cnt = 1

        WHILE ( array_structure_lines[a_cnt] <> EMPTY ) DO

            FILE WRITE a_file, array_structure_lines[a_cnt], status
            a_cnt = a_cnt + 1

        ENDWHILE

        { ------------------------------------------------------------------------- }
        { All done writing data to file, save it and process / check errors         }
        { ------------------------------------------------------------------------- }

        FILE CLOSE  a_file, status

    ELSE

        status = EMPTY

    ENDIF   { user did not want to append/correct structure file, must have already done it }

    { ------------------------------------------------------------------------------------ }
    { Now continue with messages - this checks message.txt for the file so no veto needed  }
    { ------------------------------------------------------------------------------------ }

    IF ( status <> EMPTY ) THEN

        FLASH_MESSAGE ( "** Error appending to structure.txt, cannot continue " : status, TRUE )   { cannot be message.txt is install of self }

    ELSEIF ( GLOBAL ( "MODE" ) = "INTERACTIVE" ) THEN

        { ------------------------------------------------------------------------- }
        { These messages cannot be translated (the message file is not there)       }
        { ------------------------------------------------------------------------- }

        internal_structure ( "create_structure ", "OK", "", "SMP$TEXTREPORTS" )

        IF confirm_with_text ( "Did structure create ok ?" ) THEN                                 { cannot be message.txt is install of self }

            internal_structure ( "convert_table ", "successfully", "-mode CONVERT -tables * -noconfirm", "SMP$TEXTREPORTS" )

            IF confirm_with_text ( "Did structure convert ok ?" ) THEN

                internal_structure ( "create_message ", "OK", " ", "SMP$TEXTREPORTS" )

                retval = confirm_with_text ( "Did messages create ok?" )                  { cannot be message.txt is install of self }

            ELSE

                retval = FALSE

            ENDIF

        ELSE

            retval = FALSE

        ENDIF
    ELSE

        { ------------------------------------------------------------------------- }
        { Non-interactive - so use the return value to determine success            }
        { ------------------------------------------------------------------------- }

        IF ( internal_structure ( "create_structure ", "OK", "", "SMP$TEXTREPORTS" ) ) THEN

            retval = internal_structure ( "convert_table ", "successfully", "-mode CONVERT -tables * -noconfirm", "SMP$TEXTREPORTS" )

        ENDIF

        retval = ( retval ) AND ( internal_structure ( "create_message ", "Section made", " ", "SMP$TEXTREPORTS" ) )

    ENDIF

    RETURN ( retval )

ENDROUTINE  {  internal_first_time }

{ **************************************************************************** }

ROUTINE internal_set_structure_lines ( array_structure_lines )

    array_structure_lines[ 1] = ""
    array_structure_lines[ 2] = ""
    array_structure_lines[ 3] = "{ **************************************************************************************** }"
    array_structure_lines[ 4] = " "
    array_structure_lines[ 5] = "TABLE SMP_MODULE;"
    array_structure_lines[ 6] = "     FIELD SMP_VERSION             datatype IDENTITY(10) default '2004R2'   used_for unique_key,primary_browse;"
    array_structure_lines[ 7] = "     FIELD IDENTITY                datatype IDENTITY(16)                    used_for unique_key,display_browse (1);"
    array_structure_lines[ 8] = "     FIELD VERSION_NUMBER          datatype PACKED_DECIMAL                  used_for unique_key,version_number,display_browse (2);"
    array_structure_lines[ 9] = "     FIELD DESCRIPTION             datatype TEXT(255)                       used_for display_browse (3);"
    array_structure_lines[10] = "     FIELD DATE_INSTALLED          datatype DATE                            used_for display_browse (4);"
    array_structure_lines[11] = "     FIELD DATE_REMOVED            datatype DATE                            used_for display_browse (5);"
    array_structure_lines[12] = "     FIELD MODULE_TYPE             datatype IDENTITY(10) PROMPT_TYPE Choose CHOOSE_TYPE  MOD_TYPE  default 'IFM' used_for display_browse (6);"
    array_structure_lines[13] = "     FIELD INSTALL_SET             datatype TEXT(234)  DEFAULT 'SMP$INSTALL.SMP';"
    array_structure_lines[14] = "     FIELD INSTALL_SET_ZIP_FILE    datatype TEXT(234);"
    array_structure_lines[15] = "     FIELD STRUCTURE_UPDATED       datatype BOOLEAN true_word 'Yes'  false_word 'No'  default 'No' ;"
    array_structure_lines[16] = "     FIELD MESSAGES_UPDATED        datatype BOOLEAN true_word 'Yes'  false_word 'No'  default 'No' ;"
    array_structure_lines[17] = "     FIELD SMW_MENU_UPDATED        datatype BOOLEAN true_word 'Yes'  false_word 'No'  default 'No' ;"
    array_structure_lines[18] = "     FIELD FILES_UPDATED           datatype BOOLEAN true_word 'Yes'  false_word 'No'  default 'No' ;"
    array_structure_lines[19] = "     FIELD CRITERIA_VERSIONED      datatype BOOLEAN true_word 'Yes'  false_word 'No'  default 'No' ;"
    array_structure_lines[20] = "     FIELD STAGE_OF_INSTALL        datatype BOOLEAN true_word 'Installed'  false_word 'Phased_Install'  default 'Phased_Install';"
    array_structure_lines[21] = "     FIELD MENU_CONTEXT            datatype IDENTITY(20) PROMPT_TYPE phrase valid  PHRASE_TYPE MENU_NMBR;"
    array_structure_lines[22] = "     FIELD NEW_VERSION             datatype BOOLEAN true_word 'Yes'  false_word 'No'  default 'No' ;"
    array_structure_lines[23] = "     FIELD NEW_ENTRY_CODE          datatype BOOLEAN true_word 'Yes'  false_word 'No'  default 'No' ;"
    array_structure_lines[24] = "     FIELD MODIFIED_ON             datatype DATE                            used_for modified_on,display_browse (7);"
    array_structure_lines[25] = "     FIELD MODIFIED_BY             links_to PERSONNEL.IDENTITY              used_for modified_by,display_browse (8);"
    array_structure_lines[26] = "{----------------}"
    array_structure_lines[27] = "{----------------}"
    array_structure_lines[28] = " "
    array_structure_lines[29] = " "
    array_structure_lines[30] = "{ **************************************************************************************** }"
    array_structure_lines[31] = " "
    array_structure_lines[32] = "TABLE SMP_MODULE_CRITERIA;"
    array_structure_lines[33] = "     FIELD SMP_VERSION             links_to SMP_MODULE.SMP_VERSION      used_for unique_key,primary_browse;"
    array_structure_lines[34] = "     FIELD IDENTITY                links_to SMP_MODULE.IDENTITY         used_for unique_key,display_browse (1);"
    array_structure_lines[35] = "     FIELD VERSION_NUMBER          links_to SMP_MODULE.VERSION_NUMBER   used_for unique_key,version_number,display_browse (2);"
    array_structure_lines[36] = "     FIELD ORDER_NUMBER            datatype PACKED_DECIMAL              used_for unique_key,ordering;"
    array_structure_lines[37] = "     FIELD SAVE_MODE               datatype IDENTITY(10) PROMPT_TYPE phrase identities valid PHRASE_TYPE SAVE_MODES used_for display_browse (3);"
    array_structure_lines[38] = "     FIELD TABLE_NAME              datatype IDENTITY(20)                used_for  display_browse (4);"
    array_structure_lines[39] = "     FIELD CRITERIA_SAVED          links_to CRITERIA_SAVED.IDENTITY     used_for  display_browse (5);"
    array_structure_lines[40] = "     FIELD CSV_FILE                datatype TEXT(234)                   used_for  display_browse (6);"
    array_structure_lines[41] = "     FIELD FILE_LOGICAL            datatype IDENTITY(40)                used_for  display_browse (7);"
    array_structure_lines[42] = "     FIELD FILE_SUB_DIRECTORY      datatype IDENTITY(40)                used_for  display_browse (10);"
    array_structure_lines[43] = "     FIELD FILE_ID                 datatype TEXT(100)                   used_for  display_browse (8);"
    array_structure_lines[44] = "     FIELD FILE_EXTENSION          datatype IDENTITY(10) PROMPT_TYPE phrase identities valid PHRASE_TYPE FILE_EXT   used_for display_browse (9);"
    array_structure_lines[45] = "     FIELD DESCRIPTION             datatype TEXT(234)                   used_for  display_browse (11);"
    array_structure_lines[46] = "     FIELD NO_RECORDS_TO_LOAD      datatype INTEGER lower_limit 0  upper_limit 99999 default 0 ;"
    array_structure_lines[47] = "     FIELD NO_RECORDS_LOADED       datatype INTEGER lower_limit 0  upper_limit 99999 default 0 ;"
    array_structure_lines[48] = "     FIELD NO_RECORDS_SKIPPED      datatype INTEGER lower_limit 0  upper_limit 99999 default 0 ;"
    array_structure_lines[49] = "     FIELD NO_COMPILES             datatype INTEGER lower_limit 0  upper_limit 999   default 0 ;"
    array_structure_lines[50] = "     FIELD NO_FILES_MOVED          datatype INTEGER lower_limit 0  upper_limit 999   default 0 ;"
    array_structure_lines[51] = "     FIELD MODE_TABLE              datatype TEXT(30);"
    array_structure_lines[52] = "{----------------}"
    array_structure_lines[53] = "{----------------}"
    array_structure_lines[54] = " "
    array_structure_lines[55] = "{ **************************************************************************************** }"
    array_structure_lines[56] = " "
    array_structure_lines[57] = "TABLE SMP_MODULE_PROGRAM;"
    array_structure_lines[58] = "     FIELD SMP_VERSION             links_to SMP_MODULE.SMP_VERSION        used_for unique_key,primary_browse;"
    array_structure_lines[59] = "     FIELD IDENTITY                links_to SMP_MODULE.IDENTITY           used_for unique_key,display_browse (1);"
    array_structure_lines[60] = "     FIELD VERSION_NUMBER          links_to SMP_MODULE.VERSION_NUMBER     used_for unique_key,version_number,display_browse (2);"
    array_structure_lines[61] = "     FIELD ORDER_NUMBER            datatype PACKED_DECIMAL                used_for unique_key,ordering,display_browse (3);"
    array_structure_lines[62] = "     FIELD PROGRAM_DLL             datatype TEXT(200)                     used_for  display_browse (4);"
    array_structure_lines[63] = "     FIELD FILENAME_ONLY           datatype TEXT(50);"
    array_structure_lines[64] = "     FIELD PROGRAM_SET             datatype IDENTITY(10)                  used_for  display_browse (5);"
    array_structure_lines[65] = "     FIELD CLIENT_SERVER           datatype BOOLEAN true_word 'CLIENT_DLL'  false_word 'SERVER_DLL'  default 'SERVER_DLL' ;"
    array_structure_lines[66] = "     FIELD MINIMUM_VERSION         datatype TEXT(10);"
    array_structure_lines[67] = "     FIELD DESCRIPTION             datatype TEXT(234);"
    array_structure_lines[68] = "     FIELD MODULE_INSTALL_OK       datatype BOOLEAN true_word 'Y' false_word 'N' default 'N';"
    array_structure_lines[69] = "{----------------}"
    array_structure_lines[70] = "{----------------}"
    array_structure_lines[71] = " "
    array_structure_lines[72] = " "
    array_structure_lines[73] = "{ **************************************************************************************** }"
    array_structure_lines[74] = " "
    array_structure_lines[75] = "TABLE SMP_MODULE_MENU;"
    array_structure_lines[76] = "     FIELD SMP_VERSION             links_to SMP_MODULE.SMP_VERSION        used_for unique_key,primary_browse;"
    array_structure_lines[77] = "     FIELD IDENTITY                links_to SMP_MODULE.IDENTITY           used_for unique_key,display_browse (1);"
    array_structure_lines[78] = "     FIELD VERSION_NUMBER          links_to SMP_MODULE.VERSION_NUMBER     used_for unique_key,version_number,display_browse (2);"
    array_structure_lines[79] = "     FIELD PROCEDURE_NUM           links_to MASTER_MENU.PROCEDURE_NUM     used_for unique_key,display_browse(3);"
    array_structure_lines[80] = "     FIELD SHORT_TEXT              links_to MASTER_MENU.SHORT_TEXT        used_for display_browse(4);"
    array_structure_lines[81] = "     FIELD GENERATE_NEW_ONE        datatype BOOLEAN true_word 'Y' false_word 'N' default 'N' used_for display_browse(5);"
    array_structure_lines[82] = "     FIELD NEW_PROCEDURE_NUM       links_to MASTER_MENU.PROCEDURE_NUM                        used_for display_browse(6);"
    array_structure_lines[83] = "{----------------}"
    array_structure_lines[84] = "{----------------}"
    array_structure_lines[85] = " "
    array_structure_lines[86] = " "
    array_structure_lines[87] = "{ **************************************************************************************** }"
    array_structure_lines[88] = " "
    array_structure_lines[89] = "TABLE SMP_MODULE_INSTRUCT;"
    array_structure_lines[90] = "     FIELD SMP_VERSION             links_to SMP_MODULE.SMP_VERSION        used_for unique_key,primary_browse;"
    array_structure_lines[91] = "     FIELD IDENTITY                links_to SMP_MODULE.IDENTITY           used_for unique_key,display_browse (1);"
    array_structure_lines[92] = "     FIELD VERSION_NUMBER          links_to SMP_MODULE.VERSION_NUMBER     used_for unique_key,version_number,display_browse (2);"
    array_structure_lines[93] = "     FIELD ORDER_NUMBER            DATATYPE PACKED_DECIMAL                used_for unique_key,display_browse(3);"
    array_structure_lines[94] = "     FIELD INSTRUCTIONS            DATATYPE TEXT(234)                     used_for display_browse(4);"
    array_structure_lines[95] = "{----------------}"
    array_structure_lines[96] = "{----------------}"
    array_structure_lines[97] = " "
    array_structure_lines[98] = " "
    array_structure_lines[99] = "{ **************************************************************************************** }"
    array_structure_lines[100] = " "
    array_structure_lines[101] = "TABLE SMP_MODULE_DELIVER;"
    array_structure_lines[102] = "     FIELD SMP_VERSION             links_to SMP_MODULE.SMP_VERSION      used_for unique_key,primary_browse;"
    array_structure_lines[103] = "     FIELD IDENTITY                links_to SMP_MODULE.IDENTITY         used_for unique_key,display_browse (1);"
    array_structure_lines[104] = "     FIELD VERSION_NUMBER          links_to SMP_MODULE.VERSION_NUMBER   used_for unique_key,version_number,display_browse (2);"
    array_structure_lines[105] = "     FIELD ORDER_NUMBER            datatype PACKED_DECIMAL              used_for unique_key,ordering;"
    array_structure_lines[106] = "     FIELD PIVOTAL_ID              datatype text(20)                    used_for display_browse(3);"
    array_structure_lines[107] = "     FIELD PIVOTAL_EMAIL           datatype text(100)                   used_for display_browse(4);"
    array_structure_lines[108] = "     FIELD SCR_NUMBER              datatype text(20)                    used_for display_browse(5);"
    array_structure_lines[109] = "     FIELD DATE_DELIVERED          datatype DATE                        used_for display_browse(6);"
    array_structure_lines[110] = "     FIELD GENERAL_INFO            datatype text(256)                   used_for display_browse(7);"
    array_structure_lines[111] = "{----------------}"
    array_structure_lines[112] = "{----------------}"
    array_structure_lines[113] = " "
    array_structure_lines[114] = " "
    array_structure_lines[115] = "{ **************************************************************************************** }"
    array_structure_lines[116] = " "

ENDROUTINE   { internal_set_structure_lines }

{ **************************************************************************** }

ROUTINE internal_set_message_lines ( array_message_lines )

    DECLARE a_cnt

    retval = FALSE

    array_message_lines[ 1] = "MESSAGE GROUP     " : ASCII(34) : "LIT_LAB_SMP_MODULE_"    : ASCII(34)
    array_message_lines[ 2] = "        MESSAGE = " : ASCII(34) : "CLIENT_SERVER         " : ASCII(34) : "  TEXT = " : ASCII(34) : "Client or Server File "                                                                                                       : ASCII(34)
    array_message_lines[ 3] = "        MESSAGE = " : ASCII(34) : "COMPLETED_BUILD       " : ASCII(34) : "  TEXT = " : ASCII(34) : "Completed build of kit "                                                                                                      : ASCII(34)
    array_message_lines[ 4] = "        MESSAGE = " : ASCII(34) : "COPY_OR_ADD_CRITERIA  " : ASCII(34) : "  TEXT = " : ASCII(34) : "Add (Yes) or Copy (No) new criteria "                                                                                         : ASCII(34)
    array_message_lines[ 5] = "        MESSAGE = " : ASCII(34) : "CREATE_TITLE          " : ASCII(34) : "  TEXT = " : ASCII(34) : "SMP Module Create Package (Install Set must be blank) "                                                                       : ASCII(34)
    array_message_lines[ 6] = "        MESSAGE = " : ASCII(34) : "CRITERIA              " : ASCII(34) : "  TEXT = " : ASCII(34) : "Criteria "                                                                                                                    : ASCII(34)
    array_message_lines[ 7] = "        MESSAGE = " : ASCII(34) : "CRITERIA_HEAD_LINE    " : ASCII(34) : "  TEXT = " : ASCII(34) : "SaveMode    Table       Criteria       FileLogical     SubDirectory      FileID        FileExt       CSVFile        NoRecs "  : ASCII(34)
    array_message_lines[ 8] = "        MESSAGE = " : ASCII(34) : "CSV_FILE              " : ASCII(34) : "  TEXT = " : ASCII(34) : "CSV File "                                                                                                                    : ASCII(34)
    array_message_lines[ 9] = "        MESSAGE = " : ASCII(34) : "DATE_INSTALLED        " : ASCII(34) : "  TEXT = " : ASCII(34) : "Date Installed "                                                                                                              : ASCII(34)
    array_message_lines[10] = "        MESSAGE = " : ASCII(34) : "DATE_REMOVED          " : ASCII(34) : "  TEXT = " : ASCII(34) : "Date Removed "                                                                                                                : ASCII(34)
    array_message_lines[11] = "        MESSAGE = " : ASCII(34) : "DELIVERY              " : ASCII(34) : "  TEXT = " : ASCII(34) : "Delivery "                                                                                                                    : ASCII(34)
    array_message_lines[12] = "        MESSAGE = " : ASCII(34) : "DESCRIPTION           " : ASCII(34) : "  TEXT = " : ASCII(34) : "Description "                                                                                                                 : ASCII(34)
    array_message_lines[13] = "        MESSAGE = " : ASCII(34) : "DESTINATION_FILE      " : ASCII(34) : "  TEXT = " : ASCII(34) : "Destination "                                                                                                                 : ASCII(34)
    array_message_lines[14] = "        MESSAGE = " : ASCII(34) : "ERROR_CREATE_DIR      " : ASCII(34) : "  TEXT = " : ASCII(34) : "* ERROR * Creating directory "                                                                                                : ASCII(34)
    array_message_lines[15] = "        MESSAGE = " : ASCII(34) : "ERROR_CREATE_PACKAGER " : ASCII(34) : "  TEXT = " : ASCII(34) : "* ERROR * Creating packager table records "                                                                                   : ASCII(34)
    array_message_lines[16] = "        MESSAGE = " : ASCII(34) : "ERROR_CREATE_SUBDIR   " : ASCII(34) : "  TEXT = " : ASCII(34) : "* ERROR * Creating Subdirectories "                                                                                           : ASCII(34)
    array_message_lines[17] = "        MESSAGE = " : ASCII(34) : "ERROR_KIT_EXISTS      " : ASCII(34) : "  TEXT = " : ASCII(34) : "* ERROR * Kit already exists in SMP$INSTALL "                                                                                 : ASCII(34)
    array_message_lines[18] = "        MESSAGE = " : ASCII(34) : "ERROR_KIT_NOT_EXIST   " : ASCII(34) : "  TEXT = " : ASCII(34) : "* ERROR * Expanded Zip file / directory does not exist "                                                                      : ASCII(34)
    array_message_lines[19] = "        MESSAGE = " : ASCII(34) : "ERROR_LOAD_CRITERIA   " : ASCII(34) : "  TEXT = " : ASCII(34) : "* ERROR * Loading criteria "                                                                                                  : ASCII(34)
    array_message_lines[20] = "        MESSAGE = " : ASCII(34) : "ERROR_LOAD_DLL        " : ASCII(34) : "  TEXT = " : ASCII(34) : "* ERROR * Loading dll "                                                                                                       : ASCII(34)
    array_message_lines[21] = "        MESSAGE = " : ASCII(34) : "ERROR_MOVE_KIT        " : ASCII(34) : "  TEXT = " : ASCII(34) : "* ERROR * Moving kit "                                                                                                        : ASCII(34)
    array_message_lines[22] = "        MESSAGE = " : ASCII(34) : "ERROR_PROCEDURE       " : ASCII(34) : "  TEXT = " : ASCII(34) : "* ERROR * Invalid Procedure Number "                                                                                          : ASCII(34)
    array_message_lines[23] = "        MESSAGE = " : ASCII(34) : "ERROR_REGBAT          " : ASCII(34) : "  TEXT = " : ASCII(34) : "* ERROR * Registration update failed "                                                                                        : ASCII(34)
    array_message_lines[24] = "        MESSAGE = " : ASCII(34) : "ERROR_RESERVE         " : ASCII(34) : "  TEXT = " : ASCII(34) : "* ERROR * RESERVE new identity failed "                                                                                       : ASCII(34)
    array_message_lines[25] = "        MESSAGE = " : ASCII(34) : "ERROR_SAVE_DATA       " : ASCII(34) : "  TEXT = " : ASCII(34) : "* ERROR * Saving DATA "                                                                                                       : ASCII(34)
    array_message_lines[26] = "        MESSAGE = " : ASCII(34) : "ERROR_SAVE_FILES      " : ASCII(34) : "  TEXT = " : ASCII(34) : "* ERROR * Saving files "                                                                                                      : ASCII(34)
    array_message_lines[27] = "        MESSAGE = " : ASCII(34) : "ERROR_SMPINSTALL      " : ASCII(34) : "  TEXT = " : ASCII(34) : "* ERROR * SMP$INSTALL is a required logical "                                                                                 : ASCII(34)
    array_message_lines[28] = "        MESSAGE = " : ASCII(34) : "ERROR_UPDATE          " : ASCII(34) : "  TEXT = " : ASCII(34) : "* ERROR * UPDATE database failed "                                                                                            : ASCII(34)
    array_message_lines[29] = "        MESSAGE = " : ASCII(34) : "ERROR_UPDATE_MTB      " : ASCII(34) : "  TEXT = " : ASCII(34) : "* ERROR * UPDATE .mtb "                                                                                                       : ASCII(34)
    array_message_lines[30] = "        MESSAGE = " : ASCII(34) : "ERROR_UPDATE_LAB_LINES" : ASCII(34) : "  TEXT = " : ASCII(34) : "* ERROR * update .lab file not all lines copied  "                                                                            : ASCII(34)
    array_message_lines[31] = "        MESSAGE = " : ASCII(34) : "ERROR_UPDATE_NO_LINES " : ASCII(34) : "  TEXT = " : ASCII(34) : "* WARNING * update .lab file had no lines to add  "                                                                           : ASCII(34)
    array_message_lines[32] = "        MESSAGE = " : ASCII(34) : "ERROR_VERSION_0       " : ASCII(34) : "  TEXT = " : ASCII(34) : "* ERROR * Version 0 rollback kit could not be created "                                                                       : ASCII(34)
    array_message_lines[33] = "        MESSAGE = " : ASCII(34) : "ERROR_VERSION_0_COPY  " : ASCII(34) : "  TEXT = " : ASCII(34) : "* ERROR * Version 0 copy SMP CSV's failed "                                                                                   : ASCII(34)
    array_message_lines[34] = "        MESSAGE = " : ASCII(34) : "FILE                  " : ASCII(34) : "  TEXT = " : ASCII(34) : "File Name "                                                                                                                   : ASCII(34)
    array_message_lines[35] = "        MESSAGE = " : ASCII(34) : "FILES_UPDATED         " : ASCII(34) : "  TEXT = " : ASCII(34) : "Files have already been moved "                                                                                               : ASCII(34)
    array_message_lines[36] = "        MESSAGE = " : ASCII(34) : "FILE_EXTENSION        " : ASCII(34) : "  TEXT = " : ASCII(34) : "FileExt "                                                                                                                     : ASCII(34)
    array_message_lines[37] = "        MESSAGE = " : ASCII(34) : "FILE_LOGICAL          " : ASCII(34) : "  TEXT = " : ASCII(34) : "File Logical "                                                                                                                : ASCII(34)
    array_message_lines[38] = "        MESSAGE = " : ASCII(34) : "GENERAL_INFO          " : ASCII(34) : "  TEXT = " : ASCII(34) : "General Info "                                                                                                                : ASCII(34)
    array_message_lines[39] = "        MESSAGE = " : ASCII(34) : "HEADER                " : ASCII(34) : "  TEXT = " : ASCII(34) : "Module Package/Install "                                                                                                      : ASCII(34)
    array_message_lines[40] = "        MESSAGE = " : ASCII(34) : "IDENTITY              " : ASCII(34) : "  TEXT = " : ASCII(34) : "Identity "                                                                                                                    : ASCII(34)
    array_message_lines[41] = "        MESSAGE = " : ASCII(34) : "INPUT                 " : ASCII(34) : "  TEXT = " : ASCII(34) : "Module ID "                                                                                                                   : ASCII(34)
    array_message_lines[42] = "        MESSAGE = " : ASCII(34) : "INSTALL_SET           " : ASCII(34) : "  TEXT = " : ASCII(34) : "Install Set "                                                                                                                 : ASCII(34)
    array_message_lines[43] = "        MESSAGE = " : ASCII(34) : "INSTALL_SET_ZIP       " : ASCII(34) : "  TEXT = " : ASCII(34) : "Zip FileName "                                                                                                                : ASCII(34)
    array_message_lines[44] = "        MESSAGE = " : ASCII(34) : "INSTALL_TITLE         " : ASCII(34) : "  TEXT = " : ASCII(34) : "SMP Module Install Package (Date Installed must be NULL) "                                                                    : ASCII(34)
    array_message_lines[45] = "        MESSAGE = " : ASCII(34) : "MENU                  " : ASCII(34) : "  TEXT = " : ASCII(34) : "SMW Menu Configuration "                                                                                                      : ASCII(34)
    array_message_lines[46] = "        MESSAGE = " : ASCII(34) : "MENU_GENERATE_NEW_ONE " : ASCII(34) : "  TEXT = " : ASCII(34) : "Generate New "                                                                                                                : ASCII(34)
    array_message_lines[47] = "        MESSAGE = " : ASCII(34) : "MENU_HEAD             " : ASCII(34) : "  TEXT = " : ASCII(34) : "Procedure_No    Short_Text      New Procedure No. "                                                                           : ASCII(34)
    array_message_lines[48] = "        MESSAGE = " : ASCII(34) : "MENU_INVALID_CONTEXT  " : ASCII(34) : "  TEXT = " : ASCII(34) : "* INVALID CONTEXT * Reset Menu Context "                                                                                      : ASCII(34)
    array_message_lines[49] = "        MESSAGE = " : ASCII(34) : "MENU_NEW_PROCEDURE_NUM" : ASCII(34) : "  TEXT = " : ASCII(34) : "New Procedure No "                                                                                                            : ASCII(34)
    array_message_lines[50] = "        MESSAGE = " : ASCII(34) : "MENU_UPDATE_TITLE     " : ASCII(34) : "  TEXT = " : ASCII(34) : "Procedure Validation "                                                                                                        : ASCII(34)
    array_message_lines[51] = "        MESSAGE = " : ASCII(34) : "MESSAGES_UPDATED      " : ASCII(34) : "  TEXT = " : ASCII(34) : "Messages Updated "                                                                                                            : ASCII(34)
    array_message_lines[52] = "        MESSAGE = " : ASCII(34) : "MINIMUM_VERSION       " : ASCII(34) : "  TEXT = " : ASCII(34) : "Min.Version "                                                                                                                 : ASCII(34)
    array_message_lines[53] = "        MESSAGE = " : ASCII(34) : "MODIFIED_BY           " : ASCII(34) : "  TEXT = " : ASCII(34) : "Modified By "                                                                                                                 : ASCII(34)
    array_message_lines[54] = "        MESSAGE = " : ASCII(34) : "MODIFIED_ON           " : ASCII(34) : "  TEXT = " : ASCII(34) : "Modified On "                                                                                                                 : ASCII(34)
    array_message_lines[55] = "        MESSAGE = " : ASCII(34) : "MODULE_TYPE           " : ASCII(34) : "  TEXT = " : ASCII(34) : "Module Type "                                                                                                                 : ASCII(34)
    array_message_lines[56] = "        MESSAGE = " : ASCII(34) : "MOVE_TITLE            " : ASCII(34) : "  TEXT = " : ASCII(34) : "Module to move "                                                                                                              : ASCII(34)
    array_message_lines[57] = "        MESSAGE = " : ASCII(34) : "NO_RECORDS_TO_LOAD    " : ASCII(34) : "  TEXT = " : ASCII(34) : "NoRecs "                                                                                                                      : ASCII(34)
    array_message_lines[58] = "        MESSAGE = " : ASCII(34) : "ORDER_NUMBER          " : ASCII(34) : "  TEXT = " : ASCII(34) : "Order "                                                                                                                       : ASCII(34)
    array_message_lines[59] = "        MESSAGE = " : ASCII(34) : "PACKAGE_DESTINATION   " : ASCII(34) : "  TEXT = " : ASCII(34) : "Package select destination "                                                                                                  : ASCII(34)
    array_message_lines[60] = "        MESSAGE = " : ASCII(34) : "PACKAGE_INVALID       " : ASCII(34) : "  TEXT = " : ASCII(34) : "Package setup error, cannot complete "                                                                                        : ASCII(34)
    array_message_lines[61] = "        MESSAGE = " : ASCII(34) : "PIVOTAL_ID            " : ASCII(34) : "  TEXT = " : ASCII(34) : "CRM Identity "                                                                                                                : ASCII(34)
    array_message_lines[62] = "        MESSAGE = " : ASCII(34) : "PIVOTAL_EMAIL         " : ASCII(34) : "  TEXT = " : ASCII(34) : "EMAIL "                                                                                                                       : ASCII(34)
    array_message_lines[63] = "        MESSAGE = " : ASCII(34) : "PROGRAM               " : ASCII(34) : "  TEXT = " : ASCII(34) : "Executable extensions (SMP_MODULE_PROGRAM) "                                                                                  : ASCII(34)
    array_message_lines[64] = "        MESSAGE = " : ASCII(34) : "PROGRAM_DLL           " : ASCII(34) : "  TEXT = " : ASCII(34) : "DLL.Net "                                                                                                                     : ASCII(34)
    array_message_lines[65] = "        MESSAGE = " : ASCII(34) : "PROGRAM_HEAD_LINE     " : ASCII(34) : "  TEXT = " : ASCII(34) : "Order    DLL.Net     ClientServer   ProgramSet   Min.Version    Description "                                                 : ASCII(34)
    array_message_lines[66] = "        MESSAGE = " : ASCII(34) : "PROGRAM_SET           " : ASCII(34) : "  TEXT = " : ASCII(34) : "Program Set "                                                                                                                 : ASCII(34)
    array_message_lines[67] = "        MESSAGE = " : ASCII(34) : "SAVE_MODE             " : ASCII(34) : "  TEXT = " : ASCII(34) : "Save Mode "                                                                                                                   : ASCII(34)
    array_message_lines[68] = "        MESSAGE = " : ASCII(34) : "SCR_NUMBER            " : ASCII(34) : "  TEXT = " : ASCII(34) : "SCR_# "                                                                                                                       : ASCII(34)
    array_message_lines[69] = "        MESSAGE = " : ASCII(34) : "SELECT_FILE           " : ASCII(34) : "  TEXT = " : ASCII(34) : "Filename... "                                                                                                                 : ASCII(34)
    array_message_lines[70] = "        MESSAGE = " : ASCII(34) : "SMP_VERSION           " : ASCII(34) : "  TEXT = " : ASCII(34) : "SMP Version "                                                                                                                 : ASCII(34)
    array_message_lines[71] = "        MESSAGE = " : ASCII(34) : "SMW_MENU_CONTEXT      " : ASCII(34) : "  TEXT = " : ASCII(34) : "Menu Context  "                                                                                                               : ASCII(34)
    array_message_lines[72] = "        MESSAGE = " : ASCII(34) : "SMW_MENU_EDIT         " : ASCII(34) : "  TEXT = " : ASCII(34) : "Edit the SMW menu  "                                                                                                          : ASCII(34)
    array_message_lines[73] = "        MESSAGE = " : ASCII(34) : "SMW_MENU_UPDATED      " : ASCII(34) : "  TEXT = " : ASCII(34) : "SMW Menu updated "                                                                                                            : ASCII(34)
    array_message_lines[74] = "        MESSAGE = " : ASCII(34) : "STAGE_OF_INSTALL      " : ASCII(34) : "  TEXT = " : ASCII(34) : "Stage of Installation "                                                                                                       : ASCII(34)
    array_message_lines[75] = "        MESSAGE = " : ASCII(34) : "STARTING_BUILD        " : ASCII(34) : "  TEXT = " : ASCII(34) : "Starting build... "                                                                                                           : ASCII(34)
    array_message_lines[76] = "        MESSAGE = " : ASCII(34) : "STRUCTURE_CONFIRM     " : ASCII(34) : "  TEXT = " : ASCII(34) : "Edit structure "                                                                                                              : ASCII(34)
    array_message_lines[77] = "        MESSAGE = " : ASCII(34) : "STRUCTURE_CONFIRM_EXIT" : ASCII(34) : "  TEXT = " : ASCII(34) : "Create/Convert ok, do you still want to edit structure "                                                                      : ASCII(34)
    array_message_lines[78] = "        MESSAGE = " : ASCII(34) : "STRUCTURE_INVALID     " : ASCII(34) : "  TEXT = " : ASCII(34) : "* WARNING * are you sure you want to append to structure.txt "                                                                : ASCII(34)
    array_message_lines[79] = "        MESSAGE = " : ASCII(34) : "STRUCTURE_UPDATED     " : ASCII(34) : "  TEXT = " : ASCII(34) : "Structure updated "                                                                                                           : ASCII(34)
    array_message_lines[80] = "        MESSAGE = " : ASCII(34) : "SUB_DIRECTORY         " : ASCII(34) : "  TEXT = " : ASCII(34) : "SubDirectory "                                                                                                                : ASCII(34)
    array_message_lines[81] = "        MESSAGE = " : ASCII(34) : "SUCCESS_MOVE_KIT      " : ASCII(34) : "  TEXT = " : ASCII(34) : "Succesfully moved kit "                                                                                                       : ASCII(34)
    array_message_lines[82] = "        MESSAGE = " : ASCII(34) : "TABLE_NAME            " : ASCII(34) : "  TEXT = " : ASCII(34) : "Table "                                                                                                                       : ASCII(34)
    array_message_lines[83] = "        MESSAGE = " : ASCII(34) : "USE_CRITERIA_VERSIONS " : ASCII(34) : "  TEXT = " : ASCII(34) : "Include version in the criteria identity "                                                                                    : ASCII(34)
    array_message_lines[84] = "        MESSAGE = " : ASCII(34) : "VERSION               " : ASCII(34) : "  TEXT = " : ASCII(34) : "Version "                                                                                                                     : ASCII(34)
    array_message_lines[85] = "        MESSAGE = " : ASCII(34) : "VERSION_0_KIT         " : ASCII(34) : "  TEXT = " : ASCII(34) : "Create / Validate rollback kit "                                                                                              : ASCII(34)
    array_message_lines[86] = "        MESSAGE = " : ASCII(34) : "VERSION_RECREATE      " : ASCII(34) : "  TEXT = " : ASCII(34) : "Re-create this version of the module "                                                                                        : ASCII(34)
    array_message_lines[87] = "        MESSAGE = " : ASCII(34) : "VETO_INSTALL          " : ASCII(34) : "  TEXT = " : ASCII(34) : "Confirm Load Options (staged install)  "                                                                                      : ASCII(34)
    array_message_lines[88] = "MESSAGE GROUP     " : ASCII(34) : "LIT_PACKAGER_"          : ASCII(34)
    array_message_lines[89] = "        MESSAGE = " : ASCII(34) : "01                    " : ASCII(34) : "  TEXT = " : ASCII(34) : "* ERROR * creation of install set summary file failed "                                                                       : ASCII(34)
    array_message_lines[90] = "        MESSAGE = " : ASCII(34) : "02                    " : ASCII(34) : "  TEXT = " : ASCII(34) : "Completed kit build "                                                                                                         : ASCII(34)
    array_message_lines[91] = "        MESSAGE = " : ASCII(34) : "03                    " : ASCII(34) : "  TEXT = " : ASCII(34) : "* ERROR * Creation of zip file had errors "                                                                                   : ASCII(34)
    array_message_lines[92] = "        MESSAGE = " : ASCII(34) : "04                    " : ASCII(34) : "  TEXT = " : ASCII(34) : "* ERROR * Read of the kit did not correct data files "                                                                        : ASCII(34)
    array_message_lines[93] = "        MESSAGE = " : ASCII(34) : "05                    " : ASCII(34) : "  TEXT = " : ASCII(34) : "* ERROR * Extraction of zip failed with errors "                                                                              : ASCII(34)
    array_message_lines[94] = "        MESSAGE = " : ASCII(34) : "06                    " : ASCII(34) : "  TEXT = " : ASCII(34) : "There are no program/dll files in this install kit "                                                                          : ASCII(34)
    array_message_lines[95] = "        MESSAGE = " : ASCII(34) : "07                    " : ASCII(34) : "  TEXT = " : ASCII(34) : "CSV data files to load into the target database "                                                                             : ASCII(34)
    array_message_lines[96] = "        MESSAGE = " : ASCII(34) : "08                    " : ASCII(34) : "  TEXT = " : ASCII(34) : "There are no target files from CSV data to move onto the target server "                                                      : ASCII(34)
    array_message_lines[97] = "        MESSAGE = " : ASCII(34) : "09                    " : ASCII(34) : "  TEXT = " : ASCII(34) : "Client/Server program/dll files to load onto the target server "                                                              : ASCII(34)
    array_message_lines[98] = "        MESSAGE = " : ASCII(34) : "10                    " : ASCII(34) : "  TEXT = " : ASCII(34) : "Data files from CSV data to move to target server SMP$<logical> "                                                             : ASCII(34)
    array_message_lines[99] = "        MESSAGE = " : ASCII(34) : "11                    " : ASCII(34) : "  TEXT = " : ASCII(34) : "Files to move to target smp$<logical> target server "                                                                         : ASCII(34)
    array_message_lines[100]= "        MESSAGE = " : ASCII(34) : "12                    " : ASCII(34) : "  TEXT = " : ASCII(34) : "CSV file loaded ok  "                                                                                                         : ASCII(34)
    array_message_lines[101]= "        MESSAGE = " : ASCII(34) : "13                    " : ASCII(34) : "  TEXT = " : ASCII(34) : "_____Program/DLL file(s) loaded ok  "                                                                                         : ASCII(34)
    array_message_lines[102]= "        MESSAGE = " : ASCII(34) : "14                    " : ASCII(34) : "  TEXT = " : ASCII(34) : "_____Copy File ok  "                                                                                                          : ASCII(34)
    array_message_lines[103]= "        MESSAGE = " : ASCII(34) : "15                    " : ASCII(34) : "  TEXT = " : ASCII(34) : "_____Compile of File ok  "                                                                                                    : ASCII(34)
    array_message_lines[104]= "        MESSAGE = " : ASCII(34) : "16                    " : ASCII(34) : "  TEXT = " : ASCII(34) : "There are no files (non-csv) to move to the target server   "                                                                 : ASCII(34)
    array_message_lines[105]= "        MESSAGE = " : ASCII(34) : "17                    " : ASCII(34) : "  TEXT = " : ASCII(34) : "* ERROR * Loading of the CSV files failed or not all files have extension CSV  "                                              : ASCII(34)
    array_message_lines[106]= "        MESSAGE = " : ASCII(34) : "18                    " : ASCII(34) : "  TEXT = " : ASCII(34) : "* ERROR * Unable to update the database tables "                                                                              : ASCII(34)
    array_message_lines[107]= "        MESSAGE = " : ASCII(34) : "19                    " : ASCII(34) : "  TEXT = " : ASCII(34) : "* ERROR * Installation of files failed "                                                                                      : ASCII(34)
    array_message_lines[108]= "        MESSAGE = " : ASCII(34) : "20                    " : ASCII(34) : "  TEXT = " : ASCII(34) : "* ERROR * Installation of DLL or Program files failed  "                                                                      : ASCII(34)
    array_message_lines[109]= "        MESSAGE = " : ASCII(34) : "21                    " : ASCII(34) : "  TEXT = " : ASCII(34) : "* ERROR * CSV files have already been loaded, or no .csv files exist in install directory "                                   : ASCII(34)
    array_message_lines[110]= "        MESSAGE = " : ASCII(34) : "22                    " : ASCII(34) : "  TEXT = " : ASCII(34) : "* ERROR * Unable to read kit files  "                                                                                         : ASCII(34)
    array_message_lines[111]= "        MESSAGE = " : ASCII(34) : "23                    " : ASCII(34) : "  TEXT = " : ASCII(34) : "* ERROR * CSV files either have OK or FAILED appended to file extension  "                                                    : ASCII(34)
    array_message_lines[112]= "        MESSAGE = " : ASCII(34) : "24                    " : ASCII(34) : "  TEXT = " : ASCII(34) : "* WARNING * Compilation issues  "                                                                                             : ASCII(34)
    array_message_lines[113]= "        MESSAGE = " : ASCII(34) : "25                    " : ASCII(34) : "  TEXT = " : ASCII(34) : "* ERROR * Moving self extract   "                                                                                             : ASCII(34)
    array_message_lines[114]= "        MESSAGE = " : ASCII(34) : "26                    " : ASCII(34) : "  TEXT = " : ASCII(34) : "* ERROR * Program should only be ran from a menu   "                                                                          : ASCII(34)
    array_message_lines[115]= "        MESSAGE = " : ASCII(34) : "27                    " : ASCII(34) : "  TEXT = " : ASCII(34) : "* ERROR * Invalid zip/exe no file extension supplied   "                                                                      : ASCII(34)
    array_message_lines[116]= "        MESSAGE = " : ASCII(34) : "28                    " : ASCII(34) : "  TEXT = " : ASCII(34) : "* ERROR * Extraction of zip file had errors  "                                                                                : ASCII(34)
    array_message_lines[117]= "        MESSAGE = " : ASCII(34) : "29                    " : ASCII(34) : "  TEXT = " : ASCII(34) : "Did create structure work properly ?"                                                                                         : ASCII(34)
    array_message_lines[118]= "        MESSAGE = " : ASCII(34) : "30                    " : ASCII(34) : "  TEXT = " : ASCII(34) : "Did convert table work properly ?  "                                                                                          : ASCII(34)
    array_message_lines[119]= "        MESSAGE = " : ASCII(34) : "31                    " : ASCII(34) : "  TEXT = " : ASCII(34) : "Did create message work correctly ? "                                                                                         : ASCII(34)
    array_message_lines[120]= "        MESSAGE = " : ASCII(34) : "32                    " : ASCII(34) : "  TEXT = " : ASCII(34) : "* Warning * user trigger did not return a boolean "                                                                           : ASCII(34)
    array_message_lines[121]= "        MESSAGE = " : ASCII(34) : "33                    " : ASCII(34) : "  TEXT = " : ASCII(34) : "User Trigger completed and returned ok "                                                                                      : ASCII(34)
    array_message_lines[122]= "        MESSAGE = " : ASCII(34) : "34                    " : ASCII(34) : "  TEXT = " : ASCII(34) : "User trigger routine is not in user trigger library "                                                                         : ASCII(34)
    array_message_lines[123]= "        MESSAGE = " : ASCII(34) : "35                    " : ASCII(34) : "  TEXT = " : ASCII(34) : "User trigger library does not exist, no user triggers will be enabled "                                                       : ASCII(34)
    array_message_lines[124]= "        MESSAGE = " : ASCII(34) : "36                    " : ASCII(34) : "  TEXT = " : ASCII(34) : "Set structure_update TRUE for phased install "                                                                                : ASCII(34)
    array_message_lines[125]= "        MESSAGE = " : ASCII(34) : "37                    " : ASCII(34) : "  TEXT = " : ASCII(34) : "Set message_update TRUE for phased install "                                                                                  : ASCII(34)
    array_message_lines[126]= "        MESSAGE = " : ASCII(34) : "38                    " : ASCII(34) : "  TEXT = " : ASCII(34) : "Set smw_menu_update TRUE for phased install "                                                                                 : ASCII(34)
    array_message_lines[127]= "        MESSAGE = " : ASCII(34) : "39                    " : ASCII(34) : "  TEXT = " : ASCII(34) : "* Warning * phased install requires 2 passes, only stage 1 (structure_update) done "                                          : ASCII(34)
    array_message_lines[128]= "        MESSAGE = " : ASCII(34) : "40                    " : ASCII(34) : "  TEXT = " : ASCII(34) : "* Warning * SMW Menu / Master Menu creation issues "                                                                          : ASCII(34)
    array_message_lines[129]= "        MESSAGE = " : ASCII(34) : "41                    " : ASCII(34) : "  TEXT = " : ASCII(34) : "File copied to UNINSTALL "                                                                                                    : ASCII(34)
    array_message_lines[130]= "        MESSAGE = " : ASCII(34) : "42                    " : ASCII(34) : "  TEXT = " : ASCII(34) : "* ERROR *  Install Master Menu AutoGeneration did not complete "                                                              : ASCII(34)
    array_message_lines[131]= "        MESSAGE = " : ASCII(34) : "43                    " : ASCII(34) : "  TEXT = " : ASCII(34) : "* ERROR * Update of Master Menu AutoGeneration Procedure Num "                                                                : ASCII(34)
    array_message_lines[132]= "        MESSAGE = " : ASCII(34) : "44                    " : ASCII(34) : "  TEXT = " : ASCII(34) : "* ERROR * Reading Master Menu CSV "                                                                                           : ASCII(34)
    array_message_lines[133]= "        MESSAGE = " : ASCII(34) : "45                    " : ASCII(34) : "  TEXT = " : ASCII(34) : "* ERROR * Updating the new master menu procedure file "                                                                       : ASCII(34)
    array_message_lines[134]= "        MESSAGE = " : ASCII(34) : "46                    " : ASCII(34) : "  TEXT = " : ASCII(34) : "* ERROR * "                                                                   : ASCII(34)
    array_message_lines[135]= "        MESSAGE = " : ASCII(34) : "47                    " : ASCII(34) : "  TEXT = " : ASCII(34) : "Structure File(s) in kit  "                                                   : ASCII(34)
    array_message_lines[136]= "        MESSAGE = " : ASCII(34) : "48                    " : ASCII(34) : "  TEXT = " : ASCII(34) : "Messages File(s) in kit "                                                     : ASCII(34)
    array_message_lines[137]= "        MESSAGE = " : ASCII(34) : "49                    " : ASCII(34) : "  TEXT = " : ASCII(34) : "Menu Files(s) in kit "                                                        : ASCII(34)
    array_message_lines[138]= "        MESSAGE = " : ASCII(34) : "50                    " : ASCII(34) : "  TEXT = " : ASCII(34) : "Is this a staged install "                                                    : ASCII(34)
    array_message_lines[139]= "        MESSAGE = " : ASCII(34) : "51                    " : ASCII(34) : "  TEXT = " : ASCII(34) : "Number to load in CSV does not match number loaded - is this ok ? "           : ASCII(34)
    array_message_lines[140]= "        MESSAGE = " : ASCII(34) : "52                    " : ASCII(34) : "  TEXT = " : ASCII(34) : "Starting processing "                                                         : ASCII(34)
    array_message_lines[141]= "        MESSAGE = " : ASCII(34) : "53                    " : ASCII(34) : "  TEXT = " : ASCII(34) : "Field is missing in structure continue installation ?  "                      : ASCII(34)
    array_message_lines[142]= "        MESSAGE = " : ASCII(34) : "54                    " : ASCII(34) : "  TEXT = " : ASCII(34) : "* WARNING * MLP VALUE has no product or version set  "                        : ASCII(34)
    array_message_lines[143]= "        MESSAGE = " : ASCII(34) : "55                    " : ASCII(34) : "  TEXT = " : ASCII(34) : "* ERROR * MLP_VALUE has incorrect field headings "                            : ASCII(34)
    array_message_lines[144]= "        MESSAGE = " : ASCII(34) : "56                    " : ASCII(34) : "  TEXT = " : ASCII(34) : "* Future Use * "                                                              : ASCII(34)
    array_message_lines[145]= "        MESSAGE = " : ASCII(34) : "ERROR_READ_FILE       " : ASCII(34) : "  TEXT = " : ASCII(34) : "*ERROR* Reading file "                                                        : ASCII(34)
    array_message_lines[146]= "        MESSAGE = " : ASCII(34) : "ERROR_CSV_LENGTHS     " : ASCII(34) : "  TEXT = " : ASCII(34) : "*ERROR* Lengths invalid "                                                     : ASCII(34)
    array_message_lines[147]= "        MESSAGE = " : ASCII(34) : "ERROR_CSV_FIELDS      " : ASCII(34) : "  TEXT = " : ASCII(34) : "*ERROR* Fields invalid "                                                      : ASCII(34)
    array_message_lines[148]= "        MESSAGE = " : ASCII(34) : "ERROR_MLP_IMPORT      " : ASCII(34) : "  TEXT = " : ASCII(34) : "*ERROR* MLP import "                                                          : ASCII(34)
    array_message_lines[149]= "        MESSAGE = " : ASCII(34) : "CSV_FIELD_LENGTH      " : ASCII(34) : "  TEXT = " : ASCII(34) : "Field Lengths mismatch ok to continue ? "                                     : ASCII(34)
    array_message_lines[150]= "        MESSAGE = " : ASCII(34) : "IMPORT_CONT_OPTIONS   " : ASCII(34) : "  TEXT = " : ASCII(34) : "Continue Import Data Options "                                                : ASCII(34)
    array_message_lines[151]= "        MESSAGE = " : ASCII(34) : "IMPORT_CONT_PROMPT    " : ASCII(34) : "  TEXT = " : ASCII(34) : "Choose from options or <F3> Select "                                          : ASCII(34)
    array_message_lines[152]= "        MESSAGE = " : ASCII(34) : "IMPORT_CONT_SKIP_1    " : ASCII(34) : "  TEXT = " : ASCII(34) : "Skip 1 record "                                                               : ASCII(34)
    array_message_lines[153]= "        MESSAGE = " : ASCII(34) : "IMPORT_CONT_SKIP_TABLE" : ASCII(34) : "  TEXT = " : ASCII(34) : "Skip remaining records for table "                                            : ASCII(34)
    array_message_lines[154]= "        MESSAGE = " : ASCII(34) : "IMPORT_CONT_EXIT      " : ASCII(34) : "  TEXT = " : ASCII(34) : "Exit program  "                                                               : ASCII(34)
    array_message_lines[155]= "        MESSAGE = " : ASCII(34) : "IMPORT_CONT_ALL       " : ASCII(34) : "  TEXT = " : ASCII(34) : "Load all and quit asking "                                                    : ASCII(34)
    array_message_lines[156]= "        MESSAGE = " : ASCII(34) : "IMPORT_CONT_ALL_TABLE " : ASCII(34) : "  TEXT = " : ASCII(34) : "Do all records for this table "                                               : ASCII(34)
    array_message_lines[157]= "        MESSAGE = " : ASCII(34) : "IMPORT_CONT_DO_1      " : ASCII(34) : "  TEXT = " : ASCII(34) : "Do 1 record at a time "                                                       : ASCII(34)
    array_message_lines[158]= "        MESSAGE = " : ASCII(34) : "FIELD_NAME            " : ASCII(34) : "  TEXT = " : ASCII(34) : "Field Name "                                                                  : ASCII(34)
    array_message_lines[159]= "        MESSAGE = " : ASCII(34) : "RECORD_LOAD           " : ASCII(34) : "  TEXT = " : ASCII(34) : "Record Load "                                                                 : ASCII(34)
    array_message_lines[160]= "        MESSAGE = " : ASCII(34) : "RECORD_EXISTS         " : ASCII(34) : "  TEXT = " : ASCII(34) : "Record Exists "                                                               : ASCII(34)
    array_message_lines[161]= " "

    IF ( FILE EXISTS ( C_MESSAGE_FILE_ID ) ) THEN

        retval = TRUE

    ELSE

        FILE CREATE C_MESSAGE_FILE_ID, status
        FILE EXTEND C_MESSAGE_FILE_ID, status

        { ------------------------------------------------------------------------- }
        { Write the default lines of the messages for the module                    }
        { ------------------------------------------------------------------------- }

        a_cnt = 1

        WHILE ( array_message_lines[a_cnt] <> EMPTY ) AND ( status = EMPTY ) DO

            FILE WRITE C_MESSAGE_FILE_ID, array_message_lines[a_cnt], status
            a_cnt = a_cnt + 1

        ENDWHILE

        { ------------------------------------------------------------------------- }
        { All done writing data to file, save it and process / check errors         }
        { ------------------------------------------------------------------------- }

        FILE CLOSE C_MESSAGE_FILE_ID, status

        IF ( status <> EMPTY ) THEN

            FLASH_MESSAGE ( "** Error creating message file ": C_MESSAGE_FILE_ID : status, TRUE )        { cannot be message.txt is install of self }

        ELSEIF ( a_cnt < SIZE_OF_ARRAY ( array_message_lines ) ) THEN

            FLASH_MESSAGE ( "** WARNING ** may be missing messages in file ": C_MESSAGE_FILE_ID, TRUE )  { cannot be message.txt is install of self }
            retval = TRUE

        ELSE
            retval = TRUE

        ENDIF

    ENDIF   { file already exists }

    { ------------------------------------------------------------------------ }
    { Either if file exists or is created/check if referenced in message.txt   }
    { ------------------------------------------------------------------------ }

    IF retval THEN

        retval = internal_update_message_txt ( C_MESSAGE_FILE_ID_NO_DIR )

    ENDIF

    RETURN ( retval )

ENDROUTINE   { internal_set_message_lines }

{ ************************************************************************************************* }

ROUTINE internal_update_message_txt ( VALUE msg_file_2_add )

    DECLARE tmpString,
                 found    ,
                 all_lines,
                 cnt      ,
                 a_semi   ,
                 a_dir

    ARRAY all_lines

    cnt    = 1
    retval = FALSE
    found  = FALSE

    FILE OPEN "SMP$MESSAGES\MESSAGE.TXT", status

    { ------------------------------------------------------------------------- }
    { Write the default lines of the structure for the module                   }
    { ------------------------------------------------------------------------- }


    WHILE ( status = EMPTY ) AND ( not found ) DO

        FILE READ "SMP$MESSAGES\MESSAGE.TXT", tmpString, status

        all_lines[cnt] = tmpString
        cnt            = cnt + 1

        IF ( INDEX ( tmpString, msg_file_2_add ) > 0 ) THEN

            found = TRUE

        ENDIF

    ENDWHILE


    { ------------------------------------------------------------------------- }
    { All done reading message.txt = add the message reference if needed        }
    { ------------------------------------------------------------------------- }

    FILE CLOSE "SMP$MESSAGES\MESSAGE.TXT", status


    IF ( status <> EMPTY ) THEN

        FLASH_MESSAGE ( "** Error apppending to message.txt file ": status, TRUE )   { cannot be message.txt is install of self }

    ELSEIF ( NOT found ) THEN

        a_dir  = LOGICAL ( "SMP$MESSAGES" )
        a_semi = INDEX ( a_dir, ";" )

        IF ( a_semi > 0 ) THEN

            a_dir = LEFTSTRING ( a_dir, a_semi - 1 )

        ENDIF

        IF NOT FILE EXISTS ( a_dir : "\MESSAGE.TXT" ) THEN

            FILE EXTEND a_dir : "\MESSAGE.TXT", status

            cnt = 1

            WHILE ( all_lines[cnt] <> EMPTY ) DO

                FILE WRITE a_dir : "\MESSAGE.TXT", all_lines[cnt], status

                cnt = cnt + 1

            ENDWHILE

            FILE WRITE  a_dir : "\MESSAGE.TXT", "            " , status
            FILE WRITE  a_dir : "\MESSAGE.TXT", "INCLUDE     " : ASCII(34) : "smp$messages\" : msg_file_2_add : ASCII(34), status

        ELSE

            FILE EXTEND a_dir : "\MESSAGE.TXT", status
            FILE WRITE  a_dir : "\MESSAGE.TXT", "            " , status
            FILE WRITE  a_dir : "\MESSAGE.TXT", "INCLUDE     " : ASCII(34) : "smp$messages\" : msg_file_2_add : ASCII(34), status

        ENDIF

        FILE CLOSE a_dir : "\MESSAGE.TXT", status

        retval = ( status = EMPTY )

    ELSE

        retval = TRUE

    ENDIF


    RETURN ( retval )

ENDROUTINE  { internal_update_message_txt }

{ ************************************************************************************************* }

ROUTINE internal_structure ( VALUE a_program      ,
                             VALUE success_string ,
                             VALUE a_qualifier    ,
                             VALUE output_logical )

    DECLARE exe_path      ,
                 ext_pos       ,
                 a_len         ,
                 logfile       ,
                 log_array     ,
                 i             ,
                 save_date     ,
                 status        ,
                 append_install

    { -------------------------------------------------------------------- }
    { Build from logicals/regkeys how to get to the create_structure       }
    { -------------------------------------------------------------------- }

    retval         = FALSE
    append_install = FALSE

    ARRAY log_array

    SET DATE FORMAT "-DZ-MON-YYYZ-H24-MI"

    save_date    = STRIP ( NOW )

    RESTORE DATE FORMAT

    { -------------------------------------------------------- }
    { Where should all the create/convert logs be written....  }
    { -------------------------------------------------------- }

    logfile = LOGICAL(output_logical)

    IF ( logfile = "SMP$INSTALL" ) THEN

        logfile        = LOGICAL ( "SMP$ROOT" )
        append_install = TRUE

    ENDIF

    ext_pos = INDEX ( logfile, ";" )

    IF ( ext_pos > 0 ) THEN

        logfile = SUBSTRING ( logfile, 1, ext_pos - 1 )

    ENDIF

    IF append_install THEN

        logfile  = logfile : "\INSTALL\" : STRIP(a_program):save_date:".log"

    ELSE

        logfile  = logfile : "\" : STRIP(a_program):save_date:".log"

    ENDIF

    { -------------------------------------------------------- }
    { Now where is the executable ?  remember 9.2...           }
    { -------------------------------------------------------- }

    exe_path = LOGICAL ( "SMP$PROGRAMS" )
    ext_pos  = INDEX ( exe_path, ";" )

    IF ( ext_pos > 0 ) THEN

        a_len    = STRINGLENGTH ( exe_path)
        exe_path = RIGHTSTRING ( exe_path, a_len - ext_pos )

    ENDIF

    exe_path  = exe_path : "\":STRIP(a_program) : ".exe"

    IF NOT FILE EXISTS ( exe_path ) THEN

        flash_message ( "Server Manager Error on exe " : exe_path, TRUE )        { cannot be message.txt is install of self }

    ELSE

        exe_path = ascii(34) : exe_path : ascii(34) : " -instance " : GLOBAL ( "INSTANCE" ) : " ":a_qualifier

        { ---------------------------------------- }
        { Run the command and save the output      }
        { ---------------------------------------- }

        FILE DELETE logfile, status

        status = lib_utils_spawn_with_log ( exe_path, logfile )

        IF status <> EMPTY THEN

            flash_message ( "Server Manager Error " : status, TRUE )         { cannot be message.txt is install of self }

        ELSEIF FILE EXISTS ( logfile ) THEN

            FILE OPEN logfile, status

            IF status = EMPTY THEN

                i = 1
                FILE READ logfile, log_array[i], status

                WHILE ( status = EMPTY ) AND NOT ( retval ) DO

                    i = i + 1
                    FILE READ logfile, log_array[i], status

                    IF ( INDEX ( log_array[i], success_string ) > 0 ) THEN

                        retval = TRUE

                    ENDIF

                ENDWHILE

            ENDIF

            FILE CLOSE logfile, status

            IF ( GLOBAL ( "MODE" ) = "INTERACTIVE" ) THEN

                WriteToLog("FILE SEND ":logfile:", DISPLAY/")
                FILE SEND logfile, "DISPLAY/"

            ENDIF

        ELSE

            flash_message ( "Server Manager Error on Logfile ", TRUE )     { cannot be message.txt is install of self }

        ENDIF  { logfile output from create structure }

    ENDIF  { build command }

    RESTORE DATE FORMAT

    RETURN ( retval )

ENDROUTINE {  internal_structure }

{ **************************************************************************** }

ROUTINE MENU_create_package ( VALUE menu_id )

    DECLARE a_title     ,
                a_msg       ,
                a_obj       ,
                a_dir       ,
                select_array

    ARRAY select_array

    { --------------------------------------------------------------------------------- }
    { Do not use "blank" as you will get no entries, use a field value                  }
    { --------------------------------------------------------------------------------- }

    ARRAY_SELECT_ADD ( select_array, ARRAY_SELECT_EQ, "INSTALL_SET", C_SMP_MODULE_INSTALL_SET_DIR :".": C_SMP_MODULE_INSTALL_SET_EXT )
    ARRAY_SELECT_ADD ( select_array, ARRAY_SELECT_NE, "SMP_VERSION", "IMPORTGLB"                                                     )

    { --------------------------------------------------------------------------------- }
    { Always check if setup is ok before doing any option                               }
    { --------------------------------------------------------------------------------- }

    IF NOT ( internal_validate_server ( a_dir, tables_ok ) ) THEN

        FLASH_MESSAGE ( "LIT_LAB_SMP_MODULE_ERROR_SMPINSTALL", FALSE )

    ELSE

        a_title = internal_translate_message ( "LIT_LAB_SMP_MODULE_CREATE_TITLE" )
        a_msg   = internal_translate_message ( "LIT_LAB_SMP_MODULE_INPUT" )

        IF ( internal_get_an_identity ( C_SMP_MODULE,
                                                  a_title     ,
                                                  a_msg       ,
                                                  EMPTY       ,
                                                  EMPTY       ,
                                                  select_array,
                                                  GLBL_id     ) ) THEN

            a_title = internal_translate_message ( "LIT_LAB_SMP_MODULE_STARTING_BUILD" ) : GLBL_id

            window_set_status ( a_title )

            IF ( internal_build_package ( GLBL_id, a_obj ) ) THEN

                a_title = a_obj.call_trigger ( C_TRIGGER_BUILD_COMPLETE )

            ELSE

                a_title = internal_translate_message ( "LIT_LAB_SMP_MODULE_PACKAGE_INVALID" )

            ENDIF

            a_obj = EMPTY

            window_set_status ( a_title )

        ENDIF

    ENDIF

    EXIT    { menu programs exit }

ENDROUTINE  { menu_create_package }

{ **************************************************************************** }

ROUTINE MENU_install_package ( VALUE menu_id )

    DECLARE a_title     ,
            a_msg       ,
            a_obj       ,
            a_dir       ,
            select_array,
            new_status  ,
            a_old,
            t_old

    new_status = ""
    a_old      = GLOBAL ( "AUDIT_SUPPRESSION" )
    t_old      = GLOBAL ( "COMMITTED_TABLE_SET" )

    SET GLOBAL "AUDIT_SUPPRESSION" TO "ALL"

    ARRAY select_array
    ARRAY_SELECT_ADD ( select_array, ARRAY_SELECT_EQ, "FILES_UPDATED"  , FALSE )
    ARRAY_SELECT_ADD ( select_array, ARRAY_SELECT_EQ, "DATE_INSTALLED" , NULL  )

    { -------------------------------------------------------------------- }
    { If param active could be using 2nd stage install menu option         }
    { -------------------------------------------------------------------- }

    IF ( GLOBAL ( "PARAM_ACTIVE" ) ) THEN

        { ------------------------------------------------------------------- }
        { Load can be specific to import and each table type                  }
        { ------------------------------------------------------------------- }

        PROMPT FOR a_msg

        a_msg = STRIP ( TOUPPER ( a_msg ) )

        IF ( INDEX ( a_msg, "IMPORT" ) > 0 ) THEN

            ARRAY_SELECT_ADD ( select_array, ARRAY_SELECT_LIKE, "SMP_VERSION", "IMPORT%" )

        ENDIF

        IF ( INDEX ( a_msg, "MLP" ) > 0 ) THEN

            ARRAY_SELECT_ADD ( select_array, ARRAY_SELECT_LIKE, "IDENTITY", "%MLP%" )

        ENDIF

        IF ( INDEX ( a_msg, "PDS" ) > 0 ) THEN

            ARRAY_SELECT_ADD ( select_array, ARRAY_SELECT_LIKE, "IDENTITY", "%PDS%" )

        ENDIF

        IF ( INDEX ( a_msg, "TEST" ) > 0 ) THEN

            ARRAY_SELECT_ADD ( select_array, ARRAY_SELECT_LIKE, "IDENTITY", "%TEST_SCHED%" )

        ENDIF

        IF ( INDEX ( a_msg, "ANALYSIS" ) > 0 ) THEN

            ARRAY_SELECT_ADD ( select_array, ARRAY_SELECT_LIKE, "IDENTITY", "%ANALYSIS%" )

        ENDIF

        { ------------------------------------------------------------------- }
        { Finally, a flag to rest the approval status for loaded data         }
        { ------------------------------------------------------------------- }

        IF ( GLOBAL ( "PARAM_ACTIVE" ) ) THEN

            PROMPT FOR new_status

            new_status = TOUPPER ( STRIP ( new_status ) )  { Status letter that entity is set to }

        ENDIF

    ENDIF  { Params off of menu set flags for the operation }

    { -------------------------------------------------------------------- }
    { Always check to make system is ok before actual input of any option  }
    { -------------------------------------------------------------------- }

    IF NOT ( internal_validate_server ( a_dir, tables_ok ) ) THEN

        FLASH_MESSAGE ( "LIT_LAB_SMP_MODULE_ERROR_SMPINSTALL", FALSE )

    ELSE

        a_title = internal_translate_message ( "LIT_LAB_SMP_MODULE_INSTALL_TITLE" )
        a_msg   = internal_translate_message ( "LIT_LAB_SMP_MODULE_INPUT" )

        IF ( internal_get_an_identity ( C_SMP_MODULE,
                                                  a_title     ,
                                                  a_msg       ,
                                                  EMPTY       ,
                                                  EMPTY       ,
                                                  select_array,
                                                  GLBL_id     ) ) THEN


            a_title = internal_translate_message ( "LIT_LAB_SMP_MODULE_STARTING_BUILD" ) : GLBL_id

            window_set_status ( a_title )

            IF NOT ( internal_load_package ( GLBL_id, a_obj, menu_id, FALSE, new_status ) ) THEN

                a_title = internal_translate_message ( "LIT_LAB_SMP_MODULE_PACKAGE_INVALID" )

            ELSE

                a_title = a_obj.call_trigger ( C_TRIGGER_LOAD_COMPLETE )

            ENDIF

            window_set_status ( a_title )

            a_obj = EMPTY

        ENDIF

    ENDIF

    SET GLOBAL "AUDIT_SUPPRESSION" TO a_old
    SET GLOBAL "COMMITTED_TABLE_SET" TO t_old

    EXIT    { menu programs exit }

ENDROUTINE  { menu_install_package }

{ **************************************************************************** }

ROUTINE MENU_move_zip_package ( VALUE menu_id )

    DECLARE a_title     ,
                 a_msg       ,
                 a_dir       ,
                 a_mode      ,
                 a_first

    a_first = FALSE

    IF NOT ( internal_validate_server ( a_dir, tables_ok ) ) THEN

        FLASH_MESSAGE ( "LIT_LAB_SMP_MODULE_ERROR_SMPINSTALL", FALSE )

    ELSE

        { ---------------------------------------------------------------- }
        { If this is first install the config item does not exist yet      }
        { ---------------------------------------------------------------- }

        a_first = INDEX ( menu_id, "_FIRST" )
        a_title = "Self-install of Packager ZIP "                       { msgs do not exist self install... }
        a_msg   = "<F2> Find <Packager>.exe file from your folders "  { cannot get msg - is first install }

        IF ( a_first > 0 ) THEN

            menu_id = LEFTSTRING ( menu_id, a_first - 1 )
            a_first = TRUE

        ELSE

            a_first = FALSE
            a_title = internal_translate_message ( "LIT_LAB_SMP_MODULE_MOVE_TITLE" )
            a_msg   = internal_translate_message ( "LIT_LAB_SMP_MODULE_INPUT"   )

        ENDIF

        { ---------------------------------------------------------------- }
        { 2 master menu options (ZIP or EXE) for self extract or zip       }
        { ---------------------------------------------------------------- }

        IF ( GLOBAL ( "PARAM_ACTIVE" ) ) THEN

            PROMPT FOR a_mode
            a_mode = STRIP ( TOUPPER ( a_mode ) )

            IF ( INDEX ( "#ZIP#EXE", a_mode ) = 0 ) THEN

                a_mode = "EXE"

            ENDIF

        ELSEIF ( INDEX ( "#ZIP#EXE#", menu_id ) > 0  ) THEN

            a_mode = menu_id

        ELSE

            a_mode = "EXE"

        ENDIF

        { ---------------------------------------------------------------- }
        { The get zip prompt on ok will do the actual movement             }
        { ---------------------------------------------------------------- }

        IF ( internal_get_zip_identity ( a_title, a_msg, GLBL_id, a_mode ) ) THEN

            internal_move_a_package ( GLBL_id, a_mode, a_first, FALSE )

        ENDIF  {  the a_obj is the packager object }

    ENDIF  { the server did not validate ok so nothing can run at all }


    { ---------------------------------------------------------------- }
    { First time installer give them a special message                 }
    { ---------------------------------------------------------------- }

    IF ( a_first ) THEN

        FLASH_MESSAGE ( "Please logoff and reconnect to enable the changes made for self-install", TRUE )

    ENDIF

    EXIT    { menu programs exit }

ENDROUTINE  { menu_move_zip_package }

{ **************************************************************************** }

ROUTINE MENU_correct_procedures ( VALUE menu_id )

    DECLARE a_title     ,
                 a_msg       ,
                 a_obj       ,
                 a_dir       ,
                 select_array

    ARRAY select_array
    ARRAY_SELECT_ADD ( select_array, ARRAY_SELECT_EQ, "DATE_INSTALLED"  , NULL  )
    ARRAY_SELECT_ADD ( select_array, ARRAY_SELECT_EQ, "SMW_MENU_UPDATED", FALSE )


    { -------------------------------------------------------------------- }
    { Always check to make system is ok before actual input of any option  }
    { -------------------------------------------------------------------- }

    IF NOT ( internal_validate_server ( a_dir, tables_ok ) ) THEN

        FLASH_MESSAGE ( "LIT_LAB_SMP_MODULE_ERROR_SMPINSTALL", FALSE )

    ELSE

        a_title = internal_translate_message ( "LIT_LAB_SMP_MODULE_MENU_NEW_PROCEDURE_NUM" )
        a_msg   = internal_translate_message ( "LIT_LAB_SMP_MODULE_INPUT"             )

        IF ( internal_get_an_identity ( C_SMP_MODULE,
                                                  a_title     ,
                                                  a_msg       ,
                                                  EMPTY       ,
                                                  EMPTY       ,
                                                  select_array,
                                                  GLBL_id     ) ) THEN


            IF NOT ( internal_load_package ( GLBL_id, a_obj, menu_id, TRUE, "" ) ) THEN

                a_title = internal_translate_message ( "LIT_LAB_SMP_MODULE_PACKAGE_INVALID" )

            ENDIF

            a_obj = EMPTY

        ENDIF  { input identity }

    ENDIF   { if.else server invalid }

    EXIT

ENDROUTINE  { menu_correct_procedures }

{******************************************************************************}
{                                                                              }
{                                                                              }
{                                                                              }
{                                                                              }
{                         ROUTINES USED BY THE PACKAGER                        }
{                                                                              }
{                                                                              }
{                                                                              }
{                                                                              }
{******************************************************************************}

GLOBAL ROUTINE internal_move_a_package ( VALUE GLBL_id ,
                                         VALUE a_mode  ,
                                         VALUE a_first       ,
                                         VALUE is_export_set )


    DECLARE fd_only     ,
                 a_dot       ,
                 a_dest_dir  ,
                 a_semi      ,
                 a_id        ,
                 a_obj       ,
                 a_msg

    { ---------------------------------------------------------- }
    { Got the zip file, now decode target dir from filename      }
    { ---------------------------------------------------------- }

    internal_strip_subdirs ( GLBL_id, fd_only )

    retval      = FALSE
    fd_only     = STRIP ( TOUPPER ( fd_only ) )
    a_dot       = INDEX ( fd_only, "." )
    fd_only     = STRIP ( LEFTSTRING ( fd_only, a_dot - 1 ) )

    { --------------------------------------------------------------------- }
    { If this is from export load change the source to IMPORT               }
    { --------------------------------------------------------------------- }

    IF ( is_export_set ) THEN

        a_semi = STRINGLENGTH ( fd_only )
        fd_only = "IM" : RIGHTSTRING ( fd_only, a_semi - 2 )

    ENDIF

    a_dest_dir  = LOGICAL ( C_SMP_MODULE_INSTALL_SET_DIR )

    IF ( a_dest_dir = C_SMP_MODULE_INSTALL_SET_DIR ) THEN

        a_dest_dir = LOGICAL ( "SMP$ROOT" )
        a_semi     = INDEX ( a_dest_dir, ";" )

        IF ( a_semi > 0 ) THEN

            a_dest_dir = LEFTSTRING ( a_dest_dir, a_semi - 1 )

        ENDIF

        a_dest_dir = a_dest_dir :"\": C_SMP_MODULE_INSTALL_DIR_VALUE :"\": fd_only

    ELSE

        a_dest_dir = a_dest_dir :"\": fd_only

    ENDIF

    internal_build_id_from_file ( fd_only, a_id, a_first )

    IF ( internal_create_packager_module ( a_dest_dir, a_id, fd_only, a_obj ) ) THEN

        { ------------------------------------------------- }
        { Update the correct property to the id input       }
        { ------------------------------------------------- }

        a_obj.a_mode             = a_mode           { zip or exe                          }
        a_obj.fd_only            = fd_only          { this packages directory             }
        a_obj.a_first            = a_first          { if a self install of packager       }
        a_obj.install_set_source = GLBL_id          { where we are getting zip from       }
        a_obj.is_export_set      = is_export_set    { is this pkg for import data only ?  }

        { ------------------------------------------------- }
        { If not very first install get real message values }
        { ------------------------------------------------- }


        IF NOT ( a_obj.a_first ) THEN

            a_obj.set_msg_translations()

        ENDIF


        { ------------------------------------------------- }
        { Now start the moving and installation of data     }
        { ------------------------------------------------- }

        retval = a_obj.move_zip_make_install()

        { ------------------------------------------------------------------------- }
        { If FIRST then if have smp_module...csv's & criteria ask if make Version 0 }
        { ------------------------------------------------------------------------- }

        IF ( retval ) AND ( NOT a_first ) AND ( a_obj.sm_version_0_Ok ) AND ( NOT is_export_set ) THEN

            a_msg = internal_translate_message ( "LIT_LAB_SMP_MODULE_VERSION_0_KIT" )

            IF ( C_MAKE_VERSION_0 ) AND ( CONFIRM_WITH_TEXT ( a_msg ) ) THEN   { ****** this is currently disabled...  }

                IF NOT ( a_obj.move_make_rollback_kit ( a_dest_dir, fd_only ) ) THEN

                    FLASH_MESSAGE (  "LIT_LAB_SMP_MODULE_ERROR_VERSION_0", TRUE )

                ELSE

                    a_obj.call_trigger ( C_TRIGGER_MOVE_ZIP_COMPLETE )
                    FLASH_MESSAGE (  "LIT_LAB_SMP_MODULE_SUCCESS_MOVE_KIT", TRUE )

                ENDIF

            ELSE

                a_obj.call_trigger ( C_TRIGGER_MOVE_ZIP_COMPLETE )
                FLASH_MESSAGE (  "LIT_LAB_SMP_MODULE_SUCCESS_MOVE_KIT", TRUE )

            ENDIF

        ELSEIF ( is_export_set ) AND ( retval ) THEN

            a_obj.import_set_criteria( fd_only )

            { ------------------------------------------------------- }
            { Make sure to add the "uninstall" in case pkger needs it }
            { ------------------------------------------------------- }

            a_dest_dir = a_dest_dir : "\UnInstall"

            internal_create_directory ( a_dest_dir )

            a_obj.call_trigger ( C_TRIGGER_MOVE_ZIP_COMPLETE )

            FLASH_MESSAGE (  "LIT_LAB_SMP_MODULE_SUCCESS_IMPORT", TRUE )

        ELSEIF ( retval ) THEN   { *** LIT001 only when move is ok *** }

            a_obj.call_trigger ( C_TRIGGER_MOVE_ZIP_COMPLETE )
            FLASH_MESSAGE (  "LIT_LAB_SMP_MODULE_SUCCESS_MOVE_KIT", TRUE )

        ENDIF

    ENDIF  { package module cannot be made }

    RETURN ( retval )

ENDROUTINE { internal_move_a_package }

{******************************************************************************}

ROUTINE internal_build_package ( VALUE a_id         ,
                                       a_obj        )

    DECLARE a_dir          ,
                 a_new_id       ,
                 a_uninstall_dir,
                 a_msg          ,
                 a_semi

    { -------------------------------------------------------- }
    { See if the directory exists and if not make it and pkg   }
    { -------------------------------------------------------- }

    retval   = FALSE
    a_new_id = internal_build_new_id ( a_id )
    a_msg    = internal_translate_message ( "LIT_LAB_SMP_MODULE_VERSION_RECREATE" )
    status   = EMPTY

    { ---------------------------------------------------------------------- }
    { Site may force us to not have a logical for the install kit            }
    { ---------------------------------------------------------------------- }

    a_dir = LOGICAL ( C_SMP_MODULE_INSTALL_SET_DIR )

    IF ( a_dir = C_SMP_MODULE_INSTALL_SET_DIR ) THEN

        a_dir  = LOGICAL ( "SMP$ROOT" )
        a_semi = INDEX ( a_dir, ";" )

        IF ( a_semi > 0 ) THEN

            a_dir = LEFTSTRING ( a_dir, a_semi - 1)

        ENDIF

        a_dir = a_dir : "\" : C_SMP_MODULE_INSTALL_DIR_VALUE :"\": a_new_id

    ELSE

        a_dir = a_dir :"\": a_new_id

    ENDIF

    { --------------------------------------------------------- }
    { Give em a chance to re-create the kit if need be          }
    { --------------------------------------------------------- }

    IF ( FILE EXISTS ( a_dir ) ) AND ( CONFIRM_WITH_TEXT ( a_msg ) ) THEN

        FILE DELETE a_dir, status

    ENDIF

    { --------------------------------------------------------- }
    { In any case, the file must not exist...                   }
    { --------------------------------------------------------- }

    IF NOT FILE EXISTS ( a_dir ) AND ( status = EMPTY ) THEN

        IF ( internal_create_directory ( a_dir ) ) THEN

            { -------------------------------------------------------- }
            { Make the uninstall directory populated by install        }
            { -------------------------------------------------------- }

            a_uninstall_dir = LOGICAL ( C_SMP_MODULE_INSTALL_SET_DIR )

            IF ( a_uninstall_dir = C_SMP_MODULE_INSTALL_SET_DIR ) THEN

                a_uninstall_dir = LOGICAL ( "SMP$ROOT" )
                a_semi          = INDEX ( a_uninstall_dir, ";" )

                IF ( a_semi > 0 ) THEN

                    a_uninstall_dir = LEFTSTRING ( a_uninstall_dir, a_semi - 1 )

                ENDIF

                a_uninstall_dir = a_uninstall_dir :"\": C_SMP_MODULE_INSTALL_DIR_VALUE : "\" : a_new_id : "\" : C_UNINSTALL_DIR

            ELSE

                a_uninstall_dir = a_uninstall_dir :"\": a_new_id : "\" : C_UNINSTALL_DIR

            ENDIF

            IF ( internal_create_directory ( a_uninstall_dir ) ) THEN

                { -------------------------------------------------------- }
                { Create packager object and send the system on its way    }
                { -------------------------------------------------------- }

                IF ( internal_create_packager_module ( a_dir, a_id, a_new_id, a_obj ) ) THEN

                    a_obj.module_record.initialise ( a_obj.module_record.table )
                    a_obj.module_record.select_for_update ( a_obj.criteria_array )
                    a_obj.module_record.set_first()
                    a_obj.set_msg_translations()

                         IF ( a_obj <> EMPTY ) THEN

                             a_obj.criteria_versioned = SELECT 'C_SMP_MODULE'.CRITERIA_VERSIONED IN OBJECT a_obj.module_record.current

                            { -------------------------------------------------------------------- }
                        { Load all the child tables from this record (data and dll's)          }
                        { -------------------------------------------------------------------- }

                        IF ( a_obj.package_load_criteria() ) THEN

                            IF ( a_obj.package_load_dll() ) THEN

                                { -------------------------------------------------------------------- }
                                { Using these loaded instructions now load the actual files            }
                                { -------------------------------------------------------------------- }

                                IF ( a_obj.package_subdirs() ) THEN

                                    IF ( a_obj.call_trigger( C_TRIGGER_BEFORE_MAKE_DATA ) ) THEN

                                        IF ( a_obj.package_save_data() ) THEN

                                            IF NOT ( a_obj.package_save_files() ) THEN

                                                FLASH_MESSAGE ( "LIT_LAB_SMP_MODULE_ERROR_SAVE_FILES", FALSE )

                                            ELSEIF ( a_obj.call_trigger ( C_TRIGGER_BEFORE_SAVE ) ) THEN

                                                IF ( a_obj.package_update_smp_file() ) THEN

                                                    IF ( a_obj.package_create_exe() ) THEN

                                                        a_obj.package_update_dbase()

                                                    ELSE

                                                            FLASH_MESSAGE ( "LIT_LAB_SMP_MODULE_ERROR_SAVE_DATA", FALSE )
                                                        ROLLBACK

                                                    ENDIF  { zip/extract display own messages }

                                                    ELSE

                                                   FLASH_MESSAGE ( "LIT_LAB_SMP_MODULE_ERROR_SAVE_DATA", FALSE )
                                                   ROLLBACK

                                                ENDIF  { update smp file displays own message }

                                            ENDIF  { trigger displays its own message }

                                        ELSE

                                            FLASH_MESSAGE ( "LIT_LAB_SMP_MODULE_ERROR_SAVE_DATA", FALSE )

                                        ENDIF   { error saving data }

                                    ENDIF  { trigger displays own message why it does not want to continue }

                                ELSE

                                    FLASH_MESSAGE ( "LIT_LAB_SMP_MODULE_ERROR_CREATE_DIR", FALSE )

                                ENDIF   { creation of subdirectories }

                            ELSE

                                FLASH_MESSAGE ( "LIT_LAB_SMP_MODULE_ERROR_LOAD_DLL", FALSE )

                            ENDIF  { load dll failed }

                        ELSE

                            FLASH_MESSAGE ( "LIT_LAB_SMP_MODULE_ERROR_LOAD_CRITERIA", FALSE )

                        ENDIF      { load criteria failed }

                        { -------------------------------------------- }
                        { No need to display msg, no retval returned   }
                        { -------------------------------------------- }

                         ENDIF     { a_obj EMPTY record is locked   }

                     ENDIF        { packager object failed    }

            ELSE

                FLASH_MESSAGE ( "LIT_LAB_SMP_MODULE_ERROR_CREATE_SUBDIR", FALSE )

            ENDIF     { uninstall not made correctly  }

        ELSE

            FLASH_MESSAGE ( "LIT_LAB_SMP_MODULE_ERROR_CREATE_SUBDIR", FALSE )

        ENDIF   { install dir was not made correctly  }

    ELSE

        {FLASH_MESSAGE ( "LIT_LAB_SMP_MODULE_ERROR_KIT_EXISTS", FALSE )}
        WriteToLog("LIT_LAB_SMP_MODULE_ERROR_KIT_EXISTS")

    ENDIF    { kit directory cannot exist - must delete manually }

    RETURN ( retval )

ENDROUTINE   { internal_build_package }

{******************************************************************************}

ROUTINE internal_create_directory ( VALUE a_dir )

    DECLARE fso

    retval = TRUE

    IF NOT FILE EXISTS ( a_dir ) THEN

        CREATE OBJECT CLASS_STD_OLE_AUTOMATION_SERVER,fso
            fso.create("Scripting.FileSystemObject")

        retval = fso.CreateFolder ( a_dir )

        IF ( retval <> EMPTY ) THEN

            retval = TRUE

        ELSE

            retval = FALSE

        ENDIF

    ENDIF

    RETURN ( retval )

ENDROUTINE   { internal_create_directory }

{******************************************************************************}

ROUTINE internal_build_logical ( VALUE a_dir )

    DECLARE a_fd   ,
                 stlen

    { ------------------------------------------------------------------- }
    { Replace the first underscore with a $ and get logical - smp$root... }
    { ------------------------------------------------------------------- }

    a_fd = STRIP ( internal_file_name_only ( a_dir ) )

    IF ( LEFTSTRING ( a_fd, 4 ) = "SMP_" ) THEN

        stlen = STRINGLENGTH ( a_fd )
        a_fd  = "SMP$" : RIGHTSTRING ( a_fd, stlen - 4 )

    ENDIF

    a_fd = LOGICAL ( a_fd )

    RETURN ( a_fd )

ENDROUTINE  { internal_build_logical }

{******************************************************************************}

ROUTINE internal_build_logical_full ( VALUE a_full_name ,
                                            a_logical   )

    DECLARE a_fd      ,
                 stlen     ,
                 a_slash   ,
                 a_dir_only

    { ------------------------------------------------------------------- }
    { Replace the first underscore with a $ and get logical - smp$root... }
    { ------------------------------------------------------------------- }

    a_full_name = STRIP ( TOUPPER ( a_full_name ) )
    a_fd        = INDEX ( a_full_name, "\SMP_" )

    IF ( a_fd > 0 ) THEN

        a_dir_only = internal_dir_only ( a_full_name )
        stlen      = STRINGLENGTH ( a_full_name )
        a_fd       = RIGHTSTRING ( a_full_name, stlen - a_fd )
        a_slash    = INDEX ( a_fd, "\" )

        IF ( a_slash > 0 ) THEN

            a_fd = LEFTSTRING ( a_fd, a_slash - 1 )

            IF ( LEFTSTRING ( a_fd, 4 ) = "SMP_" ) THEN

                stlen     = STRINGLENGTH ( a_fd )
                a_logical = "SMP$" : RIGHTSTRING ( a_fd, stlen - 4 )

            ENDIF

        ENDIF  { ending slash of subdirectory }

    ENDIF   { the file has "\SMP" so part of name is full path structure... }

    RETURN ( a_dir_only )

ENDROUTINE  { internal_build_logical_full }

{******************************************************************************}

ROUTINE internal_dir_only ( VALUE fd_only )

    DECLARE tmp, stlen, dir_only

    dir_only = ""
    fd_only  = STRIP(fd_only)
    stlen    = STRINGLENGTH ( fd_only )
    tmp      = INDEX ( fd_only, "\" )

    WHILE ( tmp > 0 ) DO

        dir_only = dir_only : STRIP ( LEFTSTRING ( fd_only, tmp ) )
        fd_only  = RIGHTSTRING ( fd_only, stlen - tmp )
        stlen    = STRINGLENGTH ( fd_only )
        tmp      = INDEX ( fd_only, "\" )

    ENDWHILE

    RETURN ( dir_only )

ENDROUTINE  { internal_dir_only }

{ ************************************************************************************* }

ROUTINE internal_create_packager_module (       a_dir        ,
                                                a_id         ,
                                                a_new_id     ,
                                                a_obj        )

    retval = TRUE

    define_packager_class()

    CREATE OBJECT CLASS_PACKAGER_CLASS, a_obj
        a_obj.key0                = a_id
        a_obj.key0_underscore     = a_new_id
        a_obj.key0_no_blanks      = SUBSTITUTE ( a_id, " ", "" )
        a_obj.smp_version         = LEFTSTRING ( a_id, a_obj.key1_len )
        a_obj.identity            = SUBSTRING  ( a_id, a_obj.key1_len + 1, a_obj.key2_len )
        a_obj.version_number      = PACKED_DECIMAL ( RIGHTSTRING ( a_id, 10 ) )
        a_obj.install_set         = a_dir :"\": a_new_id :".": C_INSTALL_SET_EXT
        a_obj.install_set_kit_dir = STRIP ( a_dir )
        a_obj.zip_type            = "ZIP"
        a_obj.install_set_zip_id  = a_dir :"\": a_new_id :".": a_obj.zip_type
        a_obj.install_set_sfx_id  = a_dir :"\": a_new_id :".EXE"
        a_obj.uninstall_dir       = a_obj.install_set_kit_dir : "\" : C_UNINSTALL_DIR
        a_obj.is_version_0_kit    = a_obj.version_number = 0

    ARRAY_SELECT_ADD ( a_obj.criteria_array, ARRAY_SELECT_EQ, "SMP_VERSION"   , a_obj.smp_version    )
    ARRAY_SELECT_ADD ( a_obj.criteria_array, ARRAY_SELECT_EQ, "IDENTITY"      , a_obj.identity       )
    ARRAY_SELECT_ADD ( a_obj.criteria_array, ARRAY_SELECT_EQ, "VERSION_NUMBER", a_obj.version_number )

    { -------------------------------------------------------------------- }
    { Add this record so users can change database table for new variables }
    { -------------------------------------------------------------------- }

    CREATE OBJECT C_STD_OBJECT_DATABASE, a_obj.module_record
        a_obj.module_record.table = a_obj.table

    RETURN ( retval )

ENDROUTINE        { internal_create_packager_module }

{******************************************************************************}

ROUTINE packager_action_import_set_criteria ( self, a_id )

    DECLARE status      ,
                 a_under     ,
                 a_id1       ,
                 a_id2       ,
                 a_id3       ,
                 a_id4       ,
                 a_len1      ,
                 a_len2      ,
                 a_len       ,
                 a_byte

    GET_FIELD_DETAILS 'C_SMP_MODULE'.SMP_VERSION, "FIELD_SIZE", a_len1
    GET_FIELD_DETAILS 'C_SMP_MODULE'.IDENTITY   , "FIELD_SIZE", a_len2

    retval        = FALSE
    a_id4         = STRIP ( TOUPPER ( a_id ) )
    a_len         = STRINGLENGTH ( a_id )
    a_id3         = ""
    a_under       = INDEX ( a_id4, "_" )

    a_id1         = PAD ( LEFTSTRING ( a_id4, a_under - 1 ), " ", a_len1 )
    a_id4         = STRIP ( RIGHTSTRING ( a_id4, a_len - a_under ) )
    a_len         = STRINGLENGTH ( a_id4 )
    a_byte        = GET_CHARACTER_AT ( a_id4, a_len )

    WHILE ( INDEX ( "0123456789", a_byte ) > 0 ) DO

        a_id3  = a_byte : a_id3
        a_len  = a_len - 1
        a_byte = GET_CHARACTER_AT ( a_id4, a_len )

    ENDWHILE

    { ------------------------------------------------------- }
    { Now get the right most bytes until not a number...      }
    { ------------------------------------------------------- }

    a_id2 = PAD ( LEFTSTRING ( a_id4, a_len - 1 ), " ", a_len2 )
    a_id3 = PACKED_DECIMAL ( a_id3 )
    a_id4 = PACKED_DECIMAL ( 1 )

    IF ( a_id3 = ERROR ) OR ( a_id3 = "Error" ) THEN

        a_id3 = PACKED_DECIMAL ( 1 )

    ENDIF

    { --------------------------------------------------------------------------- }
    { Create the identity in the smp_module table                                 }
    { --------------------------------------------------------------------------- }

    START WRITE TRANSACTION C_PACKAGER_WRITE_TRANS

    status = SELECT 'C_SMP_MODULE_CRITERIA'.IDENTITY FOR UPDATE
                  WHERE SMP_VERSION    = a_id1
                  AND   IDENTITY       = a_id2
                  AND   VERSION_NUMBER = a_id3
                  AND   ORDER_NUMBER   = a_id4

    IF ( status = EMPTY ) THEN

        RESERVE ENTRY 'C_SMP_MODULE_CRITERIA', a_id1:a_id2:a_id3:a_id4, status

    ELSEIF ( status = ERROR ) OR ( status = LOCKED ) THEN

        FLASH_MESSAGE ( "LIT_LAB_SMP_MODULE_ERROR_RESERVE", TRUE )

    ELSE

        status = EMPTY

    ENDIF

    { --------------------------------------------------------------------------- }
    { Ok so far, then update fields and extract the file on the new location      }
    { --------------------------------------------------------------------------- }

    IF ( status = EMPTY ) THEN

        ASSIGN 'C_SMP_MODULE_CRITERIA'.TABLE_NAME  = "MESSAGE.TXT"
        ASSIGN 'C_SMP_MODULE_CRITERIA'.CSV_FILE    = self.install_set_zip_id
        ASSIGN 'C_SMP_MODULE_CRITERIA'.DESCRIPTION = "GLOBAL_DATA ready to load ":NOW

        UPDATE 'C_SMP_MODULE_CRITERIA', status

        IF ( status <> EMPTY ) THEN

            ROLLBACK

        ELSE

            retval = TRUE
            COMMIT

        ENDIF

    ELSE

        retval = TRUE
        ROLLBACK

    ENDIF  { status empty on update or reserve }

    RETURN ( retval )

ENDROUTINE  { packager_action_import_set_Criteria }

{******************************************************************************}

ROUTINE packager_action_import_reset_counts ( self )

    self.csv_load_count   = 0
    self.csv_ignore_count = 0
    self.csv_skip_count   = 0

ENDROUTINE  { packager_action_import_reset_counts }

{******************************************************************************}

ROUTINE packager_action_import_load_mlp ( self )

    DECLARE i

    retval  = TRUE
    i       = 1

    { ------------------------------------------------------------------ }
    { First time do the mlp_header (must be the first loaded)            }
    { ------------------------------------------------------------------ }

    IF ( internal_array_mlp_slice ( self.mlp_csv_array, "\MLP_HEADER", i ) ) THEN

        retval = self.install_1_csv ( self.mlp_csv_array[i] )

        IF self.loaded_ok THEN

            self.install_set_load_array ( "CSV", self.mlp_csv_array[i], FALSE, "", "", self.mlp_csv_array[i], self.csv_mode, self.a_table )

        ENDIF

        ARRAY_REMOVE_SLICE ( self.mlp_csv_array, 1, i )

        self.import_reset_counts()

    ENDIF

    { ------------------------------------------------------------------ }
    { Next do the mlp_components (must be the first loaded)              }
    { ------------------------------------------------------------------ }

    IF ( retval ) AND ( internal_array_mlp_slice ( self.mlp_csv_array, "\MLP_COMPONENTS", i ) ) THEN

        retval = self.install_1_csv ( self.mlp_csv_array[i] )

        IF self.loaded_ok THEN

            self.install_set_load_array ( "CSV", self.mlp_csv_array[i], FALSE, "", "", self.mlp_csv_array[i], self.csv_mode, self.a_table )

        ENDIF

        ARRAY_REMOVE_SLICE ( self.mlp_csv_array, 1, i )

        self.import_reset_counts()

    ENDIF

    { ------------------------------------------------------------------ }
    { Now do anything that is remaining of the MLP's                     }
    { ------------------------------------------------------------------ }

    i = 1

    WHILE ( self.mlp_csv_array[i] <> EMPTY ) AND ( retval ) DO

        retval = self.install_1_csv ( self.mlp_csv_array[i] )

        IF self.loaded_ok THEN

            self.install_set_load_array ( "CSV", self.mlp_csv_array[i], FALSE, "", "", self.mlp_csv_array[i], self.csv_mode, self.a_table )

        ENDIF

        self.import_reset_counts()
        i = i + 1

    ENDWHILE

    RETURN ( retval )

ENDROUTINE  { packager_action_import_load_MLP }

{******************************************************************************}

ROUTINE packager_action_package_load_criteria ( self )

    DECLARE cnt         ,
                 cnt2        ,
                 cnt3        ,
                 cnt4        ,
                 cnt5        ,
                 a_val       ,
                 a_dir       ,
                 a_dir_no    ,
                 a_subdir    ,
                 a_subdir_2  ,
                 a_slash     ,
                 tmp         ,
                 a_len       ,
                 a_byte      ,
                 a_stop

    { ----------------------------------------------------------------------------- }
    { Get everything from this packages smp_module_criteria table                   }
    { ----------------------------------------------------------------------------- }

    CREATE OBJECT C_STD_OBJECT_DATABASE, self.criteria_dbase

    self.criteria_dbase.initialise ( self.criteria_table )
    self.criteria_dbase.select_for_update ( self.criteria_array )

    cnt2  = 0
    cnt   = 1
    a_val = self.criteria_dbase.get_by_number ( cnt )

    WHILE ( a_val <> EMPTY ) DO

        { ----------------------------------------------------------------------------- }
        { a_dir = smp$logical but subdir_array is SMP_<logical>                         }
        { ----------------------------------------------------------------------------- }

        a_dir    = SELECT 'self.criteria_table'.FILE_LOGICAL IN OBJECT a_val
        a_dir_no = a_dir

        IF ( LEFTSTRING ( a_dir_no, 4 ) = "SMP$" ) THEN

            a_len    = STRINGLENGTH ( a_dir_no )
            a_dir_no = "SMP_" : RIGHTSTRING ( a_dir_no, a_len - 4 )

        ENDIF

        { ----------------------------------------------------------------------------- }
        { Keep this array as the one that will drive what subdirectories to make on kit }
        { ----------------------------------------------------------------------------- }

        IF ( NOT BLANK ( a_dir_no ) ) AND ( NOT internal_array_slice ( self.subdir_array, a_dir_no, cnt3 ) ) THEN

            cnt2                    = cnt2 + 1
            self.subdir_array[cnt2] = a_dir_no

        ENDIF

        { ----------------------------------------------------------------------------- }
        { Now add on any subdirectories separating each into a single dir               }
        { ----------------------------------------------------------------------------- }

        cnt4       = SIZE_OF_ARRAY ( self.subdir_2_array )
        a_subdir   = STRIP ( SELECT 'self.criteria_table'.FILE_SUB_DIRECTORY IN OBJECT a_val )
        a_slash    = INDEX ( a_sub_dir, "\" )
        a_len      = STRINGLENGTH ( a_sub_dir )
        a_subdir_2 = a_subdir

        IF ( a_slash = 0 ) AND NOT BLANK ( a_subdir ) THEN

            cnt4                        = cnt4 + 1
            self.subdir_2_array[cnt4,1] = a_dir_no
            self.subdir_2_array[cnt4,2] = a_subdir

        ELSEIF ( a_slash > 0 ) THEN

            cnt4                        = cnt4 + 1
            self.subdir_2_array[cnt4,1] = a_dir_no
            self.subdir_2_array[cnt4,2] = LEFTSTRING ( a_subdir, a_slash - 1 )
            a_subdir                    = RIGHTSTRING ( a_subdir, a_len - a_slash )
            a_len                       = STRINGLENGTH ( a_subdir )
            cnt5                        = 3
            a_slash                     = INDEX ( a_subdir, "\" )

            WHILE ( a_slash > 0 ) DO

                self.subdir_2_array[cnt4,cnt5] = self.subdir_2_array[cnt4,cnt5-1] : "\" : LEFTSTRING ( a_subdir, a_slash - 1 )
                a_subdir                       = RIGHTSTRING ( a_subdir, a_len - a_slash )
                a_len                          = STRINGLENGTH ( a_subdir )
                cnt5                           = cnt5 + 1
                a_slash                        = INDEX ( a_subdir, "\" )

            ENDWHILE

            IF ( NOT BLANK ( a_subdir ) ) THEN

                self.subdir_2_array[cnt4,cnt5] = self.subdir_2_array[cnt4,cnt5-1]: "\" :a_subdir

            ENDIF

        ENDIF   { special directory array for dependant sub-directories }

        { ----------------------------------------------------------------------------- }
        { Keep all this data for the .smp file for input to an IQ type report           }
        { ----------------------------------------------------------------------------- }

        self.save_array[cnt,1] = SELECT 'self.criteria_table'.SAVE_MODE          IN OBJECT a_val
        self.save_array[cnt,2] = SELECT 'self.criteria_table'.TABLE_NAME         IN OBJECT a_val
        self.save_array[cnt,3] = SELECT 'self.criteria_table'.CRITERIA_SAVED     IN OBJECT a_val
        self.save_array[cnt,4] = SELECT 'self.criteria_table'.FILE_SUB_DIRECTORY IN OBJECT a_val
        self.save_array[cnt,5] = SELECT 'self.criteria_table'.FILE_ID            IN OBJECT a_val
        self.save_array[cnt,6] = SELECT 'self.criteria_table'.FILE_EXTENSION     IN OBJECT a_val

        { ----------------------------------------------------------------------- }
        { Don't use the version on the criteria saved, it is part of the dir name }
        { ----------------------------------------------------------------------- }

        IF ( self.criteria_versioned ) THEN

            tmp    = STRIP ( self.save_array[cnt,3] )
            a_len  = STRINGLENGTH ( tmp )
            cnt3   = a_len
            a_stop = TRUE

            WHILE ( cnt3 > 1 ) AND ( a_stop ) DO

                a_byte = GET_CHARACTER_AT ( tmp, cnt3 )

                IF ( a_byte = "_" ) THEN

                    a_stop = FALSE

                ENDIF

                cnt3 = cnt3 - 1

            ENDWHILE

            tmp = LEFTSTRING ( tmp, cnt3 )
        ELSE

            tmp = self.save_array[cnt,3]

        ENDIF


        self.save_array[cnt,7 ] = STRIP ( self.save_array[cnt,2] ) :"_": STRIP ( tmp ) :"_": STRIP ( self.save_array[cnt,1] ) :".csv"
        self.save_array[cnt,8 ] = a_dir_no      {  **  <-- SMP_ not SMP$   ** }
        self.save_array[cnt,9 ] = cnt
        self.save_array[cnt,10] = a_dir         {  ** SMP$ logical            }
        self.save_array[cnt,11] = a_subdir_2

        cnt   = cnt + 1
        a_val = self.criteria_dbase.get_by_number(cnt)

    ENDWHILE

    RETURN ( self.criteria_dbase.size() > 0 )

ENDROUTINE   { packager_action_package_load_criteria }

{******************************************************************************}

ROUTINE packager_action_package_load_dll ( self )

    DECLARE cnt             ,
                cnt2            ,
                a_val           ,
                a_file          ,
                a_file_name_only,
                a_dest_subdir   ,
                a_server_client ,
                a_dest

    CREATE OBJECT C_STD_OBJECT_DATABASE, self.dll_dbase

    self.dll_dbase.initialise ( self.dll_table )
    self.dll_dbase.select_for_update ( self.criteria_array )

    a_dest = STRIP ( self.install_set_dir ) :"\": self.key0_underscore
    cnt2   = 0
    cnt    = 1
    a_val  = self.dll_dbase.get_by_number(cnt)

    WHILE ( a_val <> EMPTY ) DO

        a_file           = STRIP ( SELECT 'self.dll_table'.PROGRAM_DLL   IN OBJECT a_val ) { path file        }
        a_file_name_only = STRIP ( SELECT 'self.dll_table'.FILENAME_ONLY IN OBJECT a_val ) { name file only   }
        a_server_client  = STRIP ( SELECT 'self.dll_table'.CLIENT_SERVER IN OBJECT a_val ) { client or server }
        a_dest_subdir    = STRIP ( SELECT 'self.dll_table'.PROGRAM_SET   IN OBJECT a_val ) { kit subdirectory }

        IF ( NOT BLANK ( a_file ) ) THEN

            cnt2                           = cnt2 + 1
            self.program_dll_array[cnt2,1] = a_file                  { full name to source file           }
            self.program_dll_array[cnt2,2] = a_server_client         { is this for the client or server ? }
            self.program_dll_array[cnt2,3] = a_filename_only         { only the filename                  }
            self.program_dll_array[cnt2,4] = a_dest_subdir           { only <install_set> subdir to make  }

            { --------------------------------------------- }
            { Set the destination (where kit puts files)    }
            { --------------------------------------------- }

            IF ( NOT a_server_client ) THEN

                IF NOT BLANK ( a_dest_subdir ) THEN

                    self.program_dll_array[cnt2,5] = a_dest : C_SERVER_DIR :"\": a_dest_subdir:"\"
                    self.program_dll_array[cnt2,6] = a_dest : C_SERVER_DIR :"\": a_dest_subdir:"\": a_file_name_only

                ELSE

                    self.program_dll_array[cnt2,5] = a_dest : C_SERVER_DIR: "\"
                    self.program_dll_array[cnt2,6] = a_dest : C_SERVER_DIR: "\": a_file_name_only

                ENDIF

            ELSE
                IF NOT BLANK ( a_dest_subdir ) THEN

                    self.program_dll_array[cnt2,5] = a_dest : C_CLIENT_DIR : "\": a_dest_subdir :"\"
                    self.program_dll_array[cnt2,6] = a_dest : C_CLIENT_DIR : "\": a_dest_subdir :"\": a_file_name_only

                ELSE

                    self.program_dll_array[cnt2,5] = a_dest : C_CLIENT_DIR :"\"
                    self.program_dll_array[cnt2,6] = a_dest : C_CLIENT_DIR :"\": a_file_name_only

                ENDIF

            ENDIF

        ENDIF

        cnt   = cnt + 1
                a_val = self.dll_dbase.get_by_number(cnt)

    ENDWHILE

    RETURN ( TRUE )

ENDROUTINE   { packager_action_package_load_dll }

{******************************************************************************}

ROUTINE packager_action_package_subdirs ( self )

    DECLARE cnt   ,
                 cnt2  ,
                 a_rec

    { ------------------------------------------------------------------------------------- }
    { First do the smp$logicals for all the csv_data files - the dir has SMP_ at this stage }
    { ------------------------------------------------------------------------------------- }

    retval = TRUE
    cnt    = 1

    WHILE ( self.subdir_array[cnt] <> EMPTY ) AND ( retval ) DO

        a_rec = self.install_set_dir :"\": self.key0_underscore :"\": STRIP ( self.subdir_array[cnt] )

        IF NOT ( FILE EXISTS ( a_rec ) ) THEN

            retval = internal_create_directory ( a_rec )

        ENDIF

        cnt = cnt + 1

    ENDWHILE

    { ------------------------------------------------------------------------------------- }
    { Now do all the subdirectories below the SMP_logicals (resource/help etc)              }
    { ------------------------------------------------------------------------------------- }

    cnt = 1

    WHILE ( self.subdir_2_array[cnt,1] <> EMPTY ) AND ( retval ) DO

        cnt2 = 2

        WHILE ( self.subdir_2_array[cnt,cnt2] <> EMPTY ) AND ( retval ) DO

            a_rec = self.install_set_dir :"\": self.key0_underscore :"\": STRIP ( self.subdir_2_array[cnt,1] ) :"\": STRIP ( self.subdir_2_array[cnt,cnt2] )

            IF NOT ( FILE EXISTS ( a_rec ) ) THEN

                retval = internal_create_directory ( a_rec )

            ENDIF

            cnt2 = cnt2 + 1

        ENDWHILE

        cnt = cnt + 1

    ENDWHILE

    { ------------------------------------------------------ }
    { If dll's or xml's or any other client/server make dir  }
    { ------------------------------------------------------ }

    IF retval THEN

        cnt = 1

        WHILE ( self.program_dll_array[cnt,1] <> EMPTY ) AND ( retval ) DO

            IF ( self.program_dll_array[cnt,2] ) THEN
                a_rec = self.install_set_dir :"\": self.key0_underscore : C_CLIENT_DIR
            ELSE
                a_rec = self.install_set_dir :"\": self.key0_underscore : C_SERVER_DIR
            ENDIF

            IF NOT ( FILE EXISTS ( a_rec ) ) THEN

                IF ( internal_create_directory ( a_rec ) ) THEN

                    a_rec = a_rec :"\": STRIP ( self.program_dll_array[cnt,4] )

                    IF NOT ( FILE EXISTS ( a_rec ) ) THEN

                        IF ( internal_create_directory ( a_rec ) ) THEN

                            self.program_dll_array[cnt,7] = a_rec

                        ELSE

                            retval = FALSE

                        ENDIF

                    ENDIF

                ELSE

                    retval = FALSE

                ENDIF

            ELSE

                a_rec = a_rec :"\": STRIP ( self.program_dll_array[cnt,4] )

                IF NOT ( FILE EXISTS ( a_rec ) ) THEN

                    IF ( internal_create_directory ( a_rec ) ) THEN

                        self.program_dll_array[cnt,7] = a_rec

                    ELSE

                        retval = FALSE

                    ENDIF

                ENDIF

            ENDIF

            cnt = cnt + 1

        ENDWHILE

    ENDIF

    RETURN ( retval )

ENDROUTINE   { packager_action_package_subdirs }

{******************************************************************************}

ROUTINE packager_action_package_save_data ( self )

    DECLARE cnt             ,
                selection_array ,
                list_of_fields  ,
                return_msg      ,
                strip_msg       ,
                out_file        ,
                out_table       ,
                a_rec

    { ------------------------------------------------------------ }
    { Save msg to strip off to get the number records written      }
    { ------------------------------------------------------------ }

    message_fetch ( "TABLE_SAVER_WRITE_SUCCESS", strip_msg )

    strip_msg = message_get_text ( strip_msg , 1 ) # "[]"
    cnt       = 1
    retval    = TRUE

    { ------------------------------------------------------------ }
    { Save into CSV using table saver all data referenced by crit. }
    { ------------------------------------------------------------ }

    WHILE ( self.save_array[cnt,1] <> EMPTY ) AND ( retval ) DO

        { ------------------------------------------------------------ }
        { STRUCTURE.TXT and COMPILE.VGSM are not valid tables          }
        { ------------------------------------------------------------ }

        IF ( VALID_TABLE ( self.save_array[cnt,2] ) ) THEN

            ARRAY selection_array
            ARRAY list_of_fields

            { ------------------------------------------------------------ }
            { Get all the fields from the table and save by criteria       }
            { ------------------------------------------------------------ }

            window_set_status ( self.save_array[cnt,2] )

            get_field_names_without_aliases ( self.save_array[cnt,2], list_of_fields )

            internal_remove_mod_field ( self.save_array[cnt,2], list_of_fields )

            retval = TRUE

            IF ( size_of_array ( list_of_fields ) > 0 ) THEN

                IF ( criteria_saved_load_squirrel ( self.save_array[cnt,2],
                                                                        self.save_array[cnt,3],
                                                                        selection_array       ) = EMPTY ) THEN


                    out_file                = self.install_set_dir:"\":self.key0_underscore:"\":STRIP(self.save_array[cnt,7])
                    out_table               = self.save_array[cnt,2]
                    self.save_array[cnt,13] = selection_array

                    output_csv_file ( out_file, out_table, list_of_fields, selection_array, FALSE, return_msg )

                    { ------------------------------------------------------- }
                    { If get "no records saved" then save how many were done  }
                    { ------------------------------------------------------- }

                    IF ( index ( return_msg, strip_msg ) > 0 ) THEN

                        a_rec = STRIP ( return_msg # strip_msg )

                        IF NUMTEXT ( a_rec ) THEN
                            a_rec = NUMERIC ( a_rec )
                        ELSE
                            a_rec = 0
                        ENDIF

                        self.save_array[cnt,12 ] = a_rec
                        self.save_array[cnt,14 ] = out_file

                        { ------------------------------------------------------------ }
                        { Update the smp_module_criteria with csv filename and # recs  }
                        { ------------------------------------------------------------ }

                        a_rec = self.criteria_dbase.get_by_number ( cnt )

                        IF ( a_rec <> EMPTY ) THEN

                            ASSIGN 'C_SMP_MODULE_CRITERIA'.CSV_FILE           IN OBJECT a_rec = out_file
                            ASSIGN 'C_SMP_MODULE_CRITERIA'.NO_RECORDS_TO_LOAD IN OBJECT a_rec = self.save_array[cnt,12]
                            ASSIGN 'C_SMP_MODULE_CRITERIA'.NO_RECORDS_LOADED  IN OBJECT a_rec = 0
                            ASSIGN 'C_SMP_MODULE_CRITERIA'.NO_RECORDS_SKIPPED IN OBJECT a_rec = 0
                            ASSIGN 'C_SMP_MODULE_CRITERIA'.NO_FILES_MOVED     IN OBJECT a_rec = 0
                            ASSIGN 'C_SMP_MODULE_CRITERIA'.NO_COMPILES        IN OBJECT a_rec = 0

                        ENDIF

                    ELSE
                        retval = FALSE

                    ENDIF  { no records saved not returned from output csv }

                ELSE
                    retval = FALSE

                ENDIF  { squirrel loaded }

            ENDIF   { list of fields > 0 }

            window_set_status ( self.save_array[cnt,2] )

        ELSE

            self.save_array[cnt, 6] = ""                                                                               { clear out the full filename }
            self.save_array[cnt,12] = -1                                                                               { no recs to load             }
            self.save_array[cnt,14] = self.install_set_dir:"\":self.key0_underscore:"\":STRIP(self.save_array[cnt,7])  { full file }

        ENDIF  { valid table }

        cnt = cnt + 1

    ENDWHILE

    RETURN ( retval )

ENDROUTINE   { packager_action_package_save_data }

{******************************************************************************}

ROUTINE packager_action_package_save_files ( self )

    DECLARE cnt         ,
                cnt2        ,
                fso         ,
                status      ,
                tmpObj      ,
                a_val       ,
                log_path    ,
                file_ext    ,
                a_logical   ,
                id_only     ,
                a_mode      ,
                a_semi

    cnt    = 1
    retval = TRUE

    CREATE OBJECT CLASS_STD_OLE_AUTOMATION_SERVER,fso
        fso.create("Scripting.FileSystemObject")

    { ------------------------------------------------------------------ }
    { Copy all the dll.net.xml etc files from the server/client to kit   }
    { ------------------------------------------------------------------ }

    WHILE ( self.program_dll_array[cnt,1] <> EMPTY ) AND ( retval ) DO

        { ------------------------------------------------------------------ }
        { If the file exists - then copy it from the SMP to the install dir  }
        { ------------------------------------------------------------------ }

        IF NOT ( self.program_dll_array[cnt,2] ) THEN                            { <-- server file }

            IF ( FILE EXISTS ( self.program_dll_array[cnt,1] ) ) THEN

                retval = fso.CopyFile ( self.program_dll_array[cnt,1],  self.program_dll_array[cnt,6] )

                IF ( retval <> EMPTY ) THEN
                    retval = confirm_with_text ( retval )
                ELSE
                    retval = TRUE
                ENDIF

            ENDIF

        ELSE                                                                     { <-- client file }

            IF ( FILE EXISTS ( self.program_dll_array[cnt,6] ) ) THEN

                FILE DELETE self.program_dll_array[cnt,6], status

            ENDIF

            IF ( FILE EXISTS ( self.program_dll_array[cnt,1] ) ) THEN

                retval = transfer_binary_to_server ( self.program_dll_array[cnt,1], self.program_dll_array[cnt,6] )

                IF ( retval <> EMPTY ) THEN
                    retval = confirm_with_text ( retval )
                ELSE
                    retval = TRUE
                ENDIF

            ELSE

                retval = FALSE

            ENDIF

        ENDIF

        cnt = cnt + 1

    ENDWHILE

    { ------------------------------------------------------------------ }
    { Get the same data in the csv files saved for each smp$logical      }
    { ------------------------------------------------------------------ }

    cnt  = 1

    WHILE ( self.save_array[cnt,1] <> EMPTY ) AND ( retval ) DO

        { ---------------------------------------------------------------------- }
        { If a logical is set on the csv save then we have files to copy         }
        { ---------------------------------------------------------------------- }

        IF ( NOT BLANK ( self.save_array[cnt,10] ) ) THEN        { has an SMP$logical       }

            log_path  = STRIP ( LOGICAL ( STRIP ( self.save_array[cnt,10] ) ) ) : "\"
            a_semi    = INDEX ( log_path, ";" )

            { ---------------------------------------------------------------------- }
            { If log_path is a compound search (c:\data_custom;c:\data) pick 1rst    }
            { ---------------------------------------------------------------------- }

            IF ( a_semi > 0 ) THEN

                log_path = LEFTSTRING ( log_path, a_semi - 1 ) : "\"

            ENDIF


            a_logical = STRIP ( self.save_array[cnt,10] )   { save just as smp$ }

            { ---------------------------------------------------------------------- }
            { If this is a resource (ICO, HTML) then it will be a subdirectory       }
            { ---------------------------------------------------------------------- }

            IF ( NOT BLANK ( self.save_array[cnt,4] ) ) THEN

                log_path = log_path : STRIP ( self.save_array[cnt,4] ) : "\"

            ENDIF

            { ---------------------------------------------------------------------- }
            { File extension VGSM (report compile) otherwise files to copy           }
            { ---------------------------------------------------------------------- }

            file_ext = self.save_array[cnt,6]

            IF ( self.save_array[cnt,2] = C_STRUCTURE_TXT     )
            OR ( self.save_array[cnt,2] = C_COMPILE_VGSM      )
            OR ( self.save_array[cnt,2] = C_SMW_MENU          )
            OR ( self.save_array[cnt,2] = C_CRITERIA_CRT      )
            OR ( self.save_array[cnt,2] = C_DEFAULT_LAB       )
            OR ( self.save_array[cnt,2] = C_DOCUMENT_DOC      )
            OR ( self.save_array[cnt,2] = C_HELP_FILE         )
            OR ( self.save_array[cnt,2] = C_PRESENTATION_PPT  )
            OR ( self.save_array[cnt,2] = C_MTB_MENU          )
            OR ( self.save_array[cnt,2] = C_MESSAGE_TXT       ) THEN

                id_only = STRIP ( self.save_array[cnt,5] )
                retval  = self.package_copy_a_file ( id_only, fso, cnt, file_ext, a_logical, log_path, TRUE )


            ELSEIF ( file_ext <> EMPTY ) AND NOT BLANK ( self.save_array[cnt,2] ) THEN

                { ---------------------------------------------------------------------- }
                { Get all the same records from database that the csv saved              }
                { ---------------------------------------------------------------------- }

                CREATE OBJECT C_STD_OBJECT_DATABASE, tmpObj

                tmpObj.initialise ( self.save_array[cnt,2] )    { the table_name            }
                tmpObj.select ( self.save_array[cnt,13] )       { criteria_loaded_squirrel  }

                cnt2  = 1
                a_val = tmpObj.get_by_number ( cnt2 )

                WHILE ( a_val <> EMPTY ) AND ( retval ) DO

                    { ---------------------------------------------------------------------- }
                    { Some tables have compound or not identity, pick the files correctly    }
                    { ---------------------------------------------------------------------- }

                    IF ( self.package_build_key0 ( cnt, id_only, a_val, a_mode ) ) THEN

                        retval = self.package_copy_a_file ( id_only, fso, cnt, file_ext, a_logical, log_path, a_mode )


                    ENDIF

                    cnt2  = cnt2 + 1
                    a_val = tmpObj.get_by_number(cnt2)

                ENDWHILE

                tmpObj = EMPTY

            ENDIF {  file_ext is not empty }

        ENDIF  { array[x,5] is the logical for filenames }

        cnt = cnt + 1

    ENDWHILE

    fso = EMPTY

    RETURN ( retval )

ENDROUTINE   { packager_action_package_save_files }

{******************************************************************************}

ROUTINE packager_action_package_build_key0 (       self      ,
                                             VALUE cnt       ,
                                                   id_only   ,
                                                   a_val     ,
                                                   a_mode    )

    { ----------------------------------------------------------- }
    { Get first identity field - this is pointer to files         }
    { ----------------------------------------------------------- }

    DECLARE a_table,
                 a_key0

    ARRAY a_key0

    a_mode  = TRUE
    a_table = STRIP ( self.save_array[cnt,2] )

    GET_TABLE_DETAILS 'a_table', "KEY0_FIELD", a_key0

    id_only = STRIP ( SELECT 'self.save_array[cnt,2]'.'a_key0[1]' IN OBJECT a_val )

    IF ( a_table = "CRITERIA_SAVED" ) THEN

        a_table = STRIP ( SELECT 'self.save_array[cnt,2]'.TABLE_NAME IN OBJECT a_val )
        id_only = STRIP ( SELECT 'self.save_array[cnt,2]'.IDENTITY   IN OBJECT a_val )
        id_only = STRIP ( a_table ) : "_" : STRIP ( id_only ) : "_" : STRIP ( number_to_text ( LENGTH ( a_table ) , "99" ) )

    ELSEIF ( SIZE_OF_ARRAY ( a_key0 ) = 2 ) THEN

        id_only = id_only :"_" : STRIP ( SELECT 'self.save_array[cnt,2]'.'a_key0[2]' IN OBJECT a_val )

    ELSEIF ( SIZE_OF_ARRAY ( a_key0 ) = 3 ) THEN

        id_only = id_only :"_" : STRIP ( SELECT 'self.save_array[cnt,2]'.'a_key0[2]' IN OBJECT a_val ) : "_" :
             STRIP ( SELECT 'self.save_array[cnt,2]'.'a_key0[3]' IN OBJECT a_val )

    ELSEIF ( SIZE_OF_ARRAY ( a_key0 ) = 4 ) THEN

        id_only = id_only :"_" : STRIP ( SELECT 'self.save_array[cnt,2]'.'a_key0[2]' IN OBJECT a_val ) : "_" :
             STRIP ( SELECT 'self.save_array[cnt,2]'.'a_key0[3]' IN OBJECT a_val ) : "_" :
             STRIP ( SELECT 'self.save_array[cnt,2]'.'a_key0[4]' IN OBJECT a_val )

    ELSE

        a_mode = FALSE

    ENDIF

    RETURN ( TRUE )

ENDROUTINE  { packager_action_package_build_key0 }

{******************************************************************************}

ROUTINE packager_action_package_copy_a_file (       self      ,
                                                    id_only   ,
                                                    fso       ,
                                              VALUE cnt       ,
                                              VALUE file_ext  ,
                                              VALUE a_logical ,
                                              VALUE log_path  ,
                                              VALUE is_file   )

    DECLARE tmp    ,
                to_file

    { ------------------------------------------------------- }
    { To this install set location file ext may be blank      }
    { ------------------------------------------------------- }

    IF NOT BLANK ( self.save_array[cnt,11] ) THEN

        IF ( NOT BLANK ( file_ext ) ) THEN

            tmp     = log_path : id_only : "." : STRIP ( file_ext )
            to_file = STRIP ( self.install_set_dir   ) :"\":
                           STRIP ( self.key0_underscore   ) :"\":
                           STRIP ( self.save_array[cnt,8] ) :"\":
                           STRIP ( self.save_array[cnt,11]) :"\":
                           STRIP ( id_only                ) :".":
                           STRIP ( file_ext               )

        ELSE

            tmp     = log_path : id_only
            to_file = STRIP ( self.install_set_dir   ) :"\":
                           STRIP ( self.key0_underscore   ) :"\":
                           STRIP ( self.save_array[cnt,8] ) :"\":
                           STRIP ( self.save_array[cnt,11]) :"\":
                           STRIP ( id_only                )

        ENDIF

    ELSE

        IF ( NOT BLANK ( file_ext ) ) THEN

            tmp     = log_path : id_only : "." : STRIP ( file_ext )
            to_file = STRIP ( self.install_set_dir   ) :"\":
                           STRIP ( self.key0_underscore   ) :"\":
                           STRIP ( self.save_array[cnt,8] ) :"\":
                           STRIP ( id_only                ) :".":
                           STRIP ( file_ext               )

        ELSE

            tmp     = log_path : id_only
            to_file = STRIP ( self.install_set_dir   ) :"\":
                           STRIP ( self.key0_underscore   ) :"\":
                           STRIP ( self.save_array[cnt,8] ) :"\":
                           STRIP ( id_only                )

        ENDIF

    ENDIF

    { --------------------------------- }
    { And finally copy the file...      }
    { --------------------------------- }

    window_set_status ( tmp:to_file )

    IF ( FILE EXISTS ( tmp ) ) THEN

        retval = fso.CopyFile ( tmp, to_file )
        retval = ( retval = EMPTY )

    ELSEIF ( self.is_version_0_kit ) THEN

        to_file = C_VERSION_0_NO_FILE
        retval  = TRUE

    ELSEIF ( self.package_select_file ( a_logical, log_path, tmp, id_only, file_ext ) ) THEN

        retval = fso.CopyFile ( tmp, to_file )
        retval = ( retval = EMPTY )

    ELSE

        retval = FALSE

    ENDIF

    { -------------------------------------- }
    { Save each file copied for .smp summary }
    { -------------------------------------- }

    IF ( retval ) THEN

        IF ( is_file ) THEN

            tmp                       = SIZE_OF_ARRAY ( self.file_save_array) + 1
            self.file_save_array[tmp] = to_file

        ELSE

            tmp                      = SIZE_OF_ARRAY ( self.csv_save_array) + 1
            self.csv_save_array[tmp] = to_file

        ENDIF

    ENDIF  { retval }

    RETURN ( retval )

ENDROUTINE  { packager_action_package_copy_a_file  }

{******************************************************************************}

ROUTINE packager_action_package_select_file (       self      ,
                                              VALUE a_logical ,
                                              VALUE log_path  ,
                                                    full_path ,
                                              VALUE file_id   ,
                                              VALUE file_ext  )

    DECLARE files_array, cnt, file_2_array

    retval = TRUE

    ARRAY files_array
    ARRAY file_2_array

    { -------------------------------------------------------- }
    { Find will go through search path and get all matches     }
    { -------------------------------------------------------- }

    IF BLANK ( file_id ) THEN

        retval = FALSE

    ELSE

        FILE FIND a_logical:"\":file_id:".":file_ext, files_array, retval

        IF ( retval = EMPTY ) AND ( SIZE_OF_ARRAY ( files_array ) > 0 ) THEN

            cnt = 1

            WHILE ( files_array[cnt] <> EMPTY ) DO

                file_2_array[cnt,1] = files_array[cnt]
                file_2_array[cnt,2] = files_array[cnt]
                cnt                 = cnt + 1

            ENDWHILE

            { -------------------------------------------------------- }
            { Only have one to select from then use this one, else ask }
            { -------------------------------------------------------- }

            IF ( SIZE_OF_ARRAY ( file_2_array ) = 1 ) THEN

                full_path = file_2_array[1,1]
                retval    = TRUE

            ELSE

                retval = self.package_select_files_array ( a_logical, file_id, file_2_array, full_path )

            ENDIF

        ELSEIF ( self.is_version_0_kit ) THEN

            retval = TRUE

        ELSE

            { -------------------------------------------------------- }
            { Got no idea where to get it, so ask the user...          }
            { -------------------------------------------------------- }

            retval = self.package_select_1_file ( log_path, full_path, file_id, file_ext )

        ENDIF

    ENDIF  { blank file LTE is wrong }

    RETURN ( retval )

ENDROUTINE   { packager_action_package_select_file }

{******************************************************************************}

ROUTINE packager_action_package_select_files_array (       self        ,
                                                     VALUE a_logical   ,
                                                     VALUE file_id     ,
                                                           files_array ,
                                                           full_path   )


    DECLARE form, cs_prompt

    retval = FALSE

    PROMPT OBJECT form CLASS PROMPT_CLASS_FORM
        form.column           = 5
        form.row              = 5
        form.width            = 120
        form.height           = 1
        form.border           = TRUE
        form.header           = a_logical
        form.confirm_required = FALSE
        form.return_behaviour = FORM_RETURN_STAY
        form.proportional     = TRUE

    PROMPT OBJECT cs_prompt ON LINE 1 FROM 32 TO form.width CHOOSE OUT_OF files_array

    form.add_display ( PAD ( internal_translate_message ("LIT_LAB_SMP_MODULE_FILE"), " ",30),2,1,PROMPT_RENDITION_BOLD+PROMPT_RENDITION_RAISED )
    form.add_prompt ( cs_prompt  )
    form.add_frame ( file_id, 1, 1, 2, form.width - 1 )
    form.start_prompt()

    REPEAT

        form.wait_prompt()
        retval = form.get_lastkey() = "DO"

    UNTIL ( retval ) OR ( form.get_lastkey() = "EXIT" )

    form.end_prompt()

    { ---------------------------------------------------------- }
    { Set the actual filename that the user wants for the save   }
    { ---------------------------------------------------------- }

    IF ( NOT BLANK ( cs_prompt.value ) ) AND ( retval ) THEN
        full_path = cs_prompt.value
    ELSE
        retval = FALSE
    ENDIF

    RETURN ( retval )

ENDROUTINE   { packager_action_package_select_files_array }

{******************************************************************************}

ROUTINE packager_action_package_select_1_file (       self      ,
                                                VALUE log_path  ,
                                                      full_path ,
                                                VALUE file_id   ,
                                                VALUE file_ext  )


    DECLARE form, cs_prompt, dll_prompt

    retval = FALSE

    PROMPT OBJECT form CLASS PROMPT_CLASS_FORM
        form.column           = 10
        form.row              = 10
        form.width            = 100
        form.height           = 2
        form.border           = TRUE
        form.header           = file_id
        form.confirm_required = FALSE
        form.return_behaviour = FORM_RETURN_STAY
        form.proportional     = TRUE

    PROMPT OBJECT cs_prompt  ON LINE 1 FROM 32 TO 45 FORMAT 'C_SMP_MODULE_PROGRAM'.client_server
    PROMPT OBJECT dll_prompt ON LINE 2 FROM 32 BROWSE ON FILE

    cs_prompt.value                = TRUE
    cs_prompt.leave_prompt_routine = "internal_leave_cs_prompt"

    dll_prompt.file_directory  = full_path
    dll_prompt.file_extension  = file_ext
    dll_prompt.allow_multiple  = FALSE
    dll_prompt.format_only     = FALSE

    form.add_display ( PAD ( internal_translate_message ("LIT_LAB_SMP_MODULE_CLIENT_SERVER"), " ",30),2,1,PROMPT_RENDITION_BOLD+PROMPT_RENDITION_RAISED )
    form.add_display ( PAD ( internal_translate_message ("LIT_LAB_SMP_MODULE_SELECT_FILE"  ), " ",30),2,2,PROMPT_RENDITION_BOLD+PROMPT_RENDITION_RAISED )
    form.add_prompt ( cs_prompt  )
    form.add_prompt ( dll_prompt )
    form.add_frame ( log_path, 1, 1, 2, form.width - 1 )
    form.start_prompt()

    REPEAT

        form.wait_prompt()
        retval = form.get_lastkey() = "DO"

    UNTIL ( retval ) OR ( form.get_lastkey() = "EXIT" )

    form.end_prompt()

    { ---------------------------------------------------------- }
    { Set the actual filename that the user wants for the save   }
    { ---------------------------------------------------------- }

    IF ( NOT BLANK ( dll_prompt.value ) ) AND ( retval ) THEN
        full_path = dll_prompt.value
    ELSE
        retval = FALSE
    ENDIF

    RETURN ( retval )

ENDROUTINE   { packager_action_package_select_1_file }

{******************************************************************************}

ROUTINE internal_leave_cs_prompt ( self )

    self.parent_prompt.prompt_objects[2].client_file = self.parent_prompt.prompt_objects[1].value

ENDROUTINE   { internal_leave_cs_prompt }

{******************************************************************************}

ROUTINE packager_action_package_update_smp_file ( self )

    DECLARE status  ,
                cnt     ,
                fso     ,
                fsoFile ,
                tmp

    retval = FALSE
    status = ""

    CREATE OBJECT CLASS_STD_OLE_AUTOMATION_SERVER,fso
        fso.create("Scripting.FileSystemObject")

    { --------------------------------------------------- }
    { Delete any old "save sets" (anybody remember VMS?)  }
    { --------------------------------------------------- }

    IF ( FILE EXISTS ( self.install_set ) ) THEN

        FILE DELETE self.install_set, status

    ENDIF

    { --------------------------------------------------------------------- }
    { Saved all the data, now write the "summary" file (install_zip)        }
    { --------------------------------------------------------------------- }

    FILE CREATE self.install_set, status

    IF ( status = EMPTY ) THEN

        FILE EXTEND self.install_set, status

        IF ( status = EMPTY ) THEN

            FILE WRITE self.install_set, self.install_set : " " : NOW, status

            FILE WRITE self.install_set, C_SECTION_LINE, status
            FILE WRITE self.install_set, self.msg.07, status
            FILE WRITE self.install_set, C_SECTION_LINE, status

            IF ( status = EMPTY ) THEN

                { -------------------------------------------- }
                { First are all the csv files from table_saver }
                { -------------------------------------------- }

                cnt = 1

                WHILE ( self.save_array[cnt,1] <> EMPTY ) AND ( status = EMPTY ) DO

                    { ------------------------------------------------- }
                    { When element -1 it was a file and not saved data  }
                    { ------------------------------------------------- }

                    IF ( self.save_array[cnt,12] > -1 ) THEN           { no recs to load          }

                        tmp = STRIP ( self.save_array[cnt,14] )   { a file to get date       }

                        IF fso.FileExists ( tmp ) THEN

                            fsoFile = fso.GetFile(tmp)

                            IF ( fsoFile <> EMPTY ) THEN

                                tmp = tmp : C_TAB : internal_convert_fso_date ( fsoFile.DateCreated )

                            ENDIF

                        ENDIF

                        FILE WRITE self.install_set, tmp, status

                    ENDIF

                    cnt = cnt + 1

                ENDWHILE

                { -------------------------------------------- }
                { If no csv's then display msg saying so...    }
                { -------------------------------------------- }

                IF cnt = 1 THEN

                    FILE WRITE self.install_set, self.msg.08, status

                ENDIF

                { -------------------------------------------- }
                { Next are the dll's, .net and other stuff     }
                { -------------------------------------------- }

                FILE WRITE self.install_set, C_SECTION_LINE, status
                FILE WRITE self.install_set, self.msg.09, status
                FILE WRITE self.install_set, C_SECTION_LINE, status

                cnt = 1

                WHILE ( self.program_dll_array[cnt,1] <> EMPTY ) AND ( status = EMPTY ) DO

                    tmp = STRIP ( self.program_dll_array[cnt,6] )

                    IF fso.FileExists ( tmp ) THEN

                        fsoFile = fso.GetFile(tmp)

                        IF ( fsoFile <> EMPTY ) THEN
                            tmp = tmp : C_TAB : internal_convert_fso_date ( fsoFile.DateLastModified )
                        ENDIF

                    ENDIF

                    FILE WRITE self.install_set, tmp, status

                    cnt = cnt + 1

                ENDWHILE

                { -------------------------------------------- }
                { If no dll's then display msg saying so...    }
                { -------------------------------------------- }

                IF cnt = 1 THEN

                    FILE WRITE self.install_set, self.msg.06, status

                ENDIF

                { -------------------------------------------- }
                { Next the "files" with logicals (rpf etc)     }
                { -------------------------------------------- }

                FILE WRITE self.install_set, C_SECTION_LINE, status
                FILE WRITE self.install_set, self.msg.10, status
                FILE WRITE self.install_set, C_SECTION_LINE, status

                cnt = 1

                WHILE ( self.csv_save_array[cnt] <> EMPTY ) AND ( status = EMPTY ) DO

                    tmp = STRIP ( self.csv_save_array[cnt] )

                    IF fso.FileExists ( tmp ) THEN

                        fsoFile = fso.GetFile(tmp)

                        IF ( fsoFile <> EMPTY ) THEN
                            tmp = tmp : C_TAB : internal_convert_fso_date ( fsoFile.DateLastModified )
                        ENDIF

                    ENDIF

                    FILE WRITE self.install_set, tmp, status

                    cnt = cnt + 1

                ENDWHILE

                { -------------------------------------------- }
                { If no files/logicals display msg saying so...}
                { -------------------------------------------- }

                IF cnt = 1 THEN

                    FILE WRITE self.install_set, self.msg.08, status

                ENDIF

                { -------------------------------------------- }
                { Finally the "files" structure.doc.menu etc   }
                { -------------------------------------------- }

                FILE WRITE self.install_set, C_SECTION_LINE, status
                FILE WRITE self.install_set, self.msg.11, status
                FILE WRITE self.install_set, C_SECTION_LINE, status

                cnt = 1

                WHILE ( self.file_save_array[cnt] <> EMPTY ) AND ( status = EMPTY ) DO

                    tmp = STRIP ( self.file_save_array[cnt] )

                    IF fso.FileExists ( tmp ) THEN

                        fsoFile = fso.GetFile(tmp)

                        IF ( fsoFile <> EMPTY ) THEN
                            tmp = tmp : C_TAB : internal_convert_fso_date ( fsoFile.DateLastModified )
                        ENDIF

                    ENDIF

                    FILE WRITE self.install_set, tmp, status

                    cnt = cnt + 1

                ENDWHILE

                { -------------------------------------------- }
                { If no files/logicals display msg saying so...}
                { -------------------------------------------- }

                IF cnt = 1 THEN

                    FILE WRITE self.install_set, self.msg.16, status

                ENDIF


                { ------------------------------------ }
                { All done, final close of the file... }
                { ------------------------------------ }

                FILE WRITE self.install_set, C_SECTION_LINE, status
                FILE CLOSE self.install_set, status

                IF status = EMPTY THEN
                    retval = TRUE
                ENDIF

            ENDIF  { status empty first line written }

        ENDIF  { status empty file extend }

    ENDIF  { file create status empty }

    { --------------------------------------------------------------------- }
    { If some kinda issue then let the user know what happened.....         }
    { --------------------------------------------------------------------- }

    IF NOT retval THEN
        FLASH_MESSAGE ( self.msg.01:" ":status, TRUE )
    ENDIF

    RETURN ( retval )

ENDROUTINE   { packager_action_package_update_smp_file }

{******************************************************************************}

ROUTINE packager_action_package_create_cmd_zip ( self )

    DECLARE regfile  ,
                 logfile  ,
                 a_key    ,
                 a_exe_dir,
                 a_log_dir,
                 a_zip_id ,
                 a_semi   ,
                 a_spawn

    retval    = FALSE
    a_exe_dir = LOGICAL ( "SMP$PROGRAMS" )
    a_semi    = INDEX ( a_exe_dir, ";" )

    IF ( a_semi > 0 ) THEN

        a_exe_dir = LEFTSTRING ( a_exe_dir, a_semi - 1 )

    ENDIF

    a_log_dir = LOGICAL ( "SMP$TEXTREPORTS" )
    a_semi    = INDEX ( a_log_dir, ";" )

    IF ( a_semi > 0 ) THEN

        a_log_dir = LEFTSTRING ( a_log_dir, a_semi - 1 )

    ENDIF

    a_zip_id = a_exe_dir :"\": C_7ZA_EXE

    IF ( FILE EXISTS ( a_zip_id ) ) THEN

        regfile   = self.key0_underscore
        logfile   = STRIP(regfile)
        regfile   = a_log_dir : "\" : regfile : "_zip.BAT"

        FILE DELETE regfile, status
        FILE CREATE regfile, status
        FILE EXTEND regfile, status

        IF status = EMPTY THEN

            a_key = ASCII(34) : a_zip_id                 : ASCII(34) : C_7ZIP_ZIP_CREATE_CMD  :
                    ASCII(34) : self.install_set_zip_id  : ASCII(34) : " "                    :
                    ASCII(34) : self.install_set_kit_dir : "\*"      : ASCII(34)

            FILE WRITE regfile, a_key , status
            FILE WRITE regfile, "exit", status

            IF status = EMPTY THEN

                FILE CLOSE regfile, status

                IF status = EMPTY THEN

                    a_spawn = ASCII(34): regfile :ASCII(34) : " >> " : ASCII(34): STRIP (a_log_dir:"\":log_file):"_zip.log" :ASCII(34) : " 2>&1"

                    SPAWN "cmd /E:ON /D /A /C " : a_spawn, status QUIETLY

                    retval = ( status = EMPTY )

                    IF ( retval ) THEN

                        FILE DELETE regfile, status
                        FILE COPY    a_log_dir : "\" : logfile : "_zip.log", self.install_set_kit_dir : "\" : logfile : "_zip_create.log"
                        FILE DELETE  a_log_dir : "\" : logfile : "_zip.log", status

                    ENDIF

                ENDIF  { file close }

            ENDIF  { file write }

        ENDIF  { file extend }

    ENDIF   { file to zip with must exist }

    RETURN ( retval )

ENDROUTINE   { packager_action_package_create_cmd_zip }

{******************************************************************************}

ROUTINE packager_action_package_create_exe ( self )

    DECLARE regfile  ,
                 logfile  ,
                 a_key    ,
                 a_exe_dir,
                 a_log_dir,
                 a_zip_id ,
                 a_semi   ,
                 a_spawn

    retval    = FALSE
    a_exe_dir = LOGICAL ( "SMP$PROGRAMS" )
    a_semi    = INDEX ( a_exe_dir, ";" )

    IF ( a_semi > 0 ) THEN

        a_exe_dir = LEFTSTRING ( a_exe_dir, a_semi - 1 )

    ENDIF

    a_log_dir = LOGICAL ( "SMP$TEXTREPORTS" )
    a_semi    = INDEX ( a_log_dir, ";" )

    IF ( a_semi > 0 ) THEN

        a_log_dir = LEFTSTRING ( a_log_dir, a_semi - 1 )

    ENDIF

    a_zip_id = a_exe_dir :"\": C_7ZA_EXE

    IF ( FILE EXISTS ( a_zip_id ) ) THEN

        regfile   = self.key0_underscore
        logfile   = STRIP(regfile)
        regfile   = a_log_dir : "\" : regfile : ".BAT"

        FILE DELETE regfile, status
        FILE CREATE regfile, status
        FILE EXTEND regfile, status

        IF status = EMPTY THEN

            a_key = ASCII(34) : a_zip_id                 : ASCII(34) : C_7ZIP_SELF_EXTRACT_CMD :
                    ASCII(34) : self.install_set_sfx_id  : ASCII(34) : " ":
                    ASCII(34) : self.install_set_kit_dir : "\*" : ASCII(34)

            FILE WRITE regfile, a_key , status
            FILE WRITE regfile, "exit", status

            IF status = EMPTY THEN

                FILE CLOSE regfile, status

                IF status = EMPTY THEN

                    a_spawn = ASCII(34): regfile :ASCII(34) : " >> " : ASCII(34): STRIP (a_log_dir:"\":log_file):".log" :ASCII(34) : " 2>&1"

                    SPAWN "cmd /E:ON /D /A /C " : a_spawn, status QUIETLY

                    retval = ( status = EMPTY )

                    IF ( retval ) THEN

                        FILE DELETE regfile, status
                        FILE COPY   a_log_dir : "\" : logfile : ".log", self.install_set_kit_dir : "\" : logfile : "_extract_create.log"
                        FILE DELETE a_log_dir : "\" : logfile : ".log", status

                    ENDIF

                ENDIF  { file close }

            ENDIF  { file write }

        ENDIF  { file extend }

        { --------------------------------------------------------- }
        { Got the self extract, now make the zip file               }
        { --------------------------------------------------------- }

        retval = ( retval ) AND ( self.package_create_cmd_zip() )

    ENDIF  { file exists to zip with }

    RETURN ( retval )

ENDROUTINE   { packager_action_package_create_exe }

{******************************************************************************}

ROUTINE packager_action_package_update_dbase ( self )

    DECLARE a_cnt,
                a_rec

    START WRITE TRANSACTION C_PACKAGER_WRITE_TRANS

    ASSIGN 'C_SMP_MODULE'.INSTALL_SET          IN OBJECT self.module_record.current = self.install_set
    ASSIGN 'C_SMP_MODULE'.INSTALL_SET_ZIP_FILE IN OBJECT self.module_record.current = self.install_set_kit_dir:".":self.zip_type
    ASSIGN 'C_SMP_MODULE'.MODIFIED_ON          IN OBJECT self.module_record.current = NOW
    ASSIGN 'C_SMP_MODULE'.MODIFIED_BY          IN OBJECT self.module_record.current = OPERATOR
    ASSIGN 'C_SMP_MODULE'.DATE_INSTALLED       IN OBJECT self.module_record.current = ""
        ASSIGN 'C_SMP_MODULE'.DATE_REMOVED         IN OBJECT self.module_record.current = ""
        ASSIGN 'C_SMP_MODULE'.STRUCTURE_UPDATED    IN OBJECT self.module_record.current = FALSE
        ASSIGN 'C_SMP_MODULE'.MESSAGES_UPDATED     IN OBJECT self.module_record.current = FALSE
        ASSIGN 'C_SMP_MODULE'.SMW_MENU_UPDATED     IN OBJECT self.module_record.current = FALSE
        ASSIGN 'C_SMP_MODULE'.FILES_UPDATED        IN OBJECT self.module_record.current = FALSE
        ASSIGN 'C_SMP_MODULE'.STAGE_OF_INSTALL     IN OBJECT self.module_record.current = FALSE

    self.module_record.invoke_all( "UPDATE" )

    { --------------------------------------------------- }
    { Clear out the dll's moved if a rebuild of kit       }
    { --------------------------------------------------- }

    a_cnt = 1
    a_rec = self.dll_dbase.get_by_number(a_cnt)

    WHILE ( a_rec <> EMPTY ) DO

        ASSIGN 'self.dll_table'.module_install_ok IN OBJECT a_rec = FALSE

        a_cnt = a_cnt + 1
        a_rec = self.dll_dbase.get_by_number(a_cnt)

    ENDWHILE

    self.dll_dbase.invoke_all( "UPDATE" )

    { --------------------------------------------------- }
    { Clear out files moved if a rebuild of kit           }
    { --------------------------------------------------- }

    a_cnt = 1
    a_rec = self.criteria_dbase.get_by_number(a_cnt)

    WHILE ( a_rec <> EMPTY ) DO

        ASSIGN 'self.criteria_table'.no_files_moved     IN OBJECT a_rec = 0
        ASSIGN 'self.criteria_table'.no_records_loaded  IN OBJECT a_rec = 0
        ASSIGN 'self.criteria_table'.no_records_skipped IN OBJECT a_rec = 0
        ASSIGN 'self.criteria_table'.no_compiles        IN OBJECT a_rec = 0

        a_cnt = a_cnt + 1
        a_rec = self.criteria_dbase.get_by_number(a_cnt)

    ENDWHILE

    self.criteria_dbase.invoke_all( "UPDATE" )

    { --------------------------------------------------- }
    { Call the final trigger in case users want to update }
    { --------------------------------------------------- }

    self.call_trigger ( C_TRIGGER_BEFORE_BUILD_COMMIT )

    FLASH_MESSAGE ( self.msg.02 : self.install_set_kit_dir, TRUE )

    COMMIT

    self.module_record  = EMPTY
    self.dll_dbase      = EMPTY
    self.criteria_dbase = EMPTY

ENDROUTINE   { packager_action_package_update_dbase }

{******************************************************************************}

ROUTINE packager_action_call_trigger (       self   ,
                                       VALUE a_mode )

    DECLARE a_routine,
                 a_msg

    retval    = TRUE
    a_routine = SELECT REPORT.IDENTITY WHERE IDENTITY = C_TRIGGER_LIBRARY
    a_msg     = C_TRIGGER_LIBRARY

    IF ( a_routine <> EMPTY ) THEN

        a_routine = C_TRIGGER_BASE_ROUTINE : a_mode
        a_msg     = a_msg : "\" : a_routine

        IF ( VGL_VALIDATE_ROUTINE ( C_TRIGGER_LIBRARY, a_routine ) ) THEN

            CALL_ROUTINE C_TRIGGER_BASE_ROUTINE : a_mode IN LIBRARY C_TRIGGER_LIBRARY
            USING self, a_mode RETURNING retval

            IF ( retval = EMPTY ) OR ( VARIABLE_GET_TYPE ( retval ) <> "Boolean" ) THEN

                retval = TRUE

            ENDIF

            self.write_logfile ( self.msg.33 : a_msg : retval, "OK" )

        ENDIF  { does the routine in library exist }

    ENDIF   { is it in the report table }

    RETURN ( retval )

ENDROUTINE   { packager_action_call_Trigger }

{******************************************************************************}

ROUTINE packager_action_write_logfile (       self   ,
                                        VALUE a_msg  ,
                                        VALUE a_mode )

    FILE WRITE self.logfile, a_msg, status

ENDROUTINE  {  packager_action_write_logfile }

{******************************************************************************}

ROUTINE packager_action_close_logfile ( self )

    FILE WRITE self.logfile, "", status
    FILE CLOSE self.logfile, status

ENDROUTINE  {  packager_action_close_logfile }

{******************************************************************************}

ROUTINE packager_action_create_logfile ( self )

    FILE DELETE self.logfile, status
    FILE EXTEND self.logfile, status

    self.log_is_good = status = EMPTY

    IF ( self.log_is_good ) THEN

        FILE WRITE self.logfile, self.msg.52 : self.identity : " " : NOW, status
        FILE WRITE self.logfile, "", status

    ENDIF

ENDROUTINE  {  packager_action_create_logfile }

{******************************************************************************}
{                                                                              }
{                                                                              }
{                                                                              }
{                                                                              }
{                         ROUTINES USED BY THE INSTALLER                       }
{                                                                              }
{                                                                              }
{                                                                              }
{                                                                              }
{******************************************************************************}

GLOBAL ROUTINE internal_load_package ( VALUE a_id       ,
                                             a_obj      ,
                                       VALUE a_first    ,
                                       VALUE menu_check ,
                                       VALUE new_status )

    DECLARE a_dir     ,
                 a_new_id  ,
                 a_msg    ,
                 a_semi   ,
                 a_old

    a_old = GLOBAL ( "AUDIT_SUPPRESSION" )

    SET GLOBAL "AUDIT_SUPPRESSION" TO "ALL"

    retval   = FALSE
    a_new_id = internal_build_new_id ( a_id )
    a_msg    = internal_translate_message ( "LIT_LAB_SMP_MODULE_ERROR_KIT_NOT_EXIST" ) : a_id
    a_dir    = LOGICAL ( C_SMP_MODULE_INSTALL_SET_DIR )

    IF ( a_dir = C_SMP_MODULE_INSTALL_SET_DIR ) THEN

        a_dir  = LOGICAL ( "SMP$ROOT" )
        a_semi = INDEX ( a_dir, ";" )

        IF ( a_semi > 0 ) THEN

            a_dir = LEFTSTRING ( a_dir, a_semi - 1 )

        ENDIF

        a_dir = a_dir :"\": C_SMP_MODULE_INSTALL_DIR_VALUE : "\" : a_new_id

    ELSE

        a_dir = a_dir :"\": a_new_id
    ENDIF

    { ------------------------------------------------------------- }
    { Ultimately we have to have the expanded zip file on server    }
    { ------------------------------------------------------------- }

    IF ( FILE EXISTS ( a_dir ) ) THEN

        IF ( internal_create_packager_module ( a_dir, a_id, a_new_id, a_obj ) ) THEN

            { -------------------------------------------------------------------- }
            { Set key values for the structure and messages so we can skip stage   }
            { -------------------------------------------------------------------- }

            a_obj.module_record.initialise ( a_obj.module_record.table )
            a_obj.module_record.select_for_update ( a_obj.criteria_array )
            a_obj.module_record.set_first()
            a_obj.set_msg_translations()

            IF ( a_obj.module_record.current = EMPTY ) THEN

                EXIT

            ENDIF

            a_obj.csv_header_table    = SELECT 'C_SMP_MODULE'.IDENTITY           IN OBJECT a_obj.module_record.current
            a_obj.structure_updated   = SELECT 'C_SMP_MODULE'.STRUCTURE_UPDATED  IN OBJECT a_obj.module_record.current
            a_obj.messages_updated    = SELECT 'C_SMP_MODULE'.MESSAGES_UPDATED   IN OBJECT a_obj.module_record.current
            a_obj.smw_menu_updated    = SELECT 'C_SMP_MODULE'.SMW_MENU_UPDATED   IN OBJECT a_obj.module_record.current
            a_obj.files_updated       = SELECT 'C_SMP_MODULE'.FILES_UPDATED      IN OBJECT a_obj.module_record.current
            a_obj.stage_of_install    = SELECT 'C_SMP_MODULE'.STAGE_OF_INSTALL   IN OBJECT a_obj.module_record.current
            a_obj.criteria_versioned  = SELECT 'C_SMP_MODULE'.CRITERIA_VERSIONED IN OBJECT a_obj.module_record.current
            a_obj.menu_check          = menu_check
            a_obj.a_first             = ( a_first = "FIRST" ) OR ( INDEX ( a_id, "PACKAGER  " ) > 0 )
            a_obj.set_approval_status = new_status

            { --------------------------------------------------------------------- }
            { Get only the base table and no suffixes (-NV or -NC)                  }
            { --------------------------------------------------------------------- }

            a_semi = INDEX ( a_obj.csv_header_table, "-" )

            IF ( a_semi > 0 ) THEN

                a_obj.csv_header_table = LEFTSTRING ( a_obj.csv_header_table, a_semi - 1 )

            ENDIF

            { --------------------------------------------------------------------- }
            { A few special values for FIRST or IMPORT modes...                     }
            { --------------------------------------------------------------------- }

            IF (  a_obj.a_first ) THEN

                a_obj.structure_updated = TRUE
                a_obj.stage_of_install  = TRUE
                a_obj.messages_updated  = TRUE
                a_obj.files_updated     = FALSE

            ELSEIF ( STRIP ( a_obj.smp_version ) = "IMPORTGLB" ) OR ( STRIP ( a_obj.smp_version ) = "MIGRATE" ) THEN

                a_obj.is_export_set     = TRUE
                a_obj.structure_updated = TRUE
                a_obj.stage_of_install  = TRUE
                a_obj.messages_updated  = TRUE
                a_obj.smw_menu_updated  = TRUE
                a_obj.files_updated     = FALSE

                { --------------------------------------------------------------------- }
                { Must remove the "instance" from csv_header_table from IMPORT          }
                { --------------------------------------------------------------------- }

                a_obj.csv_header_table = STRIP ( a_obj.csv_header_table )
                a_semi                 = INDEX ( a_obj.csv_header_table, "_" )
                a_dir                  = STRINGLENGTH ( a_obj.csv_header_table )

                IF ( a_semi > 0 ) THEN

                    a_obj.csv_header_table = RIGHTSTRING ( a_obj.csv_header_table, a_dir - a_semi )

                ENDIF

            ENDIF  { this package is a staged install with the first stage (structure only) must be ran (or not) }

            { --------------------------------------------------------------------- }
            { Name logfile based upon mode of operation                             }
            { --------------------------------------------------------------------- }

            a_obj.logfile = a_obj.logfile : "\" : a_new_id : "\install_log_" : a_obj.install_date_time

            IF ( a_obj.menu_check ) THEN

                a_obj.logfile = a_obj.logfile : "_MENU_CHECK.txt"

            ELSEIF ( a_obj.a_first ) THEN

                a_obj.logfile = a_obj.logfile : "_FIRST.txt"

            ELSEIF ( a_obj.is_export_set ) THEN

                a_obj.logfile = a_obj.logfile : "_IMPORT.txt"

            ELSEIF ( NOT a_obj.stage_of_install ) THEN

                a_obj.logfile = a_obj.logfile : "_STAGE_INSTALL.txt"

            ELSE

                a_obj.logfile = a_obj.logfile : "_INSTALL.txt"

            ENDIF

            { -------------------------------------------------------------------- }
            { When interactive give user option to override all settings....       }
            { -------------------------------------------------------------------- }

            IF NOT ( a_obj.menu_check ) AND NOT ( a_obj.a_first ) AND NOT ( a_obj.is_export_set ) THEN

                a_obj.install_veto()

            ENDIF

            a_obj.create_logfile()

            { -------------------------------------------------------------------- }
            { Load all the data from the kit checking for errors along the way     }
            { -------------------------------------------------------------------- }

            IF ( a_obj.install_read_kit() ) THEN

                IF ( NOT a_obj.menu_check ) THEN

                    IF ( a_obj.install_file_stage() ) THEN

                        IF ( a_obj.install_dlls() ) THEN

                            IF ( a_obj.install_csv_files() ) THEN

                                IF ( a_obj.install_update_dbase() ) THEN

                                    retval = TRUE
                                    a_msg  = a_obj.msg.02 : a_id : " " : NOW

                                    a_obj.write_logfile ( a_msg, "OK" )
                                    a_obj.close_logfile()

                                    WriteToLog("FILE SEND ":a_obj.logfile:", DISPLAY/")
                                    FILE SEND a_obj.logfile, "DISPLAY/"

                                ELSE

                                    a_msg = a_obj.msg.18

                                ENDIF  { update database had issue }

                            ELSE
                                a_msg = a_obj.msg.19

                            ENDIF  { install csv had issue }

                        ELSE
                            a_msg = a_obj.msg.20

                        ENDIF  { install dll's had issue }

                    ELSE
                        a_msg = a_obj.msg.21

                    ENDIF  { install files had issue }

                ELSE

                    retval = a_obj.menu_check_main()

                ENDIF  { Menu check procedure numbers for collision prior to install }

            ELSE
                a_msg = a_obj.msg.22

            ENDIF   { read kit had issue }

            { ----------------------------------------------------------------------------- }
            { Write any error to logfile if things went wrong else call final trigger       }
            { ----------------------------------------------------------------------------- }

            IF NOT retval THEN

                a_obj.write_logfile(a_msg, "ERROR")
                FLASH_MESSAGE ( a_msg, TRUE )

            ELSEIF NOT ( a_obj.menu_check ) THEN

                retval = a_obj.call_trigger ( C_TRIGGER_INSTALL_COMPLETE )

            ENDIF

            a_obj.close_logfile()

        ENDIF   { create the packager object had issue }

    ELSE

        FLASH_MESSAGE ( a_msg, TRUE )

    ENDIF  { dir must exist }

    SET GLOBAL "AUDIT_SUPPRESSION" TO a_old

    RETURN ( retval )

ENDROUTINE   { internal_load_package }

{******************************************************************************}

ROUTINE packager_action_install_veto ( self  )

    DECLARE form         ,
                 p_structure  ,
                 p_message    ,
                 p_menu       ,
                 p_stage      ,
                 a_last       ,
                 struct_found ,
                 msg_found    ,
                 menu_found   ,
                 max_size

    { ------------------------------------------------------------------------------------------ }
    { Build the form and ask for the veto - set display only when no file found for stage....    }
    { ------------------------------------------------------------------------------------------ }

    max_size = find_max_number ( 30      , STRINGLENGTH ( STRIP ( self.msg.47 ) ) )
    max_size = find_max_number ( max_size, STRINGLENGTH ( STRIP ( self.msg.48 ) ) )
    max_size = find_max_number ( max_size, STRINGLENGTH ( STRIP ( self.msg.49 ) ) )
    max_size = find_max_number ( max_size, STRINGLENGTH ( STRIP ( self.msg.50 ) ) )

    self.install_veto_modes ( struct_found, msg_found, menu_found )

    CREATE OBJECT PROMPT_CLASS_FORM, form
        form.header           = internal_translate_message ( "LIT_LAB_SMP_MODULE_VETO_INSTALL" )
        form.row              = 5
        form.column           = 20
        form.height           = 4
        form.width            = max_size + 20
        form.return_behaviour = FORM_RETURN_STAY
        form.button_style     = FORM_BUTTON_OK_CANCEL

    PROMPT OBJECT p_structure ON LINE 1 FROM max_size TO form.width - 2 FORMAT SMP_MODULE.STRUCTURE_UPDATED
    PROMPT OBJECT p_message   ON LINE 2 FROM max_size TO form.width - 2 FORMAT SMP_MODULE.MESSAGES_UPDATED
    PROMPT OBJECT p_menu      ON LINE 3 FROM max_size TO form.width - 2 FORMAT SMP_MODULE.SMW_MENU_UPDATED
    PROMPT OBJECT p_stage     ON LINE 4 FROM max_size TO form.width - 2 FORMAT SMP_MODULE.STAGE_OF_INSTALL

    p_structure.display_only = NOT struct_found
    p_message.display_only   = NOT msg_found
    p_menu.display_only      = NOT msg_found
    p_stage.display_only     = p_structure.display_only

    form.add_display ( PAD ( self.msg.47, ".",max_size),2,1,PROMPT_RENDITION_BOLD+PROMPT_RENDITION_RAISED )
    form.add_display ( PAD ( self.msg.48, ".",max_size),2,2,PROMPT_RENDITION_BOLD+PROMPT_RENDITION_RAISED )
    form.add_display ( PAD ( self.msg.49, ".",max_size),2,3,PROMPT_RENDITION_BOLD+PROMPT_RENDITION_RAISED )
    form.add_display ( PAD ( self.msg.50, ".",max_size),2,4,PROMPT_RENDITION_BOLD+PROMPT_RENDITION_RAISED )

    form.add_prompt ( p_structure )
    form.add_prompt ( p_message   )
    form.add_prompt ( p_menu      )
    form.add_prompt ( p_stage     )

    form.start_prompt()
    form.wait_prompt()

    a_last = form.get_lastkey()

    form.end_prompt()

    IF ( a_last = "DO" ) THEN

        IF ( NOT p_structure.display_only ) THEN

            self.structure_updated = NOT p_structure.value

        ENDIF

        IF ( NOT p_message.display_only ) THEN

            self.messages_updated  = NOT p_message.value

        ENDIF

        IF ( NOT p_menu.display_only ) THEN

            self.smw_menu_updated  = NOT p_menu.value

        ENDIF

        IF ( NOT p_stage.display_only ) THEN

            self.stage_of_install  = p_stage.value

        ENDIF

    ENDIF


ENDROUTINE   { packager_action_install_veto }

{******************************************************************************}

ROUTINE packager_action_install_veto_modes ( self         ,
                                             struct_found ,
                                             msg_found    ,
                                             menu_found   )

    DECLARE a_array,
                 retval

    ARRAY a_array

    msg_found    = FALSE
    menu_found   = FALSE

    FILE FIND self.install_set_kit_dir:"\SMP_DATAFILES\*.TXT", a_array, retval

    struct_found = SIZE_OF_ARRAY ( a_array ) > 0

    FILE FIND self.install_set_kit_dir:"\SMP_MESSAGES\*.TXT", a_array, retval

    msg_found = SIZE_OF_ARRAY ( a_array ) > 0

    FILE FIND self.install_set_kit_dir:"\SMP_MESSAGES\*.MENU", a_array, retval

    menu_found = SIZE_OF_ARRAY ( a_array ) > 0

ENDROUTINE { packager_action_install_veto_modes }

{******************************************************************************}

ROUTINE packager_action_install_read_kit ( self  )

    DECLARE i         ,
                 i2        ,
                 i3        ,
                 i4        ,
                 tmp       ,
                 stlen     ,
                 is_client ,
                 is_server ,
                 find_array,
                 find_all  ,
                 a_logical

    retval   = TRUE
    find_all = FALSE

    ARRAY find_array

    { --------------------------------------------------------------------------- }
    { When staged install first only do message and structure                     }
    { --------------------------------------------------------------------------- }

    IF NOT ( self.stage_of_install ) THEN

        find_array[1] = "SMP_DATAFILES\*.TXT"
        find_array[2] = "SMP_MESSAGES\*.TXT"

    ELSEIF ( self.menu_check ) THEN

        find_array[1] = "SMP_USERFILES\*.LAB"   { all of these files get "rewritten" with new procedure numbers }
        find_array[2] = "SMP_MESSAGES\*.MENU"   { could have more than one smw menu to load..                   }
        find_array[3] = "SMP_MESSAGES\*.MTB"    { 9.2 way of doing menus                                        }
        find_array[4] = "MASTER_MENU_*.CSV"     { could have > 1 master menu file (some overwrite some append)  }

    ELSE

        find_array[1] = "*.*"                   { in this case we are really installing everything }
        find_all      = TRUE

    ENDIF   { staged install only does structure/message }

    { --------------------------------------------------------------------------- }
    { Read in all the files in the install kit directory / zip file               }
    { --------------------------------------------------------------------------- }

    i2 = 0
    i3 = 0
    i4 = 1

    WHILE ( find_array[i4] <> EMPTY ) DO

        FILE FIND self.install_set_kit_dir:"\":find_array[i4], self.save_array, retval

        IF ( retval = EMPTY ) AND ( SIZE_OF_ARRAY ( self.save_array ) > 0 ) THEN

            retval    = TRUE
            i         = 1
            a_logical = ""

            { --------------------------------------------------------------------------- }
            { Let's keep all the SMP$ logicals (subdirs) in an array so files get moved   }
            { --------------------------------------------------------------------------- }

            WHILE ( self.save_array[i] <> EMPTY ) AND ( retval ) DO

                self.save_array[i] = STRIP ( self.save_array[i] )
                tmp                = internal_file_name_only ( self.save_array[i] )
                stlen              = self.save_array[i]                                     { for debug set watch...                     }
                is_server          = INDEX ( TOLOWER ( self.save_array[i] ), C_SERVER_DIR ) { also for debug and testing                 }
                is_client          = INDEX ( TOLOWER ( self.save_array[i] ), C_CLIENT_DIR )

                { --------------------------------------------------------------------------- }
                { If we have a directory (no . in filename) then save this for making dir's   }
                { --------------------------------------------------------------------------- }

                IF ( INDEX ( self.save_array[i], "SMP_" ) > 0 ) AND ( INDEX ( tmp, "." ) = 0 ) THEN

                    i2                      = i2 + 1
                    stlen                   = STRINGLENGTH ( tmp )
                    self.subdir_array[i2,1] = internal_build_logical ( tmp )           { DECODED logical - could have multiple path }
                    self.subdir_array[i2,2] = i                                        { current count                              }
                    self.subdir_array[i2,3] = STRIP ( self.save_array[i] )             { full file id from kit                      }
                    self.subdir_array[i2,4] = "SMP$" : RIGHTSTRING ( tmp, stlen - 4 )  { the logical in smp$logical format          }
                    self.subdir_array[i2,5] = tmp                                      { last part of the full name                 }

                ELSEIF ( is_server > 0 ) OR ( is_client  > 0 ) THEN                         { <--- is a DLL                              }

                    i3                           = i3 + 1
                    self.program_dll_array[i3,1] = self.save_array[i]
                    self.program_dll_array[i3,2] = i
                    self.program_dll_array[i3,3] = "FOP"                                { hard code for SD }


                ELSEIF ( INDEX ( self.save_array[i], "SMP_" ) > 0 ) THEN                    { we are in staged install of structure...   }

                    IF NOT ( self.stage_of_install ) OR  ( self.menu_check ) THEN

                        a_logical               = ""
                        i2                      = i2 + 1
                        self.subdir_array[i2,1] = internal_build_logical_full ( self.save_array[i], a_logical )
                        self.subdir_array[i2,2] = i
                        self.subdir_array[i2,3] = STRIP ( self.save_array[i] )
                        self.subdir_array[i2,4] = a_logical
                        self.subdir_array[i2,5] = tmp

                    ENDIF

                ENDIF

                { ---------------------------------------------------------------------------- }
                { special mode for menu check - regenerating .menu, .lab, .csv, and .mtb files }
                { ---------------------------------------------------------------------------- }

                IF ( self.menu_check ) THEN

                    self.install_set_load_array ( "FILE", tmp, FALSE, self.subdir_array[i2,5], a_logical, self.save_array[i], "", "" )

                ENDIF

                i = i + 1

            ENDWHILE

        ELSEIF ( find_all ) THEN      { have to find something to install, structure/messages/menu are optional }

            retval         = CONFIRM_WITH_TEXT ( self.install_set_kit_dir:"\":find_array[i4] )
            self.error_msg = self.msg.04

        ELSE

            retval = TRUE

        ENDIF  { retval not empty or find files has no files }

        i4 = i4 + 1

    ENDWHILE    {  when structure.messages have 2, else all files in kit dir  }

    RETURN ( retval )

ENDROUTINE   { packager_action_install_read_kit }

{******************************************************************************}

ROUTINE packager_action_install_csv_files ( self  )

    DECLARE i       ,
                 tmp     ,
                 i2

    retval = TRUE
    i      = 1

    IF ( NOT self.stage_of_install ) THEN    { means STRUCTURE updated }

        self.write_logfile ( self.msg.39, "WARNING" )

    ELSE

        { --------------------------------------------------------------------------- }
        { Let's keep all the SMP$ logicals (subdirs) in an array so files get moved   }
        { --------------------------------------------------------------------------- }

        WHILE ( self.save_array[i] <> EMPTY ) AND ( retval ) DO

            self.save_array[i] = STRIP ( TOUPPER ( self.save_array[i] ) )
            tmp                = LEFTSTRING ( self.save_array[i], 4 )

            IF ( tmp = "SMP_"                                                )                    { a subdirectory }
            OR ( INDEX (           self.save_array[i]  , ".ZIP"        ) > 0 )                    { the zip file   }
            OR ( INDEX ( TOLOWER ( self.save_array[i] ), C_SERVER_DIR  ) > 0 )                    { dll for server }
            OR ( INDEX ( TOLOWER ( self.save_array[i] ), C_CLIENT_DIR  ) > 0 )                    { dll for client }
            OR ( INDEX (           self.save_array[i]  , ".CSV"        ) = 0 )                    { not data load  }
            OR ( INDEX (           self.save_array[i]  , ".LOG"        ) > 0 )                    { no LOGFILES    }
            OR ( INDEX (           self.save_array[i]  , ".SMP"        ) > 0 ) THEN               { date time file }

                window_set_status ( self.save_array[i] )                     { do nothing...  }

            ELSEIF ( INDEX ( TOLOWER ( self.save_array[i]), C_OK_SUFFIX   ) > 0 ) { already loaded }
            OR     ( INDEX ( TOLOWER ( self.save_array[i]), C_FAIL_SUFFIX ) > 0 ) { errors on load }

                IF ( CONFIRM_WITH_TEXT ( self.msg.51 ) ) THEN

                    retval = TRUE

                ELSE

                    self.error_msg = self.msg.23
                    self.write_logfile(self.error_msg, "ERROR")

                ENDIF

            ELSEIF ( self.is_export_set ) AND ( INDEX ( self.save_array[i], "\MLP_" ) > 0 ) THEN

                i2                     = SIZE_OF_ARRAY ( self.mlp_csv_array ) + 1
                self.mlp_csv_array[i2] = self.save_array[i]

            ELSE

                { ----------------------------------------------------- }
                { Using tableloader library load the file...            }
                { ----------------------------------------------------- }

                retval = self.install_1_csv ( self.save_array[i] )

                IF self.loaded_ok THEN

                    self.install_set_load_array ( "CSV", self.save_array[i], FALSE, "", "", self.save_array[i], self.csv_mode, self.a_table )

                ENDIF

                self.import_reset_counts()

            ENDIF  { not a CSV file }

            i = i + 1

        ENDWHILE  { all files from install kit }

        { ----------------------------------------------------- }
        { If we have MLP's then they must be loaded in order    }
        { ----------------------------------------------------- }

        self.csv_base_table = "MLP_HEADER"
        retval              = retval AND self.import_load_mlp()

        { ----------------------------------------------------- }
        { If everything went ok to here update date installed   }
        { ----------------------------------------------------- }

        IF ( retval ) THEN

            self.files_updated = TRUE

            { --------------------------------------------------------------------- }
            { SMW menu - let the user run the same interactive program from menu    }
            { --------------------------------------------------------------------- }

            IF  ( SIZE_OF_ARRAY ( self.load_menu_smw_array ) > 0 )
            AND ( NOT self.smw_menu_updated                      )
            AND ( NOT self.is_export_set                         ) THEN

                tmp = internal_translate_message ( "LIT_LAB_SMP_MODULE_SMW_MENU_EDIT" )

                IF ( CONFIRM_WITH_TEXT ( tmp ) ) THEN

                    self.install_import_smw_menu()

                ENDIF

            ENDIF

        ENDIF   { CSV updated ok }

    ENDIF   { phased install so skip this stage }

    RETURN ( retval )

ENDROUTINE   { packager_action_install_csv_files }

{******************************************************************************}

ROUTINE packager_action_install_1_csv (       self         ,
                                        VALUE a_file       )

    DECLARE cmd_rename

    { ---------------------------------------------------- }
    { Low level interface to table saver keep messages     }
    { ---------------------------------------------------- }

    retval          = FALSE
    cmd_rename      = "rename " : ASCII(34) : a_file : ASCII(34)
    self.fd_only    = internal_file_name_only ( a_file )
    self.loaded_ok  = FALSE
    self.csv_file   = a_file

    { ----------------------------------------------------- }
    { Set mode of the load from the filename                }
    { ----------------------------------------------------- }

    IF     ( INDEX ( a_file, "OVERWRITE" ) > 0 ) THEN

        self.csv_mode = "OVERWRITE"

    ELSEIF ( INDEX ( a_file, "ERASE" ) > 0 ) THEN

        self.csv_mode = "ERASE"

    ELSE

        self.csv_mode = "IGNORE"

    ENDIF

    { ----------------------------------------------------- }
    { Set the style for new version load and MLP entry code }
    { ----------------------------------------------------- }

    IF     ( INDEX ( a_file, "-NV"    ) > 0 ) THEN

        self.csv_new_version    = TRUE
        self.csv_new_entry_code = TRUE

    ELSEIF ( INDEX ( a_file, "-NC" ) > 0 ) THEN

        self.csv_new_entry_code = TRUE

    ENDIF

    window_set_status ( self.fd_only :" ": self.csv_mode )

    { ----------------------------------------------------------- }
    { The action that does the load of the data for a file        }
    { ----------------------------------------------------------- }
{fm(self.fd_only)}
    IF ( self.install_csv_load() )

        cmd_rename      = cmd_rename : " " : self.fd_only : C_OK_SUFFIX
        retval          = TRUE
        self.loaded_ok  = TRUE

        IF NOT ( self.is_export_set ) THEN

            self.write_logfile ( self.msg.12 :"(":self.fd_only:") [": STRIP(self.csv_load_count):" - ":STRIP(self.csv_ignore_count):"]", "OK" )
        WriteToLog(self.msg.12 :"(":self.fd_only:") [": STRIP(self.csv_load_count):" - ":STRIP(self.csv_ignore_count):"]")
        ENDIF

    ELSE

        self.error_msg = self.msg.21 : self.error_msg
        cmd_rename     = cmd_rename :" ": self.fd_only : C_FAIL_SUFFIX

        self.write_logfile ( self.error_msg, "ERROR")
        WriteToLog(self.error_msg)

    ENDIF  { action returned true }

    { ---------------------------------------------------- }
    { Load csv file renamed based upon success of load     }
    { ---------------------------------------------------- }

    lib_utils_spawn_with_log ( cmd_rename, LOGICAL ( "SMP$TEXTREPORTS" ) :"\":GLOBAL( "PROCESS_ID" ):".log" )

    RETURN ( retval )

ENDROUTINE  { packager_action_install_1_csv }

{******************************************************************************}

ROUTINE packager_action_install_csv_load ( self )

    DECLARE retval  ,
                 save_me

    retval  = FALSE
    save_me = GLOBAL ( "FORMAT_TEXT" )

    SET FORMAT      C_REAL_FORMAT
    SET DATE FORMAT C_DATE_FORMAT

    FILE OPEN self.csv_file, self.csv_return_msg

    WriteToLog("FILE OPEN  ":self.fd_only {self.csv_file:", ":self.csv_return_msg})
    IF (self.fd_only = "PROD_SCHED.CSV") OR (self.fd_only = "MLP_SCHEDULE.CSV") THEN
        retval = retval
    ENDIF
    IF ( self.csv_return_msg = EMPTY ) THEN

        IF ( self.install_csv_read_header() ) THEN

            GET_TABLE_DETAILS 'self.csv_table_to_load', "APPROVAL_STATUS", self.csv_approval_field
            GET_TABLE_DETAILS 'self.csv_table_to_load', "KEY0_FIELD"     , self.csv_key0_fields
            GET_TABLE_DETAILS 'self.csv_table_to_load', "VERSION_FIELD"  , self.csv_vers_field
            
            IF ( NOT BLANK ( self.csv_approval_field ) ) THEN

                self.install_csv_get_appr_fld_no()

            ENDIF

            retval = self.install_csv_load_data()

        ENDIF

    ELSE

        self.csv_error_msg = self.csv_file : self.csv_return_msg

    ENDIF  { error message from file open }

    FILE CLOSE self.csv_file, self.csv_return_msg
    WriteToLog("FILE CLOSE ":self.fd_only:ASCII(10) {self.csv_file:", ":self.csv_return_msg})

    RESTORE DATE FORMAT
    SET FORMAT save_me

    RETURN ( retval )

ENDROUTINE   { packager_action_install_csv_load }

{******************************************************************************}

ROUTINE packager_action_install_csv_read_header ( self )

    DECLARE retval

    retval = FALSE

    { ----------------------------------------------------------------------------------------- }
    { Read the first 4 lines of the csv file and validate each line against this system....     }
    { ----------------------------------------------------------------------------------------- }

    IF ( self.install_csv_read_1_line() ) THEN

        IF NOT VALID_TABLE ( STRIP ( self.csv_line ) ) THEN

            self.csv_error_msg = internal_translate_message ( "TABLE_LOADER_ILL_TBL_NAME" ) : self.csv_line

        ELSE

            self.csv_table_to_load = STRIP ( TOUPPER ( self.csv_line ) )

            IF NOT ( self.install_csv_read_1_line() ) THEN

                window_set_status ( self.csv_error_msg )

            ELSEIF NOT ( self.install_csv_valid_fields() ) THEN

                self.csv_error_msg = internal_translate_message ( "TABLE_LOADER_HEADER_CORR" ) : self.csv_file : self.csv_line : self.csv_line_count

            ELSEIF NOT ( self.install_csv_read_1_line() ) THEN

                window_set_status ( self.csv_error_msg )

            ELSEIF NOT ( self.install_csv_valid_lengths() ) THEN

                self.csv_error_msg = internal_translate_message ( "TABLE_LOADER_HEADER_CORR" ) : self.csv_file : self.csv_line : self.csv_line_count

            ELSEIF NOT ( self.install_csv_read_1_line() ) THEN

                window_set_status ( self.csv_error_msg )

            ELSEIF ( NUMERIC ( STRIP ( self.csv_line ) ) = ERROR ) THEN

                self.csv_error_msg = internal_translate_message ( "TABLE_LOADER_HEADER_CORR" ) : self.csv_file : self.csv_line : self.csv_line_count

            ELSE

                self.csv_no_to_load = NUMERIC ( self.csv_line )
                retval              = TRUE

            ENDIF   { no recs to load is really numeric... }

        ENDIF  { valid table read in line 1 and read status is empty }

    ENDIF  { read 1 line was ok }

    RETURN ( retval )

ENDROUTINE   { packager_action_install_read_csv_header }

{******************************************************************************}

ROUTINE packager_action_install_csv_get_appr_fld_no ( self )

    DECLARE a_cnt, found

    self.csv_appr_fld_no = 0
    found                = FALSE
    a_cnt                = 1

    WHILE ( self.csv_fields_array[a_cnt] <> EMPTY ) AND NOT ( found ) DO

        IF ( self.csv_fields_array[a_cnt] = self.csv_approval_field ) THEN

            self.csv_appr_fld_no = a_cnt
            found                = TRUE

        ENDIF

        a_cnt = a_cnt + 1

    ENDWHILE

ENDROUTINE   { packager_action_install_csv_get_appr_fld_no }

{******************************************************************************}

ROUTINE packager_action_install_csv_read_1_line ( self )

    DECLARE retval

    retval = TRUE

    FILE READ self.csv_file, self.csv_line, self.csv_return_msg

IF self.csv_return_msg = EMPTY THEN
    WriteToLog(self.csv_line)
ELSE
    {WriteToLog(self.csv_return_msg)}
ENDIF

    self.csv_line_count = self.csv_line_count + 1

    IF ( self.csv_return_msg <> EMPTY ) AND ( self.csv_return_msg = self.csv_EOF_msg ) THEN

        IF ( self.csv_no_to_load > self.csv_no_read ) THEN

            retval = confirm_with_text ( self.msg.51 : self.csv_table_to_load :" ": self.csv_file : " " : self.csv_no_to_load : "<>" : self.csv_no_read )

        ENDIF

    ELSEIF ( self.csv_return_msg <> EMPTY ) THEN

        self.csv_error_msg = internal_translate_message ( "LIT_PACKAGER_ERROR_READ_FILE" ) : self.csv_file : self.csv_line_count : self.csv_return_msg
        retval             = FALSE

    ENDIF

    RETURN ( retval )

ENDROUTINE  { packager_action_install_csv_read_1_line }

{******************************************************************************}

ROUTINE packager_action_install_csv_valid_fields ( self )

    DECLARE a_array ,
                 retval  ,
                 a_cnt

    retval = FALSE

    ARRAY a_array
    ARRAY self.csv_fields_array

    IF ( self.install_csv_line_2_array(a_array) ) THEN

        self.csv_fields_array = a_array
        a_cnt                 = SIZE_OF_ARRAY ( a_array )
        retval                = TRUE

        WHILE ( a_cnt >= 1 ) AND ( retval ) DO

            retval = VALID_FIELD ( self.csv_table_to_load, a_array[a_cnt] )

            IF ( STRIP ( a_array[a_cnt] = "PRODUCT_ID" ) ) OR ( STRIP ( a_array[a_cnt] = "IDENTITY" ) ) THEN

                self.ae_prod_id = a_cnt

            ELSEIF ( STRIP ( a_array[a_cnt] = "PRODUCT_VERSION" ) ) THEN

                self.ae_prod_vers = a_cnt

            ELSEIF ( STRIP ( a_array[a_cnt] = "ANALYSIS_ID" ) ) THEN

                self.ae_anal_id = a_cnt

            ELSEIF ( STRIP ( a_array[a_cnt] = "COMPONENT_NAME" ) ) THEN

                self.ae_comp_name = a_cnt

            ENDIF

            { ------------------------------------------------------------------ }
            { Super users confirm when fields are missing                        }
            { ------------------------------------------------------------------ }

            IF NOT ( retval ) THEN

                retval = CONFIRM_WITH_TEXT ( self.msg.53 : self.csv_table_to_load : " -> ":a_array[a_cnt] )  { field missing - happens when source system has diff structure for optional fields }

            ENDIF

            a_cnt  = a_cnt - 1

        ENDWHILE

    ENDIF   { convert line to array had an error.... }

    IF ( retval ) THEN

        IF ( self.csv_table_to_load = "MLP_VALUES" ) OR ( self.csv_table_to_load = "MLP_COMPONENTS" )  THEN

            retval = ( self.ae_prod_id <> 0 ) AND ( self.ae_prod_vers <> 0 ) AND ( self.ae_anal_id <> 0 ) AND ( self.ae_comp_name <> 0 )

        ELSEIF ( INDEX ( self.csv_table_to_load, "MLP_" ) > 0 ) THEN

            retval = ( self.ae_prod_id <> 0 ) AND ( self.ae_prod_vers <> 0 )

        ENDIF

        IF NOT ( retval ) THEN

            self.write_logfile ( self.msg.55, "*ERROR*" )

        ENDIF
    ENDIF

    RETURN ( retval )

ENDROUTINE   { packager_action_install_csv_valid_fields }

{******************************************************************************}

ROUTINE packager_action_install_csv_valid_lengths ( self )


    DECLARE a_array ,
                 retval  ,
                 a_cnt   ,
                 db_len  ,
                 db_type

    retval = FALSE

    ARRAY a_array
    ARRAY self.csv_field_length_array

    IF ( self.install_csv_line_2_array ( a_array ) ) THEN

        IF ( SIZE_OF_ARRAY ( self.csv_fields_array ) ) <> ( SIZE_OF_ARRAY ( a_array ) ) THEN

            self.csv_error_msg = internal_translate_message ( "LIT_PACKAGER_ERROR_CSV_LENGTHS" ) : self.csv_file : self.csv_line_count : self.csv_line
            retval             = CONFIRM_WITH_TEXT ( self.csv_error_msg )       { lengths for missing fields can be ok }

        ELSE

            retval = TRUE
            a_cnt  = 1

            { -------------------------------------------------------------------------------------- }
            { Valid fields were already veto'ed so if a missing field then it is ok...               }
            { -------------------------------------------------------------------------------------- }

            WHILE ( a_array[a_cnt] <> EMPTY ) AND ( retval ) DO

                IF NOT ( VALID_FIELD ( self.csv_table_to_load, self.csv_fields_array[a_cnt] ) ) THEN

                    window_set_status ( self.csv_table_to_load : self.csv_fields_array[a_cnt] )  { ** may want to write this to logfile ** }

                ELSE

                    GET_FIELD_DETAILS 'self.csv_table_to_load'.'self.csv_fields_array[a_cnt]', "FIELD_SIZE", db_len
                    GET_FIELD_DETAILS 'self.csv_table_to_load'.'self.csv_fields_array[a_cnt]', "DATA_TYPE" , db_type

                    a_array[a_cnt] = STRIP ( a_array[a_cnt] ) # ASCII(34)

                    IF NOT NUMTEXT ( a_array[a_cnt] ) THEN

                        retval             = FALSE
                        self.csv_error_msg = internal_translate_message ( "LIT_PACKAGER_ERROR_CSV_FIELDS" ) : self.csv_file : self.csv_line : a_cnt : a_array[a_cnt]

                    ELSE

                        a_array[a_cnt] = TRUNC ( NUMERIC ( a_array[a_cnt] ) )
                        retval         = ( db_len >= a_array[a_cnt] ) OR ( db_type = "Date" )

                        IF NOT retval THEN

                            retval = internal_translate_message ( "LIT_PACKAGER_CSV_FIELD_LENGTH" ) : self.csv_table_to_load :"_": self.csv_fields_array[a_cnt] : db_len :"<>": a_array[a_cnt]
                            retval = confirm_with_text ( retval )

                        ENDIF

                    ENDIF

                ENDIF   { valid field missing is ok ... }

                a_cnt  = a_cnt + 1

            ENDWHILE   { validate all fields in database are as big or bigger than the file to load's data }

            self.csv_field_length_array = a_array

        ENDIF

    ENDIF   { convert line to array had an error.... }

    RETURN ( retval )

ENDROUTINE   { packager_action_install_csv_valid_lengths }

{******************************************************************************}

ROUTINE packager_action_install_csv_line_2_array (       self    ,
                                                         a_array )

    DECLARE del_idx       ,
                 exit_now      ,
                 add_part      ,
                 st_val        ,
                 part          ,
                 a_cnt

    a_cnt              = 0
    st_val             = STRIP ( self.csv_line )
    retval             = TRUE
    self.csv_error_msg = internal_translate_message ("TABLE_LOADER_DATA_CORR") : self.csv_file : self.csv_line_count : self.csv_line

    { ------------------------------------------------------------- }
    { Parse the line into an array check as we go along for errors  }
    { ------------------------------------------------------------- }

    WHILE ( retval ) AND ( NOT BLANK ( st_val ) ) DO

        IF ( LEFTSTRING ( st_val , 1 ) = "," ) THEN

            st_val = st_val # ","

        ENDIF

        IF ( LEFTSTRING ( st_val , 1 ) = C_DELIMIT_CHAR ) THEN

            st_val  = st_val # C_DELIMIT_CHAR
            del_idx = INDEX ( st_val, C_DELIMIT_CHAR )

            IF ( del_idx = 0 ) THEN

                retval = FALSE

            ELSE

                part     = ""
                exit_now = FALSE

                WHILE ( NOT exit_now ) DO

                    add_part = LEFTSTRING ( st_val , del_idx - 1 )
                    part     = part : add_part
                    st_val   = STRIP ( st_val # ( add_part : C_DELIMIT_CHAR ) )

                    IF BLANK ( st_val ) THEN

                        exit_now = TRUE

                    ELSEIF ( LEFTSTRING ( st_val, 1 ) = "," ) THEN

                        exit_now = TRUE

                    ELSEIF ( LEFTSTRING ( st_val , 1 ) = C_DELIMIT_CHAR ) THEN

                        part   = part   : C_DELIMIT_CHAR
                        st_val = st_val # C_DELIMIT_CHAR

                    ELSE

                        retval   = FALSE
                        exit_now = TRUE

                    ENDIF

                    IF ( NOT exit_now ) THEN

                        del_idx = INDEX ( st_val,  C_DELIMIT_CHAR )

                        IF ( del_idx = 0 ) THEN

                            retval   = FALSE
                            exit_now = TRUE

                        ENDIF
                    ENDIF

                ENDWHILE   { exit now = stay in loop until got a full delimited value }

            ENDIF  { did not find a delimiter in remainder of the line }

        ELSE

            del_idx = INDEX ( st_val , "," )

            IF ( del_idx > 0 ) THEN

                part   = LEFTSTRING ( st_val , del_idx - 1 )
                st_val = st_val # part

            ELSE

                part   = STRIP ( st_val )
                st_val = ""

            ENDIF

        ENDIF  { first byte is not delimiter and the very last element of the line }

        { --------------------------------------------------------------- }
        { Keep all we did in the final array that the caller wants        }
        { --------------------------------------------------------------- }

        a_cnt          = a_cnt + 1
        a_array[a_cnt] = part

    ENDWHILE  { no errors and stuff still left on the line }

    RETURN ( retval )

ENDROUTINE   { packager_action_install_csv_line_2_array }

{******************************************************************************}

ROUTINE packager_action_install_csv_load_data ( self )

DECLARE retval, do_more
{fm("self.csv_file: ":self.csv_file)}

    do_more = TRUE
    retval  = TRUE

    { -------------------------------------------------------------------- }
    { Cleanout the table when erase, then do all rec's in csv file         }
    { -------------------------------------------------------------------- }

    IF ( self.install_csv_clean_table() ) THEN

        self.csv_no_read = 0

        WHILE ( retval ) AND ( do_more ) DO

            ARRAY self.csv_value_array

            IF ( self.install_csv_read_1_line() ) AND ( self.csv_return_msg <> self.csv_EOF_msg ) THEN

                IF ( self.install_csv_line_2_array(self.csv_value_array) ) THEN

                    self.csv_no_read = self.csv_no_read + 1

                    IF ( self.install_csv_reset_fields() )

                        retval = self.install_csv_write_1_record()

                    ENDIF

                ELSE

                    retval = FALSE

                ENDIF

            ELSEIF ( self.csv_return_msg = self.csv_EOF_msg ) THEN

                retval  = TRUE
                do_more = FALSE

            ELSE


                retval = FALSE

            ENDIF

            { ------------------------------------------------------------- }
            { If we were to do transaction size this is where it would work }
            { ------------------------------------------------------------- }

            IF ( retval ) THEN

                COMMIT

                IF do_more THEN

                    START WRITE TRANSACTION self.csv_file
                    retval = self.install_csv_lock_table()

                ENDIF

            ENDIF

        ENDWHILE   { read to end of the file }

    ELSE

        self.csv_error_msg = internal_translate_message ( "TABLE_LOADER_CANT_LOCK" ) : self.csv_table_to_load
        retval             = FALSE

    ENDIF   { clean table starts trans and gets rid of older data if need be }

    { ------------------------------------------------------ }
    { Do the final commit - is this really needed ?          }
    { ------------------------------------------------------ }

    IF ( NOT retval ) THEN
        ROLLBACK
    ELSE
        COMMIT
    ENDIF

    RETURN ( retval )

ENDROUTINE   { packager_action_install_csv_load_data }

{******************************************************************************}

ROUTINE packager_action_install_csv_reset_fields ( self )

    DECLARE reset_ok

    reset_ok = TRUE

    { ------------------------------------------------------------------------ }
    { Change data from the loaded csv based upon configuration items           }
    { ------------------------------------------------------------------------ }

    IF ( self.csv_new_entry_code ) THEN
        IF ( self.csv_table_to_load = "MLP_VALUES" ) THEN
            IF ( SIZE_OF_ARRAY ( self.version_array ) > 0 ) THEN
                self.install_read_version ( self.csv_value_array, self.version_array )
            ENDIF
            reset_ok = self.install_read_entry_code ( self.csv_value_array )
        ELSEIF ( self.csv_table_to_load = "MLP_HEADER" ) 
           OR  ( self.csv_table_to_load = "MLP_COMPONENTS" )  
           {OR  ( self.csv_table_to_load = "MLP_SCHEDULE" )} THEN
            internal_create_entry_code ( self.csv_value_array, self.csv_table_to_load )
        ENDIF
    ENDIF   { caller passes in auto_create_entry_code }

    IF ( self.csv_table_to_load = "PARM_SETUP_LINK_FIELDS" ) THEN

        {internal_create_new_identity ( self.csv_value_array, self.csv_table_to_load )}

    ENDIF

    IF ( reset_ok ) THEN
        { --------------------------------------------------------------------- }
        { Get the key0 values from the read record - may be changed below....   }
        { --------------------------------------------------------------------- }
        self.install_csv_get_key0()
        { --------------------------------------------------------------------- }
        { This has all the smarts to get a new version only one time for key0   }
        { --------------------------------------------------------------------- }
        IF ( self.csv_vers_field = EMPTY ) THEN
            GET_TABLE_DETAILS 'self.csv_base_table', "VERSION_FIELD", self.csv_vers_field
        ENDIF

        IF ( self.csv_new_version ) AND ( self.csv_vers_field <> EMPTY ) AND ( VALID_FIELD ( self.csv_table_to_load, self.csv_vers_field ) ) THEN
            IF ( STRIP ( self.csv_table_to_load ) = "MLP_LEVEL" ) OR ( STRIP ( self.csv_table_to_load ) = "MLP_VALUES" ) THEN
                { do nothing - these are special identity }
            ELSE
                IF ( self.csv_table_to_load = self.csv_base_table ) THEN
                    self.csv_base_key0 = self.csv_key0                 { ** use current key to find new version }
                ENDIF
                self.install_csv_create_version()                           { ***** this may reset the key           }
                IF ( self.csv_table_to_load = self.csv_base_table ) THEN
                    WriteTolog("csv_table_to_load: ":self.csv_table_to_load:"; Change csv_base_key0 from ":self.csv_base_key0:" to ":self.csv_key0)
{**************************************************************************************************************}
                    IF self.csv_table_to_load = "MLP_HEADER" THEN
                        DECLARE m, v, prod_id, prod_ver
                        GET_FIELD_DETAILS MLP_HEADER.IDENTITY, "FIELD_SIZE", m
                        prod_id = LEFTSTRING(self.csv_key0, m)
                        GET_FIELD_DETAILS MLP_HEADER.PRODUCT_VERSION, "FIELD_SIZE", v
                        prod_ver = RIGHTSTRING(self.csv_key0, v)
                        WriteToLog("insert_iu('UPDATE', 'UPDATE_MLP', ":prod_id:", ":prod_ver:")")
                        insert_iu("UPDATE", "UPDATE_MLP", prod_id, prod_ver) 
                    ENDIF 
{***************************************************************************************************************}
                    self.csv_base_key0 = self.csv_key0                 { ** save the reset key                  }
                ENDIF
            ENDIF
        ENDIF  { only do new version on table/fields that have new version.... }
        { ------------------------------------------------------------------------ }
        { Change the approval status to parameter passed from master menu          }
        { ------------------------------------------------------------------------ }
        IF NOT BLANK ( self.set_approval_status ) AND ( self.csv_appr_fld_no > 0 ) THEN
            self.csv_value_array[self.csv_appr_fld_no] = self.set_approval_status
        ENDIF
        { --------------------------------------------------------------------- }
        { Finally do all the keys for dynamic data using previous tables loaded }
        { --------------------------------------------------------------------- }
        IF     ( self.csv_table_to_load = "LOT_HEADER"            ) THEN
        ELSEIF ( self.csv_table_to_load = "LOT_DETAILS"           ) THEN
        ELSEIF ( self.csv_table_to_load = "JOB_HEADER"            ) THEN
        ELSEIF ( self.csv_table_to_load = "SAMPLE"                ) THEN
        ELSEIF ( self.csv_table_to_load = "TEST"                  ) THEN
        ELSEIF ( self.csv_table_to_load = "RESULT"                ) THEN
        ELSEIF ( self.csv_table_to_load = "AUDIT_DATA"            ) THEN
        ELSEIF ( self.csv_table_to_load = "AUDIT_EVENT"           ) THEN
        ELSEIF ( self.csv_table_to_load = "AUDIT_TRANSACTION"     ) THEN
        ELSEIF ( self.csv_table_to_load = "ESIG_DATA"             ) THEN
        ELSEIF ( self.csv_table_to_load = "ESIG_EVENT"            ) THEN
        ELSEIF ( self.csv_table_to_load = "INCIDENTS"             ) THEN
        ELSEIF ( self.csv_table_to_load = "INC_CHECKLIST_RESULTS" ) THEN
        ENDIF
    ENDIF   { reset_ok }
    RETURN ( reset_ok )
ENDROUTINE  { packager_action_install_csv_reset_fields }

{******************************************************************************}

ROUTINE packager_action_install_csv_clean_table ( self )

    DECLARE retval

    START WRITE TRANSACTION self.csv_file

    retval = self.install_csv_lock_table()

    IF ( self.csv_mode = "ERASE" ) THEN

        execute_sql ( "DELETE FROM " : self.csv_table_to_load )

        COMMIT

        START WRITE TRANSACTION self.csv_file

        retval = self.install_csv_lock_table()

    ENDIF

    RETURN ( retval )

ENDROUTINE  { packager_action_install_csv_clean_table }

{******************************************************************************}

ROUTINE packager_action_install_csv_lock_table ( self )

    DECLARE table_array ,
                 retval      ,
                 retry_count

    ARRAY table_array ARRAYSIZE ( 1 )

    retval         = FALSE
    retry_count    = 0
    table_array[1] = self.csv_table_to_load

    IF ( lock_tables ( table_array ) ) THEN

        retval = TRUE

    ELSE

        WHILE ( NOT retval ) AND ( retry_count < C_CSV_LOAD_LOCK_RETRY ) DO

            window_set_status ( C_CSV_INTERVAL_SLEEP : self.csv_table_to_load )

            SLEEP FOR C_CSV_INTERVAL_SLEEP

            retval      = lock_tables ( table_array )
            retry_count = retry_count + 1

        ENDWHILE

        IF ( NOT retval ) THEN

            self.csv_error_msg = internal_translate_message ( "TABLE_LOADER_CANT_LOCK" ) : self.csv_table_to_load
            retval             = CONFIRM_WITH_TEXT ( self.error_msg )

        ENDIF

    ENDIF

    RETURN ( retval )

ENDROUTINE  { packager_action_install_csv_lock_table }

{******************************************************************************}

ROUTINE packager_action_install_csv_write_1_record ( self )

    DECLARE retval         ,
                 lock_check     ,
                 tmp

    retval        = TRUE
    self.csv_skip = TRUE

    { --------------------------------------------------------------------- }
    { Based upon load mode record is made or updated or skipped             }
    { --------------------------------------------------------------------- }

    IF ( self.install_csv_veto_load() ) THEN

        self.csv_skip = FALSE

        RESERVE ENTRY 'self.csv_table_to_load', self.csv_key0, self.csv_error_msg

        IF ( self.csv_error_msg <> EMPTY ) THEN

            IF ( self.csv_mode = "OVERWRITE" ) AND ( self.csv_error_msg = GET_USER_MESSAGE( "DB_ID_EXISTS", 1 ) ) THEN

                ARRAY_SELECT ( self.csv_table_to_load, TRUE, self.csv_key0_select_array )

                lock_check = SELECT 'self.csv_table_to_load'.'self.csv_key0_fields[1]' FOR UPDATE

                IF ( lock_check = LOCKED ) THEN

                    retval             = FALSE
                    self.csv_error_msg = "*LOCKED* " : self.csv_table_to_load : self.csv_key0

                ENDIF

            ELSEIF ( self.csv_mode = "IGNORE" ) THEN

                self.csv_skip = TRUE

            ELSE

                retval             = FALSE
                self.csv_error_msg = "*ERROR* " : self.csv_table_to_load : self.csv_key0 : self.csv_error_msg

            ENDIF

        ENDIF

        { ------------------------------------------------------------------------------------- }
        { If still no error then assign all the other fields on this single record              }
        { ------------------------------------------------------------------------------------- }

        IF ( NOT self.csv_skip ) AND ( retval ) THEN

            self.install_csv_assign_fields()

            UPDATE 'self.csv_table_to_load'

            self.csv_load_count = self.csv_load_count + 1

            window_set_status ( self.csv_table_to_load : self.csv_load_count )

        ELSEIF ( retval ) THEN
{
            self.csv_show_key     = C_SKIP_PREFIX : self.csv_show_key
            self.csv_ignore_count = self.csv_ignore_count + 1

            window_set_status ( self.csv_table_to_load : self.csv_ignore_count )
}
        ELSE

            self.csv_show_key = self.csv_show_key : self.csv_error_msg

        ENDIF

    ELSE

        self.csv_show_key   = C_VETO_PREFIX : self.csv_show_key
        self.csv_skip_count = self.csv_skip_count + 1

        window_set_status ( self.csv_table_to_load : self.csv_skip_count )

    ENDIF  { continue_load action off of caller object }

    { -------------------------------------------------------- }
    { Write which way we did things to the load logfile        }
    { -------------------------------------------------------- }

    IF ( self.logfile <> EMPTY ) THEN

        FILE WRITE self.logfile, self.csv_show_key, tmp

    ENDIF

    RETURN ( retval )

ENDROUTINE  { packager_action_install_csv_write_1_record }

{******************************************************************************}

ROUTINE packager_action_install_csv_get_key0 ( self )

    DECLARE a_cnt   ,
                 tmp     ,
                 a_type  ,
                 a_size  ,
                 aray_sz ,
                 ndex

    { ---------------------------------------------------------------- }
    { Build the key0 from these values - VERSION FIELD NAME MUST MATCH }
    { ---------------------------------------------------------------- }

    ARRAY self.csv_key0_select_array
    ARRAY self.csv_key0_val_array

    aray_sz       = SIZE_OF_ARRAY ( self.csv_key0_fields )
    self.csv_key0 = ""
    a_cnt         = 1

    WHILE ( a_cnt <= aray_sz )

        GET_FIELD_DETAILS 'self.csv_table_to_load'.'self.csv_key0_fields[a_cnt]', "DATA_TYPE" , a_type
        GET_FIELD_DETAILS 'self.csv_table_to_load'.'self.csv_key0_fields[a_cnt]', "FIELD_SIZE", a_size

        IF ( internal_array_slice ( self.csv_fields_array, self.csv_key0_fields[a_cnt], ndex ) ) THEN

            IF  ( self.csv_key0_fields[a_cnt] = self.csv_vers_field ) THEN

                self.csv_vers_field_no = ndex

            ENDIF

            IF ( a_type = "Packed decimal" ) THEN

                tmp                            = PACKED_DECIMAL ( self.csv_value_array[ndex] )
                self.csv_key0_val_array[a_cnt] = tmp

            ELSE

                FORMAT tmp FROM self.csv_value_array[ndex] USING 'self.csv_table_to_load'.'self.csv_key0_fields[a_cnt]'

                self.csv_key0_val_array[a_cnt] = PAD ( tmp, " ", a_size )

            ENDIF

            self.csv_key0 = self.csv_key0 : self.csv_key0_val_array[a_cnt]

            { ---------------------------------------------------------------- }
            { While we are at it, save the select array for later use....      }
            { ---------------------------------------------------------------- }

            IF ( SIZE_OF_ARRAY ( self.csv_key0_select_array ) > 0 ) THEN

                array_select_add ( self.csv_key0_select_array, ARRAY_SELECT_AND, EMPTY, EMPTY )

            ENDIF

            array_select_add ( self.csv_key0_select_array, ARRAY_SELECT_EQ, self.csv_key0_fields[a_cnt], self.csv_key0_val_array[a_cnt] )

        ELSE

            FLASH_MESSAGE ( "** SYSTEM ERROR ** MISSION IMPOSSIBLE " : self.csv_key0_fields[a_cnt], TRUE )
            EXIT

        ENDIF

        a_cnt = a_cnt + 1

    ENDWHILE

    { --------------------------------------------------------------------- }
    { Save table and key0 for output to reports.logfiles etc...             }
    { --------------------------------------------------------------------- }

    self.csv_show_key = C_SHOW_PREFIX : PAD ( self.csv_table_to_load, " ", 30 ) : " -> " : self.csv_key0

    IF ( self.csv_table_to_load = "MLP_VALUES" ) THEN

        self.csv_show_key = self.csv_show_key : self.csv_value_array[self.ae_anal_id] : self.csv_value_array[self.ae_comp_name]

    ENDIF

ENDROUTINE   {  packager_action_install_csv_get_key0 }

{******************************************************************************}

ROUTINE packager_action_install_csv_assign_fields ( self )

    DECLARE a_cnt     ,
                 a_field   ,
                 a_type    ,
                 a_key0    ,
                 a_size    ,
                 a_value   ,
                 this_type ,
                 a_field_type ,
                 a_ok

    a_cnt = 1

    WHILE ( self.csv_fields_array[a_cnt] <> EMPTY ) DO

        a_field = self.csv_fields_array[a_cnt]

        IF ( VALID_FIELD ( self.csv_table_to_load, a_field ) ) THEN

            GET_FIELD_DETAILS 'self.csv_table_to_load'.'a_field', "DATA_TYPE" , a_type
            GET_FIELD_DETAILS 'self.csv_table_to_load'.'a_field', "KEY0_FIELD", a_key0
            GET_FIELD_DETAILS 'self.csv_table_to_load'.'a_field', "FIELD_SIZE", a_size

            a_value   = STRIP ( self.csv_value_array [ a_cnt ] )
            this_type = VARIABLE_GET_TYPE ( a_value )

            IF ( a_key0 ) THEN

                a_ok = FALSE

            ELSEIF ( this_type = a_type ) THEN

                a_ok = TRUE

            ELSEIF ( a_type = "Integer" ) AND ( NUMTEXT ( a_value ) ) THEN

                a_ok = TRUE

            ELSEIF ( a_type = "Real" ) AND ( NUMTEXT ( a_value ) ) THEN

                a_ok = TRUE

            ELSEIF ( a_type = "Boolean" ) AND ( ( a_value = TRUE ) OR ( a_value = FALSE ) ) THEN

                a_ok = TRUE

            ELSEIF ( a_type = "Interval" ) AND ( IS_INTERVAL ( a_value ) ) THEN

                a_ok = TRUE

            ELSEIF ( a_type = "Packed decimal" ) AND ( NUMTEXT ( a_value ) ) THEN

                a_ok = TRUE

                self.csv_value_array [ a_cnt ] = JUSTIFY(PAD(self.csv_value_array [ a_cnt ]," ",a_size),"RIGHT")

            ELSEIF ( a_type = "Date" ) AND ( ( a_value = NULL ) OR ( IS_DATE ( a_value ) ) ) THEN

                a_ok = TRUE

            ELSEIF ( a_value = NULL ) THEN

                a_ok = TRUE

            ELSE

                a_msg = STRIP ( self.csv_table_to_load ) :".": STRIP (a_field) :" ": STRIP ( this_type ) :" ": STRIP (a_type) :"=[":  STRIP (a_value):"]"
                a_ok  = confirm_with_text ( a_msg )

            ENDIF

            { ---------------------------------------------------------------------- }
            { If all checks say data is ok then load and coerce as appropriate       }
            { ---------------------------------------------------------------------- }

            IF a_ok THEN

                GET_FIELD_DETAILS 'self.csv_table_to_load'.'a_field', "DATA_TYPE", a_field_type

                IF ( TOUPPER ( a_field_type) = "DATE" ) THEN
                    IF ( IS_DATE ( a_value ) ) THEN
                        a_value = DATE ( a_value )
                    ELSE
                        a_value = ""
                    ENDIF
                ENDIF

                ASSIGN 'self.csv_table_to_load'.'a_field' = a_value

            ELSE

                { *** may want to write something to logfile.... }

            ENDIF

        ELSE

            { ----------------------------------------------------------------------------------------------- }
            { ------  Not a valid field (or is key0 field) on the target database, ignore value from csv file }
            { ----------------------------------------------------------------------------------------------- }

            { *** may want to write something to logfile.... }

        ENDIF

        a_cnt = a_cnt + 1

    ENDWHILE   { count of all fields on the table }

ENDROUTINE   {  packager_action_install_csv_assign_fields }

{******************************************************************************}

ROUTINE packager_action_install_csv_create_version ( self )

    DECLARE ndex, new_version, cnt {,dynamic_sql, field}

    { ---------------------------------------------------------------- }
    { Either get a new version or read one already obtained...         }
    { ---------------------------------------------------------------- }

    IF ( internal_array_version ( self.version_array, self.csv_base_key0, ndex, self.csv_base_table ) ) THEN

        self.csv_key0_val_array[self.csv_vers_field_no] = self.version_array[ndex,2]

    ELSE

        { ---------------------------------------------------------------- }
        { Select on all but the version field                              }
        { ---------------------------------------------------------------- }

        cnt = SIZE_OF_ARRAY ( self.csv_key0_fields )

{BLOCK created by CONSULT-02 to select correct version from table.}
{WriteToLog("self.csv_base_table: ":self.csv_base_table)}
        IF self.csv_table_to_load = "PARM_SETUP" THEN
            new_version = SELECT max_active_mlp_ver . max_version WHERE identity = self.csv_key0_val_array[1]
            IF new_version = EMPTY THEN
                new_version = SELECT max_active_anal_ver . max_version WHERE identity = self.csv_key0_val_array[1]
            ENDIF
{            WriteToLog("New version, PARM_SETUP    : ":STRIP(self.csv_key0_val_array[1]):"/":STRIP(new_version))}
{        ELSEIF self.csv_table_to_load = "PARM_SETUP" THEN
            self.csv_key0_val_array[4] = JUSTIFY(PAD(self.csv_key0_val_array[4]," ",10),"RIGHT")
            CREATE OBJECT "STD_DYNAMIC_SQL" , dynamic_sql
            dynamic_sql . add_to_sql_statement ( "SELECT MAX(IDENTITY_VERSION) " )
            dynamic_sql . add_to_sql_statement ( "FROM PARM_SETUP" )
            dynamic_sql . add_to_sql_statement ( " WHERE TRIM(":STRIP(self.csv_key0_fields[1]):") = '": STRIP(self.csv_key0_val_array[1]) :"'" )
            dynamic_sql . add_to_sql_statement ( " AND TRIM(":STRIP(self.csv_key0_fields[3]):") = '": STRIP(self.csv_key0_val_array[3]) :"'" )
            dynamic_sql . add_to_sql_statement ( " AND TRIM(":STRIP(self.csv_key0_fields[4]):") = '": STRIP(self.csv_key0_val_array[4]) :"'" )
            field = dynamic_sql . add_select_field  ("PARM_SETUP", "IDENTITY_VERSION")
            dynamic_sql . execute ()
            new_version = dynamic_sql . select ( 1 )
            dynamic_sql . next ()}
        ELSEIF self.csv_table_to_load = "PROD_SCHED" THEN
            new_version = SELECT max_active_mlp_ver . max_version WHERE identity = self.csv_key0_val_array[1]
{            WriteToLog("New version, PROD_SCHED    : ":STRIP(self.csv_key0_val_array[1]):"/":STRIP(new_version))}
        ELSEIF self.csv_table_to_load = "MLP_COMPONENTS" THEN
            new_version = SELECT max_active_mlp_ver . max_version WHERE identity = self.csv_key0_val_array[1]
{            WriteToLog("New version, MLP_COMPONENTS: ":STRIP(self.csv_key0_val_array[1]):"/":STRIP(new_version))}
        ELSEIF self.csv_table_to_load = "MLP_SCHEDULE" THEN
            new_version = SELECT max_active_mlp_ver . max_version WHERE identity = self.csv_key0_val_array[1]
{            WriteToLog("New version, MLP_SCHEDULE  : ":STRIP(self.csv_key0_val_array[1]):"/":STRIP(new_version))}
        ELSEIF self.csv_table_to_load = "VERSIONED_COMPONENT" THEN
            new_version = SELECT max_active_anal_ver . max_version WHERE identity = self.csv_key0_val_array[1]
        ELSEIF self.csv_table_to_load = "VERSIONED_ANALYSIS_STOCK_USE" THEN
            new_version = SELECT max_active_anal_ver . max_version WHERE identity = self.csv_key0_val_array[1]
{END BLOCK created by CONSULT-02 to select correct version from table.}
        ELSEIF ( cnt = 2 ) THEN

            new_version = SELECT MAX 'self.csv_table_to_load'.'self.csv_key0_fields[2]'
                          WHERE 'self.csv_key0_fields[1]' = self.csv_key0_val_array[1]

        ELSEIF ( cnt = 3 ) THEN


               new_version = SELECT MAX 'self.csv_table_to_load'.'self.csv_key0_fields[2]'
                             WHERE 'self.csv_key0_fields[1]' = self.csv_key0_val_array[1]
                             AND   'self.csv_key0_fields[3]' = self.csv_key0_val_array[3]

        ELSEIF ( cnt = 4 ) THEN

                new_version = SELECT MAX 'self.csv_table_to_load'.'self.csv_key0_fields[2]'
                              WHERE 'self.csv_key0_fields[1]' = self.csv_key0_val_array[1]
                              AND   'self.csv_key0_fields[3]' = self.csv_key0_val_array[3]
                              AND   'self.csv_key0_fields[4]' = self.csv_key0_val_array[4]
        ELSE

            FLASH_MESSAGE ( "LIT_LAB_SMP_MODULE_KEY0_TOO_BIG", TRUE )
            EXIT

        ENDIF




        { ------------------------------------------------------------------- }
        { Increment to next or make one if not found at all                   }
        { ------------------------------------------------------------------- }

        IF ( new_version = EMPTY ) OR ( new_version = NULL ) THEN

            new_version = PACKED_DECIMAL ( 1 )

        ELSE

            IF NUMTEXT ( new_version ) THEN

                new_version = PACKED_DECIMAL ( new_version + 1 )

            ELSE

                new_version = PACKED_DECIMAL ( 1 )

            ENDIF

        ENDIF

        ndex                       = SIZE_OF_ARRAY ( self.version_array ) + 1
        self.version_array[ndex,1] = self.csv_key0
        self.version_array[ndex,2] = new_version
        self.version_array[ndex,3] = self.csv_table_to_load
        self.version_array[ndex,4] = FALSE
        self.version_array[ndex,5] = FALSE
        self.version_array[ndex,6] = self.csv_base_table
        self.version_array[ndex,7] = self.csv_base_key0

        self.csv_key0_val_array[2] = new_version              { **** VERSION FIELD MUST ALWAYS BE 2nd key ****** }

    ENDIF  { already have this keys new version or made a new one... }

    { ------------------------------------------------------------------ }
    { In all cases the identities are new ones, build from new data      }
    { ------------------------------------------------------------------ }

    self.csv_key0 = ""
    cnt           = 1

    WHILE ( self.csv_key0_val_array[cnt] <> EMPTY ) DO

        self.csv_key0 = self.csv_key0 : self.csv_key0_val_array[cnt]
        cnt           = cnt + 1

    ENDWHILE

ENDROUTINE  { packager_action_install_csv_create_version  }

{******************************************************************************}

ROUTINE packager_action_install_csv_veto_load ( self )

    DECLARE retval        ,
                 msg          ,
                 msg2         ,
                 msg3         ,
                 msg4         ,
                 msg5         ,
                 msg6         ,
                 msg7         ,
                 msg8         ,
                 msg9         ,
                 form         ,
                 cs_prompt    ,
                 data_prompt  ,
                 option_array ,
                 ndex         ,
                 a_len

    retval = TRUE

    { ------------------------------------------------------------------------- }
    { Prompt when user has never answered continued all to ok... or table       }
    { ------------------------------------------------------------------------- }

    IF NOT ( self.install_select_dir ) THEN

        self.install_continue_all = TRUE

    ELSEIF NOT ( self.install_continue_all ) THEN

        msg   = internal_translate_message ( "LIT_PACKAGER_IMPORT_CONT_OPTIONS"    )
        msg2  = internal_translate_message ( "LIT_PACKAGER_IMPORT_CONT_PROMPT"     )
        msg3  = internal_translate_message ( "LIT_PACKAGER_IMPORT_CONT_SKIP_1"     ) : self.csv_key0
        msg4  = internal_translate_message ( "LIT_PACKAGER_IMPORT_CONT_SKIP_TABLE" ) : self.csv_table_to_load
        msg5  = internal_translate_message ( "LIT_PACKAGER_IMPORT_CONT_EXIT"       )
        msg6  = internal_translate_message ( "LIT_PACKAGER_IMPORT_CONT_ALL"        )
        msg7  = internal_translate_message ( "LIT_PACKAGER_IMPORT_CONT_ALL_TABLE"  ) : self.csv_table_to_load
        msg8  = internal_translate_message ( "LIT_PACKAGER_IMPORT_CONT_DO_1"       ) : self.csv_key0
        a_len = STRINGLENGTH ( msg2 )

        { ------------------------------------------------------------ }
        { Show what we are adding...                                   }
        { ------------------------------------------------------------ }

        msg9 = ""
        ndex = 1

        WHILE ( self.csv_value_array[ndex] <> EMPTY ) DO

            msg9 = msg9 : " " : self.csv_value_array[ndex]
            ndex = ndex + 1

        ENDWHILE

        ARRAY option_array

        option_array[1,1] = msg3
        option_array[1,2] = msg3
        option_array[2,1] = msg4
        option_array[2,2] = msg4
        option_array[3,1] = msg5
        option_array[3,2] = msg5
        option_array[4,1] = msg6
        option_array[4,2] = msg6
        option_array[5,1] = msg7
        option_array[5,2] = msg7
        option_array[6,1] = msg8
        option_array[6,2] = msg8

        PROMPT OBJECT form CLASS PROMPT_CLASS_FORM
            form.column           = 5
            form.row              = 5
            form.width            = 120
            form.height           = 3
            form.border           = TRUE
            form.header           = msg : " : " : self.csv_table_to_load : "-" : self.csv_key0
            form.confirm_required = FALSE
            form.return_behaviour = FORM_RETURN_STAY
            form.proportional     = TRUE
            form.userinfo         = self.csv_fields_array

        PROMPT OBJECT cs_prompt ON LINE 1 FROM a_len + 2 TO form.width CHOOSE OUT_OF option_array
            cs_prompt.value          = msg3
            cs_prompt.select_routine = "internal_select_display_record"
            cs_prompt.vgl_library    = "LIT_PACKAGER"
            cs_prompt.user_info      = self.csv_value_array

        PROMPT OBJECT data_prompt ON LINE 3 FROM 2 TO form.width FORMAT TEXT
            data_prompt.value        = msg9
            data_prompt.display_only = TRUE

        form.add_display ( PAD ( msg2, " ",a_len+1),2,1,PROMPT_RENDITION_BOLD+PROMPT_RENDITION_RAISED )
        form.add_prompt ( cs_prompt    )
        form.add_prompt ( data_prompt  )

        { ------------------------------------------------------------ }
        { Keep a list by tables if we have prompted and want skip all  }
        { ------------------------------------------------------------ }

        IF NOT ( internal_array_2_slice ( self.continue_array, self.a_table, ndex, 1 ) ) THEN

            ndex                        = SIZE_OF_ARRAY ( self.continue_array ) + 1
            self.continue_array[ndex,1] = self.csv_table_to_load
            self.continue_array[ndex,2] = TRUE                           { do you need prompt on the table }
            self.continue_array[ndex,3] = TRUE                           { should the table load a record  }

        ENDIF

        { ------------------------------------------------------------- }
        { Only continue prompting if this table says to...              }
        { ------------------------------------------------------------- }

        IF ( internal_array_2_slice ( self.continue_array, self.csv_table_to_load, ndex, 1 ) ) AND ( self.continue_array[ndex,2] ) THEN

            form.start_prompt()

            REPEAT

                form.wait_prompt()
                retval = form.get_lastkey() = "DO"

            UNTIL ( retval ) OR ( form.get_lastkey() = "EXIT" )

            form.end_prompt()

        ENDIF

        { -------------------------------------------- }
        { Some values on prompts are special flags set }
        { -------------------------------------------- }

        IF ( retval ) THEN

            IF ( cs_prompt.value = msg6 ) THEN          { do all no more veto....}

                self.install_continue_all = TRUE

            ELSEIF ( cs_prompt.value = msg5 ) THEN      { quit and exit..........}

                self.close_logfile()
                WriteToLog("FILE SEND ":self.logfile:", DISPLAY/")
                FILE SEND self.logfile, "DISPLAY/"
                EXIT

            ELSEIF ( cs_prompt.value = msg4 ) THEN       { skip records on table..}

                retval                      = FALSE
                self.continue_array[ndex,2] = FALSE { no longer prompt table.}

            ELSEIF ( cs_prompt.value = msg3 ) THEN       { skip 1 record..........}

                retval = FALSE

            ELSEIF ( cs_prompt.value = msg8 ) THEN       { DO   1 record..........}

                retval = TRUE

            ELSEIF ( cs_prompt.value = msg7 ) THEN       { do all on table.........}

                self.continue_array[ndex,2] = FALSE { no longer prompt table..}
                self.continue_array[ndex,3] = TRUE  { do all on table.........}
                retval                      = TRUE

            ENDIF

        ENDIF

    ENDIF  { if continue all was entered we just keep going... }

    RETURN ( retval )

ENDROUTINE   {  packager_action_install_csv_veto_load }

{******************************************************************************}

ROUTINE packager_action_install_read_entry_code ( self, an_array )

    DECLARE a_prod, a_vers, a_anal, a_comp, a_new_entry , plen, alen, clen, entry_ok

    entry_ok = TRUE

    GET_FIELD_DETAILS MLP_COMPONENTS.PRODUCT_ID    , "FIELD_SIZE", plen
    GET_FIELD_DETAILS MLP_COMPONENTS.ANALYSIS_ID   , "FIELD_SIZE", alen
    GET_FIELD_DETAILS MLP_COMPONENTS.COMPONENT_NAME, "FIELD_SIZE", clen

    a_prod = PAD ( an_array[self.ae_prod_id   ], " ", plen )
    a_vers =       an_array[self.ae_prod_vers ]                     { already packed... }
    a_anal = PAD ( an_array[self.ae_anal_id   ], " ", alen )
    a_comp = PAD ( an_array[self.ae_comp_name ], " ", clen )
{WriteToLog("a_prod: ":a_prod:"; a_vers: ":a_vers:"; a_anal: ":a_anal:"; a_comp: ":a_comp)}
    { ----------------------------------------------------------------------- }
    { Values for levels get the entry code from the mlp header already loaded }
    { ----------------------------------------------------------------------- }

    IF ( BLANK ( a_prod ) ) AND ( BLANK ( a_vers ) ) THEN
        entry_ok = FALSE
        self.write_logfile ( self.msg.54 : an_array[1] : an_array[2] : an_array[3] : an_array[4] : a_anal : a_comp, "OK" )
    ELSEIF BLANK ( a_anal ) AND BLANK ( a_comp ) THEN
        a_new_entry = SELECT MLP_HEADER.ENTRY_CODE
                      WHERE IDENTITY = a_prod
                      AND   VERSION  = a_vers
        IF ( a_new_entry <> EMPTY ) THEN
            an_array[1] = a_new_entry
        ELSE
            entry_ok = FALSE
            a_msg    = internal_translate_message ( "LIT_PACKAGER_ERROR_MLP_IMPORT" ) : a_prod : a_vers
            self.write_logfile ( a_msg, "WARNING" )
        ENDIF
    ELSE
        { ----------------------------------------------------------------------- }
        { Values for components come from the already loaded components           }
        { ----------------------------------------------------------------------- }
        a_new_entry = SELECT MLP_COMPONENTS.ENTRY_CODE
                      WHERE PRODUCT_ID      = a_prod
                      AND   PRODUCT_VERSION = a_vers
                      AND   ANALYSIS_ID     = a_anal
                      AND   COMPONENT_NAME  = a_comp
        IF ( a_new_entry <> EMPTY ) THEN
            an_array[1] = a_new_entry
        ELSE
            fm(internal_translate_message("LIT_PACKAGER_ERROR_MLP_IMPORT"):ASCII(10):ASCII(10):
               "MLP_COMPONENTS.ENTRY_CODE = EMPTY ":ASCII(10):ASCII(10):
               "Product: ":STRIP(a_prod):"/":a_vers:" ":ASCII(10):
               "Analysis. ":a_anal:ASCII(10):
               "Component: ": a_comp)
            EXIT
        ENDIF
    ENDIF

    RETURN ( entry_ok )

ENDROUTINE   { packager_action_install_read_entry_code }

{******************************************************************************}

ROUTINE internal_create_new_identity ( an_array, VALUE a_table )

DECLARE keep_looking, entry_number, max_value

    keep_looking = TRUE

        WHILE keep_looking DO

        entry_number  = ( increment ( "PARAMETER_ID", "PARM_SETUP_HEADER" ))
flash_message (entry_number, true)
            max_value = SELECT MAX limit . entry_code

            IF ( max_value <> EMPTY ) AND ( max_value > entry_number ) THEN

            set_increment ( "PARAMETER_ID", "PARM_SETUP_HEADER", max_value)

        ELSE

                keep_looking = FALSE

        ENDIF

        ENDWHILE

        an_array[1] = ( entry_number )

ENDROUTINE   { internal_create_entry_code }


{******************************************************************************}

ROUTINE internal_create_entry_code ( an_array, VALUE a_table )

    IF     ( a_table = "MLP_HEADER" ) THEN

        an_array[3] = limit_get_entry_code()
{WriteToLog(a_table:"; entry_code = ":an_array[3])}
    ELSEIF ( a_table = "MLP_COMPONENTS" ) THEN

        an_array[10] = limit_get_entry_code()
{WriteToLog(a_table:"; entry_code = ":an_array[10])}
    ENDIF

ENDROUTINE   { internal_create_entry_code }

{******************************************************************************}

ROUTINE limit_get_entry_code

        DECLARE keep_looking, max_value, entry_number

        keep_looking = TRUE

        WHILE keep_looking DO

                entry_number = packed_decimal ( increment ( "MLP_COMPS", "ENTRY_CODE" ))

                max_value = SELECT MAX limit . entry_code

                IF ( max_value <> EMPTY ) AND ( max_value > entry_number ) THEN

                        set_increment ("MLP_COMPS" , "ENTRY_CODE" , max_value)

                ELSE

                        keep_looking = FALSE

                ENDIF

        ENDWHILE

        RETURN ( entry_number )

ENDROUTINE    { limit_get_entry_code }

{******************************************************************************}

ROUTINE packager_action_install_read_version (  self           ,
                                                values_array   ,
                                                version_array  )
    DECLARE nested_id, ndex, len1

    GET_FIELD_DETAILS MLP_HEADER.IDENTITY, "FIELD_SIZE", len1

    nested_id = PAD ( values_array[self.ae_prod_id], " ", len1 ) : PACKED_DECIMAL ( values_array[self.ae_prod_vers] )

    IF ( internal_array_version ( version_array, nested_id, ndex, "MLP_HEADER" ) ) THEN

        values_array[self.ae_prod_vers] = version_array[ndex,2]

    ELSE

        FLASH_MESSAGE ( "LIT_EXPORT_DATA_ERROR_MLP_VALUES", TRUE )
        EXIT

    ENDIF

ENDROUTINE   { packager_action_install_read_version }

{******************************************************************************}

ROUTINE internal_array_version (       test_array    ,
                                 VALUE nested_id     ,
                                       index_found   ,
                                 VALUE base_table    )


    DECLARE count

    count       = 0
    index_found = 0

    IF ( SIZE_OF_ARRAY ( test_array ) > 0 ) THEN

        WHILE ( count < SIZE_OF_ARRAY ( test_array ) ) DO

            count = count + 1

            IF ( test_array[count,1] = nested_id ) AND ( test_array[count,3] = base_table ) THEN

                index_found = count
                count       = SIZE_OF_ARRAY ( test_array )  { get outta while }

            ENDIF

        ENDWHILE

    ENDIF

    RETURN ( index_found > 0 )

ENDROUTINE   { end of internal_array_version }

{******************************************************************************}

ROUTINE packager_action_install_dlls ( self  )

    DECLARE i

    retval = TRUE
    i      = 1

    { -------------------------------------------------------------------- }
    { Loop for all the program / dll files to move to server               }
    { -------------------------------------------------------------------- }

    IF ( NOT self.stage_of_install ) THEN    { means STRUCTURE updated }

        self.write_logfile ( self.msg.39, "WARNING" )

    ELSE


        WHILE ( self.program_dll_array[i,1] <> EMPTY ) AND ( retval ) DO

            IF     ( INDEX ( TOLOWER ( self.program_dll_array[i,1]), C_SERVER_DIR ) > 0 )

                retval = self.install_copy_dll(self.program_dll_array[i,1], "SMP$PROGRAMS", "" )

            ELSEIF ( INDEX ( TOUPPER ( self.program_dll_array[i,1]), C_CLIENT_DIR ) > 0 )

                retval = self.install_copy_dll(self.program_dll_array[i,1], "SMP$PROGRAMS, self.program_dll_array[i,3]" )  { SD FOP subdir }

            ENDIF

            i = i + 1

        ENDWHILE

    ENDIF   { staged install only updates structure.messages }

    RETURN ( retval )

ENDROUTINE   { packager_action_install_dlls }

{******************************************************************************}

ROUTINE packager_action_install_copy_dll (       self     ,
                                           VALUE a_dir    ,
                                           VALUE a_dest   ,
                                           VALUE a_subdir )

    DECLARE i         ,
                i2        ,
                a_1_array ,
                a_2_array ,
                a_fd

    { --------------------------------------------------------------------------- }
    { If compound destination (like 920) then take the first in the list          }
    { --------------------------------------------------------------------------- }


    retval = TRUE
    a_dest = LOGICAL ( a_dest )
    a_fd   = INDEX ( a_dest, ";" )

    IF ( a_fd > 0 ) THEN

        a_dest = LEFTSTRING ( a_dest, a_fd - 1 ) : "\"

    ENDIF

    { --------------------------------------------------------------------------- }
    { If destination has a subdirectory append this so copy in the correct place  }
    { --------------------------------------------------------------------------- }

    IF NOT BLANK ( a_subdir ) THEN

        a_dest = a_dest : a_subdir : "\"

        IF NOT FILE EXISTS ( a_dest ) THEN

            retval = internal_create_directory ( a_dest )

        ENDIF

    ENDIF

    { --------------------------------------------------------------------------- }
    { Read in all the files in the install kit directory                          }
    { --------------------------------------------------------------------------- }

    IF retval THEN

        ARRAY a_1_array
        ARRAY a_2_array

        FILE FIND a_dir:"\*.*", a_1_array, retval

        IF ( retval = EMPTY ) AND ( SIZE_OF_ARRAY ( a_1_array ) > 0 ) THEN

            retval = TRUE
            i      = 1

            WHILE ( a_1_array[i] <> EMPTY ) AND ( retval ) DO

                FILE FIND STRIP ( a_1_array[i] ):"\*.*", a_2_array, retval

                { --------------------------------------------------------------------------- }
                { Each server set of files is its own directory                               }
                { --------------------------------------------------------------------------- }

                IF ( retval = EMPTY ) AND ( SIZE_OF_ARRAY ( a_2_array ) > 0 ) THEN

                    retval = TRUE
                    i2     = 1

                    WHILE ( a_2_array[i2] <> EMPTY ) AND ( retval ) DO

                        a_fd   = internal_file_name_only ( a_2_array[i2] )
                        retval = self.install_copy_1_file ( a_2_array[i2], a_dest, i2 )

                        IF NOT retval THEN

                            self.error_msg = self.msg.05 : a_fd : a_dest
                            self.write_logfile ( self.error_msg, "ERROR" )

                        ELSE

                            { --------------------------------------------------------- }
                            { Set this csv array load count for write to database later }
                            { --------------------------------------------------------- }

                            self.install_set_load_array ( "DLL", a_fd, FALSE, "","", a_2_array[i2], "", "" )

                            self.write_logfile ( self.msg.13 : a_dest, "OK" )

                            IF  ( INDEX ( TOLOWER (a_fd)         , ".dll"       ) > 0 )
                            AND ( INDEX ( TOLOWER (a_2_array[i2]), C_SERVER_DIR ) > 0 ) THEN

                                IF ( self.install_register_dll ( a_fd, a_dest ) ) THEN

                                    self.write_logfile ( self.msg.47 : a_dest : a_fd, "OK" )

                                ENDIF

                            ENDIF  { only do .dll files }

                        ENDIF

                        i2 = i2 + 1

                    ENDWHILE

                ELSE

                    self.error_msg = self.msg.04 : a_1_array[i]
                    retval = TRUE

                ENDIF   { a_2_array has some files }

                i = i + 1

            ENDWHILE   { while of all subdirs }

        ELSE

            self.error_msg = self.msg.04 : a_dir
            retval         = TRUE

        ENDIF   {  a_1_array has files on server directory that need to be moved }

    ELSE

        self.error_msg = self.msg.04
        self.write_logfile ( self.error_msg, "OK" )

    ENDIF  { retval from create subdir }


    IF ( retval = EMPTY ) THEN
        retval = FALSE
    ENDIF

    RETURN ( retval )

ENDROUTINE   { packager_action_install_copy_dll }

{******************************************************************************}

ROUTINE packager_action_install_register_dll (       self    ,
                                               VALUE a_file  ,
                                               VALUE a_dest  )



    DECLARE regfile  ,
                 logfile  ,
                 a_key    ,
                 a_exe_dir,
                 a_log_dir,
                 a_semi   ,
                 a_spawn

    retval    = TRUE
    a_exe_dir = LOGICAL ( "SMP$PROGRAMS" )
    a_semi    = INDEX ( a_exe_dir, ";" )

    IF ( a_semi > 0 ) THEN

        a_exe_dir = RIGHTSTRING ( a_exe_dir, a_semi - 1 )

    ENDIF

    a_log_dir = LOGICAL ( "SMP$TEXTREPORTS" )
    a_semi    = INDEX ( a_log_dir, ";" )

    IF ( a_semi > 0 ) THEN

        a_log_dir = LEFTSTRING ( a_log_dir, a_semi - 1 )

    ENDIF

    regfile   = self.key0_underscore:"_":a_file
    logfile   = STRIP(regfile):"_register_dll.log"
    regfile   = a_log_dir : "\" : regfile : ".BAT"

    FILE DELETE regfile, status
    FILE CREATE regfile, status
    FILE EXTEND regfile, status

    IF status = EMPTY THEN

        a_key = "regsvr32/s " : ASCII(34) : a_exe_dir:"\":a_file : ASCII(34)

        FILE WRITE regfile, a_key , status
        FILE WRITE regfile, "exit", status

        IF status = EMPTY THEN

            FILE CLOSE regfile, status

            IF status = EMPTY THEN

                a_spawn = ASCII(34): regfile :ASCII(34) : " >> " : ASCII(34): STRIP (a_log_dir:"\":log_file) :ASCII(34) : " 2>&1"

                SPAWN "cmd /E:ON /D /A /C " : a_spawn, status QUIETLY

                retval = ( status = EMPTY )

                IF ( retval ) THEN

                    FILE DELETE regfile, status
                    FILE COPY   a_log_dir : "\" : logfile, self.install_set_kit_dir : "\" : logfile
                    FILE DELETE a_log_dir : "\" : logfile, status

                ENDIF

            ENDIF  { file close }

        ENDIF  { file write }

    ENDIF  { file extend }

    RETURN ( retval )

ENDROUTINE  { packager_action_install_register_dll }

{******************************************************************************}

ROUTINE packager_action_install_copy_1_file (       self      ,
                                              VALUE a_file    ,
                                              VALUE a_dest    ,
                                              VALUE a_counter )

    DECLARE fd_only  ,
                 fso      ,
                 status   ,
                 cmd      ,
                 logfile  ,
                 a_dest_copy


    CREATE OBJECT CLASS_STD_OLE_AUTOMATION_SERVER,fso
        fso.create("Scripting.FileSystemObject")

    { ---------------------------------------------------------------- }
    { Get only the filename and build the destination full name        }
    { ---------------------------------------------------------------- }

    retval  = TRUE
    fd_only = internal_file_name_only ( a_file )

    { ---------------------------------------------------------------- }
    { Get destinations logical and if multiple only use 1 dir          }
    { ---------------------------------------------------------------- }

    IF ( BLANK ( self.install_set_destination ( a_dest, a_file ) ) ) THEN

        self.error_msg = self.msg.06
        retval         = FALSE
        self.write_logfile ( self.error_msg, "ERROR" )

    ELSEIF ( INDEX ( fd_only, "." ) > 0 ) THEN     { file must have extension - folders do not }

        { ---------------------------------------------------------------- }
        { Does the file already exist ?  move it to uninstall directory    }
        { ---------------------------------------------------------------- }

        a_dest       = STRIP ( a_dest )             : "\" : fd_only
        a_dest_copy  = STRIP ( self.uninstall_dir ) : "\" : fd_only
        a_file       = STRIP ( a_file )

        IF ( FILE EXISTS ( a_dest ) ) THEN

            { ------------------------------------------------ }
            { When multiple copies in uninstall append time    }
            { ------------------------------------------------ }

            IF ( FILE EXISTS ( a_dest_copy ) ) THEN

                a_dest_copy = a_dest_copy : "_" : self.install_date_time

            ENDIF  { dest file exists }

            retval = fso.CopyFile ( a_dest, a_dest_copy )
            retval = ( retval = EMPTY )

            IF retval THEN

                self.write_logfile ( self.msg.41 : a_dest, "OK" )

            ENDIF

        ENDIF  { file exists }

        { ---------------------------------------------------------------- }
        { Copy the file passed in to the destination "logical"             }
        { ---------------------------------------------------------------- }

        IF retval THEN

            status = EMPTY

            IF ( FILE EXISTS ( a_dest ) ) THEN

                { -------------------------------------------- }
                { Reprotect read only so we can delete file    }
                { -------------------------------------------- }

                logfile =  internal_logical_to_string ( "SMP$TEXTREPORTS" ) : "\spawn_attrib_" : GLOBAL ( "PROCESS_ID" ) : ".log"
                cmd     = "ATTRIB -R " : a_dest

                lib_utils_spawn_with_log ( cmd, logfile )

                FILE DELETE a_dest, status

            ENDIF

            IF ( status = EMPTY ) THEN

                window_set_status ( a_dest )

                retval = fso.CopyFile ( a_file, a_dest )
                retval = ( retval = EMPTY )

                IF retval THEN
                    self.write_logfile ( self.msg.14 : a_dest, "OK" )
                ENDIF

            ELSE

                FLASH_MESSAGE ( status, TRUE )
                retval = FALSE

            ENDIF

        ELSE

            self.error_msg = self.msg.06

        ENDIF

    ELSE

        retval = self.install_subdir_files ( a_file, a_dest, fd_only, a_counter )

    ENDIF   { destination is ok }

    RETURN ( retval )

ENDROUTINE   { packager_action_install_copy_1_file }

{******************************************************************************}

ROUTINE packager_action_install_set_destination (       self    ,
                                                        a_dest  ,
                                                  VALUE a_file  )


    DECLARE new_dest  ,
                 a_semi    ,
                 stlen     ,
                 i         ,
                 dest_array

    ARRAY dest_array

    new_dest = STRIP ( LOGICAL ( a_dest ) )
    a_semi   = INDEX ( new_dest, ";" )
    stlen    = STRINGLENGTH ( new_dest )
    i        = 0

    WHILE ( a_semi > 0 ) DO

        i               = i + 1
        dest_array[i,1] = STRIP ( LEFTSTRING ( new_dest, a_semi ) ) # ";"
        dest_array[i,2] = dest_array[i,1]
        new_dest        = STRIP ( RIGHTSTRING ( new_dest, stlen - a_semi ) )
        a_semi          = INDEX ( new_dest, ";" )
        stlen           = STRINGLENGTH ( new_dest )

    ENDWHILE

    { -------------------------------------------------------- }
    { Anything left over is also a destination                 }
    { -------------------------------------------------------- }

    IF ( NOT BLANK ( new_dest ) ) THEN

        i               = i + 1
        dest_array[i,1] = STRIP ( new_dest ) # ";"

    ENDIF

    { -------------------------------------------------------- }
    { Pick only one if there are more than one else just the 1 }
    { -------------------------------------------------------- }

    IF ( SIZE_OF_ARRAY ( dest_array ) > 1 ) AND ( self.install_select_dir ) THEN

        IF NOT ( self.install_select_destination ( dest_array, a_dest, a_file ) ) THEN
            a_dest = ""
        ENDIF

    ELSE

        a_dest = dest_array[1,1]

    ENDIF

    RETURN ( a_dest )

ENDROUTINE   { packager_action_install_set_destination }

{******************************************************************************}

ROUTINE packager_action_install_select_destination (       self       ,
                                                           dest_array ,
                                                           a_dest     ,
                                                     VALUE a_file     )

    DECLARE form      ,
                 cs_prompt

    retval = TRUE

    { -------------------------------------------------------------------- }
    { Only prompt 1 time for all the rpf files...                          }
    { -------------------------------------------------------------------- }

    IF ( self.rpf_directory <> EMPTY ) AND ( INDEX ( TOUPPER ( a_file ), "RPF" ) > 0 ) THEN

        a_dest = self.rpf_directory

    ELSEIF ( self.crt_directory <> EMPTY ) AND ( INDEX ( TOUPPER ( a_file ), "CRT" ) > 0 ) THEN

        a_dest = self.crt_directory

    ELSEIF ( self.caf_directory <> EMPTY ) AND ( INDEX ( TOUPPER ( a_file ), "CAF" ) > 0 ) THEN

        a_dest = self.caf_directory

    ELSEIF ( self.sxf_directory <> EMPTY ) AND ( INDEX ( TOUPPER ( a_file ), "SXF" ) > 0 ) THEN

        a_dest = self.sxf_directory

    ELSE

        PROMPT OBJECT form CLASS PROMPT_CLASS_FORM
            form.column           = 10
            form.row              = 10
            form.width            = 120
            form.height           = 1
            form.border           = TRUE
            form.header           = a_file
            form.confirm_required = FALSE
            form.return_behaviour = FORM_RETURN_STAY
            form.proportional     = TRUE

        PROMPT OBJECT cs_prompt ON LINE 1 FROM 32 TO form.width - 2 CHOOSE OUT_OF dest_array

        form.add_display ( PAD ( internal_translate_message ("LIT_LAB_SMP_MODULE_PACKAGE_DESTINATION"), " ",30),2,1,PROMPT_RENDITION_BOLD+PROMPT_RENDITION_RAISED )
        form.add_prompt ( cs_prompt  )
        form.start_prompt()

        REPEAT

            form.wait_prompt()
            retval = form.get_lastkey() = "DO"

        UNTIL ( retval ) OR ( form.get_lastkey() = "EXIT" )

        a_dest = cs_prompt.value

        form.end_prompt()

        { ---------------------------------------------------------- }
        { Set the actual filename that the user wants for the save   }
        { ---------------------------------------------------------- }

        IF ( NOT BLANK ( cs_prompt.value ) ) AND ( retval ) THEN

            IF ( self.rpf_directory = EMPTY ) AND ( INDEX ( TOUPPER ( a_file ), ".RPF" ) > 0 ) THEN

                self.rpf_directory = a_dest

            ELSEIF ( self.crt_directory = EMPTY ) AND ( INDEX ( TOUPPER ( a_file ), ".CRT" ) > 0 ) THEN

                self.crt_directory = a_dest

            ELSEIF ( self.caf_directory = EMPTY ) AND  ( INDEX ( TOUPPER ( a_file ), ".CAF" ) > 0 ) THEN

                self.caf_directory = a_dest

            ELSEIF ( self.sxf_directory = EMPTY ) AND  ( INDEX ( TOUPPER ( a_file ), ".SXF" ) > 0 ) THEN

                self.sxf_directory = a_dest

            ENDIF

        ENDIF   { prompt is not blank and retval }

    ENDIF  { do it 1 time if already done, otherwise prompt and set for 1 time }

    RETURN ( retval )

ENDROUTINE   { packager_action_install_select_destination }

{******************************************************************************}

ROUTINE packager_action_install_file_stage ( self )

    retval = TRUE

    IF NOT ( self.stage_of_install ) THEN

        IF ( self.install_files ( "*STRUCTURE*.TXT" ) ) THEN

            self.messages_updated  = TRUE
            self.structure_updated = TRUE

        ELSE

            retval         = FALSE
            self.error_msg = self.msg.39

            FLASH_MESSAGE ( self.error_msg, TRUE )

        ENDIF

    ELSE

        retval = self.install_files( "*.*" )

    ENDIF   { stage of install is only structure on first pass }

    RETURN ( retval )

ENDROUTINE   { packager_action_install_file_stage }

{******************************************************************************}

ROUTINE packager_action_install_files (       self        ,
                                        VALUE search_mask )

    DECLARE  i         ,
                 i2        ,
                 a_1_array ,
                 tmp       ,
                 tmp8      ,
                 a_type    ,
                 a_logical

    retval = TRUE

    { --------------------------------------------------------------------------- }
    { If a staged install then do specific files, otherwise all files found       }
    { --------------------------------------------------------------------------- }

    i2 = 1

    WHILE ( self.subdir_array[i2,1] <> EMPTY ) AND ( retval ) DO

        ARRAY a_1_array

        IF NOT self.stage_of_install THEN

            tmp = STRIP( self.subdir_array[i2,3] )

        ELSE

            tmp = STRIP( self.subdir_array[i2,3] ):"\":search_mask

        ENDIF   { staged install finds specific files only }

        { --------------------------------------------------------------------------- }
        { Read in all the files in the install kit directory                          }
        { --------------------------------------------------------------------------- }

        FILE FIND tmp, a_1_array, retval

        IF ( retval = EMPTY ) AND ( SIZE_OF_ARRAY ( a_1_array ) > 0 ) THEN

            a_logical = self.subdir_array[i2,4]
            retval    = TRUE
            i         = 1

            WHILE ( a_1_array[i] <> EMPTY ) AND ( retval ) DO

                { --------------------------------------------------------------- }
                { If 2 stage install (structure) then don't install files again   }
                { --------------------------------------------------------------- }

                IF NOT self.files_updated THEN

                    retval = self.install_copy_1_file ( a_1_array[i], a_logical, i2 )

                ELSE

                    window_set_status ( " ****** " : a_1_array[i] : " ****** "  )
                    SLEEP FOR INTERVAL ( "0 00:00:03" )

                ENDIF

                { --------------------------------------------------------------- }
                { Save all that was done for later use                            }
                { --------------------------------------------------------------- }

                IF ( retval ) AND ( NOT self.files_updated ) THEN

                    tmp  = internal_file_name_only ( a_1_array[i] )
                    tmp8 = TOLOWER ( LEFTSTRING ( tmp, 8 ) )

                    { --------------------------------------------------------- }
                    { Set this csv array load count for write to database later }
                    { --------------------------------------------------------- }

                    IF ( self.install_is_compile ( a_logical, a_type ) ) THEN

                        self.install_set_load_array ( "FILE", tmp, TRUE, self.subdir_array[i2,5], a_logical, a_1_array[i], a_type, "" )

                    ELSEIF ( a_logical = "SMP$CRITERIA" ) AND ( tmp8 <> "explore_" ) THEN

                        self.install_set_load_array ( "FILE", tmp, FALSE, self.subdir_array[i2,5], a_logical, a_1_array[i], "", "" )

                    ELSE

                        self.install_set_load_array ( "FILE", tmp, FALSE, self.subdir_array[i2,3], "", a_1_array[i], "", "" )

                    ENDIF

                ENDIF

                i = i + 1

            ENDWHILE   { while of all subdirs }

        ELSEIF ( self.is_export_set ) THEN

            self.error_msg = ""
            retval         = TRUE      { can have subdirs with no files from exported data and that is ok }

        ELSE

            self.error_msg = self.msg.07 : tmp
            tmp8           = internal_translate_message ( "LIT_PACKAGER_08" ) : tmp
            retval         = CONFIRM_WITH_TEXT ( tmp8 )

        ENDIF

        i2 = i2 + 1

    ENDWHILE   { all csv logical dir's files copied }

    { ------------------------------------------------------------------- }
    { If all is ok and we loaded a structure, message or menu then update }
    { ------------------------------------------------------------------- }

    IF ( retval ) AND ( NOT self.is_export_set ) THEN

        { ----------------------------------------------------------------------------------- }
        { Save current copy in the uninstall directory so a manual rollback can be done       }
        { ----------------------------------------------------------------------------------- }

        FILE COPY "SMP$DATAFILES\structure.txt", self.uninstall_dir : "\structure.txt", status
        FILE COPY "SMP$MESSAGES\message.txt"   , self.uninstall_dir : "\message.txt"  , status
        FILE COPY "SMP$USERFILES\default.lab"  , self.uninstall_dir : "\default.lab"  , status

        { ----------------------------------------------------------------------------------- }
        { If we have updates to structure, messages or .lab then do them now (unless dbase)   }
        { ----------------------------------------------------------------------------------- }

        IF  ( SIZE_OF_ARRAY ( self.load_structure_array ) > 0 )
        AND ( NOT ( self.structure_updated )                  ) THEN

            self.install_append_structure()

            retval = self.install_structure_txt()

        ENDIF

        IF  ( SIZE_OF_ARRAY ( self.load_messages_array ) > 0 )
        AND ( NOT self.messages_updated                      ) THEN

            retval = retval AND self.install_messages_txt()

        ENDIF

        { --------------------------------------------------------------------- }
        { .LAB file checks if install file contents are already in .lab file    }
        { --------------------------------------------------------------------- }

        IF  ( SIZE_OF_ARRAY ( self.load_menu_lab_array ) > 0 )
        AND ( NOT self.smw_menu_updated                      ) THEN

            retval = retval AND self.install_default_lab()

        ENDIF

        { --------------------------------------------------------------------- }
        { .MTB file special for 920 menus                                       }
        { --------------------------------------------------------------------- }

        IF  ( SIZE_OF_ARRAY ( self.load_menu_mtb_array ) > 0 )
        AND ( NOT self.smw_menu_updated                      ) THEN

            retval = retval AND self.install_920_mtb()

        ENDIF

    ENDIF  { retval ok from install }

    RETURN ( retval )

ENDROUTINE   { packager_action_install_files }

{******************************************************************************}

ROUTINE packager_action_install_subdir_files (       self      ,
                                               VALUE a_dir     ,
                                               VALUE a_logical ,
                                               VALUE fd_only   ,
                                               VALUE a_counter )

    DECLARE i         ,
                 a_1_array ,
                 tmp

    ARRAY a_1_array

    { -------------------------------------------------------------------------- }
    { These files are in non smp$logicals (e.g. sub-directories) like Resource...}
    { -------------------------------------------------------------------------- }

    a_logical = a_logical :"\":fd_only      { append this dir for the destination... }
    retval    = TRUE
    tmp       = STRIP( a_dir ):"\*.*"

    FILE FIND tmp, a_1_array, status

    IF ( status = EMPTY ) AND ( SIZE_OF_ARRAY ( a_1_array ) > 0 ) THEN

        retval    = TRUE
        i         = 1

        WHILE ( a_1_array[i] <> EMPTY ) AND ( retval ) DO

            { --------------------------------------------------------------- }
            { If 2 stage install (structure) then don't install files again   }
            { --------------------------------------------------------------- }

            IF NOT self.files_updated THEN

                IF NOT ( FILE EXISTS ( a_logical ) ) THEN

                    retval = internal_create_directory ( a_logical )

                ENDIF

                retval = ( retval ) AND ( self.install_copy_1_file ( a_1_array[i], a_logical, a_counter ) )

            ELSE

                window_set_status ( " ****** " : a_1_array[i] : " ****** "  )
                SLEEP FOR INTERVAL ( "0 00:00:02" )

            ENDIF

            { --------------------------------------------------------------- }
            { Save all that was done for later use                            }
            { --------------------------------------------------------------- }

            IF ( retval ) AND ( NOT self.files_updated ) THEN

                tmp  = internal_file_name_only ( a_1_array[i] )

                self.install_set_load_array ( "FILE", tmp, FALSE, self.subdir_array[a_counter,3], "", a_1_array[i], "", "" )

            ENDIF

            i = i + 1

        ENDWHILE   { while of all subdirs }

    ENDIF  { find file some files }

    RETURN ( retval )

ENDROUTINE     { packager_action_install_subdir_files }

{******************************************************************************}

ROUTINE packager_action_install_is_compile (       self      ,
                                             VALUE a_dir     ,
                                                   a_type    )

    DECLARE is_compile

    is_compile = FALSE
    a_type     = ""

    IF ( a_dir = "SMP$REPORTS" ) OR ( a_dir = "SMP_REPORTS" ) THEN

        a_type     = LIBRARY_REPORT
        is_compile = TRUE

    ELSEIF ( a_dir = "SMP$CALCULATIONS" ) OR ( a_dir = "SMP_CALCULATIONS" ) THEN

        a_type     = LIBRARY_CALCULATION
        is_compile = TRUE

    ELSEIF ( a_dir = "SMP$LIMIT_CALCULATIONS" ) OR ( a_dir = "SMP_LIMIT_CALCULATIONS" ) THEN

        a_type     = LIBRARY_LIMIT_CALCULATION
        is_compile = TRUE

    ELSEIF ( a_dir = "SMP$LIST_RESULTS" ) OR ( a_dir = "SMP_LIST_RESULTS" ) THEN

        a_type     = LIBRARY_LIST_RESULT
        is_compile = TRUE

    ELSEIF ( a_dir = "SMP$SIG_FIGS" ) OR ( a_dir = "SMP_SIG_FIGS" ) THEN

        a_type     = LIBRARY_SIG_FIGS
        is_compile = TRUE

    ELSEIF ( a_dir = "SMP$SYNTAXES" ) OR ( a_dir = "SMP_SYNTAXES" ) THEN

        a_type     = LIBRARY_SYNTAX
        is_compile = TRUE

    ENDIF

    RETURN ( is_compile )

ENDROUTINE  {  packager_action_install_is_compile }

{******************************************************************************}

ROUTINE packager_action_install_structure_txt ( self )

    DECLARE edit_ok

    retval  = FALSE
    edit_ok = internal_translate_message ("LIT_LAB_SMP_MODULE_STRUCTURE_CONFIRM")

    IF ( CONFIRM_WITH_TEXT ( edit_ok ) ) THEN

        { --------------------------------------------------------- }
        { Stay in the edit cycle until user quits or is done        }
        { --------------------------------------------------------- }

        edit_ok = FALSE

        WHILE ( NOT edit_ok ) DO

            OUTPUT_TO_EDITOR ( C_STRUCTURE_TXT_FULL, FALSE )

            edit_ok = self.install_create_convert()

            IF edit_ok THEN
                retval = TRUE
            ENDIF

        ENDWHILE   { retval from all the reading of the files is ok }

    ELSE

        retval = TRUE

    ENDIF   { size of array to append has no files, or user don't want to edit }

    { --------------------------------------------------------- }
    { Confirm to save data so far (phased installs)             }
    { --------------------------------------------------------- }

    IF ( retval ) THEN

        self.structure_updated = CONFIRM_WITH_TEXT ( self.msg.36 )

    ENDIF

    RETURN ( retval )

ENDROUTINE    { packager_action_install_structure_txt }

{******************************************************************************}

ROUTINE packager_action_install_append_structure ( self )

    DECLARE status    ,
                 a_cnt     ,
                 a_2_add

    { --------------------------------------------------------- }
    { First read all files that are append type, then add them  }
    { --------------------------------------------------------- }

    a_msg = internal_translate_message ( "LIT_LAB_SMP_MODULE_STRUCTURE_INVALID" )

    IF ( SIZE_OF_ARRAY ( self.load_structure_array ) > 0 ) THEN

        retval = self.install_read_append_files()

        IF ( retval ) AND ( SIZE_OF_ARRAY ( self.append_structure_array ) = 0 ) THEN

            retval = TRUE   { nothing to append }
            status = EMPTY

        ELSEIF ( retval ) AND ( CONFIRM_WITH_TEXT ( a_msg ) ) THEN

            a_2_add = SIZE_OF_ARRAY ( self.append_structure_array )

            FILE EXTEND C_STRUCTURE_TXT_FULL, status

            IF ( status = EMPTY ) THEN

                a_cnt = 1

                WHILE ( self.append_structure_array[a_cnt] <> EMPTY ) AND ( status = EMPTY ) DO

                    FILE WRITE C_STRUCTURE_TXT_FULL, self.append_structure_array[a_cnt], status
                    a_cnt = a_cnt + 1

                ENDWHILE

                IF ( a_cnt >= a_2_add ) THEN

                    retval = TRUE

                ENDIF

            ENDIF

            { --------------------------------------------------------- }
            { Close - should we be real careful and check status ?      }
            { --------------------------------------------------------- }

            FILE CLOSE C_STRUCTURE_TXT_FULL, status

        ENDIF  { retval from read append }

    ELSE

        retval = TRUE
        status = EMPTY

    ENDIF    { read of files in kit had not files that were append to structure }

    retval = ( retval ) AND ( status = EMPTY )

    RETURN ( retval )

ENDROUTINE    { packager_action_install_append_structure }

{******************************************************************************}

ROUTINE packager_action_install_read_append_files ( self )

    DECLARE a_cnt

    retval = TRUE
    a_cnt  = 1

    WHILE ( self.load_structure_array[a_cnt,1] <> EMPTY ) AND ( retval ) DO

        IF ( self.load_structure_array[a_cnt,2] ) THEN

            IF NOT (  self.install_read_a_file ( "smp$datafiles\":self.load_structure_array[a_cnt,1], "APPEND" ) ) THEN

                retval = FALSE

            ENDIF

        ENDIF   { we have a structure file, but it is not type append }

        a_cnt = a_cnt + 1

    ENDWHILE   { read all lines from all appends into array }

    RETURN ( retval )

ENDROUTINE   { packager_action_install_read_append_files }

{******************************************************************************}

ROUTINE packager_action_install_read_a_file (       self        ,
                                              VALUE a_file      ,
                                              VALUE append_mode )


    DECLARE status  ,
                 read_cnt

    { ----------------------------------------------------------------- }
    { May have multiple files to append, but 1 structure.txt file       }
    { ----------------------------------------------------------------- }

    IF ( append_mode = "APPEND" ) THEN

        read_cnt = SIZE_OF_ARRAY ( self.append_structure_array ) + 1

    ELSEIF ( append_mode = "STRUCTURE" ) THEN

        read_cnt = SIZE_OF_ARRAY ( self.smp_structure_array    ) + 1

    ELSE

        read_cnt = SIZE_OF_ARRAY ( self.message_txt_array      ) + 1

    ENDIF

    { ------------------------------------------------------------------ }
    { Open the file and read until no more lines to read                 }
    { ------------------------------------------------------------------ }

    FILE OPEN a_file, status

    IF ( status = EMPTY ) THEN

        WHILE ( status = EMPTY ) DO

            IF ( append_mode = "APPEND" ) THEN

                FILE READ a_file, self.append_structure_array[read_cnt], status

            ELSEIF ( append_mode = "STRUCTURE" ) THEN

                FILE READ a_file, self.smp_structure_array[read_cnt], status

            ELSE

                FILE READ a_file, self.message_txt_array[read_cnt,1], status

            ENDIF

            read_cnt = read_cnt + 1

        ENDWHILE

    ELSE

        FLASH_MESSAGE ( a_file : status, TRUE )

    ENDIF   { status open of file }

    { ------------------------------------------------------- }
    { If we read a line at all then return true               }
    { ------------------------------------------------------- }

    FILE CLOSE a_file, status

    retval = read_cnt > 1

    RETURN ( retval )

ENDROUTINE    { packager_action_install_read_a_file }

{******************************************************************************}

ROUTINE packager_action_install_create_convert ( self )

    retval = internal_structure ( "create_structure ", "OK", "", "SMP$INSTALL" )

    IF confirm_with_text ( self.msg.29 ) THEN

        internal_structure ( "convert_table ", "successfully", "-mode CONVERT -tables * -noconfirm", "SMP$INSTALL" )
        retval = confirm_with_text ( self.msg.30 )

    ENDIF

    RETURN ( retval )

ENDROUTINE    { packager_action_install_create_convert }

{******************************************************************************}

ROUTINE packager_action_install_messages_txt ( self )

    DECLARE a_cnt ,
                 ndex

    retval = self.install_read_a_file ( C_MESSAGE_TXT_FULL, "MESSAGE" )

    IF ( retval ) THEN

        { ---------------------------------------------------- }
        { Search each file to be added if in message.txt       }
        { ---------------------------------------------------- }

        a_cnt  = 1

        WHILE ( self.load_messages_array[a_cnt,1] <> EMPTY ) DO

            IF ( NOT internal_array_2_index ( self.message_txt_array, self.load_messages_array[a_cnt,1], ndex, 1 ) ) THEN

                retval                            = FALSE
                self.load_messages_array[a_cnt,2] = TRUE

            ELSE

                self.load_messages_array[a_cnt,2] = FALSE

            ENDIF

            a_cnt = a_cnt + 1

        ENDWHILE

        { ---------------------------------------------------- }
        { IF one is not there, then add it                     }
        { ---------------------------------------------------- }

        IF NOT ( retval ) THEN

            FILE EXTEND C_MESSAGE_TXT_FULL, status

            IF ( status = EMPTY ) THEN

                a_cnt = 1

                WHILE ( self.load_messages_array[a_cnt,1] <> EMPTY ) AND ( status = EMPTY ) DO

                    IF ( self.load_messages_array[a_cnt,2] ) THEN

                        ndex = C_MESSAGE_INCLUDE_PREFIX : ASCII(34) : STRIP ( self.load_messages_array[a_cnt,1] ) : ASCII(34)

                        FILE WRITE C_MESSAGE_TXT_FULL, ndex, status

                    ENDIF

                    a_cnt = a_cnt + 1

                ENDWHILE

            ENDIF

            FILE CLOSE C_MESSAGE_TXT_FULL, status

            retval = ( status = EMPTY )

        ENDIF  { not retval of the files contained in message.txt }

        { ---------------------------------------------------- }
        { Did the appends to the message.txt now create them   }
        { ---------------------------------------------------- }

        IF ( retval ) THEN

            retval = self.install_create_message()

        ENDIF

    ENDIF   {  retval read of message.txt was ok }

    RETURN ( retval )

ENDROUTINE    { packager_action_install_messages_txt }

{******************************************************************************}

ROUTINE packager_action_install_create_message ( self )

    internal_structure ( "create_message ", "OK", " ", "SMP$INSTALL" )
    retval = confirm_with_text ( self.msg.31 )

    { --------------------------------------------------------- }
    { Confirm to save data so far (phased installs)             }
    { --------------------------------------------------------- }

    IF ( retval ) THEN

        self.messages_updated = CONFIRM_WITH_TEXT ( self.msg.37 )

    ENDIF

    RETURN ( retval )

ENDROUTINE    { packager_action_install_create_message }

{******************************************************************************}

ROUTINE packager_action_install_default_lab ( self )

    DECLARE a_cnt

    retval = TRUE
    a_cnt  = 1

    WHILE ( self.load_menu_lab_array[a_cnt] <> EMPTY ) AND ( retval ) DO

        IF ( self.load_menu_lab_array[a_cnt] <> EMPTY ) THEN

            IF NOT ( self.install_default_lab_file ( self.load_menu_lab_array[a_cnt] ) ) THEN

                self.error_msg = internal_translate_message ( "LIT_LAB_SMP_MODULE_ERROR_UPDATE_LAB_LINES" ) : a_cnt : self.load_menu_lab_array[a_cnt]

                FLASH_MESSAGE ( self.error_msg, TRUE )

                self.write_logfile ( self.error_msg, "ERROR" )

            ENDIF

        ENDIF

        a_cnt = a_cnt + 1

    ENDWHILE   {  while any files to load are done }

    RETURN ( retval )

ENDROUTINE    { packager_action_install_default_lab }

{******************************************************************************}

ROUTINE packager_action_install_default_lab_file (       self   ,
                                                   VALUE a_file )


    DECLARE a_cnt         ,
                 lines_array  ,
                 lines_2_array,
                 found

    ARRAY lines_array
    ARRAY lines_2_array

    found  = FALSE
    retval = TRUE
    a_cnt  = 0

    FILE OPEN a_file, status

    WHILE ( status = EMPTY ) DO

        a_cnt = a_cnt + 1
        FILE READ a_file, lines_array[a_cnt], status

    ENDWHILE

    { ---------------------------------------------------------- }
    { If we have any lines to add check if they are not there    }
    { ---------------------------------------------------------- }

    IF ( SIZE_OF_ARRAY ( lines_array ) > 0 ) THEN

        { ---------------------------------------------------------- }
        { Get all the existing lines in the .lab file                }
        { ---------------------------------------------------------- }

        FILE OPEN C_DEFAULT_LAB_FILE, status

        WHILE ( status = EMPTY ) DO

            a_cnt = a_cnt + 1
            FILE READ C_DEFAULT_LAB_FILE, lines_2_array[a_cnt], status

        ENDWHILE

        { ---------------------------------------------------------- }
        { Check each one, and if not there then add it to the .lab   }
        { ---------------------------------------------------------- }

        FILE EXTEND C_DEFAULT_LAB_FILE, status

        a_cnt = 1

        WHILE ( lines_array[a_cnt] <> EMPTY ) AND ( status = EMPTY ) DO

            IF NOT ( internal_array_slice ( lines_2_array, lines_array[a_cnt], found ) ) THEN

                FILE WRITE C_DEFAULT_LAB_FILE, lines_array[a_cnt], status

            ENDIF

            self.write_logfile ( C_DEFAULT_LAB_FILE : lines_array[a_cnt], "OK" )

            a_cnt = a_cnt + 1

        ENDWHILE

        { ---------------------------------------------------------- }
        { Close appended .lab and issue warning if any issues...     }
        { ---------------------------------------------------------- }

        FILE CLOSE C_DEFAULT_LAB_FILE, status

        IF ( a_cnt < SIZE_OF_ARRAY ( lines_array ) ) OR ( status <> EMPTY ) THEN

            self.error_msg = internal_translate_message ( "LIT_LAB_SMP_MODULE_ERROR_UPDATE_LAB_LINES" ) : a_file

            FLASH_MESSAGE ( self.error_msg, TRUE )

            self.write_logfile ( self.error_msg, "OK" )

        ENDIF

    ELSE

        self.error_msg = internal_translate_message ( "LIT_LAB_SMP_MODULE_ERROR_UPDATE_NO_LINES" ) : a_file

        FLASH_MESSAGE ( self.error_msg, TRUE )

        self.write_logfile ( self.error_msg, "OK" )

    ENDIF

    RETURN ( retval )

ENDROUTINE  { packager_action_install_default_lab_file }

{******************************************************************************}

ROUTINE packager_action_install_920_mtb ( self )

    DECLARE a_cnt

    retval = TRUE
    a_cnt  = 1

    WHILE ( self.load_menu_mtb_array[a_cnt] <> EMPTY ) AND ( retval ) DO

        IF ( self.load_menu_mtb_array[a_cnt] <> EMPTY ) THEN

            IF NOT ( self.install_920_mtb_file ( self.load_menu_mtb_array[a_cnt] ) ) THEN

                self.error_msg = internal_translate_message ( "LIT_LAB_SMP_MODULE_ERROR_UPDATE_MTB" ) : a_cnt : self.load_menu_mtb_array[a_cnt]

                FLASH_MESSAGE ( self.error_msg, TRUE )

                self.write_logfile ( self.error_msg, "ERROR" )

            ENDIF

        ENDIF

        a_cnt = a_cnt + 1

    ENDWHILE   {  while any files to load are done }

    RETURN ( retval )

ENDROUTINE    { packager_action_install_920_mtb }

{******************************************************************************}

ROUTINE packager_action_install_920_mtb_file (       self   ,
                                               VALUE a_file )


    self.write_logfile ( a_file, "OK" )

    RETURN ( TRUE )

ENDROUTINE    { packager_action_install_920_mtb_file }

{******************************************************************************}

ROUTINE packager_action_install_import_smw_menu ( self )

    CALL_ROUTINE "menu_edit_modify_in_context_option" IN LIBRARY "$MENU_EDIT" USING retval NEW CONTEXT

    RETURN ( TRUE )

ENDROUTINE    { packager_action_install_import_smw_menu }

{******************************************************************************}

ROUTINE packager_action_install_structure_dbase ( self )

    CALL_ROUTINE C_LIT_DATABASE_WRITE_STRUCTURE IN LIBRARY C_LIT_DATABASE USING self

    retval = self.install_create_convert()

    IF NOT ( retval ) THEN

        FLASH_MESSAGE ( "LIT_LAB_SMP_MODULE_STRUCTURE_INVALID", TRUE )

        retval = self.install_structure_txt()

    ENDIF

    RETURN ( retval )

ENDROUTINE    { packager_action_install_structure_dbase }

{******************************************************************************}

ROUTINE packager_action_install_update_dbase ( self  )

    { --------------------------------------------------------------------------- }
    { If structure is in the database and lit_database report exists then use it  }
    { --------------------------------------------------------------------------- }

    IF ( self.smp_structure_ok ) THEN

        retval = self.install_structure_dbase()

    ELSE

        retval = FALSE  { only set true when update below is ok }

    ENDIF

    { --------------------------------------------------------------------------- }
    { All transactions and assigns for installation are in this routine           }
    { --------------------------------------------------------------------------- }

    START WRITE TRANSACTION C_PACKAGER_WRITE_TRANS

    { --------------------------------------------------------------------------- }
    { Objects must be created here due to the table load of the csv's             }
    { --------------------------------------------------------------------------- }

    CREATE OBJECT C_STD_OBJECT_DATABASE, self.module_record
        self.module_record.table = self.table
        self.module_record.initialise ( self.module_record.table )
        self.module_record.select_for_update ( self.criteria_array )
        self.module_record.set_first()

    CREATE OBJECT C_STD_OBJECT_DATABASE, self.criteria_dbase
        self.criteria_dbase.initialise ( self.criteria_table )
        self.criteria_dbase.select_for_update ( self.criteria_array )
        self.criteria_dbase.add_index ( "CSV_FILE" )
        self.criteria_dbase.add_index ( "FILE_ID" )
        self.criteria_dbase.add_index ( "FILE_LOGICAL" )
        self.criteria_dbase.add_index ( "TABLE_NAME" )
        self.criteria_dbase.add_index ( "MODE_TABLE" )

    CREATE OBJECT C_STD_OBJECT_DATABASE, self.dll_dbase
        self.dll_dbase.initialise ( self.dll_table )
        self.dll_dbase.select_for_update ( self.criteria_array )
        self.dll_dbase.add_index ( "FILENAME_ONLY" )

    ASSIGN 'C_SMP_MODULE'.MODIFIED_ON    IN OBJECT self.module_record.current = NOW
    ASSIGN 'C_SMP_MODULE'.MODIFIED_BY    IN OBJECT self.module_record.current = OPERATOR

    { --------------------------------------------------------------------------- }
    { If user confirmed that the staged install is correct then update the fields }
    { --------------------------------------------------------------------------- }

    IF ( self.structure_updated ) THEN

        ASSIGN 'C_SMP_MODULE'.STRUCTURE_UPDATED IN OBJECT self.module_record.current = TRUE
        ASSIGN 'C_SMP_MODULE'.STAGE_OF_INSTALL  IN OBJECT self.module_record.current = TRUE

    ENDIF

    IF ( self.messages_updated ) THEN

        ASSIGN 'C_SMP_MODULE'.MESSAGES_UPDATED IN OBJECT self.module_record.current = TRUE

    ENDIF

    IF ( self.smw_menu_updated ) THEN

        ASSIGN 'C_SMP_MODULE'.SMW_MENU_UPDATED IN OBJECT self.module_record.current = TRUE

    ENDIF

    IF ( self.files_updated ) THEN

        ASSIGN 'C_SMP_MODULE'.FILES_UPDATED  IN OBJECT self.module_record.current = TRUE
        ASSIGN 'C_SMP_MODULE'.DATE_INSTALLED IN OBJECT self.module_record.current = NOW

    ENDIF

    IF ( self.is_export_set ) THEN

        ASSIGN 'C_SMP_MODULE'.MODULE_TYPE IN OBJECT self.module_record.current = "GLOBAL"
        ASSIGN 'C_SMP_MODULE'.INSTALL_SET IN OBJECT self.module_record.current = self.logfile

    ENDIF
    { --------------------------------------------------------------------------- }
    { Using the values from the load array update all the load and compile counts }
    { --------------------------------------------------------------------------- }

    IF ( self.install_update_all_counts() ) THEN

        self.module_record.invoke_all  ( "UPDATE" )
        self.dll_dbase.invoke_all      ( "UPDATE" )
        self.criteria_dbase.invoke_all ( "UPDATE" )

        self.call_trigger ( C_TRIGGER_BEFORE_INSTALL_COMMIT )

        COMMIT
        retval = TRUE

    ELSE
        ROLLBACK
    ENDIF

    self.module_record  = EMPTY
    self.criteria_dbase = EMPTY
    self.dll_dbase      = EMPTY

    RETURN ( retval )

ENDROUTINE   { packager_action_install_update_dbase }

{******************************************************************************}

ROUTINE packager_action_install_set_load_array (       self         ,
                                                 VALUE a_type       ,
                                                 VALUE a_id         ,
                                                 VALUE is_compile   ,
                                                 VALUE a_logical    ,
                                                 VALUE a_smp_logical,
                                                 VALUE a_full_id    ,
                                                 VALUE a_mode       ,
                                                 VALUE a_table      )

    DECLARE a_num

    IF NOT ( internal_array_2_slice ( self.load_array, a_id, a_num, 1 ) ) THEN

        a_num                    = SIZE_OF_ARRAY ( self.load_array ) + 1
        self.load_array[a_num,5] = 0

    ENDIF

    self.load_array[a_num, 1] = a_id
    self.load_array[a_num, 2] = a_type
    self.load_array[a_num, 3] = self.csv_ignore_count
    self.load_array[a_num, 4] = self.csv_skip_count
    self.load_array[a_num, 5] = self.csv_load_count
    self.load_array[a_num, 6] = is_compile
    self.load_array[a_num, 7] = a_logical
    self.load_array[a_num, 8] = a_full_id
    self.load_array[a_num, 9] = a_smp_logical
    self.load_array[a_num,10] = a_mode
    self.load_array[a_num,11] = a_table

    { -------------------------------------------------------- }
    { Save special load_array type for STRUCTURE to update     }
    { -------------------------------------------------------- }

    a_id = STRIP ( TOUPPER ( a_id ) )

    IF ( INDEX ( a_id, C_STRUCTURE_PREFIX ) > 0 ) AND ( INDEX ( a_id, ".TXT" ) > 0 ) THEN

        IF NOT ( internal_array_2_slice ( self.load_structure_array, a_id, a_num, 1 ) ) THEN

            a_num = SIZE_OF_ARRAY ( self.load_structure_array ) + 1

        ENDIF

        self.load_structure_array[a_num,1] = a_id
        self.load_structure_array[a_num,2] = INDEX ( a_id, "APPEND" ) > 0

    ENDIF  { file is type structure.txt }

    { -------------------------------------------------------- }
    { Save special load_array type for MESSAGES to update      }
    { -------------------------------------------------------- }

    IF ( INDEX ( a_id, C_MESSAGES_PREFIX ) > 0 ) AND ( INDEX ( a_id, ".TXT" ) > 0 ) THEN

        IF NOT ( internal_array_2_slice ( self.load_messages_array, a_id, a_num, 1 ) ) THEN

            a_num = SIZE_OF_ARRAY ( self.load_messages_array ) + 1

        ENDIF

        self.load_messages_array[a_num,1] = a_id
        self.load_messages_array[a_num,2] = FALSE

    ENDIF  { file is type message.txt }

    { -------------------------------------------------------- }
    { Save special load_array type for MASTER_MENU to update   }
    { -------------------------------------------------------- }

    IF ( INDEX ( a_id, "MASTER_MENU_" ) > 0 ) AND ( INDEX ( a_id, ".CSV" ) > 0 ) THEN

        IF NOT ( internal_array_slice ( self.load_menu_master_array, a_id, a_num ) ) THEN

            a_num = SIZE_OF_ARRAY ( self.load_menu_master_array ) + 1

        ENDIF

        self.load_menu_master_array[a_num] = a_full_id

    ENDIF  { file is type master_menu_*.csv }

    { -------------------------------------------------------- }
    { Save special load_array type for SMW_MENU to update      }
    { -------------------------------------------------------- }

    IF ( INDEX ( a_id, C_SMW_MENU_PREFIX ) > 0 ) AND ( INDEX ( a_id, ".MENU" ) > 0 ) THEN

        IF NOT ( internal_array_slice ( self.load_menu_smw_array, a_id, a_num ) ) THEN

            a_num = SIZE_OF_ARRAY ( self.load_menu_smw_array ) + 1

        ENDIF

        self.load_menu_smw_array[a_num] = a_full_id

    ENDIF  { file is type smw_menu.menu }

    { -------------------------------------------------------- }
    { Save special load_array type DEFAULT.LAB to update       }
    { -------------------------------------------------------- }

    IF ( INDEX ( a_id, ".LAB" ) > 0 ) THEN

        IF NOT ( internal_array_slice ( self.load_menu_lab_array, a_id, a_num ) ) THEN

            a_num = SIZE_OF_ARRAY ( self.load_menu_lab_array ) + 1

        ENDIF

        self.load_menu_lab_array[a_num] = a_full_id

    ENDIF  { file is type default.lab }

    { -------------------------------------------------------- }
    { Save special load_array type for MTB to update (920)     }
    { -------------------------------------------------------- }

    IF ( INDEX ( a_id, ".MTB" ) > 0 ) THEN

        IF NOT ( internal_array_slice ( self.load_menu_mtb_array, a_id, a_num ) ) THEN

            a_num = SIZE_OF_ARRAY ( self.load_menu_mtb_array ) + 1

        ENDIF

        self.load_menu_mtb_array[a_num] = a_full_id

    ENDIF  { file is type 920 mtb file }

ENDROUTINE   {  packager_action_install_set_load_array }

{******************************************************************************}

ROUTINE packager_action_install_update_all_counts ( self )

    DECLARE a_cnt

    { --------------------------------------------- }
    { Save all counters - compile if need be        }
    { --------------------------------------------- }

    a_cnt = 1

    WHILE ( self.load_array[a_cnt,1] <> EMPTY ) DO

        IF ( self.load_array[a_cnt,2] = "CSV" ) THEN

            self.install_update_csv_count ( self.load_array[a_cnt,10], self.load_array[a_cnt,11] )

        ELSEIF ( self.load_array[a_cnt,2] = "FILE" ) THEN

            IF NOT BLANK ( self.load_array[a_cnt,9] ) THEN

                self.install_update_file_count ( self.load_array[a_cnt,7], self.load_array[a_cnt,9], self.load_array[a_cnt,8] )

                IF ( self.load_array[a_cnt,6] ) THEN

                    self.install_compile_a_file ( a_cnt )

                ENDIF

            ELSE

                self.install_update_file_count ( self.load_array[a_cnt,1], "", "" )

            ENDIF

        ELSE

            self.install_update_dll_count ( self.load_array[a_cnt,1] )

        ENDIF

        a_cnt = a_cnt + 1

    ENDWHILE

    RETURN ( TRUE )

ENDROUTINE  { packager_action_install_update_all_counts }

{******************************************************************************}

ROUTINE packager_action_install_update_csv_count (       self         ,
                                                   VALUE a_mode       ,
                                                   VALUE a_table      )
    DECLARE a_rec

    { --------------------------------------------------------------------- }
    { Hidden field so that we can have multiple ways to load single table   }
    { --------------------------------------------------------------------- }
    a_rec = self.criteria_dbase.get_by_index ( "MODE_TABLE", a_mode : a_table )

    IF ( a_rec <> EMPTY ) THEN

        ASSIGN 'C_SMP_MODULE_CRITERIA'.NO_RECORDS_LOADED  IN OBJECT a_rec = self.csv_load_count
        ASSIGN 'C_SMP_MODULE_CRITERIA'.NO_RECORDS_SKIPPED IN OBJECT a_rec = self.csv_ignore_count

    ELSE


    ENDIF

ENDROUTINE   {  packager_action_install_update_csv_count }

{******************************************************************************}

ROUTINE packager_action_install_update_file_count (       self          ,
                                                    VALUE a_file        ,
                                                    VALUE a_logical     ,
                                                    VALUE a_csv_file    )

    DECLARE a_rec,
                a_cnt

    { ---------------------------------------------------------------- }
    { Some are just single file moves, others are due to csv move      }
    { ---------------------------------------------------------------- }

    IF BLANK ( a_logical ) THEN

        a_rec = self.criteria_dbase.get_by_index ( "FILE_ID", a_file )
        a_cnt = 1

    ELSE


        a_rec         = self.criteria_dbase.get_by_index ( "FILE_LOGICAL", a_logical )
        self.?a_file? = self.?a_file? + 1
        a_cnt         = self.?a_file?

    ENDIF

    IF ( a_rec <> EMPTY ) THEN

        ASSIGN 'C_SMP_MODULE_CRITERIA'.NO_FILES_MOVED IN OBJECT a_rec = a_cnt

    ENDIF

ENDROUTINE   { packager_action_install_update_file_count }

{******************************************************************************}

ROUTINE packager_action_install_update_dll_count (       self    ,
                                                   VALUE a_file  )

    DECLARE a_rec

    a_file = internal_file_name_only ( a_file )
    a_rec  = self.dll_dbase.get_by_index ( "FILENAME_ONLY", a_file )

    IF ( a_rec <> EMPTY ) THEN

        ASSIGN 'C_SMP_MODULE_PROGRAM'.MODULE_INSTALL_OK IN OBJECT a_rec = TRUE

    ENDIF


ENDROUTINE   { packager_action_install_update_dll_count }

{******************************************************************************}

ROUTINE packager_action_install_compile_a_file (       self    ,
                                                 VALUE a_cnt   )

    DECLARE a_rec          ,
                 a_dot          ,
                 a_file         ,
                 a_compile_count,
                 a_full_file    ,
                 a_logical      ,
                 a_type

    a_logical   = self.load_array[a_cnt,9]
    a_file      = self.load_array[a_cnt,1]
    a_full_file = a_logical : "\" : a_file
    a_type      = self.load_array[a_cnt,10]   { vgl, caf, syn, etc }
    a_dot       = INDEX ( a_file, "." )

    IF ( a_dot > 0 ) THEN

        a_file = LEFTSTRING ( a_file, a_dot - 1 )

    ENDIF

    { ----------------------------------------------------------------------------- }
    { Only portions of the files copied are really compiled...                      }
    { ----------------------------------------------------------------------------- }

    IF  ( self.load_array[a_cnt,2] = "FILE"        )
    AND ( FILE EXISTS ( a_full_file )              )
    AND ( VGL_COMPILE_VGL ( a_type, a_file, TRUE ) ) THEN

        a_rec = self.criteria_dbase.get_by_index ( "FILE_LOGICAL", a_logical )

        IF ( a_rec <> EMPTY ) THEN

            a_compile_count = 1

            IF     ( a_type = LIBRARY_REPORT            ) THEN

                self.compile_rpf = self.compile_rpf + 1
                a_compile_count  = self.compile_rpf

            ELSEIF ( a_type = LIBRARY_CALCULATION       ) THEN

                self.compile_calc = self.compile_calc + 1
                a_compile_count   = self.compile_calc

            ELSEIF ( a_type = LIBRARY_LIMIT_CALCULATION ) THEN

                self.compile_limit = self.compile_limit + 1
                a_compile_count    = self.compile_limit

            ELSEIF ( a_type = LIBRARY_LIST_RESULT       ) THEN

                self.compile_list = self.compile_list + 1
                a_compile_count   = self.compile_list

            ELSEIF ( a_type = LIBRARY_SIG_FIGS          ) THEN

                self.compile_sigfig = self.compile_sigfig + 1
                a_compile_count     = self.compile_sigfig

            ELSEIF ( a_type = LIBRARY_SYNTAX            ) THEN

                self.compile_syntax = self.compile_syntax + 1
                a_compile_count     = self.compile_syntax

            ENDIF

            ASSIGN 'C_SMP_MODULE_CRITERIA'.NO_COMPILES IN OBJECT a_rec = a_compile_count

            self.write_logfile ( self.msg.15 : STRIP(a_full_file) :" ": STRIP(a_compile_count), "OK" )

        ENDIF

    ELSE

        self.write_logfile ( self.msg.24 : a_full_file, "WARNING" )

    ENDIF

ENDROUTINE    {  packager_action_install_compile_a_file }

{******************************************************************************}
{                                                                              }
{                                                                              }
{                                                                              }
{                                                                              }
{                  ROUTINES USED BY THE MENU REBUILD                           }
{                                                                              }
{                                                                              }
{                                                                              }
{                                                                              }
{******************************************************************************}

ROUTINE packager_action_menu_rebuild_master ( self  )

    DECLARE a_cnt       ,
            a_cnt2      ,
                a_line      ,
                a_comma     ,
                stlen       ,
                a_num       ,
                a_valid_num ,
                a_file      ,
                a_array

    retval = TRUE

    IF ( SIZE_OF_ARRAY ( self.load_menu_master_array ) > 0  ) THEN

        a_cnt2 = 1
        a_file = self.load_menu_master_array[a_cnt2]

        WHILE ( a_file <> EMPTY ) AND ( retval ) DO

            IF ( INDEX ( a_file, "AUTO_PROCEDURE" ) = 0 ) THEN

                self.write_logfile ( a_file, "OK" )

                ARRAY a_array

                FILE OPEN a_file, status

                FILE READ a_file, a_array[1], status
                FILE READ a_file, a_array[2], status
                FILE READ a_file, a_array[3], status
                FILE READ a_file, a_array[4], status

                { ----------------------------------------------------------------------- }
                { Check if someone is trying to be a bit cute...                          }
                { ----------------------------------------------------------------------- }

                IF ( status <> EMPTY ) OR ( LEFTSTRING ( a_array[2], 13 ) <> "PROCEDURE_NUM" ) THEN

                    retval         = FALSE
                    self.error_msg = internal_translate_message ( "LIT_LAB_SMP_MODULE_ERROR_PROCEDURE" ) : status

                ELSE

                    { ----------------------------------------------------------------------- }
                    { Read all lines from CSV so we can check each procedure_num              }
                    { ----------------------------------------------------------------------- }

                    a_cnt = 5

                    WHILE ( status = EMPTY ) DO

                        FILE READ a_file, a_line, status

                        IF ( status = EMPTY ) THEN

                            a_line         = STRIP ( a_line )
                            a_comma        = INDEX ( a_line, "," )
                            stlen          = STRINGLENGTH ( a_line )
                            a_num          = SUBSTITUTE ( LEFTSTRING  ( a_line, a_comma - 1 ), ASCII(34), "" )     { procedure, 1rst element }
                            a_array[a_cnt] = RIGHTSTRING ( a_line, stlen - a_comma )                               { rest of the line        }

                            IF NOT NUMTEXT ( a_num ) THEN

                                retval         = FALSE
                                status         = internal_translate_message ( "LIT_LAB_SMP_MODULE_ERROR_PROCEDURE" ): a_num
                                self.error_msg = status

                            ELSE

                                a_num       = NUMERIC ( a_num )
                                a_valid_num = SELECT MASTER_MENU.PROCEDURE_NUM WHERE PROCEDURE_NUM = a_num

                                IF ( a_valid_num <> EMPTY ) AND ( self.menu_set_proc_num ( a_num ) ) THEN

                                    a_array[a_cnt]         = ASCII(34) : STRIP ( a_num ) : ASCII(34) : "," : a_array[a_cnt]
                                    self.load_menu_changed = TRUE

                                ELSE

                                    a_array[a_cnt] = a_line

                                ENDIF  { is it already in database }

                            ENDIF  { is the procedure a number ? }

                        ENDIF  { status empty on read }

                        a_cnt = a_cnt + 1

                    ENDWHILE  { status is empty }

                    retval = self.menu_check_EOF ( a_array, a_file, "MASTER_MENU", status )

                ENDIF  { first 4 reads and 1rst field is procedure number }

            ENDIF  { do not redo the auto_procedures... }

            { -------------------------------------------------------------------- }
            { Get next file from the kit that is master menu csv file              }
            { -------------------------------------------------------------------- }

            a_cnt2 = a_cnt2 + 1
            a_file = self.load_menu_master_array[a_cnt2]

        ENDWHILE   { each master menu csv (1 could be overwrite another append }

    ENDIF   { no master menu in kit }

    RETURN ( retval )

ENDROUTINE  { packager_action_menu_rebuild_master }

{******************************************************************************}

ROUTINE packager_action_menu_rebuild_smw ( self )

    DECLARE a_cnt       ,
            a_cnt2      ,
                a_line      ,
                a_comma     ,
                stlen       ,
                a_num       ,
                a_valid_num ,
                a_file      ,
                a_array

{  - - - - - - - - - - - - - - - -

    PROCEDURE_NUM,DESCRIPTION,SHORT_TEXT,MNEMONIC,LIBRARY,ROUTINE,TYPE,MENU_NAME,ENTRY_NUMBER,MENU_NUMBER,ORDER_NUMBER,OPTION_NUMBER,OPTION_NAME
    <NULL>,<NULL>,<NULL>,<NULL>,<NULL>,<NULL>,<NULL>,"SYSTEM","1248","20","17","100010","Package/Install"
    "100001","SMP_MODULE Open...","Open...","SMOP","$QUERY","EXECUTEDEFAULTCRITERIAOPTION","MENU","SYSTEM","1249","100010","1","100001","Open..."

- - - - - - - - - - - - - - - - - - }

    retval = TRUE

    ARRAY a_array

    IF ( SIZE_OF_ARRAY ( self.load_menu_smw_array ) > 0  ) THEN

        a_cnt2 = 1
        a_file = self.load_menu_smw_array[a_cnt2]

        WHILE ( a_file <> EMPTY ) AND ( retval ) DO

            IF ( INDEX ( a_file, "AUTO_PROCEDURE" ) = 0 ) THEN

                self.write_logfile ( a_file, "OK" )

                ARRAY a_array

                FILE OPEN a_file            , status
                FILE READ a_file, a_array[1], status

                { ----------------------------------------------------------------------- }
                { Check if someone is trying to be a bit cute...                          }
                { ----------------------------------------------------------------------- }

                IF ( status = EMPTY ) AND ( LEFTSTRING ( a_array[1], 13 ) <> "PROCEDURE_NUM" ) THEN

                    retval         = FALSE
                    status         = internal_translate_message ( "LIT_LAB_SMP_MODULE_ERROR_PROCEDURE" )
                    self.error_msg = status

                ELSE

                    { ----------------------------------------------------------------------- }
                    { Read all lines from CSV so we can check each procedure_num              }
                    { ----------------------------------------------------------------------- }

                    a_cnt = 2

                    WHILE ( status = EMPTY ) AND ( retval ) DO

                        FILE READ a_file, a_line, status

                        IF ( status = EMPTY ) AND ( INDEX ( a_line, "<NULL>" ) = 0 ) THEN

                            a_line         = STRIP ( a_line )
                            a_comma        = INDEX ( a_line, "," )
                            stlen          = STRINGLENGTH ( a_line )
                            a_num          = SUBSTITUTE ( LEFTSTRING  ( a_line, a_comma - 1 ), ASCII(34), "" )   { 1rst element procedure... }
                            a_array[a_cnt] = RIGHTSTRING ( a_line, stlen - a_comma )                             { rest of line...           }

                            IF NOT NUMTEXT ( a_num ) THEN

                                retval         = FALSE
                                status         = internal_translate_message ( "LIT_LAB_SMP_MODULE_ERROR_PROCEDURE" ) : a_num
                                self.error_msg = status

                            ELSE

                                a_num       = NUMERIC ( a_num )
                                a_valid_num = SELECT MASTER_MENU.PROCEDURE_NUM WHERE PROCEDURE_NUM = a_num

                                IF ( a_valid_num <> EMPTY ) AND ( self.menu_set_proc_num ( a_num ) ) THEN

                                    self.menu_build_smw_line ( a_array, a_num, a_cnt )
                                    self.load_menu_changed = TRUE

                                ELSE

                                    a_array[a_cnt] = a_line

                                ENDIF  { is it already in database }

                            ENDIF  { is the procedure a number ? }

                        ELSEIF ( status = EMPTY ) THEN

                            a_array[a_cnt] = a_line           { must be a NULL (menu group or separator) }

                        ENDIF  { status empty on read and not a NULL }

                        a_cnt = a_cnt + 1

                    ENDWHILE  { status is empty }

                    { ---------------------------------------------------------------- }
                    { Check EndOfFile and if so, then the file is rewritten            }
                    { ---------------------------------------------------------------- }

                    retval = self.menu_check_EOF ( a_array, a_file, "SMW_MENU", status )

                ENDIF  { first line of .menu and 1rst field is procedure number }

            ENDIF   { do not redo auto_procedure files }

            { -------------------------------------------------------------------- }
            { Get next file from the kit that is master menu csv file              }
            { -------------------------------------------------------------------- }

            a_cnt2 = a_cnt2 + 1
            a_file = self.load_menu_smw_array[a_cnt2]

        ENDWHILE   { each .menu file }

    ENDIF   { no smw menu in kit }

    RETURN ( retval )

ENDROUTINE  { packager_action_menu_rebuild_smw }

{******************************************************************************}

ROUTINE packager_action_menu_build_smw_line (       self    ,
                                                    a_array ,
                                              VALUE a_num   ,
                                              VALUE a_cnt   )

    DECLARE comma_cnt,
            a_comma  ,
            a_len    ,
            mid_line ,
            remainder

    { ------------------------------------------------------------------------------------- }
    { SMW menu has 2 places the same numbers is stored - must change both 10 commas...      }
    { ------------------------------------------------------------------------------------- }

    a_num          = ASCII(34) : STRIP ( a_num ) : ASCII(34)
    comma_cnt      = 0
    a_array[a_cnt] = STRIP ( a_array[a_cnt]      )
    a_comma        = INDEX ( a_array[a_cnt], "," )
    mid_line       = ""
    a_len          = STRINGLENGTH ( a_array[a_cnt] )
    remainder      = a_array[a_cnt]

    WHILE ( comma_cnt <= 9 ) DO

        comma_cnt = comma_cnt + 1
        mid_line  = mid_line : LEFTSTRING ( remainder, a_comma )
        remainder = RIGHTSTRING ( remainder, a_len - a_comma )
        a_comma   = INDEX ( remainder, "," )
        a_len     = STRINGLENGTH ( remainder )

    ENDWHILE

    a_comma   = INDEX ( remainder, "," )
    remainder = RIGHTSTRING ( remainder, a_len - a_comma )

    { --------------------------------------------------------------------------------------------- }
    { Got the 4 parts, 1st element new proc num, middle line, new proc num (again) and rest of line }
    { --------------------------------------------------------------------------------------------- }

    a_array[a_cnt] = a_num : "," : mid_line : a_num : "," : remainder

    self.write_logfile ( a_cnt : " " : a_array[a_cnt], "OK" )

    RETURN ( TRUE )

ENDROUTINE  {  packager_action_menu_build_smw_line }

{******************************************************************************}

ROUTINE packager_action_menu_rebuild_lab ( self )

    DECLARE a_cnt       ,
            a_cnt2      ,
                a_line      ,
                a_file      ,
                a_array

{ - - - - - - - - - - - - - - - - -

    ! Table                Message         :   ADD   CPY   MOD   DIS   PRI   LIS   REM   RES   TST   DEB
    !
    !
    SMP_MODULE          SMP Module         : 100002 100003 100005 100006 100007 100008 000 000   000   000
    !

- - - - - - - - - - - - - - - - - - }

    retval = TRUE

    ARRAY a_array

    IF ( SIZE_OF_ARRAY ( self.load_menu_lab_array ) > 0  ) THEN

        a_cnt2 = 1
        a_file = self.load_menu_lab_array[a_cnt2]

        WHILE ( a_file <> EMPTY ) AND ( retval ) DO

            IF ( INDEX ( a_file, "AUTO_PROCEDURE" ) = 0 ) THEN

                self.write_logfile ( a_file, "OK" )

                ARRAY a_array

                FILE OPEN a_file, status

                { ----------------------------------------------------------------------- }
                { Read all lines from LAB so we can check each procedure_num              }
                { ----------------------------------------------------------------------- }

                a_cnt = 1

                WHILE ( status = EMPTY ) AND ( retval ) DO

                    FILE READ a_file, a_line, status

                    IF ( status = EMPTY ) AND ( INDEX ( a_line, "!" ) = 0 ) THEN

                        retval = self.menu_build_lab_line ( a_array, a_line, a_cnt )

                    ELSEIF ( status = EMPTY ) THEN

                        a_array[a_cnt] = a_line

                    ENDIF

                    a_cnt = a_cnt + 1

                ENDWHILE  { status is empty }

                retval = self.menu_check_EOF ( a_array, a_file, "DEFAULT_LAB", status )

            ENDIF  { do not redo auto_procedure }

            { -------------------------------------------------------------------- }
            { Get next file from the kit that is master menu csv file              }
            { -------------------------------------------------------------------- }

            a_cnt2 = a_cnt2 + 1
            a_file = self.load_menu_lab_array[a_cnt2]

        ENDWHILE   { each lab file }

    ENDIF   { no .lab in kit }

    RETURN ( retval )

ENDROUTINE  { packager_action_menu_rebuild_lab }

{******************************************************************************}

ROUTINE packager_action_menu_build_lab_line (       self    ,
                                                    a_array ,
                                                    a_line  ,
                                              VALUE a_cnt   )

    DECLARE a_colon  ,
            a_new_1  ,
            a_len    ,
            a_space  ,
            remainder,
                 a_add_on

    { ------------------------------------------------------------------------------------- }
    { .LAB files have all procedures on one line, may need to replace all of them           }
    {  SMP_MODULE          SMP Module         : 100002 100003 100005 100006 100007 ...      }
    { ------------------------------------------------------------------------------------- }

    a_add_on = ""
    a_line   = STRIP ( a_line        )
    a_colon  = INDEX ( a_line, ":"   )
    a_len    = STRINGLENGTH ( a_line )

    IF ( a_colon > 0 ) THEN

        a_array[a_cnt] = LEFTSTRING ( a_line, a_colon )
        remainder      = STRIP ( RIGHTSTRING ( a_line, a_len - a_colon ) )
        a_space        = INDEX ( remainder, " " )
        a_new_1        = STRIP ( LEFTSTRING ( remainder, a_space ) )
        a_len          = STRINGLENGTH ( remainder )
        remainder      = STRIP ( RIGHTSTRING ( remainder, a_len - a_space ) )

        WHILE ( NOT BLANK ( remainder ) ) AND ( NOT BLANK ( a_new_1 ) ) DO

            IF ( NUMTEXT ( a_new_1 ) ) THEN

                a_new_1 = NUMERIC ( a_new_1 )

                self.menu_set_proc_num ( a_new_1 )

                a_add_on = a_add_on : " " : STRIP ( a_new_1 )

            ENDIF

            remainder = STRIP ( remainder      )
            a_len     = STRINGLENGTH ( remainder )
            a_space   = INDEX ( remainder, " " )
            a_new_1   = STRIP ( LEFTSTRING ( remainder, a_space ) )
            remainder = STRIP ( remainder # a_new_1 )

        ENDWHILE

        a_array[a_cnt] = a_array[a_cnt] : a_add_on : " " : remainder

    ENDIF   { no colon then not really a line for the .lab }

    self.write_logfile ( a_cnt : " " : a_array[a_cnt], "OK" )

    RETURN ( TRUE )

ENDROUTINE  {  packager_action_menu_build_lab_line }

{******************************************************************************}

ROUTINE packager_action_menu_rebuild_mtb ( self )

    DECLARE a_cnt       ,
            a_cnt2      ,
                a_line      ,
                a_file      ,
                a_array

{ - - - - - - - - - - - - - - - - -

    "1","0","Package/Install","MENU","0","USER_MENU","","TRUE"
    "2","1","Open...","ITEM","100001","","","FALSE"
    "3","1","Add","ITEM","100002","","","TRUE"

- - - - - - - - - - - - - - - - - - }

    retval = TRUE

    ARRAY a_array

    IF ( SIZE_OF_ARRAY ( self.load_menu_mtb_array ) > 0  ) THEN

        a_cnt2 = 1
        a_file = self.load_menu_mtb_array[a_cnt2]

        WHILE ( a_file <> EMPTY ) AND ( retval ) DO

            IF ( INDEX ( a_file, "AUTO_PROCEDURE" ) = 0 ) THEN

                self.write_logfile ( a_file, "OK" )

                ARRAY a_array

                FILE OPEN a_file, status

                { ----------------------------------------------------------------------- }
                { Read all lines from LAB so we can check each procedure_num              }
                { ----------------------------------------------------------------------- }

                a_cnt = 1

                WHILE ( status = EMPTY ) AND ( retval ) DO

                    FILE READ a_file, a_line, status

                    IF ( status = EMPTY ) AND ( INDEX ( a_line, "," : ASCII(34) : "ITEM" : ASCII(34) : "," ) > 0 ) THEN

                        retval = self.menu_build_mtb_line ( a_array, a_line, a_cnt )

                    ELSEIF ( status = EMPTY ) THEN

                        a_array[a_cnt] = a_line

                    ENDIF

                    a_cnt = a_cnt + 1

                ENDWHILE  { status is empty }

                retval = self.menu_check_EOF ( a_array, a_file, "SM_920_MTB", status )

            ENDIF  { do not redo auto_procedures }

            { -------------------------------------------------------------------- }
            { Get next file from the kit that is master menu csv file              }
            { -------------------------------------------------------------------- }

            a_cnt2 = a_cnt2 + 1
            a_file = self.load_menu_mtb_array[a_cnt2]

        ENDWHILE   { each mtb file }

    ENDIF   { no .mtb in kit }

    RETURN ( retval )

ENDROUTINE  { packager_action_menu_rebuild_mtb }

{******************************************************************************}

ROUTINE packager_action_menu_build_mtb_line (       self    ,
                                                    a_array ,
                                                    a_line  ,
                                              VALUE a_cnt   )

    DECLARE a_item   ,
            a_new_1  ,
            a_len    ,
            a_comma  ,
            remainder

    { ------------------------------------------------------------------------------------- }
    { .MTB is only one place and after the ,"ITEM","<procedure>",...                        }
    { ------------------------------------------------------------------------------------- }

    a_line = STRIP ( a_line        )
    a_len  = STRINGLENGTH ( a_line )
    a_item = INDEX ( a_line, "ITEM" : ASCII(34) : "," )

    IF ( a_item > 0 ) THEN

        a_array[a_cnt] = LEFTSTRING ( a_line, a_item + 5 )
        remainder      = STRIP ( RIGHTSTRING ( a_line, a_len - a_item - 5 ) )
        a_comma        = INDEX ( remainder, ASCII(34) : "," )
        a_len          = STRINGLENGTH ( remainder )
        a_new_1        = STRIP ( LEFTSTRING ( remainder, a_comma ) # ASCII(34) # ASCII(34) )
        remainder      = RIGHTSTRING ( remainder, a_len - a_comma )

        IF ( NUMTEXT ( a_new_1 ) ) THEN

            a_new_1 = NUMERIC ( a_new_1 )

            self.menu_set_proc_num ( a_new_1 )

            a_new_1 = STRIP ( a_new_1 )

        ENDIF

        a_line         = a_array[a_cnt] : ASCII(34) : a_new_1 : ASCII(34) : remainder
        a_array[a_cnt] = a_line

    ENDIF   { no ITEM then not really a line for the .mtb }

    self.write_logfile ( a_cnt : " " : a_line, "OK" )

    RETURN ( TRUE )

ENDROUTINE  {  packager_action_menu_build_mtb_line }

{******************************************************************************}

ROUTINE packager_action_menu_check_EOF (       self        ,
                                               write_array ,
                                         VALUE a_file      ,
                                         VALUE a_table     ,
                                         VALUE status      )


    retval = TRUE

    { ----------------------------------------------------------------------- }
    { Anything but EndOfFile status is not good... if EOF close source file   }
    { ----------------------------------------------------------------------- }

    IF ( status = GET_USER_MESSAGE ( "RPC_K_EOFTXTFIL", 1 ) ) THEN

        FILE CLOSE a_file, status

        { ----------------------------------------------------------------------- }
        { Read file ok, procedures checked and changed if need, rewrite the file  }
        { ----------------------------------------------------------------------- }

        IF ( self.load_menu_changed ) THEN

            IF ( NOT ( self.menu_rewrite_file( write_array, a_file, a_table ) ) ) THEN

                retval         = FALSE
                self.error_msg = self.msg.43 : self.error_msg

                self.write_logfile(self.error_msg, "ERROR")

            ENDIF

        ENDIF

    ELSE

        retval         = FALSE
        self.error_msg = self.msg.44 : status

        self.write_logfile(self.error_msg, "ERROR")

    ENDIF

    retval = ( retval ) AND ( status = EMPTY )

    RETURN ( retval )

ENDROUTINE  { packager_action_menu_check_EOF }

{******************************************************************************}

ROUTINE packager_action_menu_rewrite_file (       self        ,
                                                  write_array ,
                                            VALUE a_file      ,
                                            VALUE a_table     )

    DECLARE a_copy_file,
                 a_save_file,
                 a_dot      ,
                 a_cnt      ,
                 a_len      ,
                 a_ext

    retval      = TRUE
    a_file      = STRIP ( a_file )
    a_len       = STRINGLENGTH ( a_file )
    a_dot       = INDEX ( a_file, "." )
    a_ext       = RIGHTSTRING ( a_file, a_len - a_dot )
    a_copy_file = LEFTSTRING ( a_file, a_dot - 1 ) : "_AUTO_PROCEDURE." : a_ext
    a_save_file = LEFTSTRING ( a_file, a_dot - 1 ) : "_before_auto.txt"
    status      = EMPTY

    IF ( FILE EXISTS ( a_copy_file ) ) THEN

        FILE DELETE a_copy_file, status

    ENDIF

    IF ( status = EMPTY ) THEN

        FILE CREATE a_copy_file, status
        FILE EXTEND a_copy_file, status

        IF ( status <> EMPTY ) THEN

            retval         = FALSE
            self.error_msg = self.msg.45 : "EXTEND" : a_copy_file : status

            self.write_logfile(self.error_msg, "ERROR")

        ELSE

            a_cnt = 1

            WHILE ( status = EMPTY ) AND ( write_array[a_cnt] <> EMPTY ) DO

                FILE WRITE a_copy_file, write_array[a_cnt], status

                IF ( status <> EMPTY ) THEN

                    retval         = FALSE
                    self.error_msg = self.msg.45 : " WRITE " : a_copy_file : write_array[a_cnt] : status

                    self.write_logfile(self.error_msg, "ERROR")

                ENDIF

                a_cnt = a_cnt + 1

            ENDWHILE   { all the lines in the array are written ok }

        ENDIF   { status on extend }

        { ------------------------------------------------------------------------ }
        { Close the file and check if any errors so it can be loaded               }
        { ------------------------------------------------------------------------ }

        FILE CLOSE a_copy_file, status

        IF ( status <> EMPTY ) THEN

            retval         = FALSE
            self.error_msg = self.msg.45 : " CLOSE " : a_copy_file : status

            self.write_logfile(self.error_msg, "ERROR")

        ELSE

            { ------------------------------------------------------------------------ }
            { Everything is excellent, now rename the old file to a non-loadable file  }
            { ------------------------------------------------------------------------ }

            FILE COPY a_file, a_save_file, status

            IF ( status = EMPTY ) THEN

                FILE DELETE a_file, status

                self.error_msg = C_OK_SUFFIX : a_save_file

                self.write_logfile(self.error_msg, "OK")

            ELSE

                self.error_msg = C_FAIL_SUFFIX : a_save_file : status

                self.write_logfile(self.error_msg, "WARNING")

            ENDIF

        ENDIF

    ELSE

        retval         = FALSE
        self.error_msg = self.msg.45 : " DELETE " : status

        self.write_logfile(self.error_msg, "ERROR")

    ENDIF

    RETURN ( retval )

ENDROUTINE  { packager_action_menu_rewrite_file }

{******************************************************************************}

ROUTINE packager_action_menu_set_proc_num (       self               ,
                                                  a_procedure_number )

    DECLARE check_1 ,
            a_new_1 ,
                 a_remain,
                 save_format

    save_format = GLOBAL ( "FORMAT_TEXT" )

    SET FORMAT "9999999999"

    retval      = TRUE
    a_remain    = a_procedure_number MOD 10

    IF ( a_remain = 0 ) THEN

        self.write_logfile ( C_OK_SUFFIX: a_procedure_number, "OK" )

    ELSE

        check_1 = self.smw_menu_dbase.get_by_index ( "PROCEDURE_NUM", a_procedure_number )

        IF ( check_1 <> EMPTY ) THEN

            a_new_1 = SELECT 'C_SMP_MODULE_MENU'.NEW_PROCEDURE_NUM IN OBJECT check_1

            IF ( a_new_1 <> a_procedure_number ) THEN

                a_procedure_number = a_new_1

                self.write_logfile ( a_procedure_number, "OK" )

            ELSE
                self.write_logfile ( C_OK_SUFFIX : "<->" : a_procedure_number, "OK" )

            ENDIF

        ELSE

            retval         = FALSE
            self.error_msg = internal_translate_message ( "LIT_LAB_SMP_MODULE_ERROR_PROCEDURE" ) : a_procedure_number

            self.write_logfile ( C_FAIL_SUFFIX: a_procedure_number, "ERROR" )

        ENDIF  { get by index had no number for this one }

    ENDIF  { MOD 10 is a submenu }

    SET FORMAT save_format

    RETURN ( retval )

ENDROUTINE  { packager_action_menu_set_proc_num }

{******************************************************************************}

ROUTINE packager_action_menu_check_main ( self )

    DECLARE save_format

    retval = TRUE

    { ------------------------------------------------------------ }
    { Read in the menu table for the new procedure numbers         }
    { ------------------------------------------------------------ }

    CREATE OBJECT C_STD_OBJECT_DATABASE, self.smw_menu_dbase
        self.smw_menu_dbase.initialise ( self.smw_menu_table )
        self.smw_menu_dbase.select ( self.criteria_array )
        self.smw_menu_dbase.add_index ( "PROCEDURE_NUM"     )

    { ----------------------------------------------------------- }
    { Rebuild files (master, smw, .lab, .mtb) with new proc numbs }
    { ----------------------------------------------------------- }

    save_format = GLOBAL ( "FORMAT_TEXT" )

    SET FORMAT "9999999999"

    IF ( self.smw_menu_dbase.size() > 0 ) THEN

        IF ( self.menu_rebuild_master() ) THEN

            IF ( self.menu_rebuild_smw() ) THEN

                IF ( self.menu_rebuild_lab() ) THEN

                    retval = self.menu_rebuild_mtb()

                ENDIF

            ENDIF

        ENDIF

    ENDIF   { nothing to do, size of dbase is 0 }

    { --------------------------------------------------------------------------- }
    { All done and if ok then show the user, else write to logfile last error msg }
    { --------------------------------------------------------------------------- }

    IF retval THEN

        self.error_msg = internal_translate_message ( "LIT_LAB_SMP_MODULE_SMW_MENU_CONTEXT" ) : C_OK_SUFFIX
        self.write_logfile(self.error_msg, "OK")

        FLASH_MESSAGE ( self.error_msg, TRUE )

    ELSE

        self.write_logfile( C_FAIL_SUFFIX : self.error_msg, "ERROR")

        FLASH_MESSAGE ( C_FAIL_SUFFIX : self.error_msg, TRUE )

    ENDIF

    SET FORMAT save_format

    RETURN ( retval )

ENDROUTINE   { packager_action_menu_check_main }

{******************************************************************************}
{                                                                              }
{                                                                              }
{ **************************  CLASS DEFINITIONS ****************************** }
{                                                                              }
{                                                                              }
{******************************************************************************}

ROUTINE define_packager_class

    DEFINE CLASS CLASS_PACKAGER_CLASS INHERIT "STD_OBJECT_DATABASE" INITIALISATION

    PROPERTIES

            "allowed_to_prompt"         , { Used by table loader during install csv's  }
            "ae_prod_id"                , { Array element for MLP VALUEs product id    }
            "ae_prod_vers"              , { Array element for MLP VALUEs product vers  }
            "ae_anal_id"                , { Array element for MLP VALUEs analysis id   }
            "ae_comp_name"              , { Array element for MLP VALUEs component     }
            "a_false"                   , { False used by table loader                 }
            "a_true"                    , { TRUE used by table loader                  }
            "a_first"                   , { TRUE if very first self install of pkgr    }
            "a_mode"                    , { load mode of table loader                  }
            "a_table"                   , { a table name from csv table loader         }
            "append_structure_array"    , { Array lines to add to structure.txt        }
            "caf_directory"             , { Prompt 1 time on install for all caf's     }
            "compile_rpf"               , { Counters for vgl compile                   }
            "compile_calc"              , { Counters for calculations compile          }
            "compile_limit"             , { Counters for limit_calc compile            }
            "compile_list"              , { Counters for list result compile           }
            "compile_sigfig"            , { Counters for sig figs compile              }
            "compile_syntax"            , { Counters for syntax compile                }
            "criteria_array"            , { table of tables + criteria to save         }
            "criteria_dbase"            , { Object database smp_module_criteria        }
            "criteria_table"            , {                 smp_module_criteria        }
            "criteria_versioned"        , { Boolean if criteria is versioned           }
            "crt_directory"             , { Prompt 1 time on install for all crt's     }
            "csv_approval_field"        , { Approval field name for a table            }
            "csv_appr_fld_no"           , { Field no in fields array of the approve    }
            "csv_base_table"            , { Master table for set loads of csv files    }
            "csv_base_key0"             , { Master key0 for version loading            }
            "csv_error_msg"             , { Error during csv processing                }
            "csv_file"                  , { A specific file being loaded               }
            "csv_header_table"          , { Table that is start of all loads           }
            "csv_key0"                  , { catenated values of all fields for key0    }
            "csv_key0_fields"           , { Array of field names for key0 table load   }
            "csv_key0_select_array"     , { Array select of fields + values            }
            "csv_key0_val_array"        , { Array of the values only for key0          }
            "csv_EOF_msg"               , { End of File message when read csv files    }
            "csv_fields_array"          , { Array field names of table loaded          }
            "csv_field_length_array"    , { Array field lengths table loaded           }
            "csv_ignore_count"          , { counter of number ignored on load csv      }
            "csv_line"                  , { 1 line read from csv file                  }
            "csv_line_count"            , { Number of line from csv (header also)      }
            "csv_load_count"            , { counter of number loaded from csv          }
            "csv_mode"                  , { Load mode (OVER,ERASE,IGNORE)              }
            "csv_new_version"           , { Boolean if new version of entities made    }
            "csv_new_entry_code"        , { Boolean if new entry code MLP is made      }
            "csv_no_read"               , { Number of data records read from csv       }
            "csv_no_to_load"            , { # records to load from a CSV               }
            "csv_return_msg"            , { return from read of csv files              }
            "csv_show_key"              , { Table + catenated values for reporting     }
            "csv_skip"                  , { Boolean if record is skipped on load       }
            "csv_skip_count"            , { counter of number skipped from csv         }
            "csv_save_array"            , { array of files from table_save files       }
            "csv_table_to_load"         , { Table being loaded                         }
            "csv_vers_field"            , { CSV version field caption                  }
            "csv_vers_field_no"         , { CSV version number in array                }
            "csv_value_array"           , { Values from the csv file in an array       }
            "dll_dbase"                 , { Object database smp_module_program         }
            "dll_table"                 , {                 smp_module_program         }
            "error_msg"                 , { generic error message                      }
            "fd_only"                   , { only the filename part of a kit            }
            "files_updated"             , { Boolean read from smp_module already done  }
            "file_save_array"           , { array of files txt,doc,userfiles           }
            "identity"                  , { key2 ...                                   }
            "install_select_dir"        , { Boolean allow user to select dir install   }
            "install_set_dir"           , { directory where all is written             }
            "install_set"               , { filename of installation kit made          }
            "install_set_kit_dir"       , { directory where all read from              }
            "install_set_zip_id"        , { Id of the ZIP file destination             }
            "install_set_sfx_id"        , { Id self extract EXE file destination       }
            "install_set_source"        , { Id of file being moved                     }
            "install_date_time"         , { Date/time for filenames of install         }
            "install_continue_all"      , { load continue all no more veto prompt      }
            "is_version_0_kit"          , { If version 0 then build does special skip  }
            "is_export_set"             , { If this pkg is for export/import only      }
            "key0"                      , { catenated key with blanks pad to widths    }
            "key0_noblanks"             , { compressed value of all keys               }
            "key0_underscore"           , { compressed with underscore all keys        }
            "key1_len"                  , { stringlength key1 smp_module.smp_version   }
            "key2_len"                  , { stringlength key2 smp_module.identity      }
                                          { packed_dec   key3 smp_module.version_number}
            "loaded_ok"                 , { boolean if 1 csv loaded ok                 }
            "load_array"                , { Array of all loads and counts              }
            "load_menu_lab_array"       , { Array of default.lab files                 }
            "load_menu_master_array"    , { Array of master menu csv PROCEDURE_NUM     }
            "load_menu_smw_array"       , { Array of smw_menu.menu files               }
            "load_menu_mtb_array"       , { Array of 920 mtb files                     }
            "load_menu_changed"         , { Boolean if a new procedure num required    }
            "load_messages_array"       , { Array of messages.txt files                }
            "load_structure_array"      , { Array of structure.txt files               }
            "logfile"                   , { The logfile for installation process       }
            "log_is_good"               , { Boolean if logging of messages             }
            "menu_check"                , { If menu start point is check menu numbers  }
            "messages_updated"          , { Boolean read from smp_module already done  }
            "message_txt_array"         , { Array read from messages.txt of files      }
            "module_record"             , { STD_OBJECT_RECORD smp_module.key0          }
            "msg"                       , { All messages for translation               }
            "mlp_csv_array"             , { Array of import files for MLP special load }
            "program_dll_array"         , { table of dll's or exe's or xml etc         }
            "return_msg"                , { Return msg from csv table loader           }
            "rpf_directory"             , { Prompt 1 time on install for all rpf's     }
            "save_array"                , { array of table_save files to make          }
            "set_approval_status"       , { Single byte config item for import static  }
            "sm_version_0_Ok"           , { Boolean if necessary files to make V0 kit  }
            "smp_structure_array"       , { Array lines already in structure.txt       }
            "smp_structure_ok"          , { Boolean if smp_structure is in system      }
            "SMP_CALCULATIONS"          , { Logical counters files moved/compiled      }
            "SMP_CRITERIA"              , { Logical counters files moved/compiled      }
            "SMP_REPORTS"               , { Logical counters files moved/compiled      }
            "SMP_LIMIT_CALCULATIONS"    , { Logical counters files moved/compiled      }
            "SMP_LIST_RESULTS"          , { Logical counters files moved/compiled      }
            "SMP_SIG_FIGS"              , { Logical counters files moved/compiled      }
            "SMP_SYNTAXES"              , { Logical counters files moved/compiled      }
            "smp_version"               , { key1 of key0 array                         }
            "smw_menu_updated"          , { Boolean read from smp_module already done  }
            "smw_menu_dbase"            , { Object database of smp_module_menu table   }
            "smw_menu_table"            , { Table used by smw_menu_dbase               }
            "stage_of_install"          , { Boolean read from smp_module if 2 stages   }
            "structure_updated"         , { Boolean read from smp_module already done  }
            "subdir_array"              , { Array of all directories from criteria     }
            "subdir_2_array"            , { Array of subdirectories FILE_SUB_DIR...    }
            "sxf_directory"             , { Prompt 1 time on install for all sxf's     }
            "userinfo"                  , { User value for triggers                    }
            "version_number"            , { key3 ...                                   }
            "version_array"             , { keep master version table new_version      }
            "continue_array"            , { Veto table by table on load                }
            "uninstall_dir"             , { Directory for uninstall copy files         }
            "zip_type"                    { Exe (self extracting) or Zip               }

        ACTIONS

            "call_trigger"               , { call a user trigger                        }
            "close_logfile"              , { close logfile                              }
            "create_logfile"             , { create logfile                             }
            "set_msg_translations"       , { decode message pointers for translations   }
            "write_logfile"              , { write to logfile for install               }
            "package_build_key0"         , { find identity of csv files for save data   }
            "package_copy_a_file"        , { copy the file from input to install kit    }
            "package_create_cmd_zip"     , { make a zip file using good ole cmd         }
            "package_create_exe"         , { make SFX for self extract exe              }
            "package_load_criteria"      , { load child table smp_module_criteria       }
            "package_load_dll"           , { load child table smp_module_program        }
            "package_save_data"          , { save all table_saves from module_criteria  }
            "package_save_files"         , { save all files from program_dll table      }
            "package_select_1_file"      , { Interactive select target files            }
            "package_select_file"        , { search list find files and choose one      }
            "package_select_files_array" , { Interactive select target files            }
            "package_subdirs"            , { make all sub-directories of kit            }
            "package_update_smp_file"    , { update the smp_module with kit data        }
            "package_update_dbase"       , { do the final database update               }
            "install_1_csv"              , { INSTALL load a single csv/rename           }
            "install_920_mtb"            , { INSTALL update all .mtb files in kit       }
            "install_920_mtb_file"       , { INSTALL update a single .mtb file          }
            "install_append_structure"   , { INSTALL if need to add lines to structure  }
            "install_compile_a_file"     , { INSTALL compile all that needed to on load }
            "install_continue_load"      , { INSTALL veto in table saver                }
            "install_copy_dll"           , { INSTALL SMP$EXE files                      }
            "install_copy_1_file"        , { INSTALL move (and keep old copy) of a file }
            "install_create_convert"     , { INSTALL run create/convert                 }
            "install_create_message"     , { INSTALL run create_message                 }
            "install_csv_assign_fields"  , { INSTALL CSV assign all fields              }
            "install_csv_clean_table"    , { INSTALL CSV get rid of existing data       }
            "install_csv_create_version" , { INSTALL CSV create new version of record   }
            "install_csv_files"          , { INSTALL CSV load all criteria files        }
            "install_csv_get_key0"       , { INSTALL CSV get the key0 of to load record }
            "install_csv_get_appr_fld_no", { INSTALL CSV get approval fld number        }
            "install_csv_line_2_array"   , { INSTALL CSV convert line to array          }
            "install_csv_load"           , { INSTALL CSV load data                      }
            "install_csv_load_data"      , { INSTALL CSV main for loading data          }
            "install_csv_lock_table"     , { INSTALL CSV make sure no conflict on load  }
            "install_csv_read_header"    , { INSTALL CSV read header of csv file        }
            "install_csv_read_1_line"    , { INSTALL CSV read a single line from file   }
            "install_csv_reset_fields"   , { INSTALL CSV change entry_code, status, etc }
            "install_csv_valid_fields"   , { INSTALL CSV validate field names from file }
            "install_csv_valid_lengths"  , { INSTALL CSV lengths from file ok with db   }
            "install_csv_write_1_record" , { INSTALL CSV write a specific record        }
            "install_csv_veto_load"      , { INSTALL CSV veto for load records          }
            "install_default_lab"        , { INSTALL update all .lab files in kit       }
            "install_default_lab_file"   , { INSTALL update a single .lab file          }
            "install_dlls"               , { INSTALL all dll files                      }
            "install_files"              , { INSTALL move SMP$ files                    }
            "install_file_stage"         , { INSTALL move files based on stage install  }
            "install_subdir_files"       , { INSTALL move files below SMP$ dir's        }
            "install_import_smw_menu"    , { INSTALL add the smw.menu                   }
            "install_is_compile"         , { INSTALL if files are compiled              }
            "install_load_csv"           , { INSTALL interface to table saver           }
            "install_messages_txt"       , { INSTALL create.messages                    }
            "install_read_kit"           , { INSTALL read the full dir of the kit       }
            "install_read_a_file"        , { INSTALL read structure/messages            }
            "install_read_append_files"  , { INSTALL read all files that should append  }
            "install_register_dll"       , { INSTALL register dll via reg.bat           }
            "install_read_entry_code"    , { INSTALL read entry code for MLP Values     }
            "install_read_version"       , { INSTALL read prod version for MLP Values   }
            "install_select_destination" , { INSTALL if logical is multiple choose 1    }
            "install_set_load_array"     , { INSTALL keep counts of each load           }
            "install_set_destination"    , { INSTALL if logical is multiple do only 1   }
            "install_structure_dbase"    , { INSTALL create.convert structure. (dbase)  }
            "install_structure_txt"      , { INSTALL create.convert structure.txt       }
            "install_update_all_counts"  , { INSTALL all counters in all tables         }
            "install_update_csv_count"   , { INSTALL count update # csv loaded          }
            "install_update_dbase"       , { INSTALL update all the tables              }
            "install_update_dll_count"   , { INSTALL count update # dlls loaded         }
            "install_update_file_count"  , { INSTALL count update # files loaded        }
            "install_veto"               , { INSTALL veto form PACKAGE loader           }
            "install_veto_modes"         , { INSTALL veto set mode found                }
            "move_copy_criteria"         , { MOVE copies crt files to version 0 kit     }
            "move_edit_1_file"           , { MOVE changes contents to version 0 kit     }
            "move_expand_7zip"           , { MOVE expands 7zip.zip file                 }
            "move_expand_self_extract"   , { MOVE expands self extracting zip exe file  }
            "move_expand_server_kit"     , { MOVE expands kit                           }
            "move_load_0_version_csv"    , { MOVE loads csv files for version 0 kit     }
            "move_make_rollback_kit"     , { MOVE makes version 0 kit for un-install    }
            "move_rebuild_data_lines"    , { MOVE rebuilds each line with version 0     }
            "move_zip_make_install"      , { MOVE moves zip file and makes install dir  }
            "menu_check_main"            , { MENU main for check master,smw,lab files   }
            "menu_check_EOF"             , { MENU if end of file then commence write    }
            "menu_build_smw_line"        , { MENU redo one line of an smw.menu file     }
            "menu_build_lab_line"        , { MENU redo one line of a .lab file          }
            "menu_build_mtb_line"        , { MENU redo one line of a .mtb file          }
            "menu_rebuild_master"        , { MENU rebuild master_menu*.csv files        }
            "menu_rebuild_smw"           , { MENU rebuild smw*.menu files               }
            "menu_rebuild_lab"           , { MENU rebuild default_lab.lab file          }
            "menu_rebuild_mtb"           , { MENU rebuild SM920.mtb files               }
            "menu_rewrite_file"          , { MENU rewrite a single file new proc numbs  }
            "menu_set_proc_num"          , { MENU set proc numb to value from LTE grid  }
            "import_set_criteria"        , { When a global import kit make load info    }
            "import_load_mlp"            , { Special load of imported MLP data          }
            "import_reset_counts"          { During import reset key fields             }

    END CLASS

    DEFINE CLASS CLASS_MESSAGES
    PROPERTIES
            "01"   ,
            "02"   ,
            "03"   ,
            "04"   ,
            "05"   ,
            "06"   ,
            "07"   ,
            "08"   ,
            "09"   ,
            "10"   ,
            "11"   ,
            "12"   ,
            "13"   ,
            "14"   ,
            "15"   ,
            "16"   ,
            "17"   ,
            "18"   ,
            "19"   ,
            "20"   ,
            "21"   ,
            "22"   ,
            "23"   ,
            "24"   ,
            "25"   ,
            "26"   ,
            "27"   ,
            "28"   ,
            "29"   ,
            "30"   ,
            "31"   ,
            "32"   ,
            "33"   ,
            "34"   ,
            "35"   ,
            "36"   ,
            "37"   ,
            "38"   ,
            "39"   ,
            "40"   ,
            "41"   ,
            "42"   ,
            "43"   ,
            "44"   ,
            "45"   ,
            "46"   ,
            "47"   ,
            "48"   ,
            "49"   ,
            "50"   ,
            "51"   ,
            "52"   ,
            "53"   ,
            "54"   ,
            "55"   ,
            "56"
    END CLASS

ENDROUTINE        { define_packager_class  }

{ ************************************************************************************* }

ROUTINE packager_class_initialisation ( self )

    DECLARE a_semi

    ARRAY self.criteria_array               { array of smp$xxx to save                 }
    ARRAY self.program_dll_array            { array of xml, .net, dll's                }
    ARRAY self.subdir_array                 { build subdirectories for each of above 2 }
    ARRAY self.subdir_2_array               { build subdirectories each subdir_array   }
    ARRAY self.save_array                   { the criteria to get each table_save's    }
    ARRAY self.csv_save_array               { all the files from the csv's copied      }
    ARRAY self.file_save_array              { all the files txt, doc, menu etc         }
    ARRAY self.mlp_csv_array                { special import of mlp data to load       }

    ARRAY self.load_menu_master_array       { The file(s) from the kit for loading     }
    ARRAY self.load_menu_smw_array          { And .menu files also for loading         }
    ARRAY self.load_menu_lab_array          { and the .lab files also for loading      }
    ARRAY self.load_menu_mtb_array          { and the .mtb files also for loading      }

    ARRAY self.load_array                   { each load, type, count and compile       }
    ARRAY self.load_structure_array         { All structure.txt updates                }
    ARRAY self.load_messages_array          { All message.txt updates                  }

    ARRAY self.append_structure_array       { All lines that may be added to structure }
    ARRAY self.smp_structure_array          { All lines already in structure           }
    ARRAY self.message_txt_array            { All lines read from message.txt          }

    ARRAY self.version_array                { Keep version of key0 for new_version     }
    ARRAY self.continue_array               { Veto of each table if skip all           }

    self.ae_prod_id   = 0                   { Array elements of the MLP VALUE          }
    self.ae_prod_vers = 0
    self.ae_anal_id   = 0
    self.ae_comp_name = 0

    self.csv_EOF_msg            = GET_USER_MESSAGE ( "RPC_K_EOFTXTFIL", 1 )
    self.csv_base_table         = "VERSIONED_ANALYSIS"
    self.error_msg              = EMPTY
    self.install_set_dir        = LOGICAL ( C_SMP_MODULE_INSTALL_SET_DIR )

    IF ( self.install_set_dir = C_SMP_MODULE_INSTALL_SET_DIR ) THEN

        self.install_set_dir = LOGICAL ( "SMP$ROOT" )
        a_semi               = INDEX ( self.install_set_dir, ";" )

        IF ( a_semi > 0 ) THEN

            self.install_set_dir = LEFTSTRING ( self.install_set_dir, a_semi - 1 )

        ENDIF

        self.install_set_dir = self.install_set_dir : "\" : C_SMP_MODULE_INSTALL_DIR_VALUE

    ENDIF

    self.logfile                = self.install_set_dir
    self.load_menu_changed      = FALSE
    self.log_is_good            = FALSE
    self.structure_updated      = FALSE
    self.messages_updated       = FALSE
    self.smw_menu_updated       = FALSE
    self.stage_of_install       = FALSE
    self.a_first                = FALSE
    self.allowed_to_prompt      = FALSE
    self.a_false                = FALSE
    self.is_version_0_kit       = FALSE
    self.is_export_set          = FALSE
    self.criteria_versioned     = FALSE
    self.files_updated          = FALSE
    self.sm_version_0_Ok        = FALSE
    self.csv_new_version        = FALSE
    self.csv_new_entry_code     = FALSE
    self.install_continue_all   = FALSE
    self.install_select_dir     = FALSE

    { ---------------------------------------------------------------------------- }
    { Optional global config item to veto all items as they are installed          }
    { ---------------------------------------------------------------------------- }

    IF GLOBAL_EXISTS ( C_PKG_INSTALL_VETO ) THEN

        self.install_select_dir = GLOBAL ( C_PKG_INSTALL_VETO )

    ENDIF

    self.a_true                 = TRUE

    self.table                  = C_SMP_MODULE
    self.criteria_table         = C_SMP_MODULE_CRITERIA
    self.dll_table              = C_SMP_MODULE_PROGRAM
    self.smw_menu_table         = C_SMP_MODULE_MENU
    self.rpf_directory          = EMPTY
    self.crt_directory          = EMPTY
    self.caf_directory          = EMPTY
    self.sxf_directory          = EMPTY

    self.compile_rpf            = 0
    self.compile_calc           = 0
    self.compile_limit          = 0
    self.compile_list           = 0
    self.compile_sigfig         = 0
    self.compile_syntax         = 0
    self.csv_ignore_count       = 0
    self.csv_skip_count         = 0
    self.csv_load_count         = 0
    self.csv_line_count         = 0

    self.SMP_REPORTS            = 0
    self.SMP_CALCULATIONS       = 0
    self.SMP_LIMIT_CALCULATIONS = 0
    self.SMP_LIST_RESULTS       = 0
    self.SMP_SIG_FIGS           = 0
    self.SMP_SYNTAXES           = 0
    self.SMP_CRITERIA           = 0

    self.a_table                = ""
    self.csv_base_key0          = ""

    SET DATE FORMAT "DZ-MON-YYYZ-H24-MI"

        self.install_date_time = STRIP ( NOW )

    RESTORE DATE FORMAT


    { --------------------------------------------------------------------- }
    { Options and sizes of items from the database that may be optional     }
    { --------------------------------------------------------------------- }

    IF ( VALID_TABLE ( C_SMP_MODULE ) ) THEN

        GET_FIELD_DETAILS 'C_SMP_MODULE'.SMP_VERSION, "FIELD_SIZE", self.key1_len
        GET_FIELD_DETAILS 'C_SMP_MODULE'.IDENTITY   , "FIELD_SIZE", self.key2_len

    ELSE

        self.key1_len = C_SMP_KEY1_LEN     { kit is being installed...      }
        self.key2_len = C_SMP_KEY2_LEN     { self install has no tables yet }

    ENDIF

    { --------------------------------------------------------------------- }
    { If structure is in database then load of table/fields is via CSV      }
    { --------------------------------------------------------------------- }

    self.smp_structure_ok = VALID_TABLE ( C_SMP_STRUCTURE )

    IF( self.smp_structure_ok ) THEN

        { --------------------------------------------------------------------- }
        { But have to have module to write structure.txt from database also     }
        { --------------------------------------------------------------------- }

        self.smp_structure_ok = SELECT REPORT.IDENTITY WHERE IDENTITY = C_LIT_DATABASE

        IF ( self.smp_structure_ok = EMPTY ) THEN

            self.smp_structure_ok = FALSE

        ELSEIF ( FILE EXISTS ( "SMP$REPORTS\" : C_LIT_DATABASE : ".RPF" )  ) THEN

            self.smp_structure_ok = VGL_VALIDATE_ROUTINE ( C_LIT_DATABASE, C_LIT_DATABASE_WRITE_STRUCTURE )

        ELSE

            self.smp_structure_ok = FALSE

        ENDIF

    ENDIF    { not only have to have the tables but also a valid library }

    { --------------------------------------------------------------------- }
    { On first install no reconnect done yet, so do not have messages       }
    { --------------------------------------------------------------------- }

    CREATE OBJECT CLASS_MESSAGES, self.msg
        self.msg.01 = ""
        self.msg.02 = ""
        self.msg.03 = ""
        self.msg.04 = ""
        self.msg.05 = ""
        self.msg.06 = ""
        self.msg.07 = ""
        self.msg.08 = ""
        self.msg.09 = ""
        self.msg.10 = ""
        self.msg.11 = ""
        self.msg.12 = ""
        self.msg.13 = ""
        self.msg.14 = ""
        self.msg.15 = ""
        self.msg.16 = ""
        self.msg.17 = ""
        self.msg.18 = ""
        self.msg.19 = ""
        self.msg.20 = ""
        self.msg.21 = ""
        self.msg.22 = ""
        self.msg.23 = ""
        self.msg.24 = ""
        self.msg.25 = ""
        self.msg.26 = ""
        self.msg.27 = ""
        self.msg.28 = ""
        self.msg.29 = ""
        self.msg.30 = ""
        self.msg.31 = ""
        self.msg.32 = ""
        self.msg.33 = ""
        self.msg.34 = ""
        self.msg.35 = ""
        self.msg.36 = ""
        self.msg.37 = ""
        self.msg.38 = ""
        self.msg.39 = ""
        self.msg.40 = ""
        self.msg.41 = ""
        self.msg.42 = ""
        self.msg.43 = ""
        self.msg.44 = ""
        self.msg.45 = ""
        self.msg.46 = ""
        self.msg.47 = ""
        self.msg.48 = ""
        self.msg.49 = ""
        self.msg.50 = ""
        self.msg.51 = ""
        self.msg.52 = ""
        self.msg.53 = ""
        self.msg.54 = ""
        self.msg.55 = ""
        self.msg.56 = ""

ENDROUTINE   { packager_class_initialisation }

{******************************************************************************}

ROUTINE packager_action_set_msg_translations ( self )

    { --------------------------------------------------------------------- }
    { Now we have the message.sec ok, we can read all the messages          }
    { --------------------------------------------------------------------- }

    self.msg.01 = internal_translate_message ( "LIT_PACKAGER_01" )
    self.msg.02 = internal_translate_message ( "LIT_PACKAGER_02" )
    self.msg.03 = internal_translate_message ( "LIT_PACKAGER_03" )
    self.msg.04 = internal_translate_message ( "LIT_PACKAGER_04" )
    self.msg.05 = internal_translate_message ( "LIT_PACKAGER_05" )
    self.msg.06 = internal_translate_message ( "LIT_PACKAGER_06" )
    self.msg.07 = internal_translate_message ( "LIT_PACKAGER_07" )
    self.msg.08 = internal_translate_message ( "LIT_PACKAGER_08" )
    self.msg.09 = internal_translate_message ( "LIT_PACKAGER_09" )
    self.msg.10 = internal_translate_message ( "LIT_PACKAGER_10" )
    self.msg.11 = internal_translate_message ( "LIT_PACKAGER_11" )
    self.msg.12 = internal_translate_message ( "LIT_PACKAGER_12" )
    self.msg.13 = internal_translate_message ( "LIT_PACKAGER_13" )
    self.msg.14 = internal_translate_message ( "LIT_PACKAGER_14" )
    self.msg.15 = internal_translate_message ( "LIT_PACKAGER_15" )
    self.msg.16 = internal_translate_message ( "LIT_PACKAGER_16" )
    self.msg.17 = internal_translate_message ( "LIT_PACKAGER_17" )
    self.msg.18 = internal_translate_message ( "LIT_PACKAGER_18" )
    self.msg.19 = internal_translate_message ( "LIT_PACKAGER_19" )
    self.msg.20 = internal_translate_message ( "LIT_PACKAGER_20" )
    self.msg.21 = internal_translate_message ( "LIT_PACKAGER_21" )
    self.msg.22 = internal_translate_message ( "LIT_PACKAGER_22" )
    self.msg.23 = internal_translate_message ( "LIT_PACKAGER_23" )
    self.msg.24 = internal_translate_message ( "LIT_PACKAGER_24" )
    self.msg.25 = internal_translate_message ( "LIT_PACKAGER_25" )
    self.msg.26 = internal_translate_message ( "LIT_PACKAGER_26" )
    self.msg.27 = internal_translate_message ( "LIT_PACKAGER_27" )
    self.msg.28 = internal_translate_message ( "LIT_PACKAGER_28" )
    self.msg.29 = internal_translate_message ( "LIT_PACKAGER_29" )
    self.msg.30 = internal_translate_message ( "LIT_PACKAGER_30" )
    self.msg.31 = internal_translate_message ( "LIT_PACKAGER_31" )
    self.msg.32 = internal_translate_message ( "LIT_PACKAGER_32" )
    self.msg.33 = internal_translate_message ( "LIT_PACKAGER_33" )
    self.msg.34 = internal_translate_message ( "LIT_PACKAGER_34" )
    self.msg.35 = internal_translate_message ( "LIT_PACKAGER_35" )
    self.msg.36 = internal_translate_message ( "LIT_PACKAGER_36" )
    self.msg.37 = internal_translate_message ( "LIT_PACKAGER_37" )
    self.msg.38 = internal_translate_message ( "LIT_PACKAGER_38" )
    self.msg.39 = internal_translate_message ( "LIT_PACKAGER_39" )
    self.msg.40 = internal_translate_message ( "LIT_PACKAGER_40" )
    self.msg.41 = internal_translate_message ( "LIT_PACKAGER_41" )
    self.msg.42 = internal_translate_message ( "LIT_PACKAGER_42" )
    self.msg.43 = internal_translate_message ( "LIT_PACKAGER_43" )
    self.msg.44 = internal_translate_message ( "LIT_PACKAGER_44" )
    self.msg.45 = internal_translate_message ( "LIT_PACKAGER_45" )
    self.msg.46 = internal_translate_message ( "LIT_PACKAGER_46" )
    self.msg.47 = internal_translate_message ( "LIT_PACKAGER_47" )
    self.msg.48 = internal_translate_message ( "LIT_PACKAGER_48" )
    self.msg.49 = internal_translate_message ( "LIT_PACKAGER_49" )
    self.msg.50 = internal_translate_message ( "LIT_PACKAGER_50" )
    self.msg.51 = internal_translate_message ( "LIT_PACKAGER_51" )
    self.msg.52 = internal_translate_message ( "LIT_PACKAGER_52" )
    self.msg.53 = internal_translate_message ( "LIT_PACKAGER_53" )
    self.msg.54 = internal_translate_message ( "LIT_PACKAGER_54" )
    self.msg.55 = internal_translate_message ( "LIT_PACKAGER_55" )
    self.msg.56 = internal_translate_message ( "LIT_PACKAGER_56" )

ENDROUTINE   { packager_action_set_msg_translations }

{******************************************************************************}
{                                                                              }
{                                                                              }
{                                                                              }
{                                                                              }
{                     ROUTINES SHARED BY ALL MODES                             }
{                                                                              }
{                                                                              }
{                                                                              }
{                                                                              }
{******************************************************************************}

ROUTINE internal_get_root_directory ( a_id      ,
                                      root_dir  )

    DECLARE fso

    CREATE OBJECT CLASS_STD_OLE_AUTOMATION_SERVER,fso
        fso.create("Scripting.FileSystemObject")

    root_dir = fso.GetBaseName ( a_id )

    RETURN ( root_dir <> EMPTY )

ENDROUTINE   { internal_get_root_dir }

{******************************************************************************}

ROUTINE internal_select_display_record ( self )

    DECLARE a_dash         ,
                 a_table        ,
                 a_key0         ,
                 stlen          ,
                 key0_fields    ,
                 key0_array     ,
                 a_cnt          ,
                 a_cnt2         ,
                 a_size         ,
                 comp_array     ,
                 fld_array      ,
                 data_fld_array ,
                 pass_key       ,
                 comp_rec       ,
                 msg1           ,
                 msg2           ,
                 msg3           ,
                 a_form         ,
                 tmp            ,
                 a_type         ,
                 list_review

    msg1 = internal_translate_message ( "LIT_PACKAGER_FIELD_NAME"   )
    msg2 = internal_translate_message ( "LIT_PACKAGER_RECORD_LOAD"  )
    msg3 = internal_translate_message ( "LIT_PACKAGER_RECORD_EXIST" )

    ARRAY key0_array
    ARRAY key0_fields
    ARRAY fld_array
    ARRAY comp_array
    ARRAY data_fld_array

    data_fld_array = self.parent_prompt.user_info
    pass_key       = STRIP ( self.parent_prompt.header )
    a_dash         = INDEX ( pass_key, " : " ) + 2
    stlen          = STRINGLENGTH ( pass_key )
    pass_key       = STRIP ( RIGHTSTRING ( pass_key, stlen - a_dash ) )
    stlen          = STRINGLENGTH ( pass_key )
    a_dash         = INDEX ( pass_key, "-" )
    a_table        = LEFTSTRING ( pass_key, a_dash - 1 )
    a_key0         = RIGHTSTRING ( pass_key, stlen - a_dash )
    stlen          = STRINGLENGTH ( a_key0 )

    IF ( VALID_TABLE ( a_table ) ) THEN

        GET_TABLE_DETAILS 'a_table', "KEY0_FIELD", key0_fields
        GET_FIELD_NAMES ( a_table, fld_array )

        a_cnt = 1

        WHILE ( a_cnt <= SIZE_OF_ARRAY ( key0_fields ) ) DO

            GET_FIELD_DETAILS 'a_table'.'key0_fields[a_cnt]', "FIELD_SIZE", a_size
            GET_FIELD_DETAILS 'a_table'.'key0_fields[a_cnt]', "DATA_TYPE" , a_type

            tmp = LEFTSTRING ( a_key0, a_size )

            IF ( a_type = "Packed decimal" ) THEN

                tmp = PACKED_DECIMAL ( tmp )

            ENDIF

            key0_array[a_cnt] = tmp
            a_key0            = RIGHTSTRING ( a_key0, stlen - a_size )
            stlen             = STRINGLENGTH ( a_key0 )
            a_cnt             = a_cnt + 1

        ENDWHILE

        { ---------------------------------------------------------- }
        { Next select the target systems record that may be replaced }
        { ---------------------------------------------------------- }

        IF     ( SIZE_OF_ARRAY ( key0_fields ) = 1 ) THEN

            comp_rec = SELECT 'a_table'.'key0_fields[1]'
                                      WHERE 'key0_fields[1]' = key0_array[1]

        ELSEIF ( SIZE_OF_ARRAY ( key0_fields ) = 2 ) THEN

            comp_rec = SELECT 'a_table'.'key0_fields[1]'
                                      WHERE 'key0_fields[1]' = key0_array[1]
                                      AND   'key0_fields[2]' = key0_array[2]

        ELSEIF ( SIZE_OF_ARRAY ( key0_fields ) = 3 ) THEN

            comp_rec = SELECT 'a_table'.'key0_fields[1]'
                                      WHERE 'key0_fields[1]' = key0_array[1]
                                      AND   'key0_fields[2]' = key0_array[2]
                                      AND   'key0_fields[3]' = key0_array[3]

        ELSEIF ( SIZE_OF_ARRAY ( key0_fields ) = 4 ) THEN

            comp_rec = SELECT 'a_table'.'key0_fields[1]'
                                      WHERE 'key0_fields[1]' = key0_array[1]
                                      AND   'key0_fields[2]' = key0_array[2]
                                      AND   'key0_fields[3]' = key0_array[3]
                                      AND   'key0_fields[4]' = key0_array[4]

        ELSEIF ( SIZE_OF_ARRAY ( key0_fields ) = 5 ) THEN

            comp_rec = SELECT 'a_table'.'key0_fields[1]'
                                      WHERE 'key0_fields[1]' = key0_array[1]
                                      AND   'key0_fields[2]' = key0_array[2]
                                      AND   'key0_fields[3]' = key0_array[3]
                                      AND   'key0_fields[4]' = key0_array[4]
                                      AND   'key0_fields[5]' = key0_array[5]

        ELSE

            comp_rec = EMPTY

        ENDIF

        { ---------------------------------------------------------- }
        { Get all the field values if we have the record             }
        { ---------------------------------------------------------- }

        a_cnt = 1

        WHILE ( data_fld_array[a_cnt] <> EMPTY ) DO

            comp_array[a_cnt,1] = data_fld_array[a_cnt]
            comp_array[a_cnt,2] = self.userinfo[a_cnt]
            comp_array[a_cnt,3] = SELECT 'a_table'.'data_fld_array[a_cnt]'
            a_cnt               = a_cnt + 1

        ENDWHILE

        { ---------------------------------------------------------- }
        { Finally show a list of the comparison of the 2 records     }
        { ---------------------------------------------------------- }

        CREATE OBJECT "STD_FORM", a_form
            a_form.header = self.parent_prompt.header
            a_form.height = GLOBAL ( "GUI_HEIGHT") - 6
            a_form.width  = GLOBAL ( "GUI_WIDTH" ) - 6
            a_form.column = 2
            a_form.row    = 2

        define_list_viewer_class()

        CREATE OBJECT LIST_VIEWER_CLASS, list_review
            list_review.vgl_library          = global ( "current_library" )
            list_review.row                  = 1
            list_review.column               = 1
            list_review.width                = a_form.width  - 1
            list_review.height               = a_form.height - 1
            list_review.user_info            = self
            list_review.auto_size            = TRUE
            list_review.menu_criteria        = FALSE
            list_review.menu_refresh         = FALSE
            list_review.use_images ( EMPTY, 0 )

        list_review.add_column ( msg1, 30 )
        list_review.add_column ( msg2, 50 )
        list_review.add_column ( msg3, 50 )

        { ----------------------------------------------------------------- }
        { Put all the data onto the list                                    }
        { ----------------------------------------------------------------- }

        a_cnt  = 1

        WHILE ( comp_array[a_cnt,1] <> EMPTY ) DO

            a_cnt2 = 1

            { ----------------------------------------------------------- }
            { 3 icons are 3 ways to compare, not there, match, no match   }
            { ----------------------------------------------------------- }

            IF ( comp_rec = EMPTY ) THEN

                list_review.insert_item( comp_array[a_cnt,1], 12  )     { 12 is  RED X  }

            ELSEIF ( comp_array[a_cnt,2] = comp_array[a_cnt,3] ) THEN

                list_review.insert_item( comp_array[a_cnt,1], 200 )     { 200 is a blank }

            ELSE

                list_review.insert_item( comp_array[a_cnt,1], 168 )     { 168 something red and bold }

            ENDIF

            { ----------------------------------------------------------- }
            { Fill in the values for each column                          }
            { ----------------------------------------------------------- }

            WHILE ( comp_array[a_cnt,a_cnt2] <> EMPTY ) DO

                list_review.set_item(a_cnt2, comp_array[a_cnt,a_cnt2])

                a_cnt2 = a_cnt2 + 1

            ENDWHILE

            a_cnt = a_cnt + 1

        ENDWHILE

        { ----------------------------------------------------------------- }
        { Show the form and let the user play around with it...             }
        { ----------------------------------------------------------------- }

        a_form.add_prompt ( list_review )

        a_form.start_prompt()
        a_form.wait_prompt()
        a_form.end_prompt()

        SET GLOBAL "LASTKEY" TO "CONTINUE"

    ENDIF   { can browse on userinfo fields }

ENDROUTINE  { internal_select_display_record }

{******************************************************************************}

ROUTINE internal_remove_mod_field ( a_table, list_of_fields )

    DECLARE mod_on_field,
                mod_by_field,
                a_ndex


    GET_TABLE_DETAILS 'a_table', "MODIFIED_BY_FIELD", mod_by_field
    GET_TABLE_DETAILS 'a_table', "MODIFIED_ON_FIELD", mod_on_field

    IF ( NOT BLANK ( mod_by_field ) ) AND ( internal_array_slice ( list_of_fields, mod_by_field, a_ndex ) ) THEN

        ARRAY_REMOVE_SLICE ( list_of_fields, 1, a_ndex )

    ENDIF


    IF ( NOT BLANK ( mod_on_field ) ) AND ( internal_array_slice ( list_of_fields, mod_on_field, a_ndex ) ) THEN

        ARRAY_REMOVE_SLICE ( list_of_fields, 1, a_ndex )

    ENDIF

ENDROUTINE  {   internal_remove_mod_field }

{******************************************************************************}

ROUTINE internal_build_new_id ( a_id )

    DECLARE a_i     ,
                a_new_id,
                a_space ,
                a_add

    a_i      = 1
    a_new_id = ""
    a_space  = GET_CHARACTER_AT ( a_id, a_i )
    a_add    = FALSE

    { ----------------------------------------------------------- }
    { Take spaces out of a_id and add only 1 "_" for each space   }
    { ----------------------------------------------------------- }

    WHILE ( a_space <> ERROR ) DO

        IF ( a_space = " " ) THEN

            IF NOT a_add THEN

                a_add   = TRUE
                a_space = "_"

            ELSE

                a_space = ""

            ENDIF

        ELSE
            a_add = FALSE
        ENDIF

        a_new_id = a_new_id : a_space
        a_i      = a_i + 1
        a_space  = GET_CHARACTER_AT ( a_id, a_i )

    ENDWHILE

    RETURN ( a_new_id )

ENDROUTINE   { internal_build_new_id }

{******************************************************************************}

GLOBAL ROUTINE internal_build_id_from_file ( VALUE fd_only ,
                                                   a_id    ,
                                                   a_first )

    DECLARE a_len1    ,
                 a_len2    ,
                 a_under   ,
                 stlen     ,
                 tmpString ,
                 a_cnt     ,
                 a_stop    ,
                 a_vers    ,
                 a_byte

    { -------------------------------------------------------------------- }
    { Make a_id from the fd_only but in the 3 parts of padded key          }
    { -------------------------------------------------------------------- }

    IF ( a_first ) THEN

        a_len1 = C_SMP_KEY1_LEN
        a_len2 = C_SMP_KEY2_LEN

    ELSE

        GET_FIELD_DETAILS 'C_SMP_MODULE'.SMP_VERSION, "FIELD_SIZE", a_len1
        GET_FIELD_DETAILS 'C_SMP_MODULE'.IDENTITY   , "FIELD_SIZE", a_len2

    ENDIF

    { ------------------------------------------------- }
    { First underscore is part 1 of key0 to first under }
    { ------------------------------------------------- }

    a_under   = INDEX ( fd_only, "_" )
    a_id      = LEFTSTRING ( fd_only, a_under - 1 )
    stlen     = STRINGLENGTH ( fd_only )
    tmpString = STRIP ( RIGHTSTRING ( fd_only, stlen - a_under ) )

    { ----------------------------------------------------------------------- }
    { The last part of the string is the version number (3rd key0)            }
    { ----------------------------------------------------------------------- }

    stlen  = STRINGLENGTH ( tmpString )
    a_cnt  = stlen
    a_stop = TRUE

    WHILE ( a_cnt > 1 ) AND ( a_stop ) DO

        a_byte = GET_CHARACTER_AT ( tmpString, a_cnt )

        IF ( a_byte = "_" ) THEN

            a_stop = FALSE

        ENDIF

        a_cnt = a_cnt - 1

    ENDWHILE

    { ----------------------------------------------------------- }
    { This id becomes the pad filled version number key0          }
    { ----------------------------------------------------------- }

    a_vers = PACKED_DECIMAL ( RIGHTSTRING ( tmpString, stlen - a_cnt - 1 ) )
    a_id   = PAD ( a_id, " ", a_len1 ) : PAD ( LEFTSTRING ( tmpString, a_cnt ), " ", a_len2 ) : a_vers

    RETURN ( TRUE )

ENDROUTINE   { internal_build_id_from_file }

{******************************************************************************}

ROUTINE internal_vgl_validate_routine ( VALUE a_library ,
                                        VALUE a_routine )

    retval    = TRUE
    a_library = SELECT REPORT.IDENTITY WHERE IDENTITY = a_library

    IF ( a_library = EMPTY ) THEN

        retval = FALSE

    ELSEIF ( NOT VGL_VALIDATE_ROUTINE ( a_library, a_routine ) ) THEN

        retval = FALSE

    ENDIF

    RETURN ( retval )

ENDROUTINE { internal_vgl_validate_routine }

{******************************************************************************}

ROUTINE internal_validate_server (       a_dir      ,
                                         tables_ok  )


    DECLARE a_config,
                a_size  ,
                status

    retval    = TRUE
    tables_ok = FALSE
    a_dir     = LOGICAL ( C_SMP_MODULE_INSTALL_SET_DIR )

    { --------------------------------------------------------------------- }
    { Logical must be valid and directory must exist that logical points to }
    { --------------------------------------------------------------------- }

    IF     ( a_dir = C_SMP_MODULE_INSTALL_SET_DIR ) THEN

        retval = internal_make_regkey ( a_dir )

    ELSEIF ( NOT FILE EXISTS ( a_dir ) ) THEN

        retval = internal_create_directory ( a_dir )

    ENDIF

    { -------------------------------------------------------------------- }
    { Always check tables...                                               }
    { -------------------------------------------------------------------- }

    IF  ( VALID_TABLE ( C_SMP_MODULE          ) )
    AND ( VALID_TABLE ( C_SMP_MODULE_CRITERIA ) )
    AND ( VALID_TABLE ( C_SMP_MODULE_PROGRAM  ) ) THEN

        tables_ok = TRUE

    ENDIF

    { --------------------------------------------------------------------- }
    { Config item exist ?  If not add it...                                 }
    { --------------------------------------------------------------------- }

    a_config = SELECT CONFIG_HEADER.IDENTITY WHERE IDENTITY = C_MESSAGE_POINTERS

    IF ( a_config = EMPTY ) THEN

        START WRITE TRANSACTION C_PACKAGER_WRITE_TRANS

        GET_FIELD_DETAILS CONFIG_HEADER.IDENTITY, "FIELD_SIZE", a_size
        a_config = PAD ( C_MESSAGE_POINTERS, " ", a_size )

        RESERVE ENTRY CONFIG_HEADER, a_config, status

        retval = status = EMPTY

        IF retval THEN

            ASSIGN CONFIG_HEADER.VALUE       = FALSE
            ASSIGN CONFIG_HEADER.DATA_TYPE   = "BOOLEAN"
            ASSIGN CONFIG_HEADER.CATEGORY    = "SYSTEM"
            ASSIGN CONFIG_HEADER.MODIFIED_ON = NOW
            ASSIGN CONFIG_HEADER.MODIFIED_BY = OPERATOR
            ASSIGN CONFIG_HEADER.DESCRIPTION = C_MSG_POINTER_DESCRIPTION

            UPDATE CONFIG_HEADER, status

            COMMIT

        ELSE

            ROLLBACK

        ENDIF

    ENDIF


    { --------------------------------------------------------------------- }
    { Config item exist ?  If not add it...                                 }
    { --------------------------------------------------------------------- }

    a_config = SELECT CONFIG_HEADER.IDENTITY WHERE IDENTITY = C_PKG_INSTALL_VETO

    IF ( a_config = EMPTY ) THEN

        START WRITE TRANSACTION C_PACKAGER_WRITE_TRANS

        GET_FIELD_DETAILS CONFIG_HEADER.IDENTITY, "FIELD_SIZE", a_size
        a_config = PAD ( C_PKG_INSTALL_VETO, " ", a_size )

        RESERVE ENTRY CONFIG_HEADER, a_config, status

        retval = status = EMPTY

        IF retval THEN

            ASSIGN CONFIG_HEADER.VALUE       = FALSE
            ASSIGN CONFIG_HEADER.DATA_TYPE   = "BOOLEAN"
            ASSIGN CONFIG_HEADER.CATEGORY    = "SYSTEM"
            ASSIGN CONFIG_HEADER.MODIFIED_ON = NOW
            ASSIGN CONFIG_HEADER.MODIFIED_BY = OPERATOR
            ASSIGN CONFIG_HEADER.DESCRIPTION = C_PKG_INSTALL_VETO_MSG

            UPDATE CONFIG_HEADER, status

            COMMIT

        ELSE

            ROLLBACK

        ENDIF

    ENDIF

    RETURN ( retval )

ENDROUTINE  { internal_validate_server }

{******************************************************************************}

ROUTINE internal_make_regkey ( a_dir )

    DECLARE status    ,
                 a_key     ,
                 a_log_dir ,
                 a_exe_dir ,
                 a_root_dir,
                 a_semi    ,
                 regfile   ,
                 logfile   ,
                 a_spawn

    retval    = FALSE
    a_exe_dir = LOGICAL ( "SMP$PROGRAMS" )
    a_semi    = INDEX ( a_exe_dir, ";" )

    IF ( a_semi > 0 ) THEN

        a_exe_dir = LEFTSTRING ( a_exe_dir, a_semi - 1 )

    ENDIF

    a_log_dir = LOGICAL ( "SMP$TEXTREPORTS" )
    a_semi    = INDEX ( a_log_dir, ";" )

    IF ( a_semi > 0 ) THEN

        a_log_dir = LEFTSTRING ( a_log_dir, a_semi - 1 )

    ENDIF

    { ---------------------------------------------------------------------------- }
    { Get server's registry key for SMP$ROOT                                       }
    { ---------------------------------------------------------------------------- }

    a_root_dir = registry_get_value ( C_REG_HKEY_LOCAL_MACHINE, C_REG_THERMO_INSTANCE : STRIP ( GLOBAL ( "INSTANCE" )), "SMP$ROOT" )
    a_semi     = INDEX ( a_root_dir, ";" )

    IF ( a_semi > 0 ) THEN

        a_root_dir = LEFTSTRING ( a_root_dir, a_semi - 1 )

    ENDIF

    regfile    = "SMP_INSTALL_REG_KEY" : "_" : STRIP ( GLOBAL ( "INSTANCE" ) )
    logfile    = a_log_dir : "\" : STRIP(regfile):".log"
    regfile    = a_exe_dir : "\" : regfile : ".BAT"
    a_dir      = STRIP ( a_root_dir : "\" : C_SMP_MODULE_INSTALL_DIR_VALUE )

    FILE DELETE regfile, status
    FILE CREATE regfile, status
    FILE EXTEND regfile, status

    IF status = EMPTY THEN

        a_key = C_REG_KEY_ADD_INSTALL                                     : ASCII(34) :
                        "HKLM\" : C_REG_THERMO_INSTANCE : STRIP(GLOBAL("INSTANCE")) : ASCII(34) :
                        " /v " : C_SMP_MODULE_INSTALL_SET_DIR : " /d "              : ASCII(34) : a_dir : ASCII(34) : " /f"

        FILE WRITE regfile, a_key , status
        FILE WRITE regfile, "exit", status

        IF status = EMPTY THEN

            FILE CLOSE regfile, status

            IF status = EMPTY THEN

                a_spawn = ASCII(34): regfile :ASCII(34) : " >> " : ASCII(34): STRIP (log_file) :ASCII(34) : " 2>&1"

                SPAWN "cmd /E:ON /D /A /C " : a_spawn, status QUIETLY

                IF status = EMPTY THEN

                    retval = internal_create_directory(a_dir)

                    FILE DELETE regfile, status
                    FILE DELETE logfile, status

                ELSE

                    FLASH_MESSAGE ( "LIT_LAB_SMP_MODULE_ERROR_REGBAT" : status, TRUE )

                ENDIF

            ENDIF  { file close status }

        ENDIF  { only last write should be ok }

    ENDIF  { file extend }

    RETURN ( retval )

ENDROUTINE   { internal_make_regkey }

{******************************************************************************}

ROUTINE internal_file_name_only ( VALUE fd_only )

    DECLARE tmp, stlen

    fd_only = STRIP(fd_only)
    tmp     = INDEX ( fd_only, "\"   )
    stlen   = STRINGLENGTH ( fd_only )

    WHILE ( tmp > 0 ) DO

        fd_only = STRIP ( RIGHTSTRING ( fd_only, stlen - tmp ) )
        tmp     = INDEX ( fd_only, "\" )
        stlen   = STRINGLENGTH ( fd_only )

    ENDWHILE

    RETURN ( fd_only )

ENDROUTINE   { internal_file_name_only }

{******************************************************************************}

ROUTINE internal_file_ext_only ( VALUE fd_only )

    DECLARE tmp, stlen

    fd_only = STRIP(fd_only)
    tmp     = INDEX ( fd_only, "."   )
    stlen   = STRINGLENGTH ( fd_only )

    WHILE ( tmp > 0 ) DO

        fd_only = STRIP ( RIGHTSTRING ( fd_only, stlen - tmp ) )
        tmp     = INDEX ( fd_only, "." )
        stlen   = STRINGLENGTH ( fd_only )

    ENDWHILE

    RETURN ( fd_only )

ENDROUTINE   { internal_file_ext_only }

{******************************************************************************}

ROUTINE internal_translate_message ( VALUE message )

    DECLARE val        ,
                 msg_pointer,
                 stlen      ,
                 save_text  ,
                 a_amper    ,
                 do_pointer

    { -------------------------------------------------------------------------- }
    { May not have the global yet - so just get the setting directly             }
    { -------------------------------------------------------------------------- }

    do_pointer  = GLOBAL ( C_MESSAGE_POINTERS )
    save_text   = GLOBAL ( "FORMAT_TEXT" )
    message     = STRIP ( message )
    a_amper     = INDEX ( message, "&&" )
    stlen       = STRINGLENGTH ( message )

    { --------------------------------------------------------------------------------------- }
    { Messages can be displayed as pointers, or can be MESSAGE_PRN_###, or a specific message }
    { --------------------------------------------------------------------------------------- }

    IF NOT do_pointer THEN

        SET FORMAT "9999"

        { ------------------------------------------------------------------------------ }
        { Message is like GET_USER_MESSAGE ( an_id, 2 )                                  }
        { ------------------------------------------------------------------------------ }

        IF ( a_amper > 1 ) THEN

            msg_pointer = STRIP ( RIGHTSTRING ( message, stlen - ( a_amper + 1 ) ) )
            message     = STRIP ( LEFTSTRING ( message, a_amper - 1 ) )

            IF ( NUMTEXT ( msg_pointer ) ) THEN

                msg_pointer = NUMERIC ( msg_pointer )

            ELSE

                msg_pointer = 1

            ENDIF

        ELSE

            msg_pointer = 1

        ENDIF

        { --------------------------------------------------------- }
        { If message is MESSAGE_PRN do one way, else the other way  }
        { --------------------------------------------------------- }

        IF ( INDEX ( message, "MESSAGE_PRN" ) > 0 ) THEN

            message = ROUND ( message # "MESSAGE_PRN_" )

            val = GET MESSAGE ( message, msg_pointer )

        ELSE

            val = GET_USER_MESSAGE ( message, msg_pointer )


        ENDIF

        { --------------------------------------------------------- }
        { Any mistake then return the message pointer...            }
        { --------------------------------------------------------- }

        IF val = ERROR THEN

            val = STRIP ( message )

        ENDIF

        SET FORMAT save_text

    ELSE

        val = STRIP ( message )

    ENDIF   { when do_pointer do not do anything... allows you to run application with message id's }

    RETURN ( val )

ENDROUTINE    { internal_translate_message }

{******************************************************************************}

ROUTINE internal_convert_fso_date ( VALUE FSODate )

    DECLARE SMDate      ,          { Date to Return                }
                SMInterval  ,          { Time Interval Since Base Date }
                day         ,          { Days                          }
                hour        ,          { Hours                         }
                min         ,          { Minutes                       }
                sec         ,          { Seconds                       }
                csec                   { Hundredth of a Second         }

    IF IS_DATE(FSODate) THEN

        SMDATE = DATE(FSODate)

    ELSEIF ( FSODate = EMPTY ) OR ( BLANK ( FSODate) ) THEN

        FSODate = NOW
        SMDATE  = DATE(FSODate)

    ELSE

        day  = TRUNC(FSODate)
        hour = (FSODate - day)      *  24
        min  = (hour - TRUNC(hour)) *  60
        sec  = (min  - TRUNC(min))  *  60
        csec = (sec  - TRUNC(sec))  * 100

        IF day > C_BASEDATENUM Then
            day = day - C_BASEDATE
        ENDIF

        SMInterval = STRIP(day):" ":RIGHTSTRING("00":STRIP(TRUNC(hour)),2) :":":
                                            RIGHTSTRING("00":STRIP(TRUNC(min)) ,2) :":":
                                            RIGHTSTRING("00":STRIP(TRUNC(sec)) ,2) :".":
                                            RIGHTSTRING("00":STRIP(TRUNC(csec)),2)

        IF IS_DATE ( C_BASEDATE ) AND IS_INTERVAL ( SMInterval ) THEN
            SMDate = DATE ( C_BASEDATE ) + INTERVAL ( SMInterval )
        ELSE
            SMDATE = FSODate
        ENDIF

    ENDIF

    RETURN ( SMDate )

ENDROUTINE   { internal_convert_fso_date  }

{******************************************************************************}

GLOBAL ROUTINE internal_array_slice (       test_array  ,
                                      VALUE nested_id   ,
                                            index_found )


    DECLARE count,
                retval

    retval      = FALSE
    count       = 0
    index_found = 0

    IF ( SIZE_OF_ARRAY ( test_array ) > 0 ) THEN

        WHILE ( count < SIZE_OF_ARRAY ( test_array ) ) DO

            count = count + 1

            IF ( test_array[count] = nested_id ) THEN

                retval      = TRUE
                index_found = count
                count       = SIZE_OF_ARRAY ( test_array )  { get outta while }

            ENDIF

        ENDWHILE

    ENDIF

    RETURN ( retval )

ENDROUTINE   { internal_array_slice }

{******************************************************************************}

ROUTINE internal_array_MLP_slice (       test_array  ,
                                   VALUE nested_id   ,
                                         index_found )


    DECLARE count,
                retval

    retval      = FALSE
    count       = 0
    index_found = 0

    IF ( SIZE_OF_ARRAY ( test_array ) > 0 ) THEN

        WHILE ( count < SIZE_OF_ARRAY ( test_array ) ) DO

            count = count + 1

            IF ( INDEX ( test_array[count], nested_id ) > 0 ) THEN

                retval      = TRUE
                index_found = count
                count       = SIZE_OF_ARRAY ( test_array )  { get outta while }

            ENDIF

        ENDWHILE

    ENDIF

    RETURN ( retval )

ENDROUTINE   { internal_array_MLP_slice }

{******************************************************************************}

GLOBAL ROUTINE internal_array_2_slice (       test_array    ,
                                        VALUE nested_id     ,
                                              index_found   ,
                                        VALUE array_element )


    DECLARE count, retval

    retval      = FALSE
    count       = 0
    index_found = 0

    IF ( SIZE_OF_ARRAY ( test_array ) > 0 ) THEN

        WHILE ( count < SIZE_OF_ARRAY ( test_array ) ) DO

            count = count + 1

            IF ( test_array[count,array_element] = nested_id ) THEN

                retval      = TRUE
                index_found = count
                count       = SIZE_OF_ARRAY ( test_array )  { get outta while }

            ENDIF

        ENDWHILE

    ENDIF

    RETURN ( retval )

ENDROUTINE   { end of internal_array_2_slice }

{******************************************************************************}

ROUTINE internal_array_2_index (       test_array    ,
                                 VALUE nested_id     ,
                                       index_found   ,
                                 VALUE array_element )


    DECLARE count, retval

    retval      = FALSE
    count       = 0
    index_found = 0

    IF ( SIZE_OF_ARRAY ( test_array ) > 0 ) THEN

        WHILE ( count < SIZE_OF_ARRAY ( test_array ) ) DO

            count = count + 1

            IF ( INDEX ( test_array[count,array_element], nested_id ) > 0 ) THEN

                retval      = TRUE
                index_found = count
                count       = SIZE_OF_ARRAY ( test_array )  { get outta while }

            ENDIF

        ENDWHILE

    ENDIF

    RETURN ( retval )

ENDROUTINE   { end of internal_array_2_index }

{******************************************************************************}

ROUTINE internal_build_module_criteria ( self )

    DECLARE a_table             ,
                 a_criteria          ,
                 a_module            ,
                 id_version          ,
                 menu_id             ,
                 a_rec               ,
                 a_len1              ,
                 a_len               ,
                 a_msg               ,
                 criteria_versioned

    a_table            = STRIP ( self.userinfo )
    a_criteria         = self.value
    a_msg              = internal_translate_message ( "LIT_LAB_SMP_MODULE_COPY_OR_ADD_CRITERIA" )
    criteria_versioned = SELECT 'C_SMP_MODULE'.CRITERIA_VERSIONED

    IF NOT ( BLANK ( a_criteria ) ) THEN

        IF ( criteria_versioned ) THEN

            GET_FIELD_DETAILS CRITERIA_SAVED.IDENTITY, "FIELD_SIZE", a_len1

            a_module    = SELECT 'C_SMP_MODULE'.identity
            id_version  = SELECT 'C_SMP_MODULE'.version_number
            a_criteria  = STRIP ( C_MODULE_PREFIX : STRIP ( a_module ) ) : "_"
            a_len       = a_len1 - STRINGLENGTH ( a_criteria )
            id_version  = "000000000" : STRIP ( id_version )
            a_criteria  = a_criteria  : RIGHTSTRING ( id_version, a_len )

        ENDIF

        { ------------------------------------------------------ }
        { If record exists then modify it, else add it           }
        { ------------------------------------------------------ }

        a_rec = SELECT CRITERIA_SAVED.IDENTITY
                    WHERE TABLE_NAME = a_table
                    AND   IDENTITY   = a_criteria

        IF ( a_rec = EMPTY ) THEN

            IF ( CONFIRM_WITH_TEXT ( a_msg ) ) THEN

                menu_id = C_CRITERIA_SAVED_ADD

                MENUPROC menu_id USING a_table, a_criteria

            ELSE

                menu_id = C_CRITERIA_SAVED_COPY

                MENUPROC menu_id

            ENDIF
        ELSE

            menu_id = C_CRITERIA_SAVED_MODIFY

            MENUPROC menu_id USING a_table, a_criteria

        ENDIF

    ENDIF

    RETURN ( a_criteria )

ENDROUTINE  { internal_build_module_criteria }

{******************************************************************************}

ROUTINE internal_validate_module_criteria ( self )

    DECLARE a_rec

    IF ( self.user_info = C_STRUCTURE_TXT     )
    OR ( self.user_info = C_MESSAGE_TXT       )
    OR ( self.user_info = C_DOCUMENT_DOC      )
    OR ( self.user_info = C_HELP_FILE         )
    OR ( self.user_info = C_PRESENTATION_PPT  )
    OR ( self.user_info = C_SMW_MENU          )
    OR ( self.user_info = C_CRITERIA_CRT      )
    OR ( self.user_info = C_DEFAULT_LAB       )
    OR ( self.user_info = C_COMPILE_VGSM      )
    OR ( BLANK ( self.user_info )             ) THEN

        retval = TRUE

    ELSE

        a_rec = SELECT CRITERIA_SAVED.IDENTITY
                     WHERE TABLE_NAME = self.userinfo
                     AND   IDENTITY   = self.value

        retval = ( a_rec <> EMPTY )

    ENDIF

    RETURN ( retval )

ENDROUTINE  { internal_validate_module_criteria }

{*****************************************************************************}

ROUTINE internal_strip_subdirs ( VALUE input_fullname  ,
                                       fd_only         )

    DECLARE tmp, stlen

    fd_only    = STRIP( input_fullname)
    tmp        = INDEX ( fd_only, "\"   )
    stlen      = STRINGLENGTH ( fd_only )

    WHILE ( tmp > 0 ) DO

        fd_only = STRIP ( RIGHTSTRING ( fd_only, stlen - tmp ) )
        tmp     = INDEX ( fd_only, "\" )
        stlen   = STRINGLENGTH ( fd_only )

    ENDWHILE

ENDROUTINE   { internal_strip_subdirs }

{*****************************************************************************}

ROUTINE internal_registry_instance_values (       val_Array  ,
                                            VALUE a_mask     ,
                                            VALUE make_upper ,
                                            VALUE id_only    )

    DECLARE count, value_name, value_data, cnt2

    { ------------------------------------------------------------- }
    { Go through registry and get all data into an array            }
    { ------------------------------------------------------------- }

    cnt2       = 0
    count      = 0
    value_name = registry_enum_value ( C_REG_HKEY_LOCAL_MACHINE, C_REG_THERMO_INSTANCE:STRIP(GLOBAL("INSTANCE")), count )

    WHILE value_name <> EMPTY DO

        value_data = registry_get_value ( C_REG_HKEY_LOCAL_MACHINE, C_REG_THERMO_INSTANCE:STRIP(GLOBAL("INSTANCE")), value_name )

        { ------------------------------------------------------------- }
        { If they want all in uppercase then make all in uppercase      }
        { ------------------------------------------------------------- }

        IF make_upper THEN

            value_name = STRIP ( TOUPPER ( value_name ) )
            a_mask     = STRIP ( TOUPPER ( a_mask ) )

        ENDIF

        IF ( BLANK ( a_mask ) ) THEN

            cnt2              = cnt2 + 1
            val_Array[cnt2,1] = value_name

        ELSEIF ( INDEX ( value_name, a_mask ) > 0 ) THEN

            cnt2              = cnt2 + 1
            val_Array[cnt2,1] = value_name
        ENDIF

        { ------------------------------------------------------------- }
        { If they want Id's only (IDENTITY) then use value_name again   }
        { ------------------------------------------------------------- }

        IF ( id_only ) THEN
            val_Array[cnt2,2] = value_name
        ELSE
            val_Array[cnt2,2] = value_data
        ENDIF

        count      = count + 1
        value_name = registry_enum_value ( C_REG_HKEY_LOCAL_MACHINE, C_REG_THERMO_INSTANCE:STRIP(GLOBAL("INSTANCE")), count )

    ENDWHILE

ENDROUTINE    {  internal_registry_instance_values }

{*****************************************************************************}

ROUTINE internal_phrase_logicals ( val_Array )

    DECLARE a_id,
            a_cnt

    a_cnt = 0
    a_id  = SELECT PHRASE.PHRASE_TEXT WHERE PHRASE_TYPE = C_PHRASE_LOGICALS

    WHILE ( a_id <> EMPTY ) DO

        a_cnt              = a_cnt + 1
        val_Array[a_cnt,1] = a_id
        val_Array[a_cnt,2] = a_id

        NEXT PHRASE

        a_id = SELECT PHRASE.PHRASE_TEXT

    ENDWHILE

    RETURN

ENDROUTINE    { internal_phrase_logicals }

{ **************************************************************************** }

ROUTINE internal_get_an_identity ( VALUE a_table     ,
                                   VALUE a_title     ,
                                   VALUE a_msg       ,
                                   VALUE a_x1        ,
                                   VALUE a_x2        ,
                                         select_array,
                                         GLBL_id     )

    DECLARE form      ,
                 a_prompt  ,
                 a_prompt2 ,
                 a_prompt3 ,
                 a_len     ,
                 smp_vers  ,
                 a_msg2    ,
                 a_msg3

    smp_vers = PAD ( SUBSTITUTE ( smp_version_number(), " ", "" ), " ", 10 )
    smp_vers = PAD ( SUBSTITUTE ( smp_version_number(), ".", "" ), " ", 10 )

    IF ( smp_vers = "2004R2" ) OR ( INDEX ( C_SMP_VERSIONS, smp_vers ) > 0 ) THEN

        { -------------------------- }
        { Use $prompt_window         }
        { -------------------------- }

        retval = vgl_prompt_in_window_criteria ( a_table, a_title, a_msg, a_x1, select_array, GLBL_id )

    ELSE

        CREATE OBJECT PROMPT_CLASS_FORM, form
            form.header = a_title
            form.height = 3
            form.width  = STRINGLENGTH ( a_title ) + 40   { boxes for close window are big }
            form.column = 20
            form.row    = 10

        a_msg2 = internal_translate_message ( "LIT_LAB_SMP_MODULE_SMP_VERSION" )
        a_msg3 = internal_translate_message ( "LIT_LAB_SMP_MODULE_VERSION"     )

        a_len = find_max_number ( STRINGLENGTH ( STRIP ( a_msg ) ), STRINGLENGTH ( STRIP ( a_msg2 ) ) )
        a_len = find_max_number ( a_len, STRINGLENGTH ( STRIP ( a_msg3 ) ) )
        a_len = a_len + 3


        PROMPT OBJECT a_prompt
        ON LINE 1 FROM a_len to form.width - 2
        BROWSE ON 'C_SMP_MODULE'.SMP_VERSION
        WITH (VALUE = "IMPORTGLB")
        a_prompt.mandatory_array = select_array

{BLOCK created by CONSULT-02 to make the selection of data more lean.}

        PROMPT OBJECT a_prompt2
        ON LINE 2 FROM a_len to form.width - 2
        BROWSE ON 'C_SMP_MODULE'.IDENTITY
        WITH (enter_prompt_routine = "enter_prompt_id")

{        a_prompt2.mandatory_array = select_array}

        PROMPT OBJECT a_prompt3 ON LINE 3 FROM a_len to form.width - 2 BROWSE ON 'C_SMP_MODULE'.VERSION_NUMBER
        WITH (enter_prompt_routine = "enter_prompt_vn")
        a_prompt3.mandatory_array = select_array

{END BLOCK created by CONSULT-02.}

        form.add_prompt( a_prompt  )
        form.add_prompt( a_prompt2 )
        form.add_prompt( a_prompt3 )

        form.add_display ( a_msg2, 1, 1, PROMPT_RENDITION_RAISED )
        form.add_display ( a_msg , 1, 2, PROMPT_RENDITION_RAISED )
        form.add_display ( a_msg3, 1, 3, PROMPT_RENDITION_RAISED )

        form.start_prompt()
        form.wait_prompt()
        form.end_prompt()

        IF ( form.get_lastkey() = "EXIT"   )
        OR ( ( BLANK ( a_prompt.value ) )
        OR   ( BLANK ( a_prompt.value ) )
        OR   ( BLANK ( a_prompt.value ) )  ) THEN

            ret_val = FALSE

        ELSE

            GLBL_id = a_prompt.value : a_prompt2.value : a_prompt3.value
            ret_val = TRUE

        ENDIF

    ENDIF

    RETURN ( ret_val )

ENDROUTINE   { internal_get_an_identity }

{BLOCK created by CONSULT-02 to make the selection of data more lean.}

{ **************************************************************************** }
ROUTINE enter_prompt_id ( self )

DECLARE id

id = self . parent_prompt . prompt_objects [1] . text

IF ( id <> EMPTY ) AND ( NOT BLANK ( id )) THEN

ARRAY self . mandatory_array

    ARRAY_SELECT_ADD ( self . mandatory_array, ARRAY_SELECT_EQ, "FILES_UPDATED"  , FALSE )
    array_select_add ( self . mandatory_array, ARRAY_SELECT_AND ,EMPTY, EMPTY )
    ARRAY_SELECT_ADD ( self . mandatory_array, ARRAY_SELECT_EQ, "DATE_INSTALLED" , NULL  )
    array_select_add ( self . mandatory_array, ARRAY_SELECT_AND ,EMPTY, EMPTY )
    ARRAY_SELECT_ADD ( self . mandatory_array, ARRAY_SELECT_EQ ,"SMP_VERSION" ,id )

ENDIF

ENDROUTINE


{ **************************************************************************** }
ROUTINE enter_prompt_vn ( self )

DECLARE id1, id2

id1 = self . parent_prompt . prompt_objects [1] . text
id2 = self . parent_prompt . prompt_objects [2] . text

IF ( id1 <> EMPTY ) AND ( NOT BLANK ( id1 )) AND ( id2 <> EMPTY ) AND ( NOT BLANK ( id2 )) THEN

ARRAY self . mandatory_array

    ARRAY_SELECT_ADD ( self . mandatory_array, ARRAY_SELECT_EQ, "FILES_UPDATED"  , FALSE )
    array_select_add ( self . mandatory_array, ARRAY_SELECT_AND ,EMPTY, EMPTY )
    ARRAY_SELECT_ADD ( self . mandatory_array, ARRAY_SELECT_EQ, "DATE_INSTALLED" , NULL  )
    array_select_add ( self . mandatory_array, ARRAY_SELECT_AND ,EMPTY, EMPTY )
    ARRAY_SELECT_ADD ( self . mandatory_array, ARRAY_SELECT_EQ ,"SMP_VERSION" ,id1 )
    array_select_add ( self . mandatory_array, ARRAY_SELECT_AND ,EMPTY, EMPTY )
    ARRAY_SELECT_ADD ( self . mandatory_array, ARRAY_SELECT_EQ ,"IDENTITY" ,id2 )

ENDIF

ENDROUTINE

{ **************************************************************************** }

{END BLOCK created by CONSULT-02.}

ROUTINE internal_get_zip_identity ( VALUE a_title     ,
                                    VALUE a_msg       ,
                                          GLBL_id     ,
                                    VALUE a_mode      )
    DECLARE form         ,
                 prompt_object,
                 a_len

    CREATE OBJECT PROMPT_CLASS_FORM, form
        form.header           = a_title : " " : a_mode
        form.height           = 1
        form.width            = 120
        form.column           = 10
        form.row              = 10
        form.confirm_required = TRUE

    a_len = STRINGLENGTH ( STRIP ( a_msg ) ) + 5

    PROMPT OBJECT prompt_object BROWSE ON FILE
        prompt_object.file_directory       = C_SMP_MODULE_INSTALL_SET_DIR
        prompt_object.file_extension       = a_mode
        prompt_object.row                  = 1
        prompt_object.column               = a_len
        prompt_object.width                = form.width - 5
        prompt_object.window               = form
        prompt_object.client_file          = TRUE
        prompt_object.user_info            = TRUE
        prompt_object.allow_multiple       = FALSE
        prompt_object.display_only         = FALSE
        prompt_object.format_only          = FALSE
        prompt_object.vgl_library          = GLOBAL ( "CURRENT_LIBRARY" )

    form.add_prompt( prompt_object )
    form.add_display ( a_msg, 1, 1, PROMPT_RENDITION_RAISED )

    form.start_prompt()
    form.wait_prompt()
    form.end_prompt()

    IF ( form.get_lastkey() = "EXIT" ) OR ( BLANK ( prompt_object.value ) ) THEN

        GLBL_id = ""
        retval  = FALSE

    ELSE

        GLBL_id = prompt_object.value
        retval  = TRUE

    ENDIF  { form lastkey exit or blank file }

    RETURN ( retval )

ENDROUTINE   { internal_get_zip_identity }

{ **************************************************************************** }

ROUTINE internal_create_record ( VALUE a_destination     ,
                                 VALUE a_id              ,
                                 VALUE structure_updated ,
                                 VALUE is_new_record     ,
                                 VALUE is_import_data    )

    DECLARE status      ,
                 a_under     ,
                 a_id1       ,
                 a_id2       ,
                 a_id3       ,
                 a_id4       ,
                 a_len1      ,
                 a_len2      ,
                 a_len       ,
                 a_byte

    GET_FIELD_DETAILS 'C_SMP_MODULE'.SMP_VERSION, "FIELD_SIZE", a_len1
    GET_FIELD_DETAILS 'C_SMP_MODULE'.IDENTITY   , "FIELD_SIZE", a_len2

    is_new_record = FALSE
    retval        = FALSE
    a_id4         = STRIP ( TOUPPER ( a_id ) )
    a_len         = STRINGLENGTH ( a_id )
    a_id3         = ""
    a_under       = INDEX ( a_id4, "_" )

    a_id1         = PAD ( LEFTSTRING ( a_id4, a_under - 1 ), " ", a_len1 )
    a_id4         = STRIP ( RIGHTSTRING ( a_id4, a_len - a_under ) )
    a_len         = STRINGLENGTH ( a_id4 )
    a_byte        = GET_CHARACTER_AT ( a_id4, a_len )

    WHILE ( INDEX ( "0123456789", a_byte ) > 0 ) DO

        a_id3  = a_byte : a_id3
        a_len  = a_len - 1
        a_byte = GET_CHARACTER_AT ( a_id4, a_len )

    ENDWHILE

    { ------------------------------------------------------- }
    { Now get the right most bytes until not a number...      }
    { ------------------------------------------------------- }

    a_id2 = PAD ( LEFTSTRING ( a_id4, a_len - 1 ), " ", a_len2 )
    a_id3 = PACKED_DECIMAL ( a_id3 )

    IF ( a_id3 = ERROR ) OR ( a_id3 = "Error" ) THEN

        a_id3 = PACKED_DECIMAL ( 1 )

    ENDIF

    { --------------------------------------------------------------------------- }
    { Create the identity in the smp_module table                                 }
    { --------------------------------------------------------------------------- }

    START WRITE TRANSACTION C_PACKAGER_WRITE_TRANS

    status = SELECT 'C_SMP_MODULE'.IDENTITY FOR UPDATE
                  WHERE SMP_VERSION    = a_id1
                  AND   IDENTITY       = a_id2
                  AND   VERSION_NUMBER = a_id3

    IF ( status = EMPTY ) THEN

        RESERVE ENTRY 'C_SMP_MODULE', a_id1:a_id2:a_id3, status
        is_new_record = TRUE

    ELSEIF ( status = ERROR ) OR ( status = LOCKED ) THEN

        FLASH_MESSAGE ( "LIT_LAB_SMP_MODULE_ERROR_RESERVE", TRUE )

    ELSEIF ( a_destination = C_DEFAULT_PACKAGE_ID ) THEN

        status = "Update completed for " : C_DEFAULT_PACKAGE_ID    { this does not need a message translation }

    ELSE

        status = EMPTY

    ENDIF

    { --------------------------------------------------------------------------- }
    { Ok so far, then update fields and extract the file on the new location      }
    { --------------------------------------------------------------------------- }

    IF ( status = EMPTY ) THEN

        ASSIGN 'C_SMP_MODULE'.MODIFIED_ON          = NOW
        ASSIGN 'C_SMP_MODULE'.MODIFIED_BY          = OPERATOR
        ASSIGN 'C_SMP_MODULE'.INSTALL_SET_ZIP_FILE = a_destination
        ASSIGN 'C_SMP_MODULE'.STRUCTURE_UPDATED    = structure_updated

        IF ( is_import_data ) THEN

            ASSIGN 'C_SMP_MODULE'.STRUCTURE_UPDATED    = TRUE
            ASSIGN 'C_SMP_MODULE'.MESSAGES_UPDATED     = TRUE
            ASSIGN 'C_SMP_MODULE'.SMW_MENU_UPDATED     = TRUE
            ASSIGN 'C_SMP_MODULE'.MODULE_TYPE          = "GLOBAL"

        ENDIF

        UPDATE 'C_SMP_MODULE', status

        IF ( status <> EMPTY ) THEN

            IF ( NOT structure_updated ) THEN
                a_byte = internal_translate_message ( "LIT_LAB_SMP_MODULE_ERROR_UPDATE" ) : status
            ELSE
                a_byte = "* ERROR * SMP_MODULE Update " : status
            ENDIF

            ROLLBACK

            FLASH_MESSAGE ( a_byte, TRUE )

        ELSE

            retval = TRUE
            COMMIT

        ENDIF

    ELSE

        a_byte = C_SMP_MODULE : " " : status

        IF NOT ( a_destination = C_DEFAULT_PACKAGE_ID ) THEN

            retval = CONFIRM_WITH_TEXT ( a_byte )

        ELSE

            retval = FALSE      { maybe make this a TRUE ???? }

        ENDIF

        ROLLBACK

    ENDIF  { status empty on update or reserve }

    RETURN ( retval )

ENDROUTINE    { internal_create_record }

{ **************************************************************************** }
{                                                                              }
{                                                                              }
{                                                                              }
{                                                                              }
{   A C T I O N S   W H E N   M O V I N G   Z I P  /  S E L F  E X T R A C T   }
{                                                                              }
{                                                                              }
{                                                                              }
{                                                                              }
{ **************************************************************************** }

ROUTINE packager_action_move_zip_make_install ( a_obj )

    DECLARE zip_option

    retval = TRUE

    { ---------------------------------------------------------- }
    { Make sure target dir exists and if not create it           }
    { ---------------------------------------------------------- }

    IF NOT ( FILE EXISTS ( a_obj.install_set_kit_dir ) ) THEN

        retval = internal_create_directory ( a_obj.install_set_kit_dir )

    ENDIF

    { ---------------------------------------------------------- }
    { We could be doing a self extract EXE or a ZIP file         }
    { ---------------------------------------------------------- }

    IF ( a_obj.a_mode = "EXE" ) THEN

        zip_option = a_obj.install_set_sfx_id

    ELSE

        zip_option = a_obj.install_set_zip_id

    ENDIF

    { ---------------------------------------------------------- }
    { Dir there or made ok, is the kit already there ?           }
    { ---------------------------------------------------------- }

    IF ( retval ) AND ( NOT FILE EXISTS ( zip_option ) ) THEN

        FILE COPY a_obj.install_set_source, zip_option, status

        IF ( FILE EXISTS ( zip_option ) ) THEN

            retval = a_obj.move_expand_server_kit( zip_option )

        ELSE

            retval = FALSE
            FLASH_MESSAGE ( "LIT_LAB_SMP_MODULE_ERROR_MOVE_KIT", FALSE )

        ENDIF

    ELSE

        retval = FALSE
        {FLASH_MESSAGE ( "LIT_LAB_SMP_MODULE_ERROR_KIT_EXISTS", FALSE )}
        {WriteToLog("LIT_LAB_SMP_MODULE_ERROR_KIT_EXISTS")}

    ENDIF

    RETURN ( retval )

ENDROUTINE  { packager_action_move_zip_make_install }

{ **************************************************************************** }

ROUTINE packager_action_move_expand_server_kit ( a_obj      ,
                                                 zip_option )

    DECLARE exObj   ,
                a_array ,
                a_cnt   ,
                found   ,
                found1  ,
                found2  ,
                found3

    found  = FALSE
    retval = FALSE

    IF ( a_obj.a_mode <> "EXE" ) AND ( FILE EXISTS ( "SMP$PROGRAMS\":C_7ZA_EXE ) ) THEN

        { --------------------------------------------------------------------------- }
        { Extract the file either by zip or self extracting                           }
        { --------------------------------------------------------------------------- }

        IF ( C_7ZIP_USE_DOT_NET ) THEN

            CREATE OBJECT CLASS_STD_NET_SERVER, exObj

            exObj.create ( C_7_ZIP, C_THERMO_7_ZIP, "")

            exObj.ArchiveFile   = zip_option
            exObj.Folder        = STRIP ( a_obj.install_set_kit_dir )
            exObj.LogFile       = STRIP ( a_obj.install_set_kit_dir ) : "\" : a_obj.key0_underscore : ".log"
            exObj.AppendLog     = TRUE
            exObj.OverwriteMode = "t"
            exObj.AssumeYes     = FALSE
            exObj.ExtractMode   = "x"

            IF exObj.Extract() THEN

                retval = TRUE

            ELSE

                FLASH_MESSAGE ( exObj.LastError, FALSE )

            ENDIF

            exObj.Dispose()
            exObj = EMPTY

        ELSEIF NOT ( a_obj.move_expand_7zip() ) THEN

            IF ( GLOBAL ( "MODE" ) = "INTERACTIVE" ) THEN

                retval = CONFIRM_WITH_TEXT ( "LIT_PACKAGER_28" )

            ELSE

                retval = FALSE
                FLASH_MESSAGE ( "Unable to expand kit " : a_obj.fd_only, FALSE )

            ENDIF

        ELSE

            retval = TRUE

        ENDIF   { use net mode... }

    ELSEIF ( a_obj.a_mode = "EXE" ) THEN

        { -------------------------------------------- }
        { 7 zip self extract ok then save all          }
        { -------------------------------------------- }

        IF NOT ( a_obj.move_expand_self_extract( zip_option ) ) THEN

            IF ( GLOBAL ( "MODE" ) = "INTERACTIVE" ) THEN

                retval = CONFIRM_WITH_TEXT ( "LIT_PACKAGER_28" )

            ELSE

                retval = FALSE
                FLASH_MESSAGE ( "Unable to expand kit " : a_obj.fd_only , FALSE )
            ENDIF

        ELSE

            retval = TRUE

        ENDIF

    ELSE

        { -------------------------------------------- }
        { 7 zip not installed, manual unzip to be done }
        { -------------------------------------------- }

        retval = TRUE
        FLASH_MESSAGE ( "** MANUAL expand kit " : a_obj.fd_only , FALSE )

    ENDIF  { update status on database of smp_module is ok }

    { -------------------------------------------------- }
    { If expansion done and not a_first then update db   }
    { -------------------------------------------------- }

    IF ( retval ) AND ( NOT a_obj.a_first ) THEN

        retval = internal_create_record ( zip_option, a_obj.key0_underscore, a_obj.is_export_set, found, a_obj.is_export_set )

        IF ( retval ) AND ( NOT found ) AND ( NOT a_obj.is_export_set ) THEN

            exObj = STRIP ( a_obj.install_set_kit_dir ) : "\*.*"

            FILE FIND exObj, a_array, status

            IF ( status = EMPTY ) AND ( SIZE_OF_ARRAY ( a_array ) > 0 ) THEN

                found  = FALSE
                found1 = FALSE
                found2 = FALSE
                found3 = FALSE
                a_cnt  = 1

                WHILE ( a_array[a_cnt] <> EMPTY ) AND NOT ( found ) DO

                    IF     ( INDEX ( a_array[a_cnt], "SMP_MODULE"          ) > 0 ) THEN

                        found1 = TRUE

                    ELSEIF ( INDEX ( a_array[a_cnt], "SMP_MODULE_CRITERIA" ) > 0 ) THEN

                        found2 = TRUE

                    ELSEIF ( INDEX ( a_array[a_cnt], "CRITERIA_SAVED"      ) > 0 ) THEN

                        found3 = TRUE

                    ENDIF

                    IF ( found1 ) AND ( found2 ) AND ( found3 ) THEN

                        found = TRUE

                    ENDIF

                    a_cnt = a_cnt + 1

                ENDWHILE

                IF ( found ) THEN

                    a_obj.sm_version_0_ok = TRUE

                ENDIF

            ENDIF   { status from file find and array has files }

        ENDIF {  retval from create record }
    ELSEIF ( NOT retval ) THEN

        FLASH_MESSAGE ( "Move Zip did not expand " : a_obj.fd_only, TRUE )

    ENDIF  { expand ok and not a FIRST install (self install of packager) }

    RETURN ( retval )

ENDROUTINE  { packager_action_move_expand_server_kit }

{ **************************************************************************** }

ROUTINE packager_action_move_expand_self_extract ( a_obj      ,
                                                   zip_option )

    DECLARE logfile   ,
                 regfile   ,
                 a_log_dir ,
                 a_semi    ,
                 a_spawn   ,
                 a_colon   ,
                 a_disk

    retval    = FALSE
    a_log_dir = LOGICAL ( "SMP$TEXTREPORTS" )
    a_semi    = INDEX ( a_log_dir, ";" )

    IF ( a_semi > 0 ) THEN

        a_log_dir = LEFTSTRING ( a_log_dir, a_semi - 1 )

    ENDIF

    a_colon   = INDEX ( a_log_dir, ":" )
    a_disk    = LEFTSTRING ( a_log_dir, a_colon )

    logfile   = STRIP(a_obj.key0_underscore) : "_move_expand_extract.log"
    regfile   = a_log_dir : "\" : a_obj.key0_underscore        : ".BAT"

    FILE DELETE regfile, status
    FILE CREATE regfile, status
    FILE EXTEND regfile, status

    IF status = EMPTY THEN

        FILE WRITE regfile, a_disk                                                            , status
        FILE WRITE regfile, "cd " : ASCII(34) : a_obj.install_set_kit_dir  : ASCII(34)        , status
        FILE WRITE regfile,         ASCII(34) : zip_option                 : ASCII(34) : " -y", status
        FILE WRITE regfile, "exit"                                                            , status

        IF status = EMPTY THEN

            FILE CLOSE regfile, status

            IF status = EMPTY THEN

                a_spawn = ASCII(34): regfile :ASCII(34) : " >> " : ASCII(34): STRIP (a_log_dir:"\":log_file) :ASCII(34) : " 2>&1"

                SPAWN "cmd /E:ON /D /A /C " : a_spawn, status QUIETLY

                retval = status = EMPTY

                IF NOT retval THEN

                    FLASH_MESSAGE ( "LIT_PACKAGER_05", TRUE )

                ELSE

                    FILE DELETE regfile, status
                    FILE COPY   a_log_dir : "\" :logfile, a_obj.install_set_kit_dir : "\" : logfile
                    FILE DELETE a_log_dir : "\" :logfile, status

                ENDIF

            ENDIF  { file close }

        ENDIF  { file write }

    ENDIF  { file extend }

    RETURN ( retval )

ENDROUTINE   {  packager_action_move_expand_self_extract }

{ **************************************************************************** }

ROUTINE packager_action_move_expand_7zip ( a_obj )

    DECLARE logfile   ,
            zip_cmd   ,
                 regfile   ,
                 a_log_dir ,
                 a_exe_dir ,
                 a_semi    ,
                 a_disk    ,
                 a_colon   ,
                 a_spawn

    retval    = FALSE
    a_log_dir = LOGICAL ( "SMP$TEXTREPORTS" )
    a_semi    = INDEX ( a_log_dir, ";" )

    IF ( a_semi > 0 ) THEN

        a_log_dir = LEFTSTRING ( a_log_dir, a_semi - 1 )

    ENDIF

    a_exe_dir = LOGICAL ( "SMP$PROGRAMS" )
    a_semi    = INDEX ( a_exe_dir, ";" )

    IF ( a_semi > 0 ) THEN

        a_exe_dir = LEFTSTRING ( a_exe_dir, a_semi - 1 )

    ENDIF

    a_colon   = INDEX ( a_log_dir, ":" )
    a_disk    = LEFTSTRING ( a_log_dir, a_colon )

    logfile   = STRIP(a_obj.key0_underscore ) : "_zip.log"
    regfile   = a_log_dir : "\" : a_obj.key0_underscore         : "_zip.BAT"

    zip_cmd   = ASCII(34) : a_exe_dir : "\" : C_7ZA_EXE : ASCII(34) : " " : C_7ZIP_ZIP_EXTRACT_CMD :" ":
                ASCII(34) : a_obj.install_set_kit_dir   : ASCII(34) : " " : C_7ZIP_UNZIP_OVERWRITE

    FILE DELETE regfile, status
    FILE CREATE regfile, status
    FILE EXTEND regfile, status

    IF status = EMPTY THEN

        FILE WRITE regfile, a_disk                                                   , status
        FILE WRITE regfile, "cd " : ASCII(34) : a_obj.install_set_kit_dir : ASCII(34), status
        FILE WRITE regfile, zip_cmd                                                  , status
        FILE WRITE regfile, "exit"                                                   , status

        IF status = EMPTY THEN

            FILE CLOSE regfile, status

            IF status = EMPTY THEN

                a_spawn = ASCII(34): regfile :ASCII(34) : " >> " : ASCII(34): STRIP (a_log_dir:"\":log_file) :ASCII(34) : " 2>&1"

                SPAWN "cmd /E:ON /D /A /C " : a_spawn, status QUIETLY

                retval = status = EMPTY

                IF NOT retval THEN

                    FLASH_MESSAGE ( "LIT_PACKAGER_05", TRUE )

                ELSE

                    FILE DELETE regfile, status
                    FILE COPY   a_log_dir : "\" : logfile, a_obj.install_set_kit_dir : "\" : logfile
                    FILE DELETE a_log_dir : "\" : logfile, status

                ENDIF

            ENDIF  { file close }

        ENDIF  { file write }

    ENDIF  { file extend }

    RETURN ( retval )

ENDROUTINE   {  packager_action_move_expand_7zip }

{ **************************************************************************** }

ROUTINE packager_action_move_make_rollback_kit (       a_obj         ,
                                                 VALUE a_dest_dir    ,
                                                 VALUE fd_only       )


    DECLARE a_byte     ,
                 a_len      ,
                 kit0_obj

    { --------------------------------------------------------------- }
    { Change fd_only to _0 for the new key                            }
    { --------------------------------------------------------------- }

    retval        = FALSE
    a_obj.fd_only = STRIP ( TOUPPER ( a_obj.fd_only ) )
    a_len         = STRINGLENGTH ( a_obj.fd_only )
    a_byte        = GET_CHARACTER_AT ( a_obj.fd_only, a_len )

    WHILE ( a_byte <> "_" ) DO

        a_len  = a_len - 1
        a_byte = GET_CHARACTER_AT ( a_obj.fd_only, a_len )

    ENDWHILE

    a_obj.fd_only = LEFTSTRING ( a_obj.fd_only, a_len ) : "0"

    { --------------------------------------------------------------- }
    { Change the key0 to now use the Version 0 kit                    }
    { --------------------------------------------------------------- }

    a_obj.key0 = LEFTSTRING ( a_obj.key0, a_obj.key1_len + a_obj.key2_len ) : PACKED_DECIMAL ( 0 )

    { --------------------------------------------------------------- }
    { Now build the new key0 kit in the smp_module table              }
    { --------------------------------------------------------------- }

    retval = internal_create_record ( a_dest_dir, a_obj.fd_only, FALSE, TRUE, FALSE )

    IF ( retval ) THEN

        { --------------------------------------------------------------- }
        { Now copy the smp_xxx.csv files changing to version 0 and load   }
        { --------------------------------------------------------------- }

        retval = a_obj.move_load_0_version_csv ( a_dest_dir, a_obj.fd_only )

        IF ( retval ) THEN

            { --------------------------------------------------------------- }
            { Now build a "kit" - in special build mode to skip nonexist data }
            { --------------------------------------------------------------- }

            retval   = ( retval ) AND ( internal_build_package ( a_obj.key0, kit0_obj ) )
            kit0_obj = EMPTY

        ENDIF  { retval from mod load csv data (changes all to version 0) }

    ENDIF   { retval ok... }

    RETURN ( retval )

ENDROUTINE   {  packager_action_move_make_rollback_kit }

{ **************************************************************************** }

ROUTINE packager_action_move_load_0_version_csv (       a_obj        ,
                                                  VALUE a_dest_dir   ,
                                                  VALUE a_v0_id      )


    DECLARE files_1_array,
                 files_2_array,
                 a_cnt        ,
                 a_dot        ,
                 status

    ARRAY files_1_array
    ARRAY files_2_array

    retval = TRUE

    { --------------------------------------------------------------- }
    { Find all smp_module_???.csv files and copy to _0_ version       }
    { --------------------------------------------------------------- }

    FILE FIND a_dest_dir : "\SMP_MODULE_*.CSV", files_1_array, status

    IF ( status = EMPTY ) AND ( SIZE_OF_ARRAY ( files_1_array ) > 0 ) THEN

        a_cnt = 1

        WHILE ( files_1_array[a_cnt] <> EMPTY ) AND ( status = EMPTY ) DO

            a_dot                = INDEX ( files_1_array[a_cnt], "." )
            files_2_array[a_cnt] = LEFTSTRING ( files_1_array[a_cnt], a_dot - 1 ) : "-Version_0.csv"

            FILE COPY files_1_array[a_cnt], files_2_array[a_cnt], status

            a_cnt = a_cnt + 1

        ENDWHILE

        { --------------------------------------------------------------- }
        { Open, edit each line changing the version_number to 0           }
        { --------------------------------------------------------------- }

        IF ( a_cnt >= SIZE_OF_ARRAY ( files_2_array ) ) THEN

            a_cnt = 1

            WHILE ( files_2_array[a_cnt] <> EMPTY ) AND ( retval ) DO

                retval = a_obj.move_edit_1_file ( files_2_array[a_cnt] )
                a_cnt  = a_cnt + 1

            ENDWHILE

            { --------------------------------------------------------------- }
            { All files edited and saved ok ?  load them into version 0 key   }
            { --------------------------------------------------------------- }

            IF ( a_cnt >= SIZE_OF_ARRAY ( files_2_array ) ) THEN

                a_cnt = 1

                WHILE ( files_2_array[a_cnt] <> EMPTY ) AND ( retval ) DO

                    { ----------------------------------------------------- }
                    { Set mode of the load from the filename                }
                    { ----------------------------------------------------- }

                    IF     ( INDEX ( files_2_array[a_cnt], "OVERWRITE" ) > 0 ) THEN

                        a_obj.a_mode = "overwrite_table"

                    ELSEIF ( INDEX ( files_2_array[a_cnt], "ERASE" ) > 0 ) THEN

                        a_obj.a_mode = "wipe_table"

                    ELSE

                        a_obj.a_mode = "ignore_file"

                    ENDIF

                    { ---------------------------------------------------- }
                    { Low level interface to table saver keep messages     }
                    { ---------------------------------------------------- }

                    a_obj.fd_only = internal_file_name_only ( files_2_array[a_cnt] )
                    retval        = a_obj.install_load_csv ( files_2_array[a_cnt] )
                    a_cnt         = a_cnt + 1

                ENDWHILE

            ELSE

                retval = FALSE
                FLASH_MESSAGE ( "LIT_LAB_SMP_MODULE_ERROR_VERSION_0_COPY", TRUE )

            ENDIF

        ELSE

            retval = FALSE
            FLASH_MESSAGE ( "LIT_LAB_SMP_MODULE_ERROR_VERSION_0_COPY", TRUE )

        ENDIF

    ELSE

        retval = FALSE
        FLASH_MESSAGE ( "LIT_LAB_SMP_MODULE_ERROR_VERSION_0_COPY", TRUE )

    ENDIF  { did not find any files for smp module, this is not real good }

    { ----------------------------------------------------- }
    { If all files are ok and loaded then copy criteria's   }
    { ----------------------------------------------------- }

    IF ( retval ) THEN

        retval = a_obj.move_copy_criteria ( a_dest_dir, a_v0_id )

    ENDIF

    RETURN ( retval )

ENDROUTINE  {  packager_action_move_load_0_version_csv }

{ **************************************************************************** }

ROUTINE packager_action_move_edit_1_file (       a_obj      ,
                                           VALUE a_file_id  )

    DECLARE a_cnt            ,
                 stlen            ,
                 status           ,
                 a_byte           ,
                 ver_no_loc       ,
                 no_commas        ,
                 tmpString        ,
                 no_records_2_load,
                 lines_array

    retval = TRUE

    ARRAY lines_array

    FILE OPEN a_file_id, status

    IF ( status = EMPTY ) THEN

        { --------------------------------------------------------------- }
        { Read the fields line, counting commas to VERSION_NUMBER field   }
        { --------------------------------------------------------------- }

        FILE READ a_file_id, lines_array[1], status     { 1rst line is table name }
        FILE READ a_file_id, lines_array[2], status     { 2nd line is field names }

        IF ( status = EMPTY ) THEN

            { --------------------------------------------------------------- }
            { Change the actual data lines so that version 0 is now the key   }
            { --------------------------------------------------------------- }

            ver_no_loc = INDEX ( lines_array[2], "VERSION_NUMBER" )
            tmpString  = LEFTSTRING ( lines_array[2], ver_no_loc - 1 )

            IF ( ver_no_loc > 0 ) THEN

                stlen     = STRINGLENGTH ( tmpString )
                a_cnt     = 1
                no_commas = 0

                WHILE ( a_cnt <= stlen ) DO

                    a_byte = GET_CHARACTER_AT( tmpString, a_cnt )

                    IF ( a_byte = "," ) THEN

                        no_commas = no_commas + 1

                    ENDIF

                    a_cnt = a_cnt + 1

                ENDWHILE

                { --------------------------------------------------------------- }
                { Read the 3rd and 4th lines to get to the data lines             }
                { --------------------------------------------------------------- }

                FILE READ a_file_id, lines_array[3], status     { 3rd line is field sizes }
                FILE READ a_file_id, lines_array[4], status     { 4th line is num records }

                no_records_2_load = STRIP ( NUMERIC ( lines_array[4] ) )

                { --------------------------------------------------------------- }
                { Routine to rebuild the rest of the lines changing version to 0  }
                { --------------------------------------------------------------- }

                IF NOT ( a_obj.move_rebuild_data_lines ( a_file_id, no_commas, no_records_2_load, lines_array ) ) THEN

                    retval = FALSE
                    a_msg  = internal_translate_message ( "LIT_LAB_SMP_MODULE_ERROR_VERSION_0_COPY" ) : a_file_id : status
                    FLASH_MESSAGE ( a_msg, TRUE )

                ENDIF


            ELSE

                retval = FALSE
                a_msg  = internal_translate_message ( "LIT_LAB_SMP_MODULE_ERROR_VERSION_0_COPY" ) : a_file_id : status
                FLASH_MESSAGE ( a_msg, TRUE )

            ENDIF   { did not find version_number in CSV file }

        ELSE

            retval = FALSE
            a_msg  = internal_translate_message ( "LIT_LAB_SMP_MODULE_ERROR_VERSION_0_COPY" ) : a_file_id : status
            FLASH_MESSAGE ( a_msg, TRUE )

        ENDIF  { status on file read to 2nd line }

    ELSE

        retval = FALSE
        a_msg  = internal_translate_message ( "LIT_LAB_SMP_MODULE_ERROR_VERSION_0_COPY" ) : a_file_id : status
        FLASH_MESSAGE ( a_msg, TRUE )

    ENDIF  { status from file open }

    { --------------------------------------------------------------- }
    { Close file, status empty return ok, file can then be loaded     }
    { --------------------------------------------------------------- }

    FILE CLOSE a_file_id, status

    IF ( status <> EMPTY ) THEN

        retval = FALSE
        a_msg  = internal_translate_message ( "LIT_LAB_SMP_MODULE_ERROR_VERSION_0_COPY" ) : a_file_id : status
        FLASH_MESSAGE ( a_msg, TRUE )

    ELSE

        { ---------------------------------------------------------------- }
        { File read ok, and all lines rebuilt - so rebuild the file        }
        { ---------------------------------------------------------------- }

        FILE DELETE a_file_id, status
        FILE CREATE a_file_id, status
        FILE EXTEND a_file_id, status

        a_cnt = 1

        IF ( status <> EMPTY ) THEN

            retval = FALSE
            a_msg  = internal_translate_message ( "LIT_LAB_SMP_MODULE_ERROR_VERSION_0_COPY" ) : a_file_id : status
            FLASH_MESSAGE ( a_msg, TRUE )

        ELSE


            WHILE ( status = EMPTY ) AND ( lines_array[a_cnt] <> EMPTY ) DO

                FILE WRITE a_file_id, lines_array[a_cnt], status

                a_cnt = a_cnt + 1

            ENDWHILE


        ENDIF  { status from extend not empty }


        FILE CLOSE a_file_id, status

        retval = ( status = EMPTY ) AND ( a_cnt >= no_records_2_load + 3 )

    ENDIF  { status from close original file copied }

    { ---------------------------------------------- }
    { Let caller know if we are ok or had issues     }
    { ---------------------------------------------- }

    RETURN ( retval )

ENDROUTINE  {  packager_action_move_edit_1_file }

{ **************************************************************************** }

ROUTINE packager_action_move_rebuild_data_lines (       a_obj             ,
                                                  VALUE a_file_id         ,
                                                  VALUE no_commas         ,
                                                  VALUE no_records_2_load ,
                                                        lines_array       )

    DECLARE left_line  ,
                 right_line ,
                 status     ,
                 a_cnt      ,
                 a_cnt2     ,
                 a_cnt3     ,
                 a_comma    ,
                 stlen      ,
                 longest

    retval = TRUE
    status = EMPTY
    a_cnt  = 1
    a_cnt3 = 5

    { --------------------------------------------------------------- }
    { Rebuild each line with "0" as the version number                }
    { --------------------------------------------------------------- }

    WHILE ( status = EMPTY ) AND ( a_cnt <= no_records_2_load ) DO

        a_cnt2     = 1
        left_line  = ""
        right_line = ""

        FILE READ a_file_id, lines_array[a_cnt3], status

        IF ( status = EMPTY ) THEN

            stlen    = STRINGLENGTH( lines_array[a_cnt3] )
            a_comma  = INDEX ( lines_array[a_cnt3], "," )
            longest  = stlen

            WHILE ( a_cnt2 <= no_commas ) AND ( a_comma > 0 ) DO

                left_line  = LEFTSTRING  ( lines_array[a_cnt3], a_comma         )
                right_line = STRIP ( RIGHTSTRING ( lines_array[a_cnt3], stlen - a_comma ) )
                a_comma    = INDEX ( right_line, "," )

                IF ( a_comma > 0 ) THEN

                    a_cnt2     = a_cnt2 + 1
                    stlen      = STRINGLENGTH ( right_line )
                    left_line  = left_line : LEFTSTRING  ( right_line, a_comma )
                    right_line = STRIP ( RIGHTSTRING ( right_line, stlen - a_comma ) )

                ENDIF

                { ------------------------------------------------------------ }
                { That got the 1rst 2 fields, now cut out the version number   }
                { ------------------------------------------------------------ }

                IF ( a_cnt2 = no_commas ) THEN

                    a_comma    = INDEX ( right_line, "," )                  { if 3rd this should be version }
                    stlen      = STRINGLENGTH ( right_line )
                    left_line  = left_line : ASCII(34) : "0" : ASCII(34)
                    right_line = RIGHTSTRING ( right_line, stlen - a_comma )

                    a_comma             = 0
                    lines_array[a_cnt3] = left_line :",": PAD ( right_line, " ", longest )

                ENDIF

            ENDWHILE { no commas until version number }

        ENDIF  { status EMPTY on READ }

        a_cnt  = a_cnt + 1
        a_cnt3 = a_cnt3 + 1

    ENDWHILE  { status empty on read and a_cnt is less than or equal to no recs in csv file }

    RETURN ( retval )

ENDROUTINE  {  packager_action_move_rebuild_data_lines }

{ **************************************************************************** }

ROUTINE packager_action_move_copy_criteria (     a_obj      ,
                                           VALUE a_dest_dir ,
                                           VALUE a_v0_id    )

    DECLARE files_1_array ,
                 a_cnt         ,
                 status        ,
                 a_criteria_dir,
                 ext_pos

    ARRAY files_1_array

    retval = TRUE

    { --------------------------------------------------------------- }
    { Criteria moves to the smp criteria first in multiple path       }
    { --------------------------------------------------------------- }

    a_criteria_dir = LOGICAL ( "SMP$CRITERIA" )
    ext_pos        = INDEX ( a_criteria_dir, ";" )

    IF ( ext_pos > 0 ) THEN

        a_criteria_dir = LEFTSTRING ( a_criteria_dir, ext_pos - 1 )

    ENDIF

    { --------------------------------------------------------------- }
    { Find all smp_module_???.csv files and copy to _0_ version       }
    { --------------------------------------------------------------- }

    FILE FIND a_dest_dir : "\SMP_CRITERIA\*.CRT", files_1_array, status

    IF ( status = EMPTY ) AND ( SIZE_OF_ARRAY ( files_1_array ) > 0 ) THEN

        a_cnt = 1

        WHILE ( files_1_array[a_cnt] <> EMPTY ) AND ( retval ) DO

            retval = a_obj.install_copy_1_file ( files_1_array[a_cnt], a_criteria_dir )
            a_cnt  = a_cnt + 1

        ENDWHILE

    ENDIF

    RETURN ( retval )

ENDROUTINE   { packager_action_move_copy_criteria }

{******************************************************************************}

GLOBAL ROUTINE internal_logical_to_string ( VALUE logical_name )

    DECLARE temp_file, semi_colon

    temp_file  = LOGICAL ( logical_name )
    semi_colon = INDEX ( temp_file, ";" )

    IF semi_colon > 1 THEN

        temp_file = SUBSTRING ( temp_file, 1, semi_colon - 1 )

    ELSEIF semi_colon = 1 THEN

        temp_file = SUBSTRING ( temp_file, 2, LENGTH ( temp_file ) - 1 )

    ENDIF

    RETURN ( STRIP ( temp_file ))

ENDROUTINE  { internal_logical_to_string }

{******************************************************************************}
{                                                                              }
{                                                                              }
{                                                                              }
{                                                                              }
{   L T E    P R O M P T S    for maintenance of the smp module fields         }
{                                                                              }
{                                                                              }
{                                                                              }
{                                                                              }
{******************************************************************************}

ROUTINE prompt_smp_module_program_dll   (       std_obj     ,
                                                grid        ,
                                          VALUE cell_column ,
                                          VALUE cell_row    ,
                                          VALUE column      ,
                                          VALUE row         ,
                                          VALUE cell_width  ,
                                                window      ,
                                          VALUE is_display  )


    DECLARE form         ,
                cs_prompt    ,
                dll_prompt   ,
                accepted     ,
                val          ,
                filename_only

    accepted = FALSE

    IF ( std_obj <> EMPTY ) THEN
        val = SELECT 'C_SMP_MODULE_PROGRAM'.program_dll IN OBJECT std_obj
    ELSE
        val = SELECT 'C_SMP_MODULE_PROGRAM'.program_dll
    ENDIF

    IF is_display THEN

        DISPLAY val ON LINE row FROM column TO column + cell_width - 1 IN WINDOW window

    ELSEIF ( NOT BLANK ( val ) ) THEN

        PROMPT FOR val ON LINE row FROM column TO column + cell_width - 1 IN WINDOW window WITH ( display_only = TRUE )

    ELSE

        PROMPT OBJECT form CLASS PROMPT_CLASS_FORM
            form.column           = 10
            form.row              = 10
            form.width            = 100
            form.height           = 2
            form.border           = TRUE
            form.header           = internal_translate_message ( "LIT_LAB_SMP_MODULE_PROGRAM_DLL" )
            form.confirm_required = FALSE
            form.return_behaviour = FORM_RETURN_LEAVE
            form.proportional     = TRUE

        PROMPT OBJECT cs_prompt  ON LINE 1 FROM 32 TO 45 FORMAT 'C_SMP_MODULE_PROGRAM'.client_server
        PROMPT OBJECT dll_prompt ON LINE 2 FROM 32 BROWSE ON FILE

        cs_prompt.leave_prompt_routine = "internal_leave_program_dll_prompt"

        dll_prompt.file_extension  = "*"
        dll_prompt.window          = window
        dll_prompt.allow_multiple  = FALSE
        dll_prompt.format_only     = FALSE

        form.add_display ( PAD ( internal_translate_message ("LIT_LAB_SMP_MODULE_CLIENT_SERVER"), " ",30),2,1,PROMPT_RENDITION_BOLD+PROMPT_RENDITION_RAISED )
        form.add_display ( PAD ( internal_translate_message ("LIT_LAB_SMP_MODULE_PROGRAM_DLL")  , " ",30),2,2,PROMPT_RENDITION_BOLD+PROMPT_RENDITION_RAISED )
        form.add_prompt ( cs_prompt  )
        form.add_prompt ( dll_prompt )
        form.add_frame ( "", 1, 1, 2, form.width - 1 )
        form.start_prompt()

        REPEAT

            form.wait_prompt()

            accepted = form.get_lastkey() = "DO"

            IF ( accepted ) AND ( std_obj <> EMPTY ) THEN

                IF NOT BLANK ( dll_prompt.value ) THEN
                    internal_strip_subdirs ( dll_prompt.value, filename_only )
                ELSE
                    filename_only = ""
                ENDIF

                ASSIGN 'C_SMP_MODULE_PROGRAM'.program_dll   IN OBJECT std_obj = dll_prompt.value
                ASSIGN 'C_SMP_MODULE_PROGRAM'.client_server IN OBJECT std_obj = cs_prompt.value
                ASSIGN 'C_SMP_MODULE_PROGRAM'.filename_only IN OBJECT std_obj = filename_only

                DISPLAY dll_prompt.value ON LINE row FROM column TO column + cell_width - 1 IN WINDOW window

                SET GLOBAL "LASTKEY" TO "RIGHT"

            ELSE

                SET GLOBAL "LASTKEY" TO "EXIT"
                accepted = TRUE

            ENDIF

        UNTIL accepted

        form.end_prompt()

    ENDIF  { is_display }

ENDROUTINE   { prompt_smp_module_program_dll }

{******************************************************************************}

ROUTINE internal_leave_program_dll_prompt ( self )

    self.parent_prompt.prompt_objects[2].client_file    = self.parent_prompt.prompt_objects[1].value
    self.parent_prompt.prompt_objects[2].file_directory = LOGICAL ( "SMP$PROGRAMS" )

ENDROUTINE   { internal_leave_program_dll_prompt }

{******************************************************************************}

ROUTINE prompt_smp_module_file_logical   (      std_obj     ,
                                                grid        ,
                                          VALUE cell_column ,
                                          VALUE cell_row    ,
                                          VALUE column      ,
                                          VALUE row         ,
                                          VALUE cell_width  ,
                                                window      ,
                                          VALUE is_display  )

    DECLARE val       ,
                 old_val   ,
                 dis2_array,
                 cnt1      ,
                 a_mask    ,
                 a_TRUE

    a_TRUE  = TRUE
    a_mask  = "smp$"

    IF ( std_obj <> EMPTY ) THEN
        val = SELECT 'C_SMP_MODULE_CRITERIA'.file_logical IN OBJECT std_obj
    ELSE
        val = SELECT 'C_SMP_MODULE_CRITERIA'.file_logical
    ENDIF

    old_val = val

    IF is_display THEN

        DISPLAY val ON LINE row FROM column TO column + cell_width - 1 IN WINDOW window

    ELSE

        ARRAY dis2_array

        IF ( C_REG_SERVER_LOGICALS ) THEN

            internal_registry_instance_values ( dis2_array, a_mask, a_TRUE, a_TRUE )

        ELSE

            internal_phrase_logicals ( dis2_array )

        ENDIF

        cnt1               = SIZE_OF_ARRAY ( dis2_array ) + 1
        dis2_array[cnt1,1] = ""
        dis2_array[cnt1,2] = ""

        PROMPT FOR val ON LINE row FROM column TO column + cell_width - 1 IN WINDOW window CHOOSE OUTOF dis2_array

        IF ( val <> old_val ) THEN

            IF ( std_obj <> EMPTY ) THEN
                ASSIGN 'C_SMP_MODULE_CRITERIA'.file_logical IN OBJECT std_obj = val
            ELSE
                ASSIGN 'C_SMP_MODULE_CRITERIA'.file_logical                   = val
            ENDIF

        ENDIF

        IF val = NULL THEN
            DISPLAY " " ON LINE row FROM column TO column + cell_width - 1 IN WINDOW window
        ELSE
            DISPLAY val ON LINE row FROM column TO column + cell_width - 1 IN WINDOW window
        ENDIF

    ENDIF  { is_display }

ENDROUTINE   { prompt_smp_module_file_logical }

{******************************************************************************}

ROUTINE prompt_smp_module_criteria_file_sub_directory (       std_obj     ,
                                                              grid        ,
                                                        VALUE cell_column ,
                                                        VALUE cell_row    ,
                                                        VALUE column      ,
                                                        VALUE row         ,
                                                        VALUE cell_width  ,
                                                              window      ,
                                                        VALUE is_display  )

    DECLARE val, old_val, subdir_array, a_logical, a_TRUE, a_FALSE

    ARRAY subdir_array

    a_TRUE  = TRUE
    a_FALSE = FALSE

    IF ( std_obj <> EMPTY ) THEN
        a_logical = SELECT 'C_SMP_MODULE_CRITERIA'.file_logical       IN OBJECT std_obj
        val       = SELECT 'C_SMP_MODULE_CRITERIA'.file_sub_directory IN OBJECT std_obj
    ELSE
        a_logical = SELECT 'C_SMP_MODULE_CRITERIA'.file_logical
        val       = SELECT 'C_SMP_MODULE_CRITERIA'.file_sub_directory
    ENDIF

    old_val = val

    IF is_display THEN

        DISPLAY val ON LINE row FROM column TO column + cell_width - 1 IN WINDOW window

    ELSEIF ( NOT BLANK ( old_val ) ) THEN

        PROMPT FOR val ON LINE row FROM column TO column + cell_width - 1 IN WINDOW window

        IF ( val <> old_val ) THEN

            IF ( std_obj <> EMPTY ) THEN
                ASSIGN 'C_SMP_MODULE_CRITERIA'.file_sub_directory IN OBJECT std_obj = val
            ELSE
                ASSIGN 'C_SMP_MODULE_CRITERIA'.file_sub_directory                   = val
            ENDIF

        ENDIF

        IF ( val = NULL ) OR ( BLANK ( val ) )  THEN
            DISPLAY " " ON LINE row FROM column TO column + cell_width - 1 IN WINDOW window
        ELSE
            DISPLAY val ON LINE row FROM column TO column + cell_width - 1 IN WINDOW window
        ENDIF

    ELSE

        a_logical = STRIP ( LOGICAL ( a_logical ) ) : "\"

        IF ( internal_get_sub_directories ( a_logical    ,
                                                    subdir_array ,
                                                    val          ,
                                                    row          ,
                                                    column       ,
                                                    cell_width   ,
                                                    window       ,
                                                    a_TRUE       ,
                                                    a_FALSE      ) ) THEN

            IF ( val <> old_val ) THEN

                IF ( std_obj <> EMPTY ) THEN
                    ASSIGN 'C_SMP_MODULE_CRITERIA'.file_sub_directory IN OBJECT std_obj = val
                ELSE
                    ASSIGN 'C_SMP_MODULE_CRITERIA'.file_sub_directory                   = val
                ENDIF

            ENDIF

            IF ( val = NULL ) OR ( BLANK ( val ) )  THEN
                DISPLAY " " ON LINE row FROM column TO column + cell_width - 1 IN WINDOW window
            ELSE
                DISPLAY val ON LINE row FROM column TO column + cell_width - 1 IN WINDOW window
            ENDIF

        ENDIF  { internal_get_sub_directories }

    ENDIF  { is_display }

ENDROUTINE   { prompt_smp_module_criteria_file_sub_directory }

{******************************************************************************}

ROUTINE internal_get_sub_directories ( VALUE a_logical    ,
                                             sub_dir_array,
                                             val          ,
                                       VALUE row          ,
                                       VALUE column       ,
                                       VALUE cell_width   ,
                                             window       ,
                                       VALUE append_blank ,
                                       VALUE ActX_Enabled )


    DECLARE fso      ,
                 form     ,
                 ObjFolder

    IF ( ActX_Enabled ) THEN

        CREATE OBJECT PROMPT_CLASS_FORM, form
        form.header           = a_logical
        form.row              = GLOBAL ( "SCREEN_HEIGHT" ) - 15
        form.column           = 20
        form.height           = 2
        form.width            = 55
        form.icon             = "INT_BROWSE"
        form.return_behaviour = FORM_RETURN_STAY
        form.button_style     = FORM_BUTTON_OK_CANCEL

        PROMPT OBJECT fso CLASS CLASS_STD_OLE_AUTOMATION_SERVER   {STD_OLE_AUTOMATION_SERVER / STD_PROMPT_OCX }
        fso.create ( "Shell.Application" )

        form.add_prompt ( fso )
        form.start_prompt()

        ObjFolder = fso.BrowseForFolder ( 0, a_logical, 0, 36 )

        IF ( ObjFolder <> EMPTY ) AND ( ObjFolder <> NULL ) THEN

            val = ObjFolder.self.Path

        ENDIF

        ObjFolder = EMPTY
        fso       = EMPTY

    ELSEIF ( NOT BLANK ( a_logical ) ) THEN

        { ------------------------------------------ }
        { NO OCX so do it the old fashioned way      }
        { ------------------------------------------ }

        PROMPT FOR val ON LINE row FROM column TO column + cell_width - 1 IN WINDOW window
        BROWSE ON VALID_PHRASE.SMP_DIRS


    ELSEIF ( append_blank ) THEN

        sub_dir_array[1,1] = ""
        sub_dir_array[1,2] = ""

        PROMPT FOR val ON LINE row FROM column TO column + cell_width - 1 IN WINDOW window
        CHOOSE OUT_OF subdir_array


    ENDIF


    RETURN ( NOT BLANK ( val ) )

ENDROUTINE  {  internal_get_sub_directories }

{******************************************************************************}

ROUTINE internal_OCX_File ( VALUE a_logical  ,
                                  a_filename )

    DECLARE form, fso

    CREATE OBJECT PROMPT_CLASS_FORM, form
        form.header           = a_logical
        form.row              = GLOBAL ( "SCREEN_HEIGHT" ) - 15
        form.column           = 20
        form.height           = 2
        form.width            = 55
        form.icon             = "INT_BROWSE"
        form.return_behaviour = FORM_RETURN_STAY
        form.button_style     = FORM_BUTTON_OK_CANCEL

    PROMPT OBJECT fso CLASS "STD_PROMPT_OCX"
        fso.control_name = "MSComDlg.CommonDialog"

    form.add_prompt ( fso )
    form.start_prompt()

    fso.set_property ( "InitDir" , a_logical )
    fso.set_property ( "Flags"   , 526604    )
    fso.set_property ( "filename", "*.*"     )

    fso.invoke ( "ShowOpen")

    a_filename = fso.get_property("filename")

ENDROUTINE

{******************************************************************************}

ROUTINE prompt_smp_module_criteria_file_id (       std_obj     ,
                                                   grid        ,
                                             VALUE cell_column ,
                                             VALUE cell_row    ,
                                             VALUE column      ,
                                             VALUE row         ,
                                             VALUE cell_width  ,
                                                   window      ,
                                             VALUE is_display  )


    DECLARE val          ,
                 a_directory  ,
                 a_extension  ,
                 a_sub_dir    ,
                 prompt_object

    IF ( std_obj <> EMPTY ) THEN

        val         = STRIP ( SELECT 'C_SMP_MODULE_CRITERIA'.file_id             IN OBJECT std_obj )
        a_sub_dir   = STRIP ( SELECT 'C_SMP_MODULE_CRITERIA'.file_sub_directory  IN OBJECT std_obj )
        a_directory = STRIP ( SELECT 'C_SMP_MODULE_CRITERIA'.file_logical        IN OBJECT std_obj ) :"\": a_sub_dir
        a_extension = STRIP ( SELECT 'C_SMP_MODULE_CRITERIA'.file_extension      IN OBJECT std_obj )

    ELSE

        val         = STRIP ( SELECT 'C_SMP_MODULE_CRITERIA'.file_id             )
        a_sub_dir   = STRIP ( SELECT 'C_SMP_MODULE_CRITERIA'.file_sub_directory  )
        a_directory = STRIP ( SELECT 'C_SMP_MODULE_CRITERIA'.file_logical        ) :"\": a_sub_dir
        a_extension = STRIP ( SELECT 'C_SMP_MODULE_CRITERIA'.file_extension      )

    ENDIF

    IF is_display THEN

        DISPLAY val ON LINE row FROM column TO column + cell_width - 1 IN WINDOW window

    ELSE

        PROMPT OBJECT prompt_object BROWSE ON FILE
            prompt_object.file_directory  = a_directory
            prompt_object.file_extension  = a_extension
            prompt_object.row             = row
            prompt_object.column          = column
            prompt_object.width           = cell_width - 1
            prompt_object.window          = window
            prompt_object.value           = val
            prompt_object.display_only    = is_display
            prompt_object.client_file     = FALSE
            prompt_object.format_only     = FALSE
            prompt_object.allow_multiple  = FALSE

        prompt_object.start_prompt()

        IF NOT is_display THEN

            prompt_object.wait_prompt()

            IF ( prompt_object.value = a_directory ) OR ( BLANK ( prompt_object.value ) ) THEN

                val                 = ""
                prompt_object.value = ""
                DISPLAY " " ON LINE row FROM column TO column + cell_width - 1 IN WINDOW window

            ELSE

                internal_strip_subdirs ( prompt_object.value, val )


                DISPLAY val ON LINE row FROM column TO column + cell_width - 1 IN WINDOW window

            ENDIF

            IF ( std_obj <> EMPTY ) THEN

                ASSIGN 'C_SMP_MODULE_CRITERIA'.file_id IN OBJECT std_obj = val

            ELSE

                ASSIGN 'C_SMP_MODULE_CRITERIA'.file_id                   = val

            ENDIF

        ENDIF

        prompt_object.end_prompt()
        prompt_object.set_globals()

    ENDIF  { is_display }

ENDROUTINE   { prompt_smp_module_criteria_file_id }

{********************************************************************************}

ROUTINE prompt_smp_module_menu_short_text_V1 ( VALUE column     ,
                                               VALUE row        ,
                                               VALUE cell_width ,
                                                     screen     ,
                                                     is_display )

    DECLARE a_empty

    a_empty = EMPTY

    prompt_smp_module_menu_short_text (  a_empty     ,
                                              a_empty     ,
                                              column      ,
                                              row         ,
                                              column      ,
                                              row         ,
                                              cell_width  ,
                                              screen      ,
                                              is_display  )

ENDROUTINE    {  prompt_smp_module_menu_short_text_v1 }

{******************************************************************************}

ROUTINE prompt_smp_module_menu_short_text   (      std_obj     ,
                                                   grid        ,
                                             VALUE cell_column ,
                                             VALUE cell_row    ,
                                             VALUE column      ,
                                             VALUE row         ,
                                             VALUE cell_width  ,
                                                   window      ,
                                             VALUE is_display  )

    DECLARE val         ,
                 proc_num

    IF ( std_obj <> EMPTY ) THEN

        proc_num     = SELECT 'C_SMP_MODULE_MENU'.PROCEDURE_NUM IN OBJECT std_obj
        val          = SELECT 'C_SMP_MODULE_MENU'.SHORT_TEXT    IN OBJECT std_obj

    ELSE

        proc_num = SELECT 'C_SMP_MODULE_MENU'.PROCEDURE_NUM
        val      = SELECT 'C_SMP_MODULE_MENU'.SHORT_TEXT

    ENDIF

    { ------------------------------------------------------------------- }
    { If it is not set, then go get the value using the procedure num     }
    { ------------------------------------------------------------------- }

    IF BLANK ( val ) THEN

        val = SELECT MASTER_MENU.SHORT_TEXT WHERE PROCEDURE_NUM = proc_num

        IF val = EMPTY THEN
            val = ""
        ENDIF

    ENDIF

    IF is_display THEN

        DISPLAY val ON LINE row FROM column TO column + cell_width - 1 IN WINDOW window

    ELSE

        PROMPT FOR val ON LINE row FROM column TO column + cell_width - 1 IN WINDOW window WITH ( display_only = TRUE, value = val )

        IF ( std_obj <> EMPTY ) THEN
            ASSIGN 'C_SMP_MODULE_MENU'.short_text IN OBJECT std_obj = val
        ELSE
            ASSIGN 'C_SMP_MODULE_MENU'.short_text                   = val
        ENDIF

        IF val = NULL THEN
            DISPLAY " " ON LINE row FROM column TO column + cell_width - 1 IN WINDOW window
        ELSE
            DISPLAY val ON LINE row FROM column TO column + cell_width - 1 IN WINDOW window
        ENDIF

    ENDIF  { is_display }

ENDROUTINE   { prompt_smp_module_menu_short_text }

{********************************************************************************}

ROUTINE prompt_smp_module_menu_new_procedure_num_V1 ( VALUE column     ,
                                                      VALUE row        ,
                                                      VALUE cell_width ,
                                                            screen     ,
                                                            is_display )

    DECLARE a_empty

    a_empty = EMPTY

    prompt_smp_module_menu_new_procedure_num (  a_empty     ,
                                                     a_empty     ,
                                                     column      ,
                                                     row         ,
                                                     column      ,
                                                     row         ,
                                                     cell_width  ,
                                                     screen      ,
                                                     is_display  )

ENDROUTINE    {  prompt_smp_module_menu_new_procedure_num_V1 }

{******************************************************************************}

ROUTINE prompt_smp_module_menu_new_procedure_num   (      std_obj     ,
                                                          grid        ,
                                                    VALUE cell_column ,
                                                    VALUE cell_row    ,
                                                    VALUE column      ,
                                                    VALUE row         ,
                                                    VALUE cell_width  ,
                                                          window      ,
                                                    VALUE is_display  )

    DECLARE val          ,
                 proc_num     ,
                 proc_context ,
                 menu_updated ,
                 do_new_1

    { ------------------------------------------------------------------- }
    { 2 items from main LTE header control if update is allowed...        }
    { ------------------------------------------------------------------- }

    proc_context = SELECT 'C_SMP_MODULE'.MENU_CONTEXT
    menu_updated = SELECT 'C_SMP_MODULE'.SMW_MENU_UPDATED

    IF ( std_obj <> EMPTY ) THEN

        proc_num = SELECT 'C_SMP_MODULE_MENU'.PROCEDURE_NUM     IN OBJECT std_obj
        val      = SELECT 'C_SMP_MODULE_MENU'.NEW_PROCEDURE_NUM IN OBJECT std_obj
        do_new_1 = SELECT 'C_SMP_MODULE_MENU'.GENERATE_NEW_ONE  IN OBJECT std_obj

    ELSE   { using 2002 system... }

        proc_num = SELECT 'C_SMP_MODULE_MENU'.PROCEDURE_NUM
        val      = SELECT 'C_SMP_MODULE_MENU'.NEW_PROCEDURE_NUM
        do_new_1 = SELECT 'C_SMP_MODULE_MENU'.GENERATE_NEW_ONE

    ENDIF

    { ------------------------------------------------------------------- }
    { If it is not set, then go get the value using the procedure num     }
    { ------------------------------------------------------------------- }

    IF NOT ( is_display ) AND ( NOT menu_updated ) AND ( do_new_1 ) THEN

        IF BLANK ( proc_context ) THEN

            proc_context = C_PROCEDURE_CONTEXT

        ENDIF

        val = SELECT MASTER_MENU.PROCEDURE_NUM WHERE PROCEDURE_NUM = proc_num

        IF val = EMPTY THEN

            val = C_PROCEDURE_OK

        ELSEIF ( NOT menu_updated ) THEN

            val = internal_create_procedure_num ( proc_context, cell_row, std_obj )

        ENDIF   {  val is ok or we made a new one }

    ELSEIF ( NOT do_new_1 ) THEN   { show them the original proc number - user wants coerce of numbers }

        val = proc_num

    ENDIF  { val NULL or blank }

    { ----------------------------------------------------------------------------- }
    { Got all the data, now prompt/display and get user acceptance...               }
    { ----------------------------------------------------------------------------- }

    IF is_display THEN

        DISPLAY val ON LINE row FROM column TO column + cell_width - 1 IN WINDOW window

    ELSE

        PROMPT FOR val ON LINE row FROM column TO column + cell_width - 1 IN WINDOW window WITH ( display_only = TRUE, value = val )

        IF ( NUMTEXT ( val ) ) THEN

            IF ( std_obj <> EMPTY ) THEN
                ASSIGN 'C_SMP_MODULE_MENU'.new_procedure_num IN OBJECT std_obj = val
            ELSE
                ASSIGN 'C_SMP_MODULE_MENU'.new_procedure_num                   = val
            ENDIF

        ENDIF  {  only assign if it is a number }

        { ----------------------------------------------------------------------------- }
        { Redisplay to show if the procedure is ok and does not need to be changed      }
        { ----------------------------------------------------------------------------- }

        IF ( val = NULL ) OR ( val = 0 ) OR ( val = C_PROCEDURE_OK ) THEN
            DISPLAY C_PROCEDURE_OK ON LINE row FROM column TO column + cell_width - 1 IN WINDOW window
        ELSE
            DISPLAY val            ON LINE row FROM column TO column + cell_width - 1 IN WINDOW window
        ENDIF

    ENDIF  { is_display }

ENDROUTINE   { prompt_smp_module_menu_new_procedure_num }

{*****************************************************************************}

ROUTINE internal_create_procedure_num ( VALUE proc_context ,
                                        VALUE row          ,
                                              a_list       )
    DECLARE a_cnt     ,
                 used_array,
                 a_proc_num

    { ---------------------------------------------------------------- }
    { Get first one using menu tools, get subsequent lookup and check  }
    { ---------------------------------------------------------------- }

    a_proc_num = lib_menu_get_new_proc_num( proc_context )


    { ---------------------------------------------------------------- }
    { If error on row 1 then due to context on main LTE form           }
    { ---------------------------------------------------------------- }

    IF ( a_proc_num = EMPTY ) THEN

        a_msg = internal_translate_message ( "LIT_LAB_SMP_MODULE_MENU_INVALID_CONTEXT" ) : proc_context

        FLASH_MESSAGE ( a_msg, TRUE )

        a_proc_num = C_PROCEDURE_OK

    ELSEIF ( row > 1 ) THEN

        ARRAY used_array

        a_cnt = 1
        a_list.collection.set_first()

        WHILE ( a_list.collection.current <> EMPTY ) DO

            IF NOT ( a_list.collection.current.deleted ) THEN

                used_array[a_cnt,1] = SELECT 'C_SMP_MODULE_MENU'.NEW_PROCEDURE_NUM IN OBJECT a_list.collection.current
                used_array[a_cnt,2] = SELECT 'C_SMP_MODULE_MENU'.SHORT_TEXT        IN OBJECT a_list.collection.current
                a_cnt               = a_cnt + 1

            ENDIF

            a_list.collection.set_next()

        ENDWHILE

        { ----------------------------------------------------------- }
        { Got all that are being used, now check for uniqueness       }
        { ----------------------------------------------------------- }

        internal_create_procedure_num_master_menu ( a_proc_num, used_array )

    ENDIF

    RETURN ( a_proc_num )

ENDROUTINE   { internal_create_procedure_num }

{*****************************************************************************}

ROUTINE internal_create_procedure_num_master_menu ( a_proc_num  ,
                                                    used_array  )

    DECLARE found    ,
                 val      ,
                 check_val

    val = SELECT MASTER_MENU.PROCEDURE_NUM WHERE PROCEDURE_NUM = a_proc_num

    IF ( val <> EMPTY ) OR ( internal_array_2_slice ( used_array, a_proc_num, found, 1 ) ) THEN

        val = a_proc_num

        WHILE ( val <> EMPTY ) DO

            val = val + 1

            IF ( ( val MOD 10 ) = 0 ) THEN

                val = val + 1

            ENDIF

            check_val = val
            val       = SELECT MASTER_MENU.PROCEDURE_NUM WHERE PROCEDURE_NUM = check_val

            IF ( internal_array_2_slice ( used_array, check_val, found, 1 ) ) THEN

                val = check_val

            ELSEIF ( val = EMPTY ) THEN

                a_proc_num = check_val

            ENDIF

        ENDWHILE

    ENDIF  { the one passed in is ok (val is empty) }

    RETURN ( a_proc_num )

ENDROUTINE   { internal_create_procedure_num_master_menu }

{*****************************************************************************}

ROUTINE prompt_smp_module_install_set ( VALUE column     ,
                                        VALUE row        ,
                                        VALUE cell_width ,
                                              window     ,
                                        VALUE is_display )


    DECLARE prompt_object,
            field_value

    field_value = SELECT 'C_SMP_MODULE'.install_set

    PROMPT OBJECT prompt_object BROWSE ON FILE
        prompt_object.file_directory  = C_SMP_MODULE_INSTALL_SET_DIR
        prompt_object.file_extension  = C_SMP_MODULE_INSTALL_SET_EXT
        prompt_object.row             = row
        prompt_object.column          = column
        prompt_object.width           = cell_width - 1
        prompt_object.window          = window
        prompt_object.value           = field_value
        prompt_object.display_only    = is_display
        prompt_object.user_info       = TRUE
        prompt_object.client_file     = TRUE
        prompt_object.format_only     = FALSE
        prompt_object.allow_multiple  = FALSE

    prompt_object.start_prompt()

    IF NOT is_display THEN

        prompt_object.wait_prompt()

        IF ( BLANK ( prompt_object.value ) ) THEN

            ASSIGN 'C_SMP_MODULE'.install_set = C_SMP_MODULE_INSTALL_SET_DIR :".": C_SMP_MODULE_INSTALL_SET_EXT

        ELSE

            ASSIGN 'C_SMP_MODULE'.install_set = prompt_object.value

        ENDIF

    ENDIF

    prompt_object.end_prompt ( )
    prompt_object.set_globals ( )

ENDROUTINE    { prompt_smp_module_install_set }

{*****************************************************************************}

ROUTINE prompt_smp_module_install_set_zip ( VALUE column     ,
                                            VALUE row        ,
                                            VALUE cell_width ,
                                                  window     ,
                                            VALUE is_display )


    DECLARE prompt_object,
            field_value

    field_value = SELECT 'C_SMP_MODULE'.install_set_zip_file

    PROMPT OBJECT prompt_object BROWSE ON FILE
        prompt_object.file_directory  = C_SMP_MODULE_INSTALL_SET_DIR
        prompt_object.file_extension  = "ZIP"
        prompt_object.row             = row
        prompt_object.column          = column
        prompt_object.width           = cell_width - 1
        prompt_object.window          = window
        prompt_object.value           = field_value
        prompt_object.display_only    = is_display
        prompt_object.user_info       = TRUE
        prompt_object.client_file     = TRUE
        prompt_object.format_only     = FALSE
        prompt_object.allow_multiple  = FALSE

    prompt_object.start_prompt()

    IF NOT is_display THEN

        prompt_object.wait_prompt()

        IF ( prompt_object.value = C_SMP_MODULE_INSTALL_SET_DIR :".ZIP" ) THEN

            ASSIGN 'C_SMP_MODULE'.install_set_zip_file = ""
            DISPLAY "                                 " AT row, column IN WINDOW window

        ELSE

            ASSIGN 'C_SMP_MODULE'.install_set_zip_file = prompt_object.value
        ENDIF

    ENDIF

    prompt_object.end_prompt ( )
    prompt_object.set_globals ( )

ENDROUTINE    { prompt_smp_module_install_set_zip }

{******************************************************************************}

ROUTINE prompt_smp_module_criteria_table_name  (      self        ,
                                                      grid        ,
                                                VALUE cell_column ,
                                                VALUE cell_row    ,
                                                VALUE column      ,
                                                VALUE row         ,
                                                VALUE cell_width  ,
                                                      window      ,
                                                VALUE is_display  )

    DECLARE val    ,
                 tables ,
                 count  ,
                 mode   ,
                 a_id

    IF ( self <> EMPTY ) THEN
        val  = SELECT 'C_SMP_MODULE_CRITERIA'.table_name IN OBJECT self
        mode = SELECT 'C_SMP_MODULE_CRITERIA'.save_mode  IN OBJECT self
    ELSE
        val  = SELECT 'C_SMP_MODULE_CRITERIA'.table_name
        mode = SELECT 'C_SMP_MODULE_CRITERIA'.save_mode
    ENDIF

    IF is_display THEN

        DISPLAY val ON LINE row FROM column TO column + cell_width - 1 IN WINDOW window FORMAT TEXT30

    ELSE

        { ------------------------------------------------------------------------ }
        { First get real table names.....                                          }
        { ------------------------------------------------------------------------ }

        GET_TABLE_NAMES ( tables )
        count = 1

        WHILE count <= SIZE_OF_ARRAY ( tables ) DO

            tables [ count, 2 ] = tables [ count, 1 ]
            count               = count + 1

        ENDWHILE

        { ------------------------------------------------------------------------ }
        { Now dummy line in case user wants to clear and put nothing...            }
        { ------------------------------------------------------------------------ }

        tables [ count, 1 ] = ""
        tables [ count, 2 ] = ""

        { ------------------------------------------------------------------------ }
        { Finally, tack on any table alias (20 char max) and special types         }
        { ------------------------------------------------------------------------ }

        a_id = SELECT PHRASE.PHRASE_TEXT WHERE PHRASE_TYPE = C_PHRASE_CRITERIA_TABLE

        WHILE ( a_id <> EMPTY ) DO

            count               = count + 1
            tables [ count, 1 ] = a_id
            tables [ count, 2 ] = a_id

            NEXT PHRASE

            a_id = SELECT PHRASE.PHRASE_TEXT

        ENDWHILE


        PROMPT FOR val ON LINE row FROM column TO column + cell_width - 1 IN WINDOW window CHOOSE OUT_OF tables

        IF ( self <> EMPTY ) THEN

            ASSIGN 'C_SMP_MODULE_CRITERIA'.table_name IN OBJECT self = val
            ASSIGN 'C_SMP_MODULE_CRITERIA'.mode_table IN OBJECT self = mode : val

        ELSE

            ASSIGN 'C_SMP_MODULE_CRITERIA'.table_name  = val
            ASSIGN 'C_SMP_MODULE_CRITERIA'.mode_table  = mode : val

        ENDIF

    ENDIF  { not display only }

ENDROUTINE { prompt_smp_module_criteria_table_name }

{*****************************************************************************}

ROUTINE prompt_smp_module_criteria_saved (      self        ,
                                                grid        ,
                                          VALUE cell_column ,
                                          VALUE cell_row    ,
                                          VALUE column      ,
                                          VALUE row         ,
                                          VALUE cell_width  ,
                                                window      ,
                                          VALUE is_display  )

    DECLARE field_value       ,
                 field_table       ,
                 a_module          ,
                 mandy_array       ,
                 id_version        ,
                 a_len             ,
                 a_len1            ,
                 save_value        ,
                 save_format       ,
                 criteria_versioned

    save_format = GLOBAL ( "FORMAT_TEXT" )

    SET FORMAT "9999999999"

    { ------------------------------------------------------------------- }
    { ID always auto-generated, sometimes with a version, so display only }
    { ------------------------------------------------------------------- }

    criteria_versioned = SELECT 'C_SMP_MODULE'.criteria_versioned      { used in build routine... global variable }
    a_module           = SELECT 'C_SMP_MODULE'.identity
    id_version         = SELECT 'C_SMP_MODULE'.version_number
    field_table        = SELECT 'C_SMP_MODULE_CRITERIA'.table_name
    field_value        = SELECT 'C_SMP_MODULE_CRITERIA'.criteria_saved
    save_value         = field_value

    IF is_display THEN

        DISPLAY field_value ON LINE row FROM column TO column + cell_width - 1 IN WINDOW window FORMAT 'C_SMP_MODULE_CRITERIA'.criteria_saved

    ELSE

        ARRAY mandy_array

        ARRAY_SELECT_ADD ( mandy_array, ARRAY_SELECT_EQ, "TABLE_NAME", field_table )

        IF ( field_table = C_STRUCTURE_TXT     )
        OR ( field_table = C_MESSAGE_TXT       )
        OR ( field_table = C_DOCUMENT_DOC      )
        OR ( field_table = C_HELP_FILE         )
        OR ( field_table = C_PRESENTATION_PPT  )
        OR ( field_table = C_SMW_MENU          )
        OR ( field_table = C_MTB_MENU          )
        OR ( field_table = C_CRITERIA_CRT      )
        OR ( field_table = C_DEFAULT_LAB       )
        OR ( field_table = C_COMPILE_VGSM      ) THEN

            is_display  = TRUE
            field_value = ""

            { -------------------------------------------------------------------------------------------- }
            { In case the user switched the line from SMW.MENU to SMW_MENU redisplay over what was entered }
            { -------------------------------------------------------------------------------------------- }

            DISPLAY field_value ON LINE row FROM column TO column + cell_width - 1 IN WINDOW window FORMAT 'C_SMP_MODULE_CRITERIA'.criteria_saved

        ELSEIF ( criteria_versioned ) THEN

            GET_FIELD_DETAILS CRITERIA_SAVED.IDENTITY, "FIELD_SIZE", a_len1

            field_value      = STRIP ( C_MODULE_PREFIX : STRIP ( a_module ) : "_" )
            a_len            = a_len1 - STRINGLENGTH ( field_value )
            id_version       = "000000000" : STRIP ( id_version )
            field_value      = field_value : RIGHTSTRING ( id_version, a_len )

        ELSEIF ( BLANK ( field_value ) ) AND ( NOT BLANK ( field_table ) ) THEN

            field_value = STRIP ( C_MODULE_PREFIX : STRIP ( a_module ) )

        ENDIF

        PROMPT FOR field_value ON LINE row FROM column TO column + cell_width - 1 IN WINDOW window
        FORMAT 'C_SMP_MODULE_CRITERIA'.criteria_saved
                  WITH ( display_only     = is_display                          ,
                       select_array       = mandy_array                         ,
                       vgl_library        = GLOBAL ( "CURRENT_LIBRARY" )        ,
                       build_routine      = "internal_build_module_criteria"    ,
                       validation_routine = "internal_validate_module_criteria" ,
                       user_info          = field_table                         )

        IF save_value <> field_value THEN

            ASSIGN 'C_SMP_MODULE_CRITERIA'.criteria_saved = field_value

        ENDIF

    ENDIF

    SET FORMAT save_format

ENDROUTINE    { prompt_smp_module_criteria_saved }

{********************************************************************************}
{                                                                                }
{                                                                                }
{                                                                                }
{     THE OLD FASHIONED WAY TO DO LTE'S FOR THOSE FOLKS NOT USING INTERFACE      }
{                                                                                }
{                                                                                }
{                                                                                }
{********************************************************************************}

ROUTINE internal_lte_table_setup ( VALUE a_table_name )

    name_of_table           = a_table_name
    directory               = EMPTY
    extn                    = EMPTY
    help_context            = EMPTY
    default_value           = EMPTY
    footer_mess             = EMPTY
    display_footer_mess     = EMPTY
    input_mess              = GET_USER_MESSAGE ( "LIT_LAB_SMP_MODULE_INPUT"      , 1 )
    header_mess             = GET_USER_MESSAGE ( "LIT_LAB_SMP_MODULE_HEADER"     , 1 )
    displayed_name_of_table = GET_USER_MESSAGE ( "LIT_LAB_SMP_MODULE_TABLE_NAME" , 1 )

    ARRAY labtable_messages       ARRAY_SIZE ( 0 )
        labtable_messages [ IDENTITY_MESSAGE ]    = GET_USER_MESSAGE ( "LIT_LAB_SMP_MODULE_VERSION"  , 1 )
        labtable_messages [ IDENTITY_MESSAGE + 1] = GET_USER_MESSAGE ( "LIT_LAB_SMP_MODULE_IDENTITY" , 1 )
        labtable_messages [ IDENTITY_MESSAGE + 2] = GET_USER_MESSAGE ( "LIT_LAB_SMP_MODULE_VERSION"  , 1 )
        labtable_messages [ MOD_ON_MESSAGE   ]    = get message ( 2546 , 1 ) { "Modified On" }
        labtable_messages [ MOD_BY_MESSAGE   ]    = get message ( 2547 , 1 ) { "Modified By" }
        labtable_messages [ READ_MESSAGE     ]    = get message ( 2566 , 1 ) { "Labtable Read Transaction" }
        labtable_messages [ WRITE_MESSAGE    ]    = get message ( 2567 , 1 ) { "Labtable Write Transaction" }

    ARRAY prompt_details ARRAY_SIZE ( 0, 6 )

        prompt_details [ 1, MESSAGE_POSITION    ] = GET_USER_MESSAGE ( "LIT_LAB_SMP_MODULE_DESCRIPTION", 1 )
        prompt_details [ 1, FIELD_NAME_POSITION ] = "DESCRIPTION"

        prompt_details [ 2, MESSAGE_POSITION    ] = GET_USER_MESSAGE ( "LIT_LAB_SMP_MODULE_DATE_INSTALLED", 1 )
        prompt_details [ 2, FIELD_NAME_POSITION ] = "DATE_INSTALLED"

        prompt_details [ 3, MESSAGE_POSITION    ] = GET_USER_MESSAGE ( "LIT_LAB_SMP_MODULE_DATE_REMOVED", 1 )
        prompt_details [ 3, FIELD_NAME_POSITION ] = "DATE_REMOVED"

        prompt_details [ 4, MESSAGE_POSITION    ] = GET_USER_MESSAGE ( "LIT_LAB_SMP_MODULE_MODULE_TYPE", 1 )
        prompt_details [ 4, FIELD_NAME_POSITION ] = "MODULE_TYPE"

        prompt_details [ 5, MESSAGE_POSITION    ] = GET_USER_MESSAGE ( "LIT_LAB_SMP_MODULE_INSTALL_SET", 1 )
        prompt_details [ 5, FIELD_NAME_POSITION ] = "INSTALL_SET"
        prompt_details [ 5, TYPE_POSITION       ] = "ROUTINE"
        prompt_details [ 5, LIBRARY_POSITION    ] = GLOBAL( "current_library" )
        prompt_details [ 5, ROUTINE_POSITION    ] = "PROMPTSMPMODULEINSTALLSET"

        prompt_details [ 6, MESSAGE_POSITION    ] = GET_USER_MESSAGE ( "LIT_LAB_SMP_MODULE_USE_CRITERIA_VERSIONS", 1 )
        prompt_details [ 6, FIELD_NAME_POSITION ] = "CRITERIA_VERSIONED"


    ARRAY fields_to_output
        fields_to_output [ 1 ]  = 1
        fields_to_output [ 2 ]  = 2
        fields_to_output [ 3 ]  = 3
        fields_to_output [ 4 ]  = 4
        fields_to_output [ 5 ]  = 5
        fields_to_output [ 6 ]  = 6

    ARRAY special_actions_report  ARRAY_SIZE ( 0, 4 )
        special_actions_report [ 1 , CHARACTER_POSITION ] = "*"
        special_actions_report [ 1 , TITLE_POSITION     ] = GET MESSAGE ( 784 , 1 )
        special_actions_report [ 2 , CHARACTER_POSITION ] = "1"
        special_actions_report [ 2 , TITLE_POSITION     ] = GET_USER_MESSAGE ( "LIT_LAB_SMP_MODULE_CRITERIA", 1 )
        special_actions_report [ 2 , LIBRARY_POSITION   ] = GLOBAL( "current_library" )
        special_actions_report [ 2 , ROUTINE_POSITION   ] = "PACKAGER_criteria_details"
        special_actions_report [ 3 , CHARACTER_POSITION ] = "2"
        special_actions_report [ 3 , TITLE_POSITION     ] = GET_USER_MESSAGE ( "LIT_LAB_SMP_MODULE_PROGRAM_DLL", 1 )
        special_actions_report [ 3 , LIBRARY_POSITION   ] = GLOBAL( "current_library" )
        special_actions_report [ 3 , ROUTINE_POSITION   ] = "PACKAGER_dll_details"


ENDROUTINE   { table_setup LTE }

{********************************************************************************}

ROUTINE do_the_work  ( VALUE operation, VALUE option )

    DECLARE a_table

    a_table = SELECT MASTER_MENU.TABLE_NAME WHERE PROCEDURE_NUM = option

    internal_lte_table_setup ( a_table )

    smp_lte_perform_option  ( name_of_table              ,
                              displayed_name_of_table    ,
                              prompt_details             ,
                              labtable_messages          ,
                              default_value              ,
                              input_mess                 ,
                              header_mess                ,
                              footer_mess                ,
                              display_footer_mess        ,
                              directory                  ,
                              extn                       ,
                              help_context               ,
                              global ("current_library") ,
                              fields_to_output           ,
                              special_actions_report     ,
                              operation                  )

ENDROUTINE { do_the_work LTE }
{********************************************************************************}
ROUTINE add_option ( option )
    do_the_work ( "add_ident", option )
ENDROUTINE
{********************************************************************************}
ROUTINE copy_option ( option )
    do_the_work ( "copy_ident", option )
ENDROUTINE
{********************************************************************************}
ROUTINE modify_option ( option )
    do_the_work ( "modify_ident", option )
ENDROUTINE
{********************************************************************************}
ROUTINE display_option ( option )
    do_the_work ( "display_ident", option )
ENDROUTINE
{********************************************************************************}
ROUTINE remove_option ( option )
    do_the_work ( "remove_ident", option )
ENDROUTINE
{********************************************************************************}
ROUTINE restore_option ( option )
    do_the_work ( "restore_ident", option )
ENDROUTINE
{********************************************************************************}
ROUTINE list_option ( option )
    do_the_work ( "list_idents", option )
ENDROUTINE
{********************************************************************************}
ROUTINE print_option ( option )
    do_the_work ( "print_ident", option )
ENDROUTINE
{********************************************************************************}
ROUTINE smp_lte_initialise
ENDROUTINE

{ **************************************************************************** }

ROUTINE validation_routine

    DECLARE a_table, labtable

    ret_val = TRUE
    a_table = C_SMP_MODULE

    labtablib_get_labtable ( labtable )

    IF labtable.name_of_table = a_table THEN
    ENDIF

    RETURN ( ret_val )

ENDROUTINE  { validation_routine - called by labtablib }

{********************************************************************************}

ROUTINE prompt_object_routine ( prompt_object, VALUE key0_count, VALUE operation )

    IF ( key0_count = 1 ) THEN
    ENDIF

ENDROUTINE  { prompt object routine }

{********************************************************************************}

ROUTINE create_id_routine

    RETURN ( EMPTY )

ENDROUTINE  { create id routine }

{********************************************************************************}

ROUTINE update_routine ( labtable )

    RETURN ( EMPTY )

ENDROUTINE  { update routine }

{********************************************************************************}

ROUTINE read_data_routine ( labtable, VALUE operation )

    IF ( operation = "MODIFY" ) OR ( operation = "ADD" ) OR ( operation = "COPY" ) THEN
    ENDIF

ENDROUTINE  { read data routine }

{********************************************************************************}

ROUTINE packager_criteria_details ( id, copy_id, operation )

    DECLARE header_line   ,
        field_details , tmp1, tmp2

    IF operation = "PRINT" THEN

        header_line = internal_translate_message ("LIT_LAB_SMP_MODULE_CRITERIA_HEAD_LINE"):id

        ARRAY field_details ARRAY_SIZE ( 0 , 2 )

        field_details [ 1 , 1 ] = "ORDER_NUMBER"
        field_details [ 1 , 2 ] = internal_translate_message ("LIT_LAB_SMP_MODULE_ORDER_NUMBER")
        field_details [ 2 , 1 ] = "SAVE_MODE"
        field_details [ 2 , 2 ] = internal_translate_message ("LIT_LAB_SMP_MODULE_SAVE_MODE")
        field_details [ 3 , 1 ] = "TABLE_NAME"
        field_details [ 3 , 2 ] = internal_translate_message ("LIT_LAB_SMP_MODULE_TABLE_NAME")
        field_details [ 4 , 1 ] = "CRITERIA_SAVED"
        field_details [ 4 , 2 ] = internal_translate_message ("LIT_LAB_SMP_MODULE_CRITERIA")
        field_details [ 5 , 1 ] = "FILE_LOGICAL"
        field_details [ 5 , 2 ] = internal_translate_message ("LIT_LAB_SMP_MODULE_FILE_LOGICAL")
        field_details [ 6 , 1 ] = "FILE_SUB_DIRECTORY"
        field_details [ 6 , 2 ] = internal_translate_message ("LIT_LAB_SMP_MODULE_SUB_DIRECTORY")
        field_details [ 7 , 1 ] = "FILE_ID"
        field_details [ 7 , 2 ] = internal_translate_message ("LIT_LAB_SMP_MODULE_DESTINATION_FILE")
        field_details [ 8 , 1 ] = "FILE_EXTENSION"
        field_details [ 8 , 2 ] = internal_translate_message ("LIT_LAB_SMP_MODULE_FILE_EXTENSION")
        field_details [ 9 , 1 ] = "CSV_FILE"
        field_details [ 9 , 2 ] = internal_translate_message ("LIT_LAB_SMP_MODULE_CSV_FILE")
        field_details [10 , 1 ] = "NO_RECORDS_TO_LOAD"
        field_details [10 , 2 ] = internal_translate_message ("LIT_LAB_SMP_MODULE_NO_RECORDS_TO_LOAD")
        field_details [11 , 1 ] = "DESCRIPTION"
        field_details [11 , 2 ] = internal_translate_message ("LIT_LAB_SMP_MODULE_DESCRIPTION")

        print_fields ( C_SMP_MODULE_CRITERIA,pad ( id," ", 20 ), header_line ," ", 3, 28, field_details )

    ELSE

        IF NOT ( global ( "LIBRARY_INITIALISED" )) THEN

            ARRAY prompt_details ARRAY_SIZE ( 0 , 6 )

            prompt_details [ 1 , 2  ] = "FORMAT"                                      { Type display/format}
            prompt_details [ 1 , 3  ] = C_SMP_MODULE_CRITERIA                         { table/library      }
                prompt_details [ 1 , 4  ] = "SAVE_MODE"                                   { field/routine      }
                prompt_details [ 1 , 5  ] = 0                                             { ?                  }
                prompt_details [ 1 , 6  ] = 10                                            { Size               }

            prompt_details [ 2 , TYPE_POSITION        ] = "ROUTINE"
            prompt_details [ 2 , TABLE_NAME_POSITION  ] = "LIT_PACKAGER"
                prompt_details [ 2 , FIELD_NAME_POSITION  ] = "PROMPT_SMP_MODULE_CRITERIA_TABLENAME_V1"
                prompt_details [ 2 , 5                    ] = 10
                prompt_details [ 2 , 6                    ] = 10

            prompt_details [ 3 , TYPE_POSITION        ] = "ROUTINE"
            prompt_details [ 3 , TABLE_NAME_POSITION  ] = "LIT_PACKAGER"
                prompt_details [ 3 , FIELD_NAME_POSITION  ] = "PROMPT_SMP_MODULE_CRITERIA_SAVED_V1"
                prompt_details [ 3 , 5                    ] = 10
                prompt_details [ 3 , 6                    ] = 10

            prompt_details [ 4 , TYPE_POSITION        ] = "ROUTINE"
            prompt_details [ 4 , TABLE_NAME_POSITION  ] = "LIT_PACKAGER"
                prompt_details [ 4 , FIELD_NAME_POSITION  ] = "PROMPT_SMP_MODULE_FILE_LOGICAL_V1"
                prompt_details [ 4 , 5                    ] = 10
                prompt_details [ 4 , 6                    ] = 10

            prompt_details [ 5 , TYPE_POSITION        ] = "ROUTINE"
            prompt_details [ 5 , TABLE_NAME_POSITION  ] = "LIT_PACKAGER"
                prompt_details [ 5 , FIELD_NAME_POSITION  ] = "PROMPT_SMP_MODULE_FILE_SUBDIRECTORY_V1"
                prompt_details [ 5 , 5                    ] = 10
                prompt_details [ 5 , 6                    ] = 10

            prompt_details [ 6 , TYPE_POSITION        ] = "ROUTINE"
            prompt_details [ 6 , TABLE_NAME_POSITION  ] = "LIT_PACKAGER"
                prompt_details [ 6 , FIELD_NAME_POSITION  ] = "PROMPT_SMP_MODULE_FILEID_V1"
                prompt_details [ 6 , 5                    ] = 10
                prompt_details [ 6 , 6                    ] = 10

            prompt_details [ 7 , TYPE_POSITION        ] = "FORMAT"
            prompt_details [ 7 , TABLE_NAME_POSITION  ] = C_SMP_MODULE_CRITERIA
                prompt_details [ 7 , FIELD_NAME_POSITION  ] = "FILE_EXTENSION"
                prompt_details [ 7 , 5                    ] = 0
                prompt_details [ 7 , 6                    ] = 10

            prompt_details [ 8 , TYPE_POSITION        ] = "DISPLAY"
            prompt_details [ 8 , TABLE_NAME_POSITION  ] = C_SMP_MODULE_CRITERIA
                prompt_details [ 8 , FIELD_NAME_POSITION  ] = "CSV_FILE"
                prompt_details [ 8 , 5                    ] = 0
                prompt_details [ 8 , 6                    ] = 10

            prompt_details [ 9 , TYPE_POSITION        ] = "DISPLAY"
            prompt_details [ 9 , TABLE_NAME_POSITION  ] = C_SMP_MODULE_CRITERIA
                prompt_details [ 9 , FIELD_NAME_POSITION  ] = "NO_RECORDS_TO_LOAD"
                prompt_details [ 9 , 5                    ] = 0
                prompt_details [ 9 , 6                    ] = 10

            prompt_details [10 , TYPE_POSITION        ] = "FORMAT"
            prompt_details [10 , TABLE_NAME_POSITION  ] = C_SMP_MODULE_CRITERIA
                prompt_details [10 , FIELD_NAME_POSITION  ] = "DESCRIPTION"
                prompt_details [10 , 5                    ] = 0
                prompt_details [10 , 6                    ] = 10

            SET GLOBAL ( "LIBRARY_INITIALISED" ) TO TRUE

        ENDIF

        tmp1 = internal_translate_message ( "LIT_LAB_SMP_MODULE_CRITERIA"           )
        tmp2 = internal_translate_message ( "LIT_LAB_SMP_MODULE_CRITERIA_HEAD_LINE" )
        ret_val = list_editor_version1 ( 19,130,5,3  ,
                           C_SMP_MODULE_CRITERIA         ,
                           tmp1                          ,
                       tmp2                          ,
                       EMPTY                         ,
                       TRUE                          ,
                       EMPTY                         ,
                       EMPTY                         ,
                               prompt_details                ,
                       "packager_criteria_insert"    ,
                       EMPTY                         ,
                       EMPTY                         ,
                       EMPTY                         ,
                           copy_id                       ,
                           id                            ,
                           global ( "current_library" )  ,
                       operation                     ,
                       the_list_editor               )

        RETURN ( ret_val )

        ENDIF  { operation not print }

ENDROUTINE   { packager_criteria_details }

{********************************************************************************}

ROUTINE packager_dll_details ( id, copy_id, operation )

    DECLARE header_line   ,
        field_details , tmp1, tmp2

    IF operation = "PRINT" THEN

        header_line = internal_translate_message ("LIT_LAB_SMP_MODULE_PROGRAM_HEAD_LINE"):id

        ARRAY field_details ARRAY_SIZE ( 0 , 2 )

        field_details [ 1 , 1 ] = "ORDER_NUMBER"
        field_details [ 1 , 2 ] = internal_translate_message ("LIT_LAB_SMP_MODULE_ORDER_NUMBER")
        field_details [ 2 , 1 ] = "PROGRAM_DLL"
        field_details [ 2 , 2 ] = internal_translate_message ("LIT_LAB_SMP_MODULE_PROGRAM_DLL")
        field_details [ 3 , 1 ] = "FILENAME_ONLY"
        field_details [ 3 , 2 ] = internal_translate_message ("LIT_LAB_SMP_MODULE_FILE")
        field_details [ 4 , 1 ] = "PROGRAM_SET"
        field_details [ 4 , 2 ] = internal_translate_message ("LIT_LAB_SMP_MODULE_PROGRAM_SET")
        field_details [ 5 , 1 ] = "CLIENT_SERVER"
        field_details [ 5 , 2 ] = internal_translate_message ("LIT_LAB_SMP_MODULE_CLIENT_SERVER")
        field_details [ 6 , 1 ] = "MINIMUM_VERSION"
        field_details [ 6 , 2 ] = internal_translate_message ("LIT_LAB_SMP_MODULE_MINIMUM_VERSION")
        field_details [ 7 , 1 ] = "DESCRIPTION"
        field_details [ 7 , 2 ] = internal_translate_message ("LIT_LAB_SMP_MODULE_DESCRIPTION")

        print_fields ( C_SMP_MODULE_PROGRAM,pad ( id," ", 20 ), header_line ," ", 3, 28, field_details )

    ELSE

        IF NOT ( global ( "LIBRARY_INITIALISED" )) THEN

            ARRAY prompt_details ARRAY_SIZE ( 0 , 6 )

            prompt_details [ 1 , 2  ] = "DISPLAY"                                     { Type display/format}
            prompt_details [ 1 , 3  ] = C_SMP_MODULE_PROGRAM                          { table/library      }
                prompt_details [ 1 , 4  ] = "ORDER_NUMBER"                                { field/routine      }
                prompt_details [ 1 , 5  ] = 0                                             { ?                  }
                prompt_details [ 1 , 6  ] = 10                                            { Size               }

            prompt_details [ 2 , TYPE_POSITION        ] = "ROUTINE"
            prompt_details [ 2 , TABLE_NAME_POSITION  ] = "LIT_PACKAGER"
                prompt_details [ 2 , FIELD_NAME_POSITION  ] = "PROMPT_SMP_MODULE_PROGRAM_DLL_V1"
                prompt_details [ 2 , 5                    ] = 30
                prompt_details [ 2 , 6                    ] = 30

            prompt_details [ 3 , 2  ] = "DISPLAY"                                     { Type display/format}
            prompt_details [ 3 , 3  ] = C_SMP_MODULE_PROGRAM                          { table/library      }
                prompt_details [ 3 , 4  ] = "FILENAME_ONLY"                               { field/routine      }
                prompt_details [ 3 , 5  ] = 0                                             { ?                  }
                prompt_details [ 3 , 6  ] = 20                                            { Size               }

            prompt_details [ 4 , 2  ] = "FORMAT"                                      { Type display/format}
            prompt_details [ 4 , 3  ] = C_SMP_MODULE_PROGRAM                          { table/library      }
                prompt_details [ 4 , 4  ] = "PROGRAM_SET"                                 { field/routine      }
                prompt_details [ 4 , 5  ] = 0                                             { ?                  }
                prompt_details [ 4 , 6  ] = 10                                            { Size               }

            prompt_details [ 5 , 2  ] = "DISPLAY"                                     { Type display/format}
            prompt_details [ 5 , 3  ] = C_SMP_MODULE_PROGRAM                          { table/library      }
                prompt_details [ 5 , 4  ] = "CLIENT_SERVER"                               { field/routine      }
                prompt_details [ 5 , 5  ] = 0                                             { ?                  }
                prompt_details [ 5 , 6  ] = 10                                            { Size               }

            prompt_details [ 6 , 2  ] = "FORMAT"                                      { Type display/format}
            prompt_details [ 6 , 3  ] = C_SMP_MODULE_PROGRAM                          { table/library      }
                prompt_details [ 6 , 4  ] = "MINIMUM_VERSION"                             { field/routine      }
                prompt_details [ 6 , 5  ] = 0                                             { ?                  }
                prompt_details [ 6 , 6  ] = 10                                            { Size               }

            prompt_details [ 7 , 2  ] = "FORMAT"                                      { Type display/format}
            prompt_details [ 7 , 3  ] = C_SMP_MODULE_PROGRAM                          { table/library      }
                prompt_details [ 7 , 4  ] = "DESCRIPTION"                                 { field/routine      }
                prompt_details [ 7 , 5  ] = 0                                             { ?                  }
                prompt_details [ 7 , 6  ] = 10                                            { Size               }

            SET GLOBAL ( "LIBRARY_INITIALISED" ) TO TRUE

        ENDIF

        tmp1 = internal_translate_message ( "LIT_LAB_SMP_MODULE_PROGRAM_DLL"       )
        tmp2 = internal_translate_message ( "LIT_LAB_SMP_MODULE_PROGRAM_HEAD_LINE" )
        ret_val = list_editor_version1 ( 19,130,5,3  ,
                           C_SMP_MODULE_PROGRAM           ,
                           tmp1                           ,
                       tmp2                          ,
                       EMPTY                         ,
                       TRUE                          ,
                       EMPTY                         ,
                       EMPTY                         ,
                               prompt_details                  ,
                       "packager_criteria_insert"     ,
                       EMPTY                         ,
                       EMPTY                         ,
                       EMPTY                         ,
                           copy_id                       ,
                           id                            ,
                           global ( "current_library" )  ,
                       operation                     ,
                       the_list_editor               )

        RETURN ( ret_val )

        ENDIF  { operation not print }

ENDROUTINE   { packager_dll_details }

{********************************************************************************}

ROUTINE packager_criteria_insert ( line , display_id , new_value)

    new_value = line

    SET GLOBAL ( "LASTKEY" ) TO "CONTINUE"

    RETURN ( new_value )

ENDROUTINE    {  packager_criteria_insert }

{********************************************************************************}

ROUTINE prompt_smp_module_program_dll_v1 ( VALUE column     ,
                                           VALUE row        ,
                                           VALUE cell_width ,
                                                 screen     ,
                                                 is_display )

    DECLARE a_empty

    a_empty = EMPTY

    prompt_smp_module_program_dll (  a_empty     ,
                                          a_empty     ,
                                          column      ,
                                          row         ,
                                          column      ,
                                          row         ,
                                          cell_width  ,
                                          screen      ,
                                          is_display  )

ENDROUTINE    {  prompt_smp_module_program_dll_v1 }

{********************************************************************************}

ROUTINE prompt_smp_module_criteria_tablename_v1 ( VALUE column     ,
                                                  VALUE row        ,
                                                  VALUE cell_width ,
                                                        screen     ,
                                                        is_display )

    DECLARE a_empty

    a_empty = EMPTY

    prompt_smp_module_criteria_tablename (  a_empty     ,
                                                a_empty     ,
                                                column      ,
                                                row         ,
                                                column      ,
                                                row         ,
                                                cell_width  ,
                                                screen      ,
                                                is_display  )


ENDROUTINE    {  prompt_smp_module_criteria_tablename_v1 }

{********************************************************************************}

ROUTINE prompt_smp_module_criteria_saved_v1 ( VALUE column     ,
                                              VALUE row        ,
                                              VALUE cell_width ,
                                                    screen     ,
                                                    is_display )

    DECLARE a_empty

    a_empty = EMPTY

    prompt_smp_module_criteria_saved ( a_empty     ,
                                           a_empty     ,
                                           column      ,
                                           row         ,
                                           column      ,
                                           row         ,
                                           cell_width  ,
                                           screen      ,
                                           is_display  )

ENDROUTINE    {  prompt_smp_module_criteria_saved_v1 }

{********************************************************************************}

ROUTINE prompt_smp_module_file_logical_v1 ( VALUE column     ,
                                            VALUE row        ,
                                            VALUE cell_width ,
                                                  screen     ,
                                                  is_display )

    DECLARE a_empty

    a_empty = EMPTY

    prompt_smp_module_file_logical (  a_empty     ,
                                          a_empty     ,
                                          column      ,
                                          row         ,
                                          column      ,
                                          row         ,
                                          cell_width  ,
                                          screen      ,
                                          is_display  )

ENDROUTINE    {  prompt_smp_module_file_logical_v1 }

{********************************************************************************}

ROUTINE prompt_smp_module_file_subdirectory_v1 ( VALUE column     ,
                                                 VALUE row        ,
                                                 VALUE cell_width ,
                                                       screen     ,
                                                       is_display )

    DECLARE a_empty

    a_empty = EMPTY

    prompt_smp_module_criteria_file_sub_directory (  a_empty     ,
                                                         a_empty     ,
                                                         column      ,
                                                         row         ,
                                                         column      ,
                                                         row         ,
                                                         cell_width  ,
                                                         screen      ,
                                                         is_display  )

ENDROUTINE    {  prompt_smp_module_file_subdirectory_v1 }

{********************************************************************************}

ROUTINE prompt_smp_module_fileid_v1 ( VALUE column     ,
                                      VALUE row        ,
                                      VALUE cell_width ,
                                            screen     ,
                                            is_display )

    DECLARE a_empty

    a_empty = EMPTY

    prompt_smp_module_criteria_file_id (  a_empty     ,
                                              a_empty     ,
                                              column      ,
                                              row         ,
                                              column      ,
                                              row         ,
                                              cell_width  ,
                                              screen      ,
                                              is_display  )

ENDROUTINE    {  prompt_smp_module_file_id_v1 }

{******************************************************************************}

ROUTINE smp_module_menu_pre_insert_routine ( self        ,
                                             grid        ,
                                             cell_column ,
                                             cell_row    ,
                                             window      ,
                                             column      ,
                                             row         ,
                                             cell_width  ,
                                             cell_height ,
                                             new_value   )

    DECLARE select_array   ,
                 package_id     ,
                 package_version,
                 crt_versioned  ,
                 crt_id         ,
                 a_len1         ,
                 a_len

    ARRAY select_array

    { ------------------------------------------------------------------ }
    { Get the master menu select array from the other grid...            }
    { ------------------------------------------------------------------ }

    crt_versioned   = SELECT 'C_SMP_MODULE'.criteria_versioned
    package_version = SELECT 'C_SMP_MODULE'.version_number
    package_id      = SELECT 'C_SMP_MODULE'.identity

    IF crt_versioned THEN

        GET_FIELD_DETAILS CRITERIA_SAVED.IDENTITY, "FIELD_SIZE", a_len1

        crt_id           = STRIP ( C_MODULE_PREFIX : STRIP ( package_id ) )
        a_len            = a_len1 - STRINGLENGTH ( crt_id ) - 1
        package_version  = "000000000" : STRIP ( package_version )
        crt_id           = crt_id  : "_" : RIGHTSTRING ( package_version, a_len )

    ELSE

        crt_id = C_MODULE_PREFIX : package_id

    ENDIF

    criteria_saved_load_squirrel ( "MASTER_MENU", crt_id, select_array )

    PROMPT FOR new_value ON LINE row FROM 1 IN WINDOW window BROWSE ON MASTER_MENU.PROCEDURE_NUM
    WITH ( select_array = select_array )


ENDROUTINE  { smp_module_menu_pre_insert_routine }

{ End LIT_PACKAGER }

{*************************************************************************
* Purpose      : Writes to predefined log,
*                using WriteLog in $lib_utils
* Parameters   : Msg - what to write in log
* Return Value : N/A
**************************************************************************}
ROUTINE WriteToLog(VALUE Msg)

    WriteLog(Msg, global("current_library"))

ENDROUTINE

{ **************************************************************************** }
{ **************************************************************************** }
{ **************************************************************************** }
